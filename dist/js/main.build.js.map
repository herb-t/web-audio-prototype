{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","app/index.js","main.build.js","app/config.js","app/libs/BloomPass.js","app/libs/EffectComposer.js","app/libs/FilmPass.js","app/libs/MaskPass.js","app/libs/OrbitControls.js","app/libs/RenderPass.js","app/libs/ShaderPass.js","app/modules/Stage.js","app/shaders/BadTv.js","app/shaders/ConvolutionShader.js","app/shaders/CopyShader.js","app/shaders/FilmShader.js","node_modules/three/build/three.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","Stage","stage","init","./config","./modules/Stage","2","config","3","THREE","BloomPass","strength","kernelSize","sigma","resolution","Pass","this","undefined","pars","minFilter","LinearFilter","magFilter","format","RGBAFormat","renderTargetX","WebGLRenderTarget","renderTargetY","CopyShader","console","error","copyShader","copyUniforms","UniformsUtils","clone","uniforms","value","materialCopy","ShaderMaterial","vertexShader","fragmentShader","blending","AdditiveBlending","transparent","ConvolutionShader","convolutionShader","convolutionUniforms","blurX","buildKernel","materialConvolution","defines","KERNEL_SIZE_FLOAT","toFixed","KERNEL_SIZE_INT","needsSwap","camera","OrthographicCamera","scene","Scene","quad","Mesh","PlaneBufferGeometry","add","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","delta","maskActive","context","disable","STENCIL_TEST","material","texture","blurY","enable","clear","Vector2","three","4","EffectComposer","renderTarget","parameters","stencilBuffer","size","getSize","width","height","renderTarget1","renderTarget2","passes","copyPass","ShaderPass","swapBuffers","tmp","addPass","pass","push","setSize","insertPass","index","splice","il","enabled","stencilFunc","NOTEQUAL","EQUAL","MaskPass","ClearMaskPass","reset","dispose","renderToScreen","5","FilmPass","noiseIntensity","scanlinesIntensity","scanlinesCount","grayscale","FilmShader","shader","nIntensity","sIntensity","sCount","6","inverse","state","buffers","color","setMask","depth","setLocked","writeValue","clearValue","stencil","setTest","setOp","REPLACE","setFunc","ALWAYS","setClear","KEEP","7","OrbitControls","object","domElement","getAutoRotationAngle","Math","PI","scope","autoRotateSpeed","getZoomScale","pow","zoomSpeed","onMouseDown","event","preventDefault","button","noRotate","STATE","ROTATE","rotateStart","set","clientX","clientY","noZoom","DOLLY","dollyStart","noPan","PAN","panStart","addEventListener","onMouseMove","onMouseUp","element","document","body","rotateEnd","rotateDelta","subVectors","rotateLeft","x","clientWidth","rotateSpeed","rotateUp","y","clientHeight","copy","dollyEnd","dollyDelta","dollyIn","dollyOut","panEnd","panDelta","pan","update","removeEventListener","NONE","onMouseWheel","wheelDelta","detail","onKeyDown","noKeys","needUpdate","keyCode","keys","UP","keyPanSpeed","BOTTOM","LEFT","RIGHT","touchstart","touches","TOUCH_ROTATE","pageX","pageY","TOUCH_DOLLY","dx","dy","distance","sqrt","TOUCH_PAN","touchmove","stopPropagation","touchend","target","Vector3","center","minDistance","maxDistance","Infinity","autoRotate","minPolarAngle","maxPolarAngle","EPS","phiDelta","thetaDelta","scale","lastPosition","changeEvent","type","angle","panLeft","panOffset","te","matrix","elements","multiplyScalar","panUp","fov","position","offset","sub","targetDistance","tan","top","right","left","bottom","warn","dollyScale","theta","atan2","z","phi","max","min","radius","sin","cos","lookAt","distanceTo","dispatchEvent","EventDispatcher","8","RenderPass","overrideMaterial","clearColor","clearAlpha","oldClearColor","oldClearAlpha","getClearColor","getHex","getClearAlpha","setClearColor","9","textureID","10","WebGLRenderer","alpha","setPixelRatio","window","devicePixelRatio","innerWidth","innerHeight","PerspectiveCamera","controls","visualElement","getAudio","requestAnimationFrame","animate","bind","_onResize","TweenMax","to","querySelector","rotation","yoyo","repeat","ease","Power1","easeOut","renderModel","effectBloom","effectFilm","composer","badTVEffect","BadTVShader","clock","Clock","fogDensity","fogColor","time","uvScale","texture1","TextureLoader","load","texture2","wrapS","wrapT","RepeatWrapping","visualMaterial","getElementById","textContent","visualMesh","TorusGeometry","antialias","appendChild","autoClear","Date","now","lastTime","getDelta","updateVisual","array","Uint8Array","analyser","frequencyBinCount","frequencyArray","Float32Array","frequencyData","barsAnalyser","getByteFrequencyData","getFloatFrequencyData","average","_getAverageVolume","frequencyAverage","barsArray","forEach","bar","style","abs","soundBars","newBars","createElement","AudioContext","createAnalyser","smoothingTimeConstant","fftSize","analyser2","sourceNode","createBufferSource","splitter","createChannelSplitter","connect","destination","request","XMLHttpRequest","open","responseType","songBuffer","onload","decodeAudioData","response","buffer","duration","start","loop","muted","_onError","send","values","aspect","updateProjectionMatrix","log","../libs/BloomPass.js","../libs/EffectComposer.js","../libs/FilmPass.js","../libs/MaskPass.js","../libs/OrbitControls.js","../libs/RenderPass.js","../libs/ShaderPass.js","../shaders/BadTv.js","../shaders/ConvolutionShader.js","../shaders/CopyShader.js","../shaders/FilmShader.js","11","tDiffuse","distortion","distortion2","speed","rollSpeed","join","12","uImageIncrement","cKernel","gauss","exp","sum","halfWidth","kMaxKernelSize","ceil","Array","13","opacity","14","15","REVISION","define","amd","Number","EPSILON","sign","Function","name","defineProperty","get","toString","match","TypeError","output","arguments","source","nextKey","hasOwnProperty","MOUSE","MIDDLE","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","FrontFaceDirectionCW","FrontFaceDirectionCCW","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","FrontSide","BackSide","DoubleSide","FlatShading","SmoothShading","NoColors","FaceColors","VertexColors","NoBlending","NormalBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","NeverDepth","AlwaysDepth","LessDepth","LessEqualDepth","EqualDepth","GreaterEqualDepth","GreaterDepth","NotEqualDepth","MultiplyOperation","MixOperation","AddOperation","NoToneMapping","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","AlphaFormat","RGBFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","LoopOnce","LoopRepeat","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroCurvatureEnding","ZeroSlopeEnding","WrapAroundEnding","TrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LinearEncoding","sRGBEncoding","GammaEncoding","RGBEEncoding","LogLuvEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","BasicDepthPacking","RGBADepthPacking","Color","g","b","setRGB","setHex","setStyle","setScalar","scalar","hex","floor","setHSL","hue2rgb","p","q","h","euclideanModulo","clamp","handleAlpha","string","parseFloat","m","exec","components","parseInt","charAt","ColorKeywords","copyGammaToLinear","gammaFactor","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","getHexString","slice","getHSL","optionalTarget","hue","saturation","hsl","lightness","getStyle","offsetHSL","addColors","color1","color2","addScalar","multiply","lerp","equals","c","fromArray","toArray","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","Quaternion","w","_x","_y","_z","_w","onChangeCallback","quaternion","setFromEuler","euler","Euler","c1","c2","c3","s1","s2","s3","order","setFromAxisAngle","axis","halfAngle","setFromRotationMatrix","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","setFromUnitVectors","v1","vFrom","vTo","dot","crossVectors","normalize","conjugate","v","lengthSq","multiplyQuaternions","premultiply","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","slerp","qb","cosHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","onChange","callback","qa","qm","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","len","tDir","setX","setY","setComponent","getComponent","addVectors","addScaledVector","subScalar","isFinite","divide","divideScalar","clampScalar","minVal","maxVal","clampLength","round","roundToZero","negate","lengthManhattan","distanceToSquared","setLength","lerpVectors","v2","fromAttribute","attribute","itemSize","rotateAround","setZ","multiplyVectors","applyEuler","applyQuaternion","applyAxisAngle","applyMatrix3","applyMatrix4","applyProjection","d","qx","qy","qz","qw","ix","iy","iz","iw","project","Matrix4","multiplyMatrices","projectionMatrix","getInverse","matrixWorld","unproject","transformDirection","cross","ax","ay","az","bx","by","bz","projectOnVector","vector","projectOnPlane","planeNormal","reflect","normal","angleTo","acos","dz","setFromSpherical","sinPhiRadius","setFromMatrixPosition","setFromMatrixColumn","setFromMatrixScale","sx","sy","sz","temp","Vector4","setW","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","epsilon","epsilon2","xx","yy","zz","xy","xz","yz","_order","DefaultOrder","RotationOrders","asin","setFromQuaternion","makeRotationFromQuaternion","setFromVector3","reorder","newOrder","toVector3","optionalResult","Line3","end","line","result","distanceSq","at","closestPointToPointParameter","startP","startEnd","point","clampToLine","startEnd2","startEnd_startP","closestPointToPoint","Box2","setFromPoints","points","makeEmpty","expandByPoint","setFromCenterAndSize","halfSize","box","isEmpty","expandByVector","expandByScalar","containsPoint","containsBox","getParameter","intersectsBox","clampPoint","distanceToPoint","clampedPoint","intersect","union","translate","Box3","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","setFromObject","updateMatrixWorld","traverse","node","geometry","Geometry","vertices","BufferGeometry","attributes","positions","intersectsSphere","closestPoint","sphere","intersectsPlane","plane","constant","getBoundingSphere","Sphere","Matrix3","n11","n12","n13","n21","n22","n23","n31","n32","n33","identity","me","setFromMatrix4","applyToVector3Array","j","applyToBuffer","getX","getY","getZ","setXYZ","determinant","throwOnDegenerate","t11","t12","t13","det","msg","detInv","transpose","flattenToArrayOffset","getNormalMatrix","matrix4","transposeIntoArray","n14","n24","n34","n41","n42","n43","n44","copyPosition","extractBasis","xAxis","yAxis","zAxis","makeBasis","extractRotation","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","x2","y2","z2","wx","wy","wz","eye","up","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","getPosition","setPosition","t14","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","decompose","invSX","invSY","invSZ","makeFrustum","near","far","makePerspective","ymax","DEG2RAD","ymin","xmin","xmax","makeOrthographic","Ray","origin","direction","ray","recast","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","diff","v0","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","b1","invDet","intersectSphere","tca","d2","radius2","thc","t0","t1","distanceToPlane","denominator","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","optionalCenter","maxRadiusSq","empty","radiusSum","deltaLengthSq","getBoundingBox","Frustum","p0","p1","p2","p3","p4","p5","planes","Plane","frustum","setFromMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","setComponents","intersectsObject","boundingSphere","computeBoundingSphere","intersectsSprite","sprite","negRadius","d1","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","intersectLine","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","referencePoint","normalMatrix","Spherical","other","makeSafe","vec3","RAD2DEG","generateUUID","chars","split","uuid","rnd","random","mapLinear","a1","a2","b2","smoothstep","smootherstep","random16","randInt","low","high","randFloat","randFloatSpread","range","degToRad","degrees","radToDeg","radians","isPowerOfTwo","nearestPowerOfTwo","LN2","nextPowerOfTwo","Spline","interpolate","t2","t3","intPoint","weight","w2","w3","pa","pb","pc","pd","v3","initFromArray","getPoint","k","getControlPointsArray","coords","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","chunks","total","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","Triangle","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","setFromPointsAndIndices","i0","i1","i2","triangle","area","midpoint","edgeList","projectedPoint","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","evaluate","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","settings","DefaultSettings_","getSettings_","copySampleValue_","stride","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","DiscreteInterpolant","LinearInterpolant","offset1","offset0","weight1","weight0","QuaternionLinearInterpolant","autoStart","startTime","oldTime","elapsedTime","running","performance","stop","getElapsedTime","newTime","listener","_listeners","listeners","indexOf","hasEventListener","listenerArray","Layers","mask","channel","toggle","test","layers","ascSort","intersectObject","raycaster","intersects","recursive","visible","raycast","children","Raycaster","params","Line","LOD","Points","threshold","Sprite","defineProperties","PointCloud","linePrecision","setFromCamera","sort","intersectObjects","objects","isArray","Object3D","onRotationChange","onQuaternionChange","Object3DIdCount","parent","DefaultUp","enumerable","modelViewMatrix","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","castShadow","receiveShadow","frustumCulled","renderOrder","userData","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","q1","rotateX","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","remove","getObjectById","id","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","updateMatrix","force","toJSON","meta","extractFromCache","cache","key","data","metadata","isRootObject","geometries","materials","textures","images","version","generator","JSON","stringify","parse","Face3","materialIndex","vertexNormals","vertexColors","BufferAttribute","normalized","dynamic","updateRange","count","needsUpdate","setDynamic","copyAt","index1","index2","copyArray","copyColorsArray","colors","copyIndicesArray","indices","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","getW","setXY","setXYZW","Int8Attribute","Int8Array","Uint8Attribute","Uint8ClampedAttribute","Uint8ClampedArray","Int16Attribute","Int16Array","Uint16Attribute","Uint16Array","Int32Attribute","Int32Array","Uint32Attribute","Uint32Array","Float32Attribute","Float64Attribute","Float64Array","DynamicBufferAttribute","InstancedBufferAttribute","meshPerAttribute","InterleavedBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","interleavedBuffer","GeometryIdCount","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","verticesNeedUpdate","elementsNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","vertex","face","jl","computeBoundingBox","obj","fromBufferGeometry","addFace","normals","tempNormals","uvs","tempUVs","uvs2","tempUVs2","uv","uv2","groups","group","computeFaceNormals","cb","ab","fl","vA","vB","vC","computeVertexNormals","areaWeighted","vl","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","computeLineDistances","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mesh","mergeVertices","verticesMap","unique","changes","precisionPoints","precision","faceIndicesToRemove","dupIndex","idx","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","getNormalIndex","hash","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","kl","DirectGeometry","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","morphTarget","morphNormal","morphAttributes","drawRange","getIndex","setIndex","addAttribute","getAttribute","removeAttribute","addGroup","clearGroups","setDrawRange","updateFromObject","direct","__directGeometry","lineDistance","fromDirectGeometry","TypeArray","isNaN","pA","pB","pC","normalizeNormals","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","geometry2","array2","MaxIndex","InstancedBufferGeometry","maxInstancedCount","instances","Uniform","onUpdate","onUpdateCallback","AnimationAction","_new","mixer","clip","localRoot","_mixer","_clip","_localRoot","tracks","nTracks","interpolants","interpolantSettings","interpolant","createInterpolant","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","_loopCount","_startTime","timeScale","_effectiveTimeScale","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","play","_activateAction","_deactivateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setLoop","mode","setEffectiveWeight","getEffectiveWeight","fadeIn","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","action","halt","startTimeScale","endTimeScale","_lendControlInterpolant","times","timeScaleInterpolant","getMixer","getClip","getRoot","_root","_update","deltaTime","timeDirection","accuIndex","timeRunning","_updateTimeScale","clipTime","_updateTime","_updateWeight","propertyMixers","accumulate","interpolantValue","loopCount","_setEndings","handle_stop","pingPong","loopDelta","pending","atStart","atEnd","weightNow","weightThen","AnimationClip","resetDuration","trim","optimize","track","json","jsonTracks","frameTime","fps","KeyframeTrack","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","AnimationUtils","getKeyframeOrder","sortedArray","NumberKeyframeTrack","findByName","objectOrClipArray","clipArray","animations","CreateClipsFromMorphTargetSequences","animationToMorphTargets","pattern","parts","animationMorphTargets","clips","parseAnimation","animation","bones","nodeName","addNonemptyTrack","trackType","trackName","animationKeys","propertyName","destTracks","flattenJSON","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationMixer","root","_initMemoryManager","_accuIndex","clipAction","optionalRoot","rootUuid","clipObject","clipUuid","actionsForClip","_actionsByClip","prototypeAction","existingAction","actionByRoot","knownActions","newAction","_Action","_bindAction","_addInactiveAction","stopAllAction","actions","_actions","nActions","_nActiveActions","bindings","_bindings","nBindings","_nActiveBindings","useCount","apply","uncacheClip","actionsByClip","actionsToRemove","cacheIndex","lastInactiveAction","pop","_removeInactiveBindingsForAction","uncacheRoot","_removeInactiveAction","bindingsByRoot","_bindingsByRootAndName","bindingByName","binding","restoreOriginalState","_removeInactiveBinding","uncacheAction","bindingsByName","referenceCount","_addInactiveBinding","path","parsedPath","PropertyMixer","PropertyBinding","ValueTypeName","getValueSize","_lendBinding","saveOriginalState","_lendAction","_takeBackBinding","_takeBackAction","_controlInterpolants","_nActiveControlInterpolants","stats","inUse","controlInterpolants","knownActionsForClip","lastKnownAction","byClipCacheIndex","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","propBinding","rootNode","lastInactiveBinding","remove_empty_map","_","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","AnimationObjectGroup","var_args","_objects","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindingsIndicesByPath","bindingsPerObject","nObjects","nCachedObjects","indicesByUUID","paths","parsedPaths","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastIndex","lastObject","last","subscribe_","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","arraySlice","from","isTypedArray","subarray","convertArray","forceClone","BYTES_PER_ELEMENT","ArrayBuffer","isView","DataView","compareTime","nValues","srcOffset","jsonKeys","valuePropertyName","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","getInterpolation","shift","timeOffset","endTime","nKeys","valid","prevTime","currTime","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","_getTrackTypeForValueTypeName","typeName","toLowerCase","ColorKeyframeTrack","BooleanKeyframeTrack","StringKeyframeTrack","parseTrackName","findNode","getValue","targetArray","setValue","sourceArray","targetObject","objectName","propertyIndex","_getValue_unavailable","_setValue_unavailable","objectIndex","skeleton","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","resolvedProperty","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","unbind","_getValue_unbound","_setValue_unbound","dest","Composite","targetGroup","optionalParsedPath","_targetGroup","firstValidIndex","re","matches","results","searchSkeleton","bone","searchNodeSubtree","childNode","subTreeNode","mixFunction","bufferType","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","currentWeight","mix","originalValueOffset","Audio","onended","onEnded","gain","createGain","getInput","autoplay","playbackRate","isPlaying","hasPlaybackControl","sourceType","filters","getOutput","setNodeSource","audioNode","setBuffer","audioBuffer","pause","currentTime","disconnect","getFilters","setFilters","getFilter","setFilter","filter","setPlaybackRate","getPlaybackRate","getLoop","getVolume","setVolume","AudioAnalyser","audio","getFrequencyData","getAverageFrequency","webkitAudioContext","PositionalAudio","panner","createPanner","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","setMaxDistance","AudioListener","removeFilter","getMasterVolume","setMasterVolume","orientation","setOrientation","Camera","matrixWorldInverse","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","options","WebGLRenderTargetCube","updateCubeMap","generateMipmaps","activeCubeFace","setRenderTarget","zoom","view","setViewOffset","fullWidth","fullHeight","offsetX","offsetY","clearViewOffset","cx","cy","zoomW","zoomH","scaleW","scaleH","focus","filmGauge","filmOffset","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","getEffectiveFOV","getFilmWidth","skew","StereoCamera","cameraL","cameraR","eyeRight","eyeLeft","eyeSep","eyeSepOnProjection","Light","intensity","groundColor","decay","penumbra","LightShadow","bias","mapSize","map","AmbientLight","DirectionalLight","shadow","DirectionalLightShadow","light","HemisphereLight","skyColor","PointLight","power","SpotLight","SpotLightShadow","AudioLoader","manager","DefaultLoadingManager","url","onLoad","onProgress","onError","loader","XHRLoader","setResponseType","Cache","files","file","Loader","onLoadStart","onLoadProgress","onLoadComplete","crossOrigin","extractUrlBase","initMaterials","texturePath","createMaterial","textureLoader","materialLoader","loadTexture","wrap","anisotropy","fullPath","Handlers","setCrossOrigin","MaterialLoader","specular","emissive","shininess","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","emissiveMap","mapEmissiveRepeat","mapEmissiveOffset","mapEmissiveWrap","mapEmissiveAnisotropy","lightMap","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","aoMap","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","bumpMap","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","bumpScale","normalMap","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","normalScale","specularMap","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","metalnessMap","mapMetalnessRepeat","mapMetalnessOffset","mapMetalnessWrap","mapMetalnessAnisotropy","roughnessMap","mapRoughnessRepeat","mapRoughnessOffset","mapRoughnessWrap","mapRoughnessAnisotropy","alphaMap","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","side","setTextures","handlers","regex","cached","setTimeout","overrideMimeType","status","itemEnd","itemError","withCredentials","itemStart","setPath","setWithCredentials","FontLoader","text","substring","font","Font","ImageLoader","image","createElementNS","URL","revokeObjectURL","src","blob","createObjectURL","JSONLoader","setTexturePath","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","parseMorphing","dstVertices","srcVertices","morphColors","parseAnimations","outputAnimations","concat","morphAnimationClips","LoadingManager","isLoading","itemsLoaded","itemsTotal","onStart","BufferGeometryLoader","TYPED_ARRAYS","typedArray","drawcalls","offsets","getTexture","roughness","metalness","shading","alphaTest","depthTest","depthWrite","colorWrite","wireframe","wireframeLinewidth","sizeAttenuation","displacementMap","displacementScale","displacementBias","emissiveIntensity","envMap","combine","reflectivity","lightMapIntensity","aoMapIntensity","ObjectLoader","lastIndexOf","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","geometryLoader","bufferGeometryLoader","widthSegments","heightSegments","depthSegments","segments","thetaStart","thetaLength","radiusTop","radiusBottom","radialSegments","openEnded","phiStart","phiLength","innerRadius","outerRadius","thetaSegments","phiSegments","tube","tubularSegments","arc","loadImage","parseConstant","Texture","mapping","getGeometry","getMaterial","SkinnedMesh","Group","levels","level","addLevel","CubeTextureLoader","urls","loaded","CubeTexture","DataTextureLoader","BinaryTextureLoader","_parser","DataTexture","texData","mipmaps","mipmapCount","CompressedTextureLoader","texDatas","CompressedTexture","isCubemap","Material","MaterialIdCount","fog","lights","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","clippingPlanes","clipShadows","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","premultipliedAlpha","overdraw","_needsUpdate","setValues","newValue","currentValue","isRoot","srcPlanes","dstPlanes","LineBasicMaterial","linewidth","linecap","linejoin","LineDashedMaterial","dashSize","gapSize","MeshBasicMaterial","refractionRatio","wireframeLinecap","wireframeLinejoin","skinning","MeshDepthMaterial","depthPacking","MeshLambertMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshStandardMaterial","STANDARD","envMapIntensity","MeshPhysicalMaterial","PHYSICAL","clearCoat","clearCoatRoughness","MultiMaterial","PointsMaterial","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","RawShaderMaterial","SpriteMaterial","ShadowMaterial","UniformsLib","ShaderChunk","encoding","TextureIdCount","sourceFile","DEFAULT_IMAGE","DEFAULT_MAPPING","premultiplyAlpha","flipY","unpackAlignment","getDataURL","canvas","toDataURL","getContext","drawImage","transformUv","DepthTexture","CanvasTexture","VideoTexture","video","readyState","HAVE_CURRENT_DATA","inverseMatrix","testPoint","rayPointDistanceSq","localThresholdSq","intersectPoint","distanceToRay","localThreshold","LineSegments","precisionSq","vStart","vEnd","interSegment","interRay","step","distSq","faceIndex","nbVertices","drawMode","updateMorphTargets","setDrawMode","morphTargetBase","morphTargetInfluences","morphTargetDictionary","ml","getMorphTargetIndexByName","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","uvA","uvB","uvC","tempA","tempB","tempC","fvA","fvB","fvC","isFaceMaterial","faceMaterial","morphInfluences","tl","influence","targets","uvs_f","Bone","skin","Skeleton","boneInverses","useVertexTexture","identityMatrix","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","pose","offsetMatrix","bindMode","bindMatrix","bindMatrixInverse","gbone","pos","rotq","scl","normalizeSkinWeights","sw","vec","skinWeight","getObjectForDistance","matrixPosition","guessSizeSq","LensFlare","lensFlares","positionScreen","customUpdateCallback","updateLensFlares","flare","vecX","vecY","wantedRotation","background","autoUpdate","Fog","FogExp2","density","merged","uniforms_src","uniforms_dst","parameter_src","common","diffuse","offsetRepeat","flipEnvMap","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","fogNear","fogFar","ambientLightColor","directionalLights","properties","shadowBias","shadowRadius","shadowMapSize","directionalShadowMap","directionalShadowMatrix","spotLights","coneCos","penumbraCos","spotShadowMap","spotShadowMatrix","pointLights","pointShadowMap","pointShadowMatrix","hemisphereLights","ShaderLib","basic","lambert","phong","standard","dashed","totalSize","cube","tCube","tFlip","equirect","tEquirect","distanceRGBA","lightPos","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","glClearColor","_premultipliedAlpha","setDefaultGLState","scissor","_currentScissor","_scissor","viewport","_currentViewport","_viewport","_clearColor","_clearAlpha","resetGLState","_currentProgram","_currentCamera","_currentGeometryProgram","_currentMaterialId","onContextLost","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReference","programInfo","program","programCache","releaseProgram","setupVertexAttributes","startIndex","extension","initAttributes","geometryAttributes","programAttributes","getAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","_gl","FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","getAttributeBuffer","enableAttributeAndDivisor","enableAttribute","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","disableUnusedAttributes","absNumericalSort","painterSortStable","reversePainterSortStable","pushRenderItem","transparentObjects","transparentObjectsLastIndex","opaqueObjects","opaqueObjectsLastIndex","renderItem","_vector3","isObjectViewable","_sphere","isSphereViewable","isSpriteViewable","_frustum","numPlanes","_clipping","_this","negRad","projectObject","sprites","ImmediateRenderObject","sortObjects","_projScreenMatrix","groupMaterial","renderObjects","renderList","setMaterial","setProgram","renderBufferImmediate","renderBufferDirect","initMaterial","materialProperties","getParameters","_lights","getProgramCode","programChange","shaderID","__webglShader","acquireProgram","numSupportedMorphTargets","maxMorphTargets","numSupportedMorphNormals","maxMorphNormals","numClippingPlanes","uniform","lightsHash","ambient","directional","spot","hemi","progUniforms","getUniforms","uniformsList","WebGLUniforms","seqWithValue","seq","dynamicUniforms","splitDynamic","CULL_FACE","setFlipSided","setBlending","setDepthFunc","setDepthTest","setDepthWrite","setColorWrite","setPolygonOffset","_usedTextureUnits","_clippingEnabled","_localClippingEnabled","useCache","setState","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","useProgram","capabilities","logarithmicDepthBuffer","uCamPos","cameraPosition","setOptional","floatVertexTextures","markUniformsLightsNeedsUpdate","refreshUniformsFog","refreshUniformsCommon","refreshUniformsLine","refreshUniformsDash","refreshUniformsPoints","refreshUniformsLambert","refreshUniformsPhong","refreshUniformsPhysical","refreshUniformsStandard","upload","dynUniforms","evalDynamic","uvScaleMap","_canvas","setupShadows","lightShadowsLength","shadows","setupLights","ll","shadowMap","viewMatrix","directionalLength","pointLength","spotLength","hemiLength","lightCache","allocTextureUnit","textureUnit","maxTextures","paramThreeToGL","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","HALF_FLOAT_OES","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","DEPTH_COMPONENT","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","SRC_ALPHA_SATURATE","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","MIN_EXT","MAX_EXT","_context","_alpha","_depth","_stencil","_antialias","_preserveDrawingBuffer","preserveDrawingBuffer","autoClearColor","autoClearDepth","autoClearStencil","localClippingEnabled","gammaInput","gammaOutput","physicallyCorrectLights","toneMapping","toneMappingExposure","toneMappingWhitePoint","_currentFramebuffer","_currentScissorTest","_width","_height","_scissorTest","WebGLClipping","_infoRender","calls","info","memory","programs","getShaderPrecisionFormat","rangeMin","rangeMax","WebGLExtensions","WebGLCapabilities","WebGLState","WebGLProperties","WebGLTextures","WebGLObjects","WebGLPrograms","WebGLLights","bufferRenderer","WebGLBufferRenderer","indexedBufferRenderer","WebGLIndexedBufferRenderer","backgroundCamera","backgroundCamera2","backgroundPlaneMesh","backgroundBoxShader","backgroundBoxMesh","BoxBufferGeometry","WebGLShadowMap","spritePlugin","SpritePlugin","lensFlarePlugin","LensFlarePlugin","getContextAttributes","forceContextLoss","loseContext","getMaxAnisotropy","getPrecision","getPixelRatio","updateStyle","setViewport","setScissor","setScissorTest","boolean","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearDepth","clearStencil","clearTarget","hasPositions","createBuffer","hasNormals","hasUvs","hasColors","bufferData","positionArray","DYNAMIC_DRAW","normalArray","nx","ny","nz","uvArray","colorArray","drawArrays","TRIANGLES","updateBuffers","geometryProgram","activeInfluences","getWireframeAttribute","ELEMENT_ARRAY_BUFFER","dataStart","dataCount","rangeStart","rangeCount","groupStart","groupCount","drawStart","drawEnd","drawCount","setLineWidth","setMode","LINES","TRIANGLE_STRIP","TRIANGLE_FAN","lineWidth","LINE_STRIP","POINTS","renderInstances","forceClear","beginShadows","endShadows","updateRenderTargetMipmap","setFaceCulling","cullFace","frontFaceDirection","setCullFace","setTexture2D","warned","slot","setTexture","setTextureCube","setTextureCubeDynamic","getCurrentRenderTarget","__webglFramebuffer","setupRenderTarget","framebuffer","isCube","renderTargetProperties","scissorTest","bindFramebuffer","FRAMEBUFFER","textureProperties","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE_CUBE_MAP_POSITIVE_X","__webglTexture","activeMipMapLevel","readRenderTargetPixels","restore","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","depthBuffer","depthTexture","drawArraysInstancedANGLE","resetGlobalState","globalState","numGlobalPlanes","projectPlanes","skipTransform","nPlanes","dstArray","flatSize","viewNormalMatrix","i4","renderingShadows","enableLocalClipping","fromCache","nGlobal","lGlobal","clippingState","drawElements","drawElementsInstancedANGLE","gl","getExtension","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getMaxPrecision","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","maxTextureSize","MAX_TEXTURE_SIZE","maxCubemapSize","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_ATTRIBS","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","_maxPrecision","WebGLGeometries","onGeometryDispose","buffergeometry","_bufferGeometry","deleteAttribute","deleteAttributes","property","bufferproperty","__webglBuffer","deleteBuffer","removeAttributeBuffer","updateAttribute","attributeProperties","updateBuffer","usage","STATIC_DRAW","bufferSubData","edges","checkEdge","list","WebGLProgram","getEncodingComponents","getTexelDecodingFunction","functionName","getTexelEncodingFunction","getToneMappingFunction","toneMappingName","generateExtensions","rendererExtensions","envMapCubeUV","flatShading","filterEmptyLine","generateDefines","fetchAttributeLocations","identifiers","getProgramParameter","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","replaceLightNums","replace","numDirLights","numSpotLights","numPointLights","numHemiLights","parseIncludes","include","unrollLoops","snippet","unroll","programIdCount","shadowMapTypeDefine","shadowMapType","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","prefixVertex","prefixFragment","gammaFactorDefine","customExtensions","customDefines","createProgram","supportsVertexTextures","maxBones","doubleSided","flipSided","shadowMapEnabled","useFog","fogExp","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","vertexGlsl","fragmentGlsl","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","programLog","getProgramInfoLog","vertexLog","getShaderInfoLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","prefix","deleteShader","cachedUniforms","cachedAttributes","destroy","deleteProgram","usedTimes","allocateBones","nVertexUniforms","nVertexMatrices","getTextureEncodingFromMap","gammaOverrideLinear","shaderIDs","parameterNames","nClipPlanes","currentRenderTarget","envMapMode","pl","addLineNumbers","lines","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","_renderer","getDepthMaterial","isPointLight","lightPositionWorld","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","useSkinning","variantIndex","_MorphingFlag","_SkinningFlag","keyA","keyB","materialsForVariant","_materialCache","cachedMaterial","renderSingleSided","renderReverseSided","shadowCamera","_renderList","_state","_lightShadows","_shadowMapSize","_lookTarget","_lightPositionWorld","_NumberOfMaterialVariants","cubeDirections","cubeUps","cube2DViewPorts","depthMaterialTemplate","distanceShader","distanceUniforms","depthMaterial","distanceMaterial","USE_SHADOWMAP","BLEND","faceCount","vpWidth","vpHeight","shadowMatrix","vpDimensions","createTexture","bindTexture","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texImage2D","WebGLColorBuffer","WebGLDepthBuffer","WebGLStencilBuffer","maxVertexAttributes","newAttributes","enabledAttributes","attributeDivisors","compressedTextureFormats","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentFlipSided","currentCullFace","currentLineWidth","currentPolygonOffsetFactor","currentPolygonOffsetUnits","currentScissorTest","currentTextureSlot","currentBoundTextures","currentScissor","currentViewport","emptyTextures","TEXTURE_2D","TEXTURE_CUBE_MAP","DEPTH_TEST","enableVertexAttribArray","vertexAttribDivisorANGLE","disableVertexAttribArray","getCompressedTextureFormats","formats","COMPRESSED_TEXTURE_FORMATS","blendEquationSeparate","blendFuncSeparate","blendFunc","setStencilTest","stencilTest","setStencilWrite","stencilWrite","setStencilFunc","stencilRef","stencilMask","setStencilOp","stencilFail","stencilZFail","stencilZPass","frontFace","CW","CCW","BACK","FRONT","FRONT_AND_BACK","factor","units","POLYGON_OFFSET_FILL","getScissorTest","SCISSOR_TEST","activeTexture","webglSlot","TEXTURE0","webglType","webglTexture","boundTexture","compressedTexImage2D","locked","currentColorMask","currentColorClear","colorMask","lock","currentDepthMask","currentDepthFunc","currentDepthClear","depthMask","NEVER","LESS","LEQUAL","GEQUAL","GREATER","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","stencilOp","clampToMaxSize","maxSize","makePowerOfTwo","HTMLImageElement","HTMLCanvasElement","textureNeedsPowerOfTwo","filterFallback","onTextureDispose","deallocateTexture","_infoMemory","onRenderTargetDispose","deallocateRenderTarget","__image__webglTextureCube","deleteTexture","__webglInit","deleteFramebuffer","__webglDepthbuffer","deleteRenderbuffer","__version","complete","uploadTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","isCompressed","isDataTexture","cubeImage","isPowerOfTwoImage","glFormat","glType","setTextureParameters","mipmap","generateMipmap","textureType","TEXTURE_WRAP_S","TEXTURE_WRAP_T","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","internalFormat","_isWebGL2","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","setupFrameBufferTexture","attachment","textureTarget","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthTexture","webglDepthTexture","setupDepthRenderbuffer","createRenderbuffer","isTargetPowerOfTwo","createFramebuffer","WebGL2RenderingContext","emptyTexture","emptyCubeTexture","UniformContainer","arrayCacheF32","arrayCacheI32","flatten","nBlocks","blockSize","firstElem","allocTexUnits","setValue1f","uniform1f","addr","setValue1i","uniform1i","setValue2fv","uniform2fv","uniform2f","setValue3fv","uniform3f","uniform3fv","setValue4fv","uniform4fv","uniform4f","setValue2fm","uniformMatrix2fv","setValue3fm","uniformMatrix3fv","setValue4fm","uniformMatrix4fv","setValueT1","unit","setValueT6","setValue2iv","uniform2iv","setValue3iv","uniform3iv","setValue4iv","uniform4iv","getSingularSetter","setValue1fv","uniform1fv","setValue1iv","uniform1iv","setValueV2a","setValueV3a","setValueV4a","setValueM2a","setValueM3a","setValueM4a","setValueT1a","setValueT6a","getPureArraySetter","SingleUniform","activeInfo","PureArrayUniform","StructuredUniform","RePathPart","addUniform","container","uniformObject","parseUniform","pathLength","matchEnd","idIsIndex","subscript","next","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","flares","vertexBuffer","elementBuffer","tempTexture","occlusionTexture","renderType","occlusionMap","screenPosition","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","validArea","TEXTURE1","copyTexImage2D","uvOffset","fogType","fillStyle","fillRect","spritePosition","spriteRotation","spriteScale","oldFogType","sceneFogType","Face4","LineStrip","LinePieces","MeshFaceMaterial","Particle","ParticleSystem","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","Vertex","isIntersectionBox","isIntersectionSphere","multiplyVector3","multiplyVector3Array","extractPosition","multiplyVector4","rotateAxis","crossVector","rotateByAxis","isIntersectionLine","isIntersectionPlane","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","getChildByName","renderDepth","eulerOrder","useQuaternion","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraNear","shadowCameraFar","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","indexOffset","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","metal","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","shadowMapCullFace","audioLoader","getData","GeometryUtils","geometry1","ImageUtils","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","Projector","projectVector","unprojectVector","pickingRay","CanvasRenderer","CurveUtils","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","SceneUtils","createMultiMaterialObject","detach","attach","ShapeUtils","contour","triangulate","snip","verts","px","py","aX","aY","bX","bY","cX","cY","apx","apy","bpx","bpy","cpx","cpy","cCROSSap","bCROSScp","aCROSSbp","vertIndices","nv","triangulateShape","holes","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","shape","prevShapeIdx","nextShapeIdx","insideAngle","hole","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","sIdx","nextIdx","intersectsHoleEdge","ihIdx","chkHole","hIdx","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","counter","h2","allPointsMap","allpoints","shapeWithoutHoles","triangles","isClockWise","pts","b2p0","b2p1","b2p2","b3","b3p0","b3p1","b3p2","b3p3","Curve","getPointAt","getUtoTmapping","getPoints","divisions","getSpacedPoints","lengths","getLengths","cacheArcLengths","current","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","getTangentAt","getPointFunc","CurvePath","curves","autoClose","curve","closePath","startPoint","endPoint","LineCurve","curveLengths","getCurveLengths","lens","cacheLengths","sums","createPointsGeometry","createGeometry","createSpacedPointsGeometry","generateShapes","createPaths","String","ret","createPath","glyph","glyphs","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","Path","outline","_cachedOutline","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha","shapes","toShapes","fromPoints","args","lastargs","aCPx","aCPy","QuadraticBezierCurve","aCP1x","aCP1y","aCP2x","aCP2y","CubicBezierCurve","splineThru","npts","SplineCurve","lastPoint","aRadius","aStartAngle","aEndAngle","aClockwise","absarc","absellipse","ellipse","xRadius","yRadius","aRotation","EllipseCurve","item","spts","spline","deltaAngle","tdivisions","isCCW","noHoles","extractSubpaths","inActions","subPaths","lastPath","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","Shape","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sLen","sho","ho","hole_unassigned","s2Idx","froms","tos","tmpHoles","extrude","ExtrudeGeometry","makeGeometry","ShapeGeometry","getPointsHoles","holesPts","extractAllPoints","extractPoints","tangent","point0","point1","point2","point3","ArcCurve","LineCurve3","QuadraticBezierCurve3","CubicBezierCurve3","SplineCurve3","CatmullRomCurve3","CubicPoly","pz","c0","initNonuniformCatmullRom","x3","dt0","dt1","dt2","initCatmullRom","tension","calc","closed","ClosedSplineCurve3","BoxGeometry","CubeGeometry","calculateVertexCount","calculateIndexCount","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","vertexBufferOffset","uvBufferOffset","numberOfVertices","indexBufferOffset","vertexCount","indexCount","CircleGeometry","CircleBufferGeometry","ii","segment","CylinderBufferGeometry","nbCap","generateTorso","tanTheta","indexRow","halfHeight","indexArray","i3","generateCap","centerIndexStart","centerIndexEnd","cosTheta","sinTheta","CylinderGeometry","ConeBufferGeometry","ConeGeometry","EdgesGeometry","thresholdAngle","sortFunction","thresholdDot","edge","vert1","vert2","face1","face2","addShapeList","addShape","scalePt2","pt","getBevelVec","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","bevelEnabled","layer","vlen","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","extrudePts","splineTube","binormal","position2","amount","bevelThickness","bevelSize","curveSegments","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","frames","TubeGeometry","FrenetFrames","shapePoints","reverse","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","binormals","indexA","indexB","indexC","indexD","LatheBufferGeometry","base","inverseSegments","n1","n2","LatheGeometry","PlaneGeometry","width_half","height_half","segment_width","segment_height","offset2","RingBufferGeometry","radiusStep","thetaSegmentLevel","RingGeometry","SphereGeometry","SphereBufferGeometry","thetaEnd","verticesRow","v4","TextGeometry","TorusBufferGeometry","TorusKnotBufferGeometry","calculatePositionOnCurve","cu","su","quOverP","cs","P1","P2","B","T","N","TorusKnotGeometry","heightScale","taper","NoTaper","ip","jp","uva","uvb","uvc","uvd","grid","numpoints","pos2","tangents","SinusoidalTaper","initialNormal3","smallest","MAX_VALUE","tz","mat","PolyhedronGeometry","prepare","that","azimuth","inclination","make","centroid","azi","correctUV","subdivide","cols","aj","bj","rows","DodecahedronGeometry","IcosahedronGeometry","OctahedronGeometry","TetrahedronGeometry","ParametricGeometry","func","slices","stacks","sliceCount","WireframeGeometry","numEdges","ol","numTris","AxisHelper","ArrowHelper","lineGeometry","coneGeometry","headLength","headWidth","cone","setDirection","setColor","BoxHelper","BoundingBoxHelper","CameraHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","setPoint","DirectionalLightHelper","lightPlane","targetLine","EdgesHelper","FaceNormalsHelper","nNormals","objGeometry","GridHelper","setColors","HemisphereLightHelper","sphereSize","lightSphere","PointLightHelper","SkeletonHelper","getBoneList","boneList","matrixWorldInv","boneMatrix","SpotLightHelper","vector2","coneLength","coneWidth","VertexNormalsHelper","objPos","objNorm","WireframeHelper","renderCallback","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","createAnimation","setAnimationWeight","lastFrame","currentFrame","active","directionBackwards","mirroredLoop","autoCreateAnimations","firstAnimation","frameRanges","morph","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","stopAnimation","keyframe"],"mappings":"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","file":"main.build.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\nvar config = require('./config');\r\nvar Stage = require('./modules/Stage');\r\n\r\nvar stage = new Stage();\r\nstage.init();\r\n\r\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\r\n\r\nvar config = require('./config');\r\nvar Stage = require('./modules/Stage');\r\n\r\nvar stage = new Stage();\r\nstage.init();\r\n\r\n\n},{\"./config\":2,\"./modules/Stage\":10}],2:[function(require,module,exports){\n'use strict';\r\n\r\nvar config = {};\r\n\r\nmodule.exports = config;\r\n\n},{}],3:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.BloomPass = function ( strength, kernelSize, sigma, resolution ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tstrength = ( strength !== undefined ) ? strength : 1;\r\n\tkernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;\r\n\tsigma = ( sigma !== undefined ) ? sigma : 4.0;\r\n\tresolution = ( resolution !== undefined ) ? resolution : 256;\r\n\r\n\t// render targets\r\n\r\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\r\n\r\n\tthis.renderTargetX = new THREE.WebGLRenderTarget( resolution, resolution, pars );\r\n\tthis.renderTargetY = new THREE.WebGLRenderTarget( resolution, resolution, pars );\r\n\r\n\t// copy material\r\n\r\n\tif ( THREE.CopyShader === undefined )\r\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.CopyShader\" );\r\n\r\n\tvar copyShader = THREE.CopyShader;\r\n\r\n\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\r\n\r\n\tthis.copyUniforms[ \"opacity\" ].value = strength;\r\n\r\n\tthis.materialCopy = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.copyUniforms,\r\n\t\tvertexShader: copyShader.vertexShader,\r\n\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\tblending: THREE.AdditiveBlending,\r\n\t\ttransparent: true\r\n\r\n\t} );\r\n\r\n\t// convolution material\r\n\r\n\tif ( THREE.ConvolutionShader === undefined )\r\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.ConvolutionShader\" );\r\n\r\n\tvar convolutionShader = THREE.ConvolutionShader;\r\n\r\n\tthis.convolutionUniforms = THREE.UniformsUtils.clone( convolutionShader.uniforms );\r\n\r\n\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurX;\r\n\tthis.convolutionUniforms[ \"cKernel\" ].value = THREE.ConvolutionShader.buildKernel( sigma );\r\n\r\n\tthis.materialConvolution = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.convolutionUniforms,\r\n\t\tvertexShader:  convolutionShader.vertexShader,\r\n\t\tfragmentShader: convolutionShader.fragmentShader,\r\n\t\tdefines: {\r\n\t\t\t\"KERNEL_SIZE_FLOAT\": kernelSize.toFixed( 1 ),\r\n\t\t\t\"KERNEL_SIZE_INT\": kernelSize.toFixed( 0 )\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.BloomPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.BloomPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 1)\r\n\r\n\t\tthis.quad.material = this.materialConvolution;\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurX;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetX, true );\r\n\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 2)\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = this.renderTargetX.texture;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurY;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetY, true );\r\n\r\n\t\t// Render original scene with superimposed blur to texture\r\n\r\n\t\tthis.quad.material = this.materialCopy;\r\n\r\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetY.texture;\r\n\r\n\t\tif ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );\r\n\r\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.BloomPass.blurX = new THREE.Vector2( 0.001953125, 0.0 );\r\nTHREE.BloomPass.blurY = new THREE.Vector2( 0.0, 0.001953125 );\n},{\"three\":15}],4:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.EffectComposer = function ( renderer, renderTarget ) {\r\n\r\n\tthis.renderer = renderer;\r\n\r\n\tif ( renderTarget === undefined ) {\r\n\r\n\t\tvar parameters = {\r\n\t\t\tminFilter: THREE.LinearFilter,\r\n\t\t\tmagFilter: THREE.LinearFilter,\r\n\t\t\tformat: THREE.RGBAFormat,\r\n\t\t\tstencilBuffer: false\r\n\t\t};\r\n\t\tvar size = renderer.getSize();\r\n\t\trenderTarget = new THREE.WebGLRenderTarget( size.width, size.height, parameters );\r\n\r\n\t}\r\n\r\n\tthis.renderTarget1 = renderTarget;\r\n\tthis.renderTarget2 = renderTarget.clone();\r\n\r\n\tthis.writeBuffer = this.renderTarget1;\r\n\tthis.readBuffer = this.renderTarget2;\r\n\r\n\tthis.passes = [];\r\n\r\n\tif ( THREE.CopyShader === undefined )\r\n\t\tconsole.error( \"THREE.EffectComposer relies on THREE.CopyShader\" );\r\n\r\n\tthis.copyPass = new THREE.ShaderPass( THREE.CopyShader );\r\n\r\n};\r\n\r\nObject.assign( THREE.EffectComposer.prototype, {\r\n\r\n\tswapBuffers: function() {\r\n\r\n\t\tvar tmp = this.readBuffer;\r\n\t\tthis.readBuffer = this.writeBuffer;\r\n\t\tthis.writeBuffer = tmp;\r\n\r\n\t},\r\n\r\n\taddPass: function ( pass ) {\r\n\r\n\t\tthis.passes.push( pass );\r\n\r\n\t\tvar size = this.renderer.getSize();\r\n\t\tpass.setSize( size.width, size.height );\r\n\r\n\t},\r\n\r\n\tinsertPass: function ( pass, index ) {\r\n\r\n\t\tthis.passes.splice( index, 0, pass );\r\n\r\n\t},\r\n\r\n\trender: function ( delta ) {\r\n\r\n\t\tvar maskActive = false;\r\n\r\n\t\tvar pass, i, il = this.passes.length;\r\n\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tpass = this.passes[ i ];\r\n\r\n\t\t\tif ( pass.enabled === false ) continue;\r\n\r\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );\r\n\r\n\t\t\tif ( pass.needsSwap ) {\r\n\r\n\t\t\t\tif ( maskActive ) {\r\n\r\n\t\t\t\t\tvar context = this.renderer.context;\r\n\r\n\t\t\t\t\tcontext.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );\r\n\r\n\t\t\t\t\tcontext.stencilFunc( context.EQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.swapBuffers();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( THREE.MaskPass !== undefined ) {\r\n\r\n\t\t\t\tif ( pass instanceof THREE.MaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = true;\r\n\r\n\t\t\t\t} else if ( pass instanceof THREE.ClearMaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\treset: function ( renderTarget ) {\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\tvar size = this.renderer.getSize();\r\n\r\n\t\t\trenderTarget = this.renderTarget1.clone();\r\n\t\t\trenderTarget.setSize( size.width, size.height );\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTarget1.dispose();\r\n\t\tthis.renderTarget2.dispose();\r\n\t\tthis.renderTarget1 = renderTarget;\r\n\t\tthis.renderTarget2 = renderTarget.clone();\r\n\r\n\t\tthis.writeBuffer = this.renderTarget1;\r\n\t\tthis.readBuffer = this.renderTarget2;\r\n\r\n\t},\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tthis.renderTarget1.setSize( width, height );\r\n\t\tthis.renderTarget2.setSize( width, height );\r\n\r\n\t\tfor ( var i = 0; i < this.passes.length; i ++ ) {\r\n\r\n\t\t\tthis.passes[i].setSize( width, height );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\nTHREE.Pass = function () {\r\n\r\n\t// if set to true, the pass is processed by the composer\r\n\tthis.enabled = true;\r\n\r\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\r\n\tthis.needsSwap = true;\r\n\r\n\t// if set to true, the pass clears its buffer before rendering\r\n\tthis.clear = false;\r\n\r\n\t// if set to true, the result of the pass is rendered to screen\r\n\tthis.renderToScreen = false;\r\n\r\n};\r\n\r\nObject.assign( THREE.Pass.prototype, {\r\n\r\n\tsetSize: function( width, height ) {},\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tconsole.error( \"THREE.Pass: .render() must be implemented in derived pass.\" );\r\n\r\n\t}\r\n\r\n} );\n},{\"three\":15}],5:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tif ( THREE.FilmShader === undefined )\r\n\t\tconsole.error( \"THREE.FilmPass relies on THREE.FilmShader\" );\r\n\r\n\tvar shader = THREE.FilmShader;\r\n\r\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\tthis.material = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.uniforms,\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t} );\r\n\r\n\tif ( grayscale !== undefined )\tthis.uniforms.grayscale.value = grayscale;\r\n\tif ( noiseIntensity !== undefined ) this.uniforms.nIntensity.value = noiseIntensity;\r\n\tif ( scanlinesIntensity !== undefined ) this.uniforms.sIntensity.value = scanlinesIntensity;\r\n\tif ( scanlinesCount !== undefined ) this.uniforms.sCount.value = scanlinesCount;\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.FilmPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.FilmPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.uniforms[ \"time\" ].value += delta;\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n},{\"three\":15}],6:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MaskPass = function ( scene, camera ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.clear = true;\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.inverse = false;\r\n\r\n};\r\n\r\nTHREE.MaskPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.MaskPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tvar context = renderer.context;\r\n\t\tvar state = renderer.state;\r\n\r\n\t\t// don't update color or depth\r\n\r\n\t\tstate.buffers.color.setMask( false );\r\n\t\tstate.buffers.depth.setMask( false );\r\n\r\n\t\t// lock buffers\r\n\r\n\t\tstate.buffers.color.setLocked( true );\r\n\t\tstate.buffers.depth.setLocked( true );\r\n\r\n\t\t// set up stencil\r\n\r\n\t\tvar writeValue, clearValue;\r\n\r\n\t\tif ( this.inverse ) {\r\n\r\n\t\t\twriteValue = 0;\r\n\t\t\tclearValue = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\twriteValue = 1;\r\n\t\t\tclearValue = 0;\r\n\r\n\t\t}\r\n\r\n\t\tstate.buffers.stencil.setTest( true );\r\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\r\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\r\n\t\tstate.buffers.stencil.setClear( clearValue );\r\n\r\n\t\t// draw into the stencil buffer\r\n\r\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\r\n\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t// unlock color and depth buffer for subsequent rendering\r\n\r\n\t\tstate.buffers.color.setLocked( false );\r\n\t\tstate.buffers.depth.setLocked( false );\r\n\r\n\t\t// only render where stencil is set to 1\r\n\r\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1\r\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\nTHREE.ClearMaskPass = function () {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n};\r\n\r\nTHREE.ClearMaskPass.prototype = Object.create( THREE.Pass.prototype );\r\n\r\nObject.assign( THREE.ClearMaskPass.prototype, {\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\trenderer.state.buffers.stencil.setTest( false );\r\n\r\n\t}\r\n\r\n} );\n},{\"three\":15}],7:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n/*global THREE, console */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\r\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\r\n// supported.\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\r\n//\r\n// This is a drop-in replacement for (most) TrackballControls used in examples.\r\n// That is, include this js file and wherever you see:\r\n//    \tcontrols = new THREE.TrackballControls( camera );\r\n//      controls.target.z = 150;\r\n// Simple substitute \"OrbitControls\" and the control should work as-is.\r\n\r\nTHREE.OrbitControls = function ( object, domElement ) {\r\n\r\n    this.object = object;\r\n    this.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n    // API\r\n\r\n    // Set to false to disable this control\r\n    this.enabled = true;\r\n\r\n    // \"target\" sets the location of focus, where the control orbits around\r\n    // and where it pans with respect to.\r\n    this.target = new THREE.Vector3();\r\n    // center is old, deprecated; use \"target\" instead\r\n    this.center = this.target;\r\n\r\n    // This option actually enables dollying in and out; left as \"zoom\" for\r\n    // backwards compatibility\r\n    this.noZoom = false;\r\n    this.zoomSpeed = 1.0;\r\n    // Limits to how far you can dolly in and out\r\n    this.minDistance = 0;\r\n    this.maxDistance = Infinity;\r\n\r\n    // Set to true to disable this control\r\n    this.noRotate = false;\r\n    this.rotateSpeed = 1.0;\r\n\r\n    // Set to true to disable this control\r\n    this.noPan = false;\r\n    this.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n    // Set to true to automatically rotate around the target\r\n    this.autoRotate = false;\r\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n    // How far you can orbit vertically, upper and lower limits.\r\n    // Range is 0 to Math.PI radians.\r\n    this.minPolarAngle = 0; // radians\r\n    this.maxPolarAngle = Math.PI; // radians\r\n\r\n    // Set to true to disable use of the keys\r\n    this.noKeys = false;\r\n    // The four arrow keys\r\n    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n    ////////////\r\n    // internals\r\n\r\n    var scope = this;\r\n\r\n    var EPS = 0.000001;\r\n\r\n    var rotateStart = new THREE.Vector2();\r\n    var rotateEnd = new THREE.Vector2();\r\n    var rotateDelta = new THREE.Vector2();\r\n\r\n    var panStart = new THREE.Vector2();\r\n    var panEnd = new THREE.Vector2();\r\n    var panDelta = new THREE.Vector2();\r\n\r\n    var dollyStart = new THREE.Vector2();\r\n    var dollyEnd = new THREE.Vector2();\r\n    var dollyDelta = new THREE.Vector2();\r\n\r\n    var phiDelta = 0;\r\n    var thetaDelta = 0;\r\n    var scale = 1;\r\n    var pan = new THREE.Vector3();\r\n\r\n    var lastPosition = new THREE.Vector3();\r\n\r\n    var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\r\n    var state = STATE.NONE;\r\n\r\n    // events\r\n\r\n    var changeEvent = { type: 'change' };\r\n\r\n\r\n    this.rotateLeft = function ( angle ) {\r\n\r\n        if ( angle === undefined ) {\r\n\r\n            angle = getAutoRotationAngle();\r\n\r\n        }\r\n\r\n        thetaDelta -= angle;\r\n\r\n    };\r\n\r\n    this.rotateUp = function ( angle ) {\r\n\r\n        if ( angle === undefined ) {\r\n\r\n            angle = getAutoRotationAngle();\r\n\r\n        }\r\n\r\n        phiDelta -= angle;\r\n\r\n    };\r\n\r\n    // pass in distance in world space to move left\r\n    this.panLeft = function ( distance ) {\r\n\r\n        var panOffset = new THREE.Vector3();\r\n        var te = this.object.matrix.elements;\r\n        // get X column of matrix\r\n        panOffset.set( te[0], te[1], te[2] );\r\n        panOffset.multiplyScalar(-distance);\r\n\r\n        pan.add( panOffset );\r\n\r\n    };\r\n\r\n    // pass in distance in world space to move up\r\n    this.panUp = function ( distance ) {\r\n\r\n        var panOffset = new THREE.Vector3();\r\n        var te = this.object.matrix.elements;\r\n        // get Y column of matrix\r\n        panOffset.set( te[4], te[5], te[6] );\r\n        panOffset.multiplyScalar(distance);\r\n\r\n        pan.add( panOffset );\r\n    };\r\n\r\n    // main entry point; pass in Vector2 of change desired in pixel space,\r\n    // right and down are positive\r\n    this.pan = function ( delta ) {\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        if ( scope.object.fov !== undefined ) {\r\n\r\n            // perspective\r\n            var position = scope.object.position;\r\n            var offset = position.clone().sub( scope.target );\r\n            var targetDistance = offset.length();\r\n\r\n            // half of the fov is center to top of screen\r\n            targetDistance *= Math.tan( (scope.object.fov/2) * Math.PI / 180.0 );\r\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n            scope.panLeft( 2 * delta.x * targetDistance / element.clientHeight );\r\n            scope.panUp( 2 * delta.y * targetDistance / element.clientHeight );\r\n\r\n        } else if ( scope.object.top !== undefined ) {\r\n\r\n            // orthographic\r\n            scope.panLeft( delta.x * (scope.object.right - scope.object.left) / element.clientWidth );\r\n            scope.panUp( delta.y * (scope.object.top - scope.object.bottom) / element.clientHeight );\r\n\r\n        } else {\r\n\r\n            // camera neither orthographic or perspective - warn user\r\n            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n\r\n        }\r\n\r\n    };\r\n\r\n    this.dollyIn = function ( dollyScale ) {\r\n\r\n        if ( dollyScale === undefined ) {\r\n\r\n            dollyScale = getZoomScale();\r\n\r\n        }\r\n\r\n        scale /= dollyScale;\r\n\r\n    };\r\n\r\n    this.dollyOut = function ( dollyScale ) {\r\n\r\n        if ( dollyScale === undefined ) {\r\n\r\n            dollyScale = getZoomScale();\r\n\r\n        }\r\n\r\n        scale *= dollyScale;\r\n\r\n    };\r\n\r\n    this.update = function () {\r\n\r\n        var position = this.object.position;\r\n        var offset = position.clone().sub( this.target );\r\n\r\n        // angle from z-axis around y-axis\r\n\r\n        var theta = Math.atan2( offset.x, offset.z );\r\n\r\n        // angle from y-axis\r\n\r\n        var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\r\n\r\n        if ( this.autoRotate ) {\r\n\r\n            this.rotateLeft( getAutoRotationAngle() );\r\n\r\n        }\r\n\r\n        theta += thetaDelta;\r\n        phi += phiDelta;\r\n\r\n        // restrict phi to be between desired limits\r\n        phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\r\n\r\n        // restrict phi to be betwee EPS and PI-EPS\r\n        phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\r\n\r\n        var radius = offset.length() * scale;\r\n\r\n        // restrict radius to be between desired limits\r\n        radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\r\n\r\n        // move target to panned location\r\n        this.target.add( pan );\r\n\r\n        offset.x = radius * Math.sin( phi ) * Math.sin( theta );\r\n        offset.y = radius * Math.cos( phi );\r\n        offset.z = radius * Math.sin( phi ) * Math.cos( theta );\r\n\r\n        position.copy( this.target ).add( offset );\r\n\r\n        this.object.lookAt( this.target );\r\n\r\n        thetaDelta = 0;\r\n        phiDelta = 0;\r\n        scale = 1;\r\n        pan.set(0,0,0);\r\n\r\n        if ( lastPosition.distanceTo( this.object.position ) > 0 ) {\r\n\r\n            this.dispatchEvent( changeEvent );\r\n\r\n            lastPosition.copy( this.object.position );\r\n\r\n        }\r\n\r\n    };\r\n\r\n\r\n    function getAutoRotationAngle() {\r\n\r\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n    }\r\n\r\n    function getZoomScale() {\r\n\r\n        return Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n    }\r\n\r\n    function onMouseDown( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n        event.preventDefault();\r\n\r\n        if ( event.button === 0 ) {\r\n            if ( scope.noRotate === true ) { return; }\r\n\r\n            state = STATE.ROTATE;\r\n\r\n            rotateStart.set( event.clientX, event.clientY );\r\n\r\n        } else if ( event.button === 1 ) {\r\n            if ( scope.noZoom === true ) { return; }\r\n\r\n            state = STATE.DOLLY;\r\n\r\n            dollyStart.set( event.clientX, event.clientY );\r\n\r\n        } else if ( event.button === 2 ) {\r\n            if ( scope.noPan === true ) { return; }\r\n\r\n            state = STATE.PAN;\r\n\r\n            panStart.set( event.clientX, event.clientY );\r\n\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.domElement.addEventListener( 'mousemove', onMouseMove, false );\r\n        scope.domElement.addEventListener( 'mouseup', onMouseUp, false );\r\n\r\n    }\r\n\r\n    function onMouseMove( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        if ( state === STATE.ROTATE ) {\r\n\r\n            if ( scope.noRotate === true ) return;\r\n\r\n            rotateEnd.set( event.clientX, event.clientY );\r\n            rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n            // rotating across whole screen goes 360 degrees around\r\n            scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n            scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n            rotateStart.copy( rotateEnd );\r\n\r\n        } else if ( state === STATE.DOLLY ) {\r\n\r\n            if ( scope.noZoom === true ) return;\r\n\r\n            dollyEnd.set( event.clientX, event.clientY );\r\n            dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n            if ( dollyDelta.y > 0 ) {\r\n\r\n                scope.dollyIn();\r\n\r\n            } else {\r\n\r\n                scope.dollyOut();\r\n\r\n            }\r\n\r\n            dollyStart.copy( dollyEnd );\r\n\r\n        } else if ( state === STATE.PAN ) {\r\n\r\n            if ( scope.noPan === true ) return;\r\n\r\n            panEnd.set( event.clientX, event.clientY );\r\n            panDelta.subVectors( panEnd, panStart );\r\n\r\n            scope.pan( panDelta );\r\n\r\n            panStart.copy( panEnd );\r\n\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function onMouseUp( /* event */ ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.domElement.removeEventListener( 'mousemove', onMouseMove, false );\r\n        scope.domElement.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n        state = STATE.NONE;\r\n\r\n    }\r\n\r\n    function onMouseWheel( event ) {\r\n\r\n        if ( scope.enabled === false || scope.noZoom === true ) return;\r\n\r\n        var delta = 0;\r\n\r\n        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\r\n\r\n            delta = event.wheelDelta;\r\n\r\n        } else if ( event.detail ) { // Firefox\r\n\r\n            delta = - event.detail;\r\n\r\n        }\r\n\r\n        if ( delta > 0 ) {\r\n\r\n            scope.dollyOut();\r\n\r\n        } else {\r\n\r\n            scope.dollyIn();\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onKeyDown( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n        if ( scope.noKeys === true ) { return; }\r\n        if ( scope.noPan === true ) { return; }\r\n\r\n        // pan a pixel - I guess for precise positioning?\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        var needUpdate = false;\r\n\r\n        switch ( event.keyCode ) {\r\n\r\n            case scope.keys.UP:\r\n                scope.pan( new THREE.Vector2( 0, scope.keyPanSpeed ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.BOTTOM:\r\n                scope.pan( new THREE.Vector2( 0, -scope.keyPanSpeed ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.LEFT:\r\n                scope.pan( new THREE.Vector2( scope.keyPanSpeed, 0 ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.RIGHT:\r\n                scope.pan( new THREE.Vector2( -scope.keyPanSpeed, 0 ) );\r\n                needUpdate = true;\r\n                break;\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        if ( needUpdate ) {\r\n\r\n            scope.update();\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function touchstart( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1:\t// one-fingered touch: rotate\r\n                if ( scope.noRotate === true ) { return; }\r\n\r\n                state = STATE.TOUCH_ROTATE;\r\n\r\n                rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                break;\r\n\r\n            case 2:\t// two-fingered touch: dolly\r\n                if ( scope.noZoom === true ) { return; }\r\n\r\n                state = STATE.TOUCH_DOLLY;\r\n\r\n                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n                var distance = Math.sqrt( dx * dx + dy * dy );\r\n                dollyStart.set( 0, distance );\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n                if ( scope.noPan === true ) { return; }\r\n\r\n                state = STATE.TOUCH_PAN;\r\n\r\n                panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                break;\r\n\r\n            default:\r\n                state = STATE.NONE;\r\n\r\n        }\r\n    }\r\n\r\n    function touchmove( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1: // one-fingered touch: rotate\r\n                if ( scope.noRotate === true ) { return; }\r\n                if ( state !== STATE.TOUCH_ROTATE ) { return; }\r\n\r\n                rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n                // rotating across whole screen goes 360 degrees around\r\n                scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n                scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n                rotateStart.copy( rotateEnd );\r\n                break;\r\n\r\n            case 2: // two-fingered touch: dolly\r\n                if ( scope.noZoom === true ) { return; }\r\n                if ( state !== STATE.TOUCH_DOLLY ) { return; }\r\n\r\n                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n                var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n                dollyEnd.set( 0, distance );\r\n                dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n                if ( dollyDelta.y > 0 ) {\r\n\r\n                    scope.dollyOut();\r\n\r\n                } else {\r\n\r\n                    scope.dollyIn();\r\n\r\n                }\r\n\r\n                dollyStart.copy( dollyEnd );\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n                if ( scope.noPan === true ) { return; }\r\n                if ( state !== STATE.TOUCH_PAN ) { return; }\r\n\r\n                panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                panDelta.subVectors( panEnd, panStart );\r\n\r\n                scope.pan( panDelta );\r\n\r\n                panStart.copy( panEnd );\r\n                break;\r\n\r\n            default:\r\n                state = STATE.NONE;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function touchend( /* event */ ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        state = STATE.NONE;\r\n    }\r\n\r\n    this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\r\n    this.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n    this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\r\n    this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\r\n\r\n    this.domElement.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n    this.domElement.addEventListener( 'touchstart', touchstart, false );\r\n    this.domElement.addEventListener( 'touchend', touchend, false );\r\n    this.domElement.addEventListener( 'touchmove', touchmove, false );\r\n\r\n};\r\n\r\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n},{\"three\":15}],8:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.overrideMaterial = overrideMaterial;\r\n\r\n\tthis.clearColor = clearColor;\r\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\r\n\r\n\tthis.clear = true;\r\n\tthis.needsSwap = false;\r\n\r\n};\r\n\r\nTHREE.RenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.RenderPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.scene.overrideMaterial = this.overrideMaterial;\r\n\r\n\t\tvar oldClearColor, oldClearAlpha;\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\toldClearColor = renderer.getClearColor().getHex();\r\n\t\t\toldClearAlpha = renderer.getClearAlpha();\r\n\r\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\r\n\r\n\t\t}\r\n\r\n\t\tthis.scene.overrideMaterial = null;\r\n\r\n\t}\r\n\r\n} );\n},{\"three\":15}],9:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ShaderPass = function ( shader, textureID ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.textureID = ( textureID !== undefined ) ? textureID : \"tDiffuse\";\r\n\r\n\tif ( shader instanceof THREE.ShaderMaterial ) {\r\n\r\n\t\tthis.uniforms = shader.uniforms;\r\n\r\n\t\tthis.material = shader;\r\n\r\n\t} else if ( shader ) {\r\n\r\n\t\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\tthis.material = new THREE.ShaderMaterial( {\r\n\r\n\t\t\tdefines: shader.defines || {},\r\n\t\t\tuniforms: this.uniforms,\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.ShaderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.ShaderPass,\r\n\r\n\trender: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( this.uniforms[ this.textureID ] ) {\r\n\r\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\r\n\r\n\t\t}\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n},{\"three\":15}],10:[function(require,module,exports){\n'use strict';\r\n\r\nvar uniforms;\r\n\r\nvar THREE = require('three');\r\n\r\nvar OrbitControls = require('../libs/OrbitControls.js');\r\n\r\nvar CopyShader = require('../shaders/CopyShader.js');\r\nvar FilmShader = require('../shaders/FilmShader.js');\r\nvar ConvolutionShader = require('../shaders/ConvolutionShader.js');\r\nvar BadTv = require('../shaders/BadTv.js');\r\n\r\nvar EffectComposer = require('../libs/EffectComposer.js');\r\nvar RenderPass = require('../libs/RenderPass.js');\r\nvar FilmPass = require('../libs/FilmPass.js');\r\nvar BloomPass = require('../libs/BloomPass.js');\r\nvar MaskPass = require('../libs/MaskPass.js');\r\nvar ShaderPass = require('../libs/ShaderPass.js');\r\n\r\nvar Stage = function() {\r\n  \r\n  this.renderer = new THREE.WebGLRenderer({alpha: true});\r\n  this.renderer.setPixelRatio(window.devicePixelRatio);\r\n  this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n\r\n  // document.body.appendChild(this.renderer.domElement);\r\n\r\n  this.camera = new THREE.PerspectiveCamera(35, ((window.innerWidth / 2) / (window.innerHeight / 2)), 1, 3000);\r\n  this.camera.position.z = 4;\r\n\r\n  this.scene = new THREE.Scene();\r\n\r\n  this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);\r\n  this.controls.autoRotate = true;\r\n\r\n  this.visualElement;\r\n\r\n};\r\n\r\nStage.prototype.init = function() {\r\n\r\n  this.getAudio();\r\n\r\n  requestAnimationFrame(this.animate.bind(this));\r\n\r\n  // on resize\r\n  window.addEventListener('resize', this._onResize.bind(this));\r\n\r\n  TweenMax.to(document.querySelector('.bg'), 2000, {\r\n    rotation: -1080,\r\n    yoyo: true,\r\n    repeat: -1,\r\n    ease: Power1.easeOut\r\n  });\r\n\r\n  this.renderModel = new THREE.RenderPass( this.scene, this.camera );\r\n  this.effectBloom = new THREE.BloomPass( 1.25 );\r\n  this.effectFilm = new THREE.FilmPass( 0.35, 0.95, 2048, false );\r\n\r\n  this.effectFilm.renderToScreen = true;\r\n\r\n  this.composer = new THREE.EffectComposer( this.renderer );\r\n\r\n  this.composer.addPass(this.renderModel);\r\n  this.composer.addPass(this.effectBloom);\r\n  this.composer.addPass(this.effectFilm);\r\n\r\n  this.badTVEffect = new THREE.ShaderPass(THREE.BadTVShader);\r\n  this.badTVEffect.uniforms['speed'].value = 10;\r\n  this.badTVEffect.uniforms['rollSpeed'].value = 20;\r\n  // this.badTVEffect.renderToScreen = true;\r\n  this.composer.addPass(this.badTVEffect);\r\n\r\n  this.clock = new THREE.Clock();\r\n\r\n  uniforms = {\r\n\r\n    fogDensity: { value: 0.1 },\r\n    fogColor:   { value: new THREE.Vector3( 0, 0, 0 ) },\r\n    time:       { value: 1.0 },\r\n    resolution: { value: new THREE.Vector2() },\r\n    uvScale:    { value: new THREE.Vector2( 3.0, 1.0 ) },\r\n    texture1:   { value: new THREE.TextureLoader().load( \"images/cloud.png\" ) },\r\n    texture2:   { value: new THREE.TextureLoader().load( \"images/lavatile.jpg\" ) }\r\n\r\n  };\r\n\r\n  uniforms.texture1.value.wrapS = uniforms.texture1.value.wrapT = THREE.RepeatWrapping;\r\n  uniforms.texture2.value.wrapS = uniforms.texture2.value.wrapT = THREE.RepeatWrapping;\r\n\r\n  var size = 0.65;\r\n\r\n  this.visualMaterial = new THREE.ShaderMaterial( {\r\n\r\n    uniforms: uniforms,\r\n    vertexShader: document.getElementById( 'vertexShader' ).textContent,\r\n    fragmentShader: document.getElementById( 'fragmentShader' ).textContent\r\n\r\n  } );\r\n\r\n  this.visualMesh = new THREE.Mesh( new THREE.TorusGeometry( size, 0.3, 30, 30 ), this.visualMaterial);\r\n  this.visualMesh.rotation.x = 0.3;\r\n  this.scene.add(this.visualMesh);\r\n\r\n  this.renderer = new THREE.WebGLRenderer({antialias: true});\r\n  this.renderer.setPixelRatio(window.devicePixelRatio);\r\n  document.body.appendChild(this.renderer.domElement);\r\n  this.renderer.autoClear = false;\r\n\r\n  this._onResize();\r\n};\r\n\r\nStage.prototype.animate = function() {\r\n  requestAnimationFrame(this.animate.bind(this));\r\n  var time = Date.now();\r\n\r\n  this.update(time);\r\n\r\n  this.renderer.render(this.scene, this.camera);\r\n\r\n};\r\n\r\nStage.prototype.update = function(time) {\r\n  var diff = time - this.lastTime;\r\n  this.lastTime = time;\r\n\r\n  if (!this.lastTime) {\r\n    this.lastTime = time;\r\n    \r\n    return;\r\n  }  \r\n\r\n  // this.object.rotation.x += 0.0025;\r\n  // this.object.rotation.y += 0.001;\r\n  //this.partSystem.rotation.y = time * 0.0005;\r\n\r\n  var delta = 5 * this.clock.getDelta();\r\n\r\n  // uniforms.time.value += 0.2 * delta;\r\n  // this.visualMaterial.uniforms['time'].value += 0.2 * delta;\r\n\r\n  this.visualMesh.rotation.y += 0.0125 * delta;\r\n  this.visualMesh.rotation.x += 0.05 * delta;\r\n\r\n  this.renderer.clear();\r\n  this.composer.render(0.1);\r\n\r\n  this.controls.update()\r\n\r\n  this.updateVisual();\r\n\r\n};\r\n\r\nStage.prototype.updateVisual = function() {\r\n  var array = new Uint8Array(this.analyser.frequencyBinCount);\r\n  var frequencyArray = new Float32Array(this.analyser.frequencyBinCount);\r\n\r\n  var frequencyData = new Uint8Array(this.barsAnalyser.frequencyBinCount);\r\n  \r\n  this.analyser.getByteFrequencyData(array);\r\n  this.analyser.getFloatFrequencyData(frequencyArray);\r\n  \r\n  var average = this._getAverageVolume(array);\r\n  var frequencyAverage = this._getAverageVolume(frequencyArray);\r\n  var frequencyDataArray = this._getAverageVolume(frequencyData);\r\n\r\n  this.visualMaterial.uniforms['fogDensity'].value = frequencyAverage / 200;\r\n  this.visualMaterial.uniforms['time'].value = average / 50;\r\n\r\n  this.barsArray.forEach(function(bar, index) {\r\n    bar.style.height = Math.abs(frequencyArray[index]) + 'px';\r\n  });\r\n\r\n};\r\n\r\nStage.prototype.soundBars = function() {\r\n\r\n  this.soundBars = document.querySelector('#soundBars');\r\n\r\n  this.barsArray = [];\r\n\r\n  var barSpacingPercent = this.barsAnalyser.frequencyBinCount / 100;\r\n  \r\n  for (var i = 0; i < this.barsAnalyser.frequencyBinCount; i++) {\r\n\r\n    this.newBars = document.createElement('div');\r\n    this.soundBars.appendChild(this.newBars);\r\n    this.barsArray.push(this.newBars);\r\n\r\n  };\r\n\r\n};\r\n\r\nStage.prototype.getAudio = function() {\r\n  var context = new AudioContext();\r\n  this.analyser = context.createAnalyser();\r\n  this.analyser.smoothingTimeConstant = 0.4;\r\n  this.analyser.fftSize = 1024;\r\n\r\n  this.analyser2 = context.createAnalyser();\r\n  this.analyser2.smoothingTimeConstant = 0.4;\r\n  this.analyser2.fftSize = 1024;\r\n\r\n  this.barsAnalyser = context.createAnalyser();\r\n  this.barsAnalyser.fftSize = 64;\r\n\r\n  var sourceNode = context.createBufferSource();\r\n  var splitter = context.createChannelSplitter();\r\n\r\n  sourceNode.connect(splitter);\r\n\r\n  splitter.connect(this.analyser, 0);\r\n  splitter.connect(this.analyser2, 1);\r\n\r\n  sourceNode.connect(context.destination);\r\n\r\n  var request = new XMLHttpRequest();\r\n  request.open('GET', 'audio/sasha.mp3', true);\r\n  request.responseType = 'arraybuffer';\r\n\r\n  var songBuffer;\r\n  \r\n  request.onload = function() {\r\n    context.decodeAudioData(request.response, function(buffer) {\r\n      songBuffer = buffer;\r\n\r\n      var dur = buffer.duration;\r\n\r\n      sourceNode.buffer = buffer;\r\n      sourceNode.start(0);\r\n      sourceNode.loop = true;\r\n      sourceNode.muted = true;\r\n\r\n    }, this._onError);\r\n  }.bind(this);\r\n\r\n  request.send();\r\n\r\n  this.soundBars();\r\n};\r\n\r\nStage.prototype._getAverageVolume = function(array) {\r\n  var values = 0;\r\n  var average;\r\n  var length = array.length;\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    values += array[i];\r\n  }\r\n\r\n  average = values / length;\r\n\r\n  return average;\r\n};\r\n\r\nStage.prototype._onResize = function() {\r\n  this.camera.aspect = window.innerWidth / window.innerHeight;\r\n  this.camera.updateProjectionMatrix();\r\n  \r\n  this.renderer.setSize( window.innerWidth, window.innerHeight );\r\n  \r\n  this.composer.setSize( window.innerWidth, window.innerHeight );\r\n  this.composer.reset();\r\n\r\n  uniforms.resolution.value.x = window.innerWidth;\r\n  uniforms.resolution.value.y = window.innerHeight;\r\n};\r\n\r\nStage.prototype._onError = function(e) {\r\n  console.log(e);\r\n};\r\n\r\nmodule.exports = Stage;\n},{\"../libs/BloomPass.js\":3,\"../libs/EffectComposer.js\":4,\"../libs/FilmPass.js\":5,\"../libs/MaskPass.js\":6,\"../libs/OrbitControls.js\":7,\"../libs/RenderPass.js\":8,\"../libs/ShaderPass.js\":9,\"../shaders/BadTv.js\":11,\"../shaders/ConvolutionShader.js\":12,\"../shaders/CopyShader.js\":13,\"../shaders/FilmShader.js\":14,\"three\":15}],11:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author Felix Turner / www.airtight.cc / @felixturner\r\n *\r\n * Bad TV Shader\r\n * Simulates a bad TV via horizontal distortion and vertical roll\r\n * Uses Ashima WebGl Noise: https://github.com/ashima/webgl-noise\r\n *\r\n * time: steadily increasing float passed in\r\n * distortion: amount of thick distortion\r\n * distortion2: amount of fine grain distortion\r\n * speed: distortion vertical travel speed\r\n * rollSpeed: vertical roll speed\r\n *\r\n * The MIT License\r\n *\r\n * Copyright (c) 2014 Felix Turner\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n *\r\n */\r\n\r\nTHREE.BadTVShader = {\r\n  uniforms: {\r\n    \"tDiffuse\":    { type: \"t\", value: null },\r\n    \"time\":        { type: \"f\", value: 0.0 },\r\n    \"distortion\":  { type: \"f\", value: 0.5 },\r\n    \"distortion2\": { type: \"f\", value: 1.5 },\r\n    \"speed\":       { type: \"f\", value: 0.5 },\r\n    \"rollSpeed\":   { type: \"f\", value: 0.0 },\r\n  },\r\n\r\n  vertexShader: [\r\n    \"varying vec2 vUv;\",\r\n    \"void main() {\",\r\n    \"vUv = uv;\",\r\n    \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n    \"}\"\r\n\r\n  ].join(\"\\n\"),\r\n\r\n  fragmentShader: [\r\n\r\n    \"uniform sampler2D tDiffuse;\",\r\n    \"uniform float time;\",\r\n    \"uniform float distortion;\",\r\n    \"uniform float distortion2;\",\r\n    \"uniform float speed;\",\r\n    \"uniform float rollSpeed;\",\r\n    \"varying vec2 vUv;\",\r\n\r\n    // Start Ashima 2D Simplex Noise\r\n\r\n    \"vec3 mod289(vec3 x) {\",\r\n    \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\",\r\n    \"}\",\r\n\r\n    \"vec2 mod289(vec2 x) {\",\r\n    \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\",\r\n    \"}\",\r\n\r\n    \"vec3 permute(vec3 x) {\",\r\n    \"  return mod289(((x*34.0)+1.0)*x);\",\r\n    \"}\",\r\n\r\n    \"float snoise(vec2 v)\",\r\n    \"  {\",\r\n    \"  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\",\r\n    \"                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\",\r\n    \"                     -0.577350269189626,  // -1.0 + 2.0 * C.x\",\r\n    \"                      0.024390243902439); // 1.0 / 41.0\",\r\n    \"  vec2 i  = floor(v + dot(v, C.yy) );\",\r\n    \"  vec2 x0 = v -   i + dot(i, C.xx);\",\r\n\r\n    \"  vec2 i1;\",\r\n    \"  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\",\r\n    \"  vec4 x12 = x0.xyxy + C.xxzz;\",\r\n    \" x12.xy -= i1;\",\r\n\r\n    \"  i = mod289(i); // Avoid truncation effects in permutation\",\r\n    \"  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\",\r\n    \"   + i.x + vec3(0.0, i1.x, 1.0 ));\",\r\n\r\n    \"  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\",\r\n    \"  m = m*m ;\",\r\n    \"  m = m*m ;\",\r\n\r\n    \"  vec3 x = 2.0 * fract(p * C.www) - 1.0;\",\r\n    \"  vec3 h = abs(x) - 0.5;\",\r\n    \"  vec3 ox = floor(x + 0.5);\",\r\n    \"  vec3 a0 = x - ox;\",\r\n\r\n    \"  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\",\r\n\r\n    \"  vec3 g;\",\r\n    \"  g.x  = a0.x  * x0.x  + h.x  * x0.y;\",\r\n    \"  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\",\r\n    \"  return 130.0 * dot(m, g);\",\r\n    \"}\",\r\n\r\n    // End Ashima 2D Simplex Noise\r\n\r\n    \"void main() {\",\r\n\r\n      \"vec2 p = vUv;\",\r\n      \"float ty = time*speed;\",\r\n      \"float yt = p.y - ty;\",\r\n\r\n      //smooth distortion\r\n      \"float offset = snoise(vec2(yt*3.0,0.0))*0.2;\",\r\n      // boost distortion\r\n      \"offset = pow( offset*distortion,3.0)/distortion;\",\r\n      //add fine grain distortion\r\n      \"offset += snoise(vec2(yt*50.0,0.0))*distortion2*0.001;\",\r\n      //combine distortion on X with roll on Y\r\n      \"gl_FragColor = texture2D(tDiffuse,  vec2(fract(p.x + offset),fract(p.y-time*rollSpeed) ));\",\r\n\r\n    \"}\"\r\n\r\n  ].join(\"\\n\")\r\n\r\n};\n},{\"three\":15}],12:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Convolution shader\r\n * ported from o3d sample to WebGL / GLSL\r\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\r\n */\r\n\r\nTHREE.ConvolutionShader = {\r\n\r\n\tdefines: {\r\n\r\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\r\n\t\t\"KERNEL_SIZE_INT\": \"25\",\r\n\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":        { value: null },\r\n\t\t\"uImageIncrement\": { value: new THREE.Vector2( 0.001953125, 0.0 ) },\r\n\t\t\"cKernel\":         { value: [] }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 imageCoord = vUv;\",\r\n\t\t\t\"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\r\n\r\n\t\t\t\"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\r\n\r\n\t\t\t\t\"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\r\n\t\t\t\t\"imageCoord += uImageIncrement;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\"}\"\r\n\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tbuildKernel: function ( sigma ) {\r\n\r\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\r\n\r\n\t\tfunction gauss( x, sigma ) {\r\n\r\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\r\n\r\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\r\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\r\n\r\n\t\tvalues = new Array( kernelSize );\r\n\t\tsum = 0.0;\r\n\t\tfor ( i = 0; i < kernelSize; ++ i ) {\r\n\r\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\r\n\t\t\tsum += values[ i ];\r\n\r\n\t\t}\r\n\r\n\t\t// normalize the kernel\r\n\r\n\t\tfor ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\r\n\r\n\t\treturn values;\r\n\r\n\t}\r\n\r\n};\n},{\"three\":15}],13:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Full-screen textured quad shader\r\n */\r\n\r\nTHREE.CopyShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"opacity\":  { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float opacity;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\"gl_FragColor = opacity * texel;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n},{\"three\":15}],14:[function(require,module,exports){\n'use strict';\n\nvar THREE = require('three');\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\n\nTHREE.FilmShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { value: null },\n\t\t\"time\":       { value: 0.0 },\n\t\t\"nIntensity\": { value: 0.5 },\n\t\t\"sIntensity\": { value: 0.05 },\n\t\t\"sCount\":     { value: 4096 },\n\t\t\"grayscale\":  { value: 1 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"#include <common>\",\n\t\t\n\t\t// control parameter\n\t\t\"uniform float time;\",\n\n\t\t\"uniform bool grayscale;\",\n\n\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float nIntensity;\",\n\n\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float sIntensity;\",\n\n\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\t\"uniform float sCount;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t// sample the source\n\t\t\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// make some noise\n\t\t\t\"float dx = rand( vUv + time );\",\n\n\t\t\t// add noise\n\t\t\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\",\n\n\t\t\t// get us a sine and cosine\n\t\t\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t\t\t// add scanlines\n\t\t\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t\t\t// interpolate between source and result by intensity\n\t\t\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t\t\t// convert to grayscale if desired\n\t\t\t\"if( grayscale ) {\",\n\n\t\t\t\t\"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor =  vec4( cResult, cTextureScreen.a );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\n},{\"three\":15}],15:[function(require,module,exports){\n// File:src/Three.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar THREE = { REVISION: '78' };\n\n//\n\nif ( typeof define === 'function' && define.amd ) {\n\n\tdefine( 'three', THREE );\n\n} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\n\n\tmodule.exports = THREE;\n\n}\n\n// Polyfills\n\nif ( Number.EPSILON === undefined ) {\n\n\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n}\n\n//\n\nif ( Math.sign === undefined ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\tMath.sign = function ( x ) {\n\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t};\n\n}\n\nif ( Function.prototype.name === undefined ) {\n\n\t// Missing in IE9-11.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\tget: function () {\n\n\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\n\t\t}\n\n\t} );\n\n}\n\nif ( Object.assign === undefined ) {\n\n\t// Missing in IE.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t( function () {\n\n\t\tObject.assign = function ( target ) {\n\n\t\t\t'use strict';\n\n\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t}\n\n\t\t\tvar output = Object( target );\n\n\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t};\n\n\t} )();\n\n}\n\n//\n\nObject.assign( THREE, {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\n\n\tMOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },\n\n\t// GL STATE CONSTANTS\n\n\tCullFaceNone: 0,\n\tCullFaceBack: 1,\n\tCullFaceFront: 2,\n\tCullFaceFrontBack: 3,\n\n\tFrontFaceDirectionCW: 0,\n\tFrontFaceDirectionCCW: 1,\n\n\t// SHADOWING TYPES\n\n\tBasicShadowMap: 0,\n\tPCFShadowMap: 1,\n\tPCFSoftShadowMap: 2,\n\n\t// MATERIAL CONSTANTS\n\n\t// side\n\n\tFrontSide: 0,\n\tBackSide: 1,\n\tDoubleSide: 2,\n\n\t// shading\n\n\tFlatShading: 1,\n\tSmoothShading: 2,\n\n\t// colors\n\n\tNoColors: 0,\n\tFaceColors: 1,\n\tVertexColors: 2,\n\n\t// blending modes\n\n\tNoBlending: 0,\n\tNormalBlending: 1,\n\tAdditiveBlending: 2,\n\tSubtractiveBlending: 3,\n\tMultiplyBlending: 4,\n\tCustomBlending: 5,\n\n\t// custom blending equations\n\t// (numbers start from 100 not to clash with other\n\t// mappings to OpenGL constants defined in Texture.js)\n\n\tAddEquation: 100,\n\tSubtractEquation: 101,\n\tReverseSubtractEquation: 102,\n\tMinEquation: 103,\n\tMaxEquation: 104,\n\n\t// custom blending destination factors\n\n\tZeroFactor: 200,\n\tOneFactor: 201,\n\tSrcColorFactor: 202,\n\tOneMinusSrcColorFactor: 203,\n\tSrcAlphaFactor: 204,\n\tOneMinusSrcAlphaFactor: 205,\n\tDstAlphaFactor: 206,\n\tOneMinusDstAlphaFactor: 207,\n\n\t// custom blending source factors\n\n\t//ZeroFactor: 200,\n\t//OneFactor: 201,\n\t//SrcAlphaFactor: 204,\n\t//OneMinusSrcAlphaFactor: 205,\n\t//DstAlphaFactor: 206,\n\t//OneMinusDstAlphaFactor: 207,\n\tDstColorFactor: 208,\n\tOneMinusDstColorFactor: 209,\n\tSrcAlphaSaturateFactor: 210,\n\n\t// depth modes\n\n\tNeverDepth: 0,\n\tAlwaysDepth: 1,\n\tLessDepth: 2,\n\tLessEqualDepth: 3,\n\tEqualDepth: 4,\n\tGreaterEqualDepth: 5,\n\tGreaterDepth: 6,\n\tNotEqualDepth: 7,\n\n\n\t// TEXTURE CONSTANTS\n\n\tMultiplyOperation: 0,\n\tMixOperation: 1,\n\tAddOperation: 2,\n\n\t// Tone Mapping modes\n\n\tNoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)\n\tLinearToneMapping: 1, // only apply exposure.\n\tReinhardToneMapping: 2,\n\tUncharted2ToneMapping: 3, // John Hable\n\tCineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\n\t// Mapping modes\n\n\tUVMapping: 300,\n\n\tCubeReflectionMapping: 301,\n\tCubeRefractionMapping: 302,\n\n\tEquirectangularReflectionMapping: 303,\n\tEquirectangularRefractionMapping: 304,\n\n\tSphericalReflectionMapping: 305,\n\tCubeUVReflectionMapping: 306,\n\tCubeUVRefractionMapping: 307,\n\n\t// Wrapping modes\n\n\tRepeatWrapping: 1000,\n\tClampToEdgeWrapping: 1001,\n\tMirroredRepeatWrapping: 1002,\n\n\t// Filters\n\n\tNearestFilter: 1003,\n\tNearestMipMapNearestFilter: 1004,\n\tNearestMipMapLinearFilter: 1005,\n\tLinearFilter: 1006,\n\tLinearMipMapNearestFilter: 1007,\n\tLinearMipMapLinearFilter: 1008,\n\n\t// Data types\n\n\tUnsignedByteType: 1009,\n\tByteType: 1010,\n\tShortType: 1011,\n\tUnsignedShortType: 1012,\n\tIntType: 1013,\n\tUnsignedIntType: 1014,\n\tFloatType: 1015,\n\tHalfFloatType: 1025,\n\n\t// Pixel types\n\n\t//UnsignedByteType: 1009,\n\tUnsignedShort4444Type: 1016,\n\tUnsignedShort5551Type: 1017,\n\tUnsignedShort565Type: 1018,\n\n\t// Pixel formats\n\n\tAlphaFormat: 1019,\n\tRGBFormat: 1020,\n\tRGBAFormat: 1021,\n\tLuminanceFormat: 1022,\n\tLuminanceAlphaFormat: 1023,\n\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\n\tRGBEFormat: THREE.RGBAFormat, //1024;\n\tDepthFormat: 1026,\n\n\t// DDS / ST3C Compressed texture formats\n\n\tRGB_S3TC_DXT1_Format: 2001,\n\tRGBA_S3TC_DXT1_Format: 2002,\n\tRGBA_S3TC_DXT3_Format: 2003,\n\tRGBA_S3TC_DXT5_Format: 2004,\n\n\t// PVRTC compressed texture formats\n\n\tRGB_PVRTC_4BPPV1_Format: 2100,\n\tRGB_PVRTC_2BPPV1_Format: 2101,\n\tRGBA_PVRTC_4BPPV1_Format: 2102,\n\tRGBA_PVRTC_2BPPV1_Format: 2103,\n\n\t// ETC compressed texture formats\n\n\tRGB_ETC1_Format: 2151,\n\n\t// Loop styles for AnimationAction\n\n\tLoopOnce: 2200,\n\tLoopRepeat: 2201,\n\tLoopPingPong: 2202,\n\n\t// Interpolation\n\n\tInterpolateDiscrete: 2300,\n\tInterpolateLinear: 2301,\n\tInterpolateSmooth: 2302,\n\n\t// Interpolant ending modes\n\n\tZeroCurvatureEnding: 2400,\n\tZeroSlopeEnding: 2401,\n\tWrapAroundEnding: 2402,\n\n\t// Triangle Draw modes\n\n\tTrianglesDrawMode: 0,\n\tTriangleStripDrawMode: 1,\n\tTriangleFanDrawMode: 2,\n\n\t// Texture Encodings\n\n\tLinearEncoding: 3000, // No encoding at all.\n\tsRGBEncoding: 3001,\n\tGammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\n\n\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\n\t// These encodings should not specified as output encodings except in rare situations.\n\tRGBEEncoding: 3002, // AKA Radiance.\n\tLogLuvEncoding: 3003,\n\tRGBM7Encoding: 3004,\n\tRGBM16Encoding: 3005,\n\tRGBDEncoding: 3006, // MaxRange is 256.\n\n\t// Depth packing strategies\n\n\tBasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers\n\tRGBADepthPacking: 3201 // for packing into RGBA buffers.\n\n} );\n\n// File:src/math/Color.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Color = function ( r, g, b ) {\n\n\tif ( g === undefined && b === undefined ) {\n\n\t\t// r is THREE.Color, hex or string\n\t\treturn this.set( r );\n\n\t}\n\n\treturn this.setRGB( r, g, b );\n\n};\n\nTHREE.Color.prototype = {\n\n\tconstructor: THREE.Color,\n\n\tr: 1, g: 1, b: 1,\n\n\tset: function ( value ) {\n\n\t\tif ( value instanceof THREE.Color ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSL: function () {\n\n\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\tif ( t < 0 ) t += 1;\n\t\t\tif ( t > 1 ) t -= 1;\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\treturn p;\n\n\t\t}\n\n\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\th = THREE.Math.euclideanModulo( h, 1 );\n\t\t\ts = THREE.Math.clamp( s, 0, 1 );\n\t\t\tl = THREE.Math.clamp( l, 0, 1 );\n\n\t\t\tif ( s === 0 ) {\n\n\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t} else {\n\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetStyle: function ( style ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar m;\n\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tvar color;\n\t\t\tvar name = m[ 1 ];\n\t\t\tvar components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tvar hex = m[ 1 ];\n\t\t\tvar size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( style && style.length > 0 ) {\n\n\t\t\t// color keywords\n\t\t\tvar hex = THREE.ColorKeywords[ style ];\n\n\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t// red\n\t\t\t\tthis.setHex( hex );\n\n\t\t\t} else {\n\n\t\t\t\t// unknown color\n\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t},\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function () {\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tthis.r = r * r;\n\t\tthis.g = g * g;\n\t\tthis.b = b * b;\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function () {\n\n\t\tthis.r = Math.sqrt( this.r );\n\t\tthis.g = Math.sqrt( this.g );\n\t\tthis.b = Math.sqrt( this.b );\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetHexString: function () {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t},\n\n\tgetHSL: function ( optionalTarget ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tvar max = Math.max( r, g, b );\n\t\tvar min = Math.min( r, g, b );\n\n\t\tvar hue, saturation;\n\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tvar delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\thsl.h = hue;\n\t\thsl.s = saturation;\n\t\thsl.l = lightness;\n\n\t\treturn hsl;\n\n\t},\n\n\tgetStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\toffsetHSL: function ( h, s, l ) {\n\n\t\tvar hsl = this.getHSL();\n\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t},\n\n\taddColors: function ( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n};\n\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n// File:src/math/Quaternion.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Quaternion = function ( x, y, z, w ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Quaternion.prototype = {\n\n\tconstructor: THREE.Quaternion,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget w () {\n\n\t\treturn this._w;\n\n\t},\n\n\tset w ( value ) {\n\n\t\tthis._w = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t},\n\n\tcopy: function ( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( euler, update ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\tvar order = euler.order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromUnitVectors: function () {\n\n\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tvar v1, r;\n\n\t\tvar EPS = 0.000001;\n\n\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\tif ( r < EPS ) {\n\n\t\t\t\tr = 0;\n\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t}\n\n\t\t\tthis._x = v1.x;\n\t\t\tthis._y = v1.y;\n\t\t\tthis._z = v1.z;\n\t\t\tthis._w = r;\n\n\t\t\treturn this.normalize();\n\n\t\t};\n\n\t}(),\n\n\tinverse: function () {\n\n\t\treturn this.conjugate().normalize();\n\n\t},\n\n\tconjugate: function () {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t},\n\n\tpremultiply: function ( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t},\n\n\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tslerp: function ( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\nObject.assign( THREE.Quaternion, {\n\n\tslerp: function( qa, qb, qm, t ) {\n\n\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t},\n\n\tslerpFlat: function(\n\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tvar s = 1 - t,\n\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tvar tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n} );\n\n// File:src/math/Vector2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Vector2 = function ( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n};\n\nTHREE.Vector2.prototype = {\n\n\tconstructor: THREE.Vector2,\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t},\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t},\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t},\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t},\n\n\t//\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector2();\n\t\t\t\tmax = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t},\n\n\tlengthManhattan: function() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tangle: function () {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\treturn angle;\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\trotateAround: function ( center, angle ) {\n\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tvar x = this.x - center.x;\n\t\tvar y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author *kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector3 = function ( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n};\n\nTHREE.Vector3.prototype = {\n\n\tconstructor: THREE.Vector3,\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVectors: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyEuler: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyEuler( euler ) {\n\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyAxisAngle: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\tapplyProjection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 projection matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\n\t\treturn this;\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t},\n\n\tproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function project( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\tunproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function unproject( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\ttransformDirection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector3();\n\t\t\t\tmax = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tcross: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tthis.x = y * v.z - z * v.y;\n\t\tthis.y = z * v.x - x * v.z;\n\t\tthis.z = x * v.y - y * v.x;\n\n\t\treturn this;\n\n\t},\n\n\tcrossVectors: function ( a, b ) {\n\n\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t},\n\n\tprojectOnVector: function ( vector ) {\n\n\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\n\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\n\t},\n\n\tprojectOnPlane: function () {\n\n\t\tvar v1;\n\n\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( v1 );\n\n\t\t};\n\n\t}(),\n\n\treflect: function () {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\tvar v1;\n\n\t\treturn function reflect( normal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t};\n\n\t}(),\n\n\tangleTo: function ( v ) {\n\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t},\n\n\tsetFromSpherical: function( s ) {\n\n\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixPosition: function ( m ) {\n\n\t\treturn this.setFromMatrixColumn( m, 3 );\n\n\t},\n\n\tsetFromMatrixScale: function ( m ) {\n\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\tif ( typeof m === 'number' ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\tvar temp = m\n\t\t\tm = index;\n\t\t\tindex = temp;\n\n\t\t}\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector4.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector4 = function ( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Vector4.prototype = {\n\n\tconstructor: THREE.Vector4,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\tthis.w *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\t this.x = 1;\n\t\t\t this.y = 0;\n\t\t\t this.z = 0;\n\n\t\t} else {\n\n\t\t\t this.x = q.x / s;\n\t\t\t this.y = q.y / s;\n\t\t\t this.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector4();\n\t\t\t\tmax = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\t\tthis.w = attribute.array[ index + 3 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Euler.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Euler = function ( x, y, z, order ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._order = order || THREE.Euler.DefaultOrder;\n\n};\n\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nTHREE.Euler.DefaultOrder = 'XYZ';\n\nTHREE.Euler.prototype = {\n\n\tconstructor: THREE.Euler,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget order () {\n\n\t\treturn this._order;\n\n\t},\n\n\tset order ( value ) {\n\n\t\tthis._order = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order || this._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t},\n\n\tcopy: function ( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\tvar clamp = THREE.Math.clamp;\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._y = 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromQuaternion: function () {\n\n\t\tvar matrix;\n\n\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t};\n\n\t}(),\n\n\tsetFromVector3: function ( v, order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t},\n\n\treorder: function () {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\tvar q = new THREE.Quaternion();\n\n\t\treturn function reorder( newOrder ) {\n\n\t\t\tq.setFromEuler( this );\n\t\t\t\n\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t},\n\n\ttoVector3: function ( optionalResult ) {\n\n\t\tif ( optionalResult ) {\n\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t} else {\n\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\n\n\t\t}\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\n// File:src/math/Line3.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Line3 = function ( start, end ) {\n\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\n\n};\n\nTHREE.Line3.prototype = {\n\n\tconstructor: THREE.Line3,\n\n\tset: function ( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t},\n\n\tdelta: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.end, this.start );\n\n\t},\n\n\tdistanceSq: function () {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t},\n\n\tdistance: function () {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tclosestPointToPointParameter: function () {\n\n\t\tvar startP = new THREE.Vector3();\n\t\tvar startEnd = new THREE.Vector3();\n\n\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\tstartP.subVectors( point, this.start );\n\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\tif ( clampToLine ) {\n\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\n\n\t\t\t}\n\n\t\t\treturn t;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n};\n\n// File:src/math/Box2.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Box2 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\n\n};\n\nTHREE.Box2.prototype = {\n\n\tconstructor: THREE.Box2,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Box3.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Box3 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\n\n};\n\nTHREE.Box3.prototype = {\n\n\tconstructor: THREE.Box3,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromArray: function ( array ) {\n\n\t\tvar minX = + Infinity;\n\t\tvar minY = + Infinity;\n\t\tvar minZ = + Infinity;\n\n\t\tvar maxX = - Infinity;\n\t\tvar maxY = - Infinity;\n\t\tvar maxZ = - Infinity;\n\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tvar x = array[ i ];\n\t\t\tvar y = array[ i + 1 ];\n\t\t\tvar z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function () {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromObject( object ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\n\n\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\n\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\tv1.fromArray( positions, i );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsSphere: ( function () {\n\n\t\tvar closestPoint;\n\n\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\n\n\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t};\n\n\t} )(),\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tvar min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tgetBoundingSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\n\t\t\tresult.center = this.center();\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar points = [\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3()\n\t\t];\n\n\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t// transform of empty box is an empty box.\n\t\t\tif( this.isEmpty() ) return this;\n\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Matrix3.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n * @author tschw\n */\n\nTHREE.Matrix3 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0,\n\t\t0, 1, 0,\n\t\t0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix3.prototype = {\n\n\tconstructor: THREE.Matrix3,\n\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix4: function( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t},\n\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\tif ( matrix instanceof THREE.Matrix4 ) {\n\n\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n\t\t}\n\n\t\tvar me = matrix.elements,\n\t\t\tte = this.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t},\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Matrix4.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Matrix4 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix4.prototype = {\n\n\tconstructor: THREE.Matrix4,\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Matrix4().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tthis.elements.set( m.elements );\n\n\t\treturn this;\n\n\t},\n\n\tcopyPosition: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0,       0,       0,       1\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function () {\n\n\t\tvar v1;\n\n\t\treturn function extractRotation( m ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeRotationFromEuler: function ( euler ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\tte[ 4 ] = xy - wz;\n\t\tte[ 8 ] = xz + wy;\n\n\t\tte[ 1 ] = xy + wz;\n\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\tte[ 9 ] = yz - wx;\n\n\t\tte[ 2 ] = xz - wy;\n\t\tte[ 6 ] = yz + wx;\n\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function () {\n\n\t\tvar x, y, z;\n\n\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\tif ( x === undefined ) {\n\n\t\t\t\tx = new THREE.Vector3();\n\t\t\t\ty = new THREE.Vector3();\n\t\t\t\tz = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\tz.z = 1;\n\n\t\t\t}\n\n\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\tz.z += 0.0001;\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t}\n\n\t\t\ty.crossVectors( z, x );\n\n\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tpremultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyToArray: function ( a, b, r ) {\n\n\t\tvar te = this.elements;\n\n\t\tthis.multiplyMatrices( a, b );\n\n\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetPosition: function () {\n\n\t\tvar v1;\n\n\t\treturn function getPosition() {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t};\n\n\t}(),\n\n\tsetPosition: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 12 ] = v.x;\n\t\tte[ 13 ] = v.y;\n\t\tte[ 14 ] = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements,\n\t\t\tme = m.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t},\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0,  0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s,  c, 0,\n\t\t\t0, 0,  0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts,  c, 0, 0,\n\t\t\t0,  0, 1, 0,\n\t\t\t0,  0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function ( position, quaternion, scale ) {\n\n\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\tthis.scale( scale );\n\t\tthis.setPosition( position );\n\n\t\treturn this;\n\n\t},\n\n\tdecompose: function () {\n\n\t\tvar vector, matrix;\n\n\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tvector = new THREE.Vector3();\n\t\t\t\tmatrix = new THREE.Matrix4();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t// if determine is negative, we need to invert one scale\n\t\t\tvar det = this.determinant();\n\t\t\tif ( det < 0 ) {\n\n\t\t\t\tsx = - sx;\n\n\t\t\t}\n\n\t\t\tposition.x = te[ 12 ];\n\t\t\tposition.y = te[ 13 ];\n\t\t\tposition.z = te[ 14 ];\n\n\t\t\t// scale the rotation part\n\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\tvar invSX = 1 / sx;\n\t\t\tvar invSY = 1 / sy;\n\t\t\tvar invSZ = 1 / sz;\n\n\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\tvar ymin = - ymax;\n\t\tvar xmin = ymin * aspect;\n\t\tvar xmax = ymax * aspect;\n\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = 1.0 / ( right - left );\n\t\tvar h = 1.0 / ( top - bottom );\n\t\tvar p = 1.0 / ( far - near );\n\n\t\tvar x = ( right + left ) * w;\n\t\tvar y = ( top + bottom ) * h;\n\t\tvar z = ( far + near ) * p;\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( matrix ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = matrix.elements;\n\n\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Ray.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Ray = function ( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\n};\n\nTHREE.Ray.prototype = {\n\n\tconstructor: THREE.Ray,\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\tlookAt: function ( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\trecast: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function recast( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.subVectors( point, this.origin );\n\t\tvar directionDistance = result.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn result.copy( this.origin );\n\n\t\t}\n\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t},\n\n\tdistanceSqToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t// point behind the ray\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t}\n\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\treturn v1.distanceToSquared( point );\n\n\t\t};\n\n\t}(),\n\n\tdistanceSqToSegment: function () {\n\n\t\tvar segCenter = new THREE.Vector3();\n\t\tvar segDir = new THREE.Vector3();\n\t\tvar diff = new THREE.Vector3();\n\n\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\tvar c = diff.lengthSq();\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\tif ( det > 0 ) {\n\n\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\n\t\t};\n\n\t}(),\n\n\tintersectSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\tvar tca = v1.dot( this.direction );\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\tvar t0 = tca - thc;\n\n\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\tvar t1 = tca + thc;\n\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t// test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t :  null;\n\n\t},\n\n\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\tvar t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, optionalTarget );\n\n\t},\n\n\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tintersectBox: function ( box, optionalTarget ) {\n\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tvar invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tvar origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t},\n\n\tintersectsBox: ( function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t};\n\n\t} )(),\n\n\tintersectTriangle: function () {\n\n\t\t// Compute the offset origin, edges, and normal.\n\t\tvar diff = new THREE.Vector3();\n\t\tvar edge1 = new THREE.Vector3();\n\t\tvar edge2 = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\n\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\tedge1.subVectors( b, a );\n\t\t\tedge2.subVectors( c, a );\n\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\tvar sign;\n\n\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\tsign = 1;\n\n\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\tsign = - 1;\n\t\t\t\tDdN = - DdN;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tdiff.subVectors( this.origin, a );\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t// b1 < 0, no intersection\n\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t// b2 < 0, no intersection\n\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// b1+b2 > 1, no intersection\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Line intersects triangle, check if ray does.\n\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t// t < 0, no intersection\n\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Ray intersects triangle.\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.sub( this.origin );\n\t\tthis.direction.normalize();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n};\n\n// File:src/math/Sphere.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Sphere = function ( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n};\n\nTHREE.Sphere.prototype = {\n\n\tconstructor: THREE.Sphere,\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function () {\n\n\t\tvar box = new THREE.Box3();\n\n\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\tvar center = this.center;\n\n\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromPoints( points ).center( center );\n\n\t\t\t}\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We use the following equation to compute the signed distance from\n\t\t// the center of the sphere to the plane.\n\t\t//\n\t\t// distance = q * n - d\n\t\t//\n\t\t// If this distance is greater than the radius of the sphere,\n\t\t// then there is no intersection.\n\n\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tresult.sub( this.center ).normalize();\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\tvar box = optionalTarget || new THREE.Box3();\n\n\t\tbox.set( this.center, this.center );\n\t\tbox.expandByScalar( this.radius );\n\n\t\treturn box;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n};\n\n// File:src/math/Frustum.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://clara.io\n */\n\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\n\tthis.planes = [\n\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\n\t];\n\n};\n\nTHREE.Frustum.prototype = {\n\n\tconstructor: THREE.Frustum,\n\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tvar planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( frustum ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix: function ( m ) {\n\n\t\tvar planes = this.planes;\n\t\tvar me = m.elements;\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\tintersectsObject: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsObject( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSprite: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar planes = this.planes;\n\t\tvar center = sphere.center;\n\t\tvar negRadius = - sphere.radius;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsBox: function () {\n\n\t\tvar p1 = new THREE.Vector3(),\n\t\t\tp2 = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\n\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t}(),\n\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n};\n\n// File:src/math/Plane.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Plane = function ( normal, constant ) {\n\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n};\n\nTHREE.Plane.prototype = {\n\n\tconstructor: THREE.Plane,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t},\n\n\torthoPoint: function ( point, optionalTarget ) {\n\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t},\n\n\tintersectLine: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tvar direction = line.delta( v1 );\n\n\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t};\n\n\t}(),\n\n\tintersectsLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t},\n\n\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar m1 = new THREE.Matrix3();\n\n\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t// transform normal based on theory here:\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n};\n\n// File:src/math/Spherical.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The poles (phi) are at the positive and negative y axis.\n * The equator starts at positive z.\n */\n\nTHREE.Spherical = function ( radius, phi, theta ) {\n\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\treturn this;\n\n};\n\nTHREE.Spherical.prototype = {\n\n\tconstructor: THREE.Spherical,\n\n\tset: function ( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( other ) {\n\n\t\tthis.radius.copy( other.radius );\n\t\tthis.phi.copy( other.phi );\n\t\tthis.theta.copy( other.theta );\n\n\t\treturn this;\n\n\t},\n\n\t// restrict phi to be betwee EPS and PI-EPS\n\tmakeSafe: function() {\n\n\t\tvar EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromVector3: function( vec3 ) {\n\n\t\tthis.radius = vec3.length();\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n};\n\n// File:src/math/Math.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Math = {\n\n\tDEG2RAD: Math.PI / 180,\n\tRAD2DEG: 180 / Math.PI,\n\n\tgenerateUUID: function () {\n\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\tvar uuid = new Array( 36 );\n\t\tvar rnd = 0, r;\n\n\t\treturn function generateUUID() {\n\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n\t\t\t\t\tuuid[ i ] = '-';\n\n\t\t\t\t} else if ( i === 14 ) {\n\n\t\t\t\t\tuuid[ i ] = '4';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uuid.join( '' );\n\n\t\t};\n\n\t}(),\n\n\tclamp: function ( value, min, max ) {\n\n\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t},\n\n\t// compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\teuclideanModulo: function ( n, m ) {\n\n\t\treturn ( ( n % m ) + m ) % m;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * ( 3 - 2 * x );\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t},\n\n\trandom16: function () {\n\n\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\treturn Math.random();\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tdegToRad: function ( degrees ) {\n\n\t\treturn degrees * THREE.Math.DEG2RAD;\n\n\t},\n\n\tradToDeg: function ( radians ) {\n\n\t\treturn radians * THREE.Math.RAD2DEG;\n\n\t},\n\n\tisPowerOfTwo: function ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t},\n\n\tnearestPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n\t},\n\n\tnextPowerOfTwo: function ( value ) {\n\n\t\tvalue --;\n\t\tvalue |= value >> 1;\n\t\tvalue |= value >> 2;\n\t\tvalue |= value >> 4;\n\t\tvalue |= value >> 8;\n\t\tvalue |= value >> 16;\n\t\tvalue ++;\n\n\t\treturn value;\n\n\t}\n\n};\n\n// File:src/math/Spline.js\n\n/**\n * Spline from Tween.js, slightly optimized (and trashed)\n * http://sole.github.com/tween.js/examples/05_spline.html\n *\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Spline = function ( points ) {\n\n\tthis.points = points;\n\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tthis.initFromArray = function ( a ) {\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t}\n\n\t};\n\n\tthis.getPoint = function ( k ) {\n\n\t\tpoint = ( this.points.length - 1 ) * k;\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\tpa = this.points[ c[ 0 ] ];\n\t\tpb = this.points[ c[ 1 ] ];\n\t\tpc = this.points[ c[ 2 ] ];\n\t\tpd = this.points[ c[ 3 ] ];\n\n\t\tw2 = weight * weight;\n\t\tw3 = weight * w2;\n\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\treturn v3;\n\n\t};\n\n\tthis.getControlPointsArray = function () {\n\n\t\tvar i, p, l = this.points.length,\n\t\t\tcoords = [];\n\n\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\tp = this.points[ i ];\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t}\n\n\t\treturn coords;\n\n\t};\n\n\t// approximate length by summing linear segments\n\n\tthis.getLength = function ( nSubDivisions ) {\n\n\t\tvar i, index, nSamples, position,\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\toldPosition = new THREE.Vector3(),\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tchunkLengths = [],\n\t\t\ttotalLength = 0;\n\n\t\t// first point has 0 length\n\n\t\tchunkLengths[ 0 ] = 0;\n\n\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\n\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\tindex = i / nSamples;\n\n\t\t\tposition = this.getPoint( index );\n\t\t\ttmpVec.copy( position );\n\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\toldPosition.copy( position );\n\n\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\tintPoint = Math.floor( point );\n\n\t\t\tif ( intPoint !== oldIntPoint ) {\n\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// last point ends with total length\n\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t};\n\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\tvar i, j,\n\t\t\tindex, indexCurrent, indexNext,\n\t\t\trealDistance,\n\t\t\tsampling, position,\n\t\t\tnewpoints = [],\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tsl = this.getLength();\n\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t}\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t}\n\n\t\tthis.points = newpoints;\n\n\t};\n\n\t// Catmull-Rom\n\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/math/Triangle.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Triangle = function ( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\n};\n\nTHREE.Triangle.normal = function () {\n\n\tvar v0 = new THREE.Vector3();\n\n\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.subVectors( c, b );\n\t\tv0.subVectors( a, b );\n\t\tresult.cross( v0 );\n\n\t\tvar resultLengthSq = result.lengthSq();\n\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t}\n\n\t\treturn result.set( 0, 0, 0 );\n\n\t};\n\n}();\n\n// static/instance method to calculate barycentric coordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\nTHREE.Triangle.barycoordFromPoint = function () {\n\n\tvar v0 = new THREE.Vector3();\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\n\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\tv0.subVectors( c, a );\n\t\tv1.subVectors( b, a );\n\t\tv2.subVectors( point, a );\n\n\t\tvar dot00 = v0.dot( v0 );\n\t\tvar dot01 = v0.dot( v1 );\n\t\tvar dot02 = v0.dot( v2 );\n\t\tvar dot11 = v1.dot( v1 );\n\t\tvar dot12 = v1.dot( v2 );\n\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tvar invDenom = 1 / denom;\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn result.set( 1 - u - v, v, u );\n\n\t};\n\n}();\n\nTHREE.Triangle.containsPoint = function () {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function containsPoint( point, a, b, c ) {\n\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t};\n\n}();\n\nTHREE.Triangle.prototype = {\n\n\tconstructor: THREE.Triangle,\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tarea: function () {\n\n\t\tvar v0 = new THREE.Vector3();\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function area() {\n\n\t\t\tv0.subVectors( this.c, this.b );\n\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t};\n\n\t}(),\n\n\tmidpoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tnormal: function ( optionalTarget ) {\n\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tplane: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Plane();\n\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tclosestPointToPoint: function () {\n\n\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\n\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\tif ( plane === undefined ) {\n\n\t\t\t\tplane = new THREE.Plane();\n\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\n\t\t\t\tprojectedPoint = new THREE.Vector3();\n\t\t\t\tclosestPoint = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\tvar minDistance = Infinity;\n\n\t\t\t// project the point onto the plane of the triangle\n\n\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t// check if the projection lies within the triangle\n\n\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t// if so, this is the closest point\n\n\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t} else {\n\n\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\tif( distance < minDistance ) {\n\n\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n};\n\n// File:src/math/Interpolant.js\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n * @author tschw\n */\n\nTHREE.Interpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tthis.parameterPositions = parameterPositions;\n\tthis._cachedIndex = 0;\n\n\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\tthis.sampleValues = sampleValues;\n\tthis.valueSize = sampleSize;\n\n};\n\nTHREE.Interpolant.prototype = {\n\n\tconstructor: THREE.Interpolant,\n\n\tevaluate: function( t ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\ti1 = this._cachedIndex,\n\n\t\t\tt1 = pp[   i1   ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tvar right;\n\n\t\t\t\tlinear_scan: {\n//- See http://jsperf.com/comparison-to-undefined/3\n//- slower code:\n//-\n//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n//- slower code:\n//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t},\n\n\tsettings: null, // optional, subclass-specific settings structure\n\t// Note: The indirection allows central control of many interpolants.\n\n\t// --- Protected interface\n\n\tDefaultSettings_: {},\n\n\tgetSettings_: function() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t},\n\n\tcopySampleValue_: function( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Template methods for derived classes:\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tthrow new Error( \"call to abstract method\" );\n\t\t// implementations shall return this.resultBuffer\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t// empty\n\n\t}\n\n};\n\nObject.assign( THREE.Interpolant.prototype, {\n\n\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_,\n\n\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_\n\n} );\n\n// File:src/math/interpolants/CubicInterpolant.js\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n *\n * @author tschw\n */\n\nTHREE.CubicInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\tthis._weightPrev = -0;\n\tthis._offsetPrev = -0;\n\tthis._weightNext = -0;\n\tthis._offsetNext = -0;\n\n};\n\nTHREE.CubicInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.CubicInterpolant,\n\n\tDefaultSettings_: {\n\n\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\tiPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t},\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/DiscreteInterpolant.js\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n *\n * @author tschw\n */\n\nTHREE.DiscreteInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.DiscreteInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.DiscreteInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n} );\n\n// File:src/math/interpolants/LinearInterpolant.js\n\n/**\n * @author tschw\n */\n\nTHREE.LinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.LinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.LinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/QuaternionLinearInterpolant.js\n\n/**\n * Spherical linear unit quaternion interpolant.\n *\n * @author tschw\n */\n\nTHREE.QuaternionLinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.QuaternionLinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.QuaternionLinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset = i1 * stride,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\n\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/core/Clock.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Clock = function ( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n};\n\nTHREE.Clock.prototype = {\n\n\tconstructor: THREE.Clock,\n\n\tstart: function () {\n\n\t\tthis.startTime = ( performance || Date ).now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.running = true;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\n\t},\n\n\tgetElapsedTime: function () {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t},\n\n\tgetDelta: function () {\n\n\t\tvar diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tvar newTime = ( performance || Date ).now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n};\n\n// File:src/core/EventDispatcher.js\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nTHREE.EventDispatcher = function () {};\n\nObject.assign( THREE.EventDispatcher.prototype, {\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function ( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\tvar array = [], i = 0;\n\t\t\tvar length = listenerArray.length;\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/core/Layers.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Layers = function () {\n\n\tthis.mask = 1;\n\n};\n\nTHREE.Layers.prototype = {\n\n\tconstructor: THREE.Layers,\n\n\tset: function ( channel ) {\n\n\t\tthis.mask = 1 << channel;\n\n\t},\n\n\tenable: function ( channel ) {\n\n\t\tthis.mask |= 1 << channel;\n\n\t},\n\n\ttoggle: function ( channel ) {\n\n\t\tthis.mask ^= 1 << channel;\n\n\t},\n\n\tdisable: function ( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel );\n\n\t},\n\n\ttest: function ( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n};\n\n// File:src/core/Raycaster.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://clara.io/\n * @author stephomi / http://stephaneginier.com/\n */\n\n( function ( THREE ) {\n\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\n\t\tthis.ray = new THREE.Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t};\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tTHREE.Raycaster.prototype = {\n\n\t\tconstructor: THREE.Raycaster,\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t};\n\n}( THREE ) );\n\n// File:src/core/Object3D.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author elephantatwork / www.elephantatwork.ch\n */\n\nTHREE.Object3D = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Object3D';\n\n\tthis.parent = null;\n\tthis.children = [];\n\n\tthis.up = THREE.Object3D.DefaultUp.clone();\n\n\tvar position = new THREE.Vector3();\n\tvar rotation = new THREE.Euler();\n\tvar quaternion = new THREE.Quaternion();\n\tvar scale = new THREE.Vector3( 1, 1, 1 );\n\n\tfunction onRotationChange() {\n\n\t\tquaternion.setFromEuler( rotation, false );\n\n\t}\n\n\tfunction onQuaternionChange() {\n\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t}\n\n\trotation.onChange( onRotationChange );\n\tquaternion.onChange( onQuaternionChange );\n\n\tObject.defineProperties( this, {\n\t\tposition: {\n\t\t\tenumerable: true,\n\t\t\tvalue: position\n\t\t},\n\t\trotation: {\n\t\t\tenumerable: true,\n\t\t\tvalue: rotation\n\t\t},\n\t\tquaternion: {\n\t\t\tenumerable: true,\n\t\t\tvalue: quaternion\n\t\t},\n\t\tscale: {\n\t\t\tenumerable: true,\n\t\t\tvalue: scale\n\t\t},\n\t\tmodelViewMatrix: {\n\t\t\tvalue: new THREE.Matrix4()\n\t\t},\n\t\tnormalMatrix: {\n\t\t\tvalue: new THREE.Matrix3()\n\t\t}\n\t} );\n\n\tthis.matrix = new THREE.Matrix4();\n\tthis.matrixWorld = new THREE.Matrix4();\n\n\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\n\tthis.matrixWorldNeedsUpdate = false;\n\n\tthis.layers = new THREE.Layers();\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\tthis.renderOrder = 0;\n\n\tthis.userData = {};\n\n};\n\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\n\nObject.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t},\n\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t},\n\n\tsetRotationFromEuler: function ( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t},\n\n\tsetRotationFromMatrix: function ( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t},\n\n\trotateOnAxis: function () {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar q1 = new THREE.Quaternion();\n\n\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\ttranslateOnAxis: function () {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function translateX( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function translateY( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function translateZ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function () {\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function worldToLocal( vector ) {\n\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object instanceof THREE.Object3D ) {\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\tthis.children.push( object );\n\n\t\t} else {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t}\n\n\t},\n\n\tgetObjectById: function ( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t},\n\n\tgetObjectByName: function ( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t},\n\n\tgetObjectByProperty: function ( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t},\n\n\tgetWorldQuaternion: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar scale = new THREE.Vector3();\n\n\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Quaternion();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldRotation: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Euler();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t};\n\n\t}(),\n\n\tgetWorldScale: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldDirection: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t};\n\n\t}(),\n\n\traycast: function () {},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseVisible: function ( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseAncestors: function ( callback ) {\n\n\t\tvar parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\t// meta is '' when called from JSON.stringify\n\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\n\t\tvar output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tvar object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\n\t\tobject.matrix = this.matrix.toArray();\n\n\t\t//\n\n\t\tif ( this.geometry !== undefined ) {\n\n\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.geometry = this.geometry.uuid;\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\n\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.material = this.material.uuid;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\t\t\treturn values;\n\n\t\t}\n\n\t},\n\n\tclone: function ( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t},\n\n\tcopy: function ( source, recursive ) {\n\n\t\tif ( recursive === undefined ) recursive = true;\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tvar child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\nTHREE.Object3DIdCount = 0;\n\n// File:src/core/Face3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n};\n\nTHREE.Face3.prototype = {\n\n\tconstructor: THREE.Face3,\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.a = source.a;\n\t\tthis.b = source.b;\n\t\tthis.c = source.c;\n\n\t\tthis.normal.copy( source.normal );\n\t\tthis.color.copy( source.color );\n\n\t\tthis.materialIndex = source.materialIndex;\n\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/BufferAttribute.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.itemSize = itemSize;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\tthis.normalized = normalized === true;\n\n};\n\nTHREE.BufferAttribute.prototype = {\n\n\tconstructor: THREE.BufferAttribute,\n\n\tget count() {\n\n\t\treturn this.array.length / this.itemSize;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyArray: function ( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t},\n\n\tcopyColorsArray: function ( colors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\tvar color = colors[ i ];\n\n\t\t\tif ( color === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\tcolor = new THREE.Color();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = color.r;\n\t\t\tarray[ offset ++ ] = color.g;\n\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyIndicesArray: function ( indices ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tvar index = indices[ i ];\n\n\t\t\tarray[ offset ++ ] = index.a;\n\t\t\tarray[ offset ++ ] = index.b;\n\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector2sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector3sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector4sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize ];\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n//\n\nTHREE.Int8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\n};\n\nTHREE.Int16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\n\n};\n\nTHREE.Uint16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\n\n};\n\nTHREE.Int32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\n\n};\n\nTHREE.Uint32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\n\n};\n\nTHREE.Float32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\n\n};\n\nTHREE.Float64Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\n\n};\n\n\n// Deprecated\n\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\n\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\n\n};\n\n// File:src/core/InstancedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\n\n\tTHREE.BufferAttribute.call( this, array, itemSize );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\n\nTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\n\n\tTHREE.BufferAttribute.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBuffer = function ( array, stride ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.stride = stride;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n};\n\nTHREE.InterleavedBuffer.prototype = {\n\n\tconstructor: THREE.InterleavedBuffer,\n\n\tget length () {\n\n\t\treturn this.array.length;\n\n\t},\n\n\tget count () {\n\n\t\treturn this.array.length / this.stride;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.stride = source.stride;\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n// File:src/core/InstancedInterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\n\n\tTHREE.InterleavedBuffer.call( this, array, stride );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\n\nTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.data = interleavedBuffer;\n\tthis.itemSize = itemSize;\n\tthis.offset = offset;\n\n};\n\n\nTHREE.InterleavedBufferAttribute.prototype = {\n\n\tconstructor: THREE.InterleavedBufferAttribute,\n\n\tget length() {\n\n\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\treturn this.array.length;\n\n\t},\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/Geometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://clara.io\n */\n\nTHREE.Geometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [ [] ];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.elementsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tvar scope = this;\n\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tvar tempNormals = [];\n\t\tvar tempUVs = [];\n\t\tvar tempUVs2 = [];\n\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( indices !== undefined ) {\n\n\t\t\tvar groups = geometry.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tvar center = this.boundingSphere.center;\n\t\tvar radius = this.boundingSphere.radius;\n\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tvar matrix = new THREE.Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\tvertices = new Array( this.vertices.length );\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new THREE.Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t},\n\n\tcomputeLineDistances: function () {\n\n\t\tvar d = 0;\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tif ( i > 0 ) {\n\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\tif ( geometry instanceof THREE.Geometry === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalMatrix,\n\t\tvertexOffset = this.vertices.length,\n\t\tvertices1 = this.vertices,\n\t\tvertices2 = geometry.vertices,\n\t\tfaces1 = this.faces,\n\t\tfaces2 = geometry.faces,\n\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tif ( uv === undefined ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( mesh instanceof THREE.Mesh === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i, il, face;\n\t\tvar indices, j, jl;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\tvar dupIndex = - 1;\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tdupIndex = n;\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tvar faces = this.faces;\n\t\tvar length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tvar newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tvar faces = [];\n\t\tvar normals = [];\n\t\tvar normalsHash = {};\n\t\tvar colors = [];\n\t\tvar colorsHash = {};\n\t\tvar uvs = [];\n\t\tvar uvsHash = {};\n\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tvar hasMaterial = true;\n\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tvar faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.vertices = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\n\t\tvar vertices = source.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\tvar faces = source.faces;\n\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.GeometryIdCount = 0;\n\n// File:src/core/DirectGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'DirectGeometry';\n\n\tthis.indices = [];\n\tthis.vertices = [];\n\tthis.normals = [];\n\tthis.colors = [];\n\tthis.uvs = [];\n\tthis.uvs2 = [];\n\n\tthis.groups = [];\n\n\tthis.morphTargets = {};\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\t// this.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\n\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\n\n\tcomputeFaceNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeGroups: function ( geometry ) {\n\n\t\tvar group;\n\t\tvar groups = [];\n\t\tvar materialIndex;\n\n\t\tvar faces = geometry.faces;\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tvar faces = geometry.faces;\n\t\tvar vertices = geometry.vertices;\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tvar morphTargets = geometry.morphTargets;\n\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\tvar morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tvar morphNormals = geometry.morphNormals;\n\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\tvar morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tvar skinIndices = geometry.skinIndices;\n\t\tvar skinWeights = geometry.skinWeights;\n\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/core/BufferGeometry.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n};\n\nObject.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tthis.index = index;\n\n\t},\n\n\taddAttribute: function ( name, attribute ) {\n\n\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( name === 'index' ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\tthis.setIndex( attribute );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tremoveAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tvar normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tsetFromObject: function ( object ) {\n\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\n\n\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\n\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tupdateFromObject: function ( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\tif ( direct === undefined ) {\n\n\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\tgeometry = direct;\n\n\t\t}\n\n\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.position;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.normal;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.color;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\tvar attribute = this.attributes.uv;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\tvar attribute = this.attributes.lineDistance;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\n\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t},\n\n\tfromDirectGeometry: function ( geometry ) {\n\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tthis.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tvar positions = this.attributes.position.array;\n\n\t\tif ( positions !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromArray( positions );\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar box = new THREE.Box3();\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function computeBoundingSphere() {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes.position;\n\n\t\t\tif ( positions ) {\n\n\t\t\t\tvar array = positions.array;\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tbox.setFromArray( array );\n\t\t\t\tbox.center( center );\n\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tvar index = this.index;\n\t\tvar attributes = this.attributes;\n\t\tvar groups = this.groups;\n\n\t\tif ( attributes.position ) {\n\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar normals = attributes.normal.array;\n\n\t\t\tvar vA, vB, vC,\n\n\t\t\tpA = new THREE.Vector3(),\n\t\t\tpB = new THREE.Vector3(),\n\t\t\tpC = new THREE.Vector3(),\n\n\t\t\tcb = new THREE.Vector3(),\n\t\t\tab = new THREE.Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tvar attribute1 = attributes[ key ];\n\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar normals = this.attributes.normal.array;\n\n\t\tvar x, y, z, n;\n\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\tx = normals[ i ];\n\t\t\ty = normals[ i + 1 ];\n\t\t\tz = normals[ i + 2 ];\n\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\tnormals[ i ] *= n;\n\t\t\tnormals[ i + 1 ] *= n;\n\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t}\n\n\t},\n\n\ttoNonIndexed: function () {\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar geometry2 = new THREE.BufferGeometry();\n\n\t\tvar indices = this.index.array;\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tvar index = 0, index2 = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tdata.data = { attributes: {} };\n\n\t\tvar index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: array\n\t\t\t};\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: attribute.normalized\n\t\t\t};\n\n\t\t}\n\n\t\tvar groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tvar boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.BufferGeometry.MaxIndex = 65535;\n\n// File:src/core/InstancedBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferGeometry = function () {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'InstancedBufferGeometry';\n\tthis.maxInstancedCount = undefined;\n\n};\n\nTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\n\nTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\n\n\tthis.groups.push( {\n\n\t\tstart: start,\n\t\tcount: count,\n\t\tinstances: instances\n\n\t} );\n\n};\n\nTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\n\n\tvar index = source.index;\n\n\tif ( index !== null ) {\n\n\t\tthis.setIndex( index.clone() );\n\n\t}\n\n\tvar attributes = source.attributes;\n\n\tfor ( var name in attributes ) {\n\n\t\tvar attribute = attributes[ name ];\n\t\tthis.addAttribute( name, attribute.clone() );\n\n\t}\n\n\tvar groups = source.groups;\n\n\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tvar group = groups[ i ];\n\t\tthis.addGroup( group.start, group.count, group.instances );\n\n\t}\n\n\treturn this;\n\n};\n\n// File:src/core/Uniform.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Uniform = function ( value ) {\n\n\tif ( typeof value === 'string' ) {\n\n\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\tvalue = arguments[ 1 ];\n\n\t}\n\n\tthis.value = value;\n\n\tthis.dynamic = false;\n\n};\n\nTHREE.Uniform.prototype = {\n\n\tconstructor: THREE.Uniform,\n\n\tonUpdate: function ( callback ) {\n\n\t\tthis.dynamic = true;\n\t\tthis.onUpdateCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/animation/AnimationAction.js\n\n/**\n *\n * Action provided by AnimationMixer for scheduling clip playback on specific\n * objects.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n *\n */\n\nTHREE.AnimationAction = function() {\n\n\tthrow new Error( \"THREE.AnimationAction: \" +\n\t\t\t\"Use mixer.clipAction for construction.\" );\n\n};\n\nTHREE.AnimationAction._new =\n\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\tthis._mixer = mixer;\n\tthis._clip = clip;\n\tthis._localRoot = localRoot || null;\n\n\tvar tracks = clip.tracks,\n\t\tnTracks = tracks.length,\n\t\tinterpolants = new Array( nTracks );\n\n\tvar interpolantSettings = {\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\t};\n\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\tinterpolants[ i ] = interpolant;\n\t\tinterpolant.settings = interpolantSettings;\n\n\t}\n\n\tthis._interpolantSettings = interpolantSettings;\n\n\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t// inside: PropertyMixer (managed by the mixer)\n\tthis._propertyBindings = new Array( nTracks );\n\n\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\tthis._timeScaleInterpolant = null;\n\tthis._weightInterpolant = null;\n\n\tthis.loop = THREE.LoopRepeat;\n\tthis._loopCount = -1;\n\n\t// global mixer time when the action is to be started\n\t// it's set back to 'null' upon start of the action\n\tthis._startTime = null;\n\n\t// scaled local time of the action\n\t// gets clamped or wrapped to 0..clip.duration according to loop\n\tthis.time = 0;\n\n\tthis.timeScale = 1;\n\tthis._effectiveTimeScale = 1;\n\n\tthis.weight = 1;\n\tthis._effectiveWeight = 1;\n\n\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\n\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n};\n\nTHREE.AnimationAction._new.prototype = {\n\n\tconstructor: THREE.AnimationAction._new,\n\n\t// State & Scheduling\n\n\tplay: function() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t},\n\n\tstop: function() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t},\n\n\treset: function() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0;\t\t\t// restart clip\n\t\tthis._loopCount = -1;\t// forget previous loops\n\t\tthis._startTime = null;\t// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t},\n\n\tisRunning: function() {\n\n\t\tvar start = this._startTime;\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t},\n\n\t// return true when play has been called\n\tisScheduled: function() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t},\n\n\tstartAt: function( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t},\n\n\tsetLoop: function( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t},\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight: function( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t},\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight: function() {\n\n\t\treturn this._effectiveWeight;\n\n\t},\n\n\tfadeIn: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t},\n\n\tfadeOut: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t},\n\n\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n\t\tvar mixer = this._mixer;\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif( warp ) {\n\n\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t},\n\n\tstopFading: function() {\n\n\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Time Scale Control\n\n\t// set the weight stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale: function( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale: function() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t},\n\n\tsetDuration: function( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\tsyncWith: function( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\thalt: function( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t},\n\n\twarp: function( startTimeScale, endTimeScale, duration ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t},\n\n\tstopWarping: function() {\n\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Object Accessors\n\n\tgetMixer: function() {\n\n\t\treturn this._mixer;\n\n\t},\n\n\tgetClip: function() {\n\n\t\treturn this._clip;\n\n\t},\n\n\tgetRoot: function() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t},\n\n\t// Interna\n\n\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t// called by the mixer\n\n\t\tvar startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tvar weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tvar interpolants = this._interpolants;\n\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_updateWeight: function( time ) {\n\n\t\tvar weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t},\n\n\t_updateTimeScale: function( time ) {\n\n\t\tvar timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t},\n\n\t_updateTime: function( deltaTime ) {\n\n\t\tvar time = this.time + deltaTime;\n\n\t\tif ( deltaTime === 0 ) return time;\n\n\t\tvar duration = this._clip.duration,\n\n\t\t\tloop = this.loop,\n\t\t\tloopCount = this._loopCount;\n\n\t\tif ( loop === THREE.LoopOnce ) {\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tthis.loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else break handle_stop;\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tvar pingPong = ( loop === THREE.LoopPingPong );\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t// wrap around\n\n\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\tthis.time = time;\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.time = time;\n\t\treturn time;\n\n\t},\n\n\t_setEndings: function( atStart, atEnd, pingPong ) {\n\n\t\tvar settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\n\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationClip.js\n\n/**\n *\n * Reusable set of Tracks that represent an animation.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationClip = function ( name, duration, tracks ) {\n\n\tthis.name = name;\n\tthis.tracks = tracks;\n\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// this means it should figure out its duration by scanning the tracks\n\tif ( this.duration < 0 ) {\n\n\t\tthis.resetDuration();\n\n\t}\n\n\t// maybe only do these on demand, as doing them here could potentially slow down loading\n\t// but leaving these here during development as this ensures a lot of testing of these functions\n\tthis.trim();\n\tthis.optimize();\n\n};\n\nTHREE.AnimationClip.prototype = {\n\n\tconstructor: THREE.AnimationClip,\n\n\tresetDuration: function() {\n\n\t\tvar tracks = this.tracks,\n\t\t\tduration = 0;\n\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tvar track = this.tracks[ i ];\n\n\t\t\tduration = Math.max(\n\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t},\n\n\ttrim: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\toptimize: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.AnimationClip, {\n\n\tparse: function( json ) {\n\n\t\tvar tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\n\n\t},\n\n\n\ttoJSON: function( clip ) {\n\n\t\tvar tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tvar json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks\n\n\t\t};\n\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t},\n\n\n\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tvar times = [];\n\t\t\tvar values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\ti,\n\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\t\tnew THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\ttimes, values\n\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t}\n\n\t\treturn new THREE.AnimationClip( name, -1, tracks );\n\n\t},\n\n\tfindByName: function( objectOrClipArray, name ) {\n\n\t\tvar clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tvar o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\n\t\tvar animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar clips = [];\n\n\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t},\n\n\t// parse the animation.hierarchy format\n\tparseAnimation: function( animation, bones, nodeName ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar addNonemptyTrack = function(\n\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\tTHREE.AnimationUtils.flattenJSON(\n\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar tracks = [];\n\n\t\tvar clipName = animation.name || 'default';\n\t\t// automatic length determination in AnimationClip.\n\t\tvar duration = animation.length || -1;\n\t\tvar fps = animation.fps || 30;\n\n\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets in a way exactly compatible\n\t\t\t// with AnimationHandler.init( animation )\n\t\t\tif ( animationKeys[0].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tvar morphTargetNames = {};\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\n\n\t\treturn clip;\n\n\t}\n\n} );\n\n// File:src/animation/AnimationMixer.js\n\n/**\n *\n * Player for AnimationClips.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.AnimationMixer = function( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n};\n\nObject.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\tprototypeAction = null;\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tvar existingAction =\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tvar newAction = new THREE.\n\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function() {\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tthis._nActiveActions = 0;\n\t\tthis._nActiveBindings = 0;\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tactions[ i ].reset();\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].useCount = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tvar action = actions[ i ];\n\n\t\t\tif ( action.enabled ) {\n\n\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tvar bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function() {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function( clip ) {\n\n\t\tvar actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function( root ) {\n\n\t\tvar rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function( clip, optionalRoot ) {\n\n\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\nTHREE.AnimationMixer._Action = THREE.AnimationAction._new;\n\n// Implementation details:\n\nObject.assign( THREE.AnimationMixer.prototype, {\n\n\t_bindAction: function( action, prototypeAction ) {\n\n\t\tvar root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar track = tracks[ i ],\n\t\t\t\ttrackName = track.name,\n\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new THREE.PropertyMixer(\n\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\n\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for _Action objects\n\n\t_isActiveAction: function( action ) {\n\n\t\tvar index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\n\t\tvar actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function( action ) {\n\n\t\tvar actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tvar clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function( action ) {\n\n\t\tvar bindings = action._propertyBindings;\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tvar binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tbindings = this._bindings;\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tremove_empty_map: {\n\n\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function() {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new THREE.LinearInterpolant(\n\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function( interpolant ) {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\n} );\n\n// File:src/animation/AnimationObjectGroup.js\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n * \t-\tAdd objects you would otherwise pass as 'root' to the\n * \t\tconstructor or the .clipAction method of AnimationMixer.\n *\n * \t-\tInstead pass this object as 'root'.\n *\n * \t-\tYou can also add and remove objects later when the mixer\n * \t\tis running.\n *\n * Note:\n *\n *  \tObjects of this class appear as one object to the mixer,\n *  \tso cache control of the individual objects must be done\n *  \ton the group.\n *\n * Limitation:\n *\n * \t- \tThe animated properties must be compatible among the\n * \t\tall objects in the group.\n *\n *  -\tA single property can either be controlled through a\n *  \ttarget group or directly, but not both.\n *\n * @author tschw\n */\n\nTHREE.AnimationObjectGroup = function( var_args ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// cached objects followed by the active ones\n\tthis._objects = Array.prototype.slice.call( arguments );\n\n\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t// note: read by PropertyBinding.Composite\n\n\tvar indices = {};\n\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t}\n\n\tthis._paths = [];\t\t\t\t\t// inside: string\n\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\tvar scope = this;\n\n\tthis.stats = {\n\n\t\tobjects: {\n\t\t\tget total() { return scope._objects.length; },\n\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t},\n\n\t\tget bindingsPerObject() { return scope._bindings.length; }\n\n\t};\n\n};\n\nTHREE.AnimationObjectGroup.prototype = {\n\n\tconstructor: THREE.AnimationObjectGroup,\n\n\tadd: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\tnew THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tvar knownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject) {\n\n\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\tremove: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// remove & forget\n\tuncache: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_: function( path, parsedPath ) {\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ],\n\t\t\tbindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tvar paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( var i = nCachedObjects,\n\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\n\t\t\tvar object = objects[ i ];\n\n\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t},\n\n\tunsubscribe_: function( path ) {\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationUtils.js\n\n/**\n * @author tschw\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function( array, from, to ) {\n\n\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tvar n = times.length;\n\t\tvar result = new Array( n );\n\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function( values, stride, order ) {\n\n\t\tvar nValues = values.length;\n\t\tvar result = new values.constructor( nValues );\n\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tvar value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/KeyframeTrack.js\n\n/**\n *\n * A timed sequence of keyframes for a specific property.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\n\tif( times === undefined || times.length === 0 ) {\n\n\t\tthrow new Error( \"no keyframes in track named \" + name );\n\n\t}\n\n\tthis.name = name;\n\n\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\n\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\tthis.validate();\n\tthis.optimize();\n\n};\n\nTHREE.KeyframeTrack.prototype = {\n\n\tconstructor: THREE.KeyframeTrack,\n\n\tTimeBufferType: Float32Array,\n\tValueBufferType: Float32Array,\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodDiscrete: function( result ) {\n\n\t\treturn new THREE.DiscreteInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.LinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: function( result ) {\n\n\t\treturn new THREE.CubicInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tsetInterpolation: function( interpolation ) {\n\n\t\tvar factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase THREE.InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( message );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t},\n\n\tgetInterpolation: function() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn THREE.InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn THREE.InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn THREE.InterpolateSmooth;\n\n\t\t}\n\n\t},\n\n\tgetValueSize: function() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t},\n\n\t// move all keyframes either forwards or backwards in time\n\tshift: function( timeOffset ) {\n\n\t\tif( timeOffset !== 0.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale: function( timeScale ) {\n\n\t\tif( timeScale !== 1.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim: function( startTime, endTime ) {\n\n\t\tvar times = this.times,\n\t\t\tnKeys = times.length,\n\t\t\tfrom = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\n\t\t\tvar stride = this.getValueSize();\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = THREE.AnimationUtils.\n\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate: function() {\n\n\t\tvar valid = true;\n\n\t\tvar valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif( nKeys === 0 ) {\n\n\t\t\tconsole.error( \"track is empty\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar prevTime = null;\n\n\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tvar currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize: function() {\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\t\t\tstride = this.getValueSize(),\n\n\t\t\twriteIndex = 1;\n\n\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\n\n\t\t\tvar keep = false;\n\n\t\t\tvar time = times[ i ];\n\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\t\t\tvar offset = i * stride,\n\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.KeyframeTrack, {\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tparse: function( json ) {\n\n\t\tif( json.type === undefined ) {\n\n\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\n\t\t}\n\n\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\tif ( json.times === undefined ) {\n\n\t\t\tvar times = [], values = [];\n\n\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\tjson.times = times;\n\t\t\tjson.values = values;\n\n\t\t}\n\n\t\t// derived classes can define a static parse method\n\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\treturn trackType.parse( json );\n\n\t\t} else {\n\n\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\treturn new trackType(\n\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function( track ) {\n\n\t\tvar trackType = track.constructor;\n\n\t\tvar json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t},\n\n\t_getTrackTypeForValueTypeName: function( typeName ) {\n\n\t\tswitch( typeName.toLowerCase() ) {\n\n\t\t\tcase \"scalar\":\n\t\t\tcase \"double\":\n\t\t\tcase \"float\":\n\t\t\tcase \"number\":\n\t\t\tcase \"integer\":\n\n\t\t\t\treturn THREE.NumberKeyframeTrack;\n\n\t\t\tcase \"vector\":\n\t\t\tcase \"vector2\":\n\t\t\tcase \"vector3\":\n\t\t\tcase \"vector4\":\n\n\t\t\t\treturn THREE.VectorKeyframeTrack;\n\n\t\t\tcase \"color\":\n\n\t\t\t\treturn THREE.ColorKeyframeTrack;\n\n\t\t\tcase \"quaternion\":\n\n\t\t\t\treturn THREE.QuaternionKeyframeTrack;\n\n\t\t\tcase \"bool\":\n\t\t\tcase \"boolean\":\n\n\t\t\t\treturn THREE.BooleanKeyframeTrack;\n\n\t\t\tcase \"string\":\n\n\t\t\t\treturn THREE.StringKeyframeTrack;\n\n\t\t}\n\n\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\n\t}\n\n} );\n\n// File:src/animation/PropertyBinding.js\n\n/**\n *\n * A reference to a real property in the scene graph.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\n\n\tthis.path = path;\n\tthis.parsedPath = parsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis.node = THREE.PropertyBinding.findNode(\n\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\n\tthis.rootNode = rootNode;\n\n};\n\nTHREE.PropertyBinding.prototype = {\n\n\tconstructor: THREE.PropertyBinding,\n\n\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t// prototype version of these methods with one that represents\n\t\t// the bound state. When the property is not found, the methods\n\t\t// become no-ops.\n\n\t},\n\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t},\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind: function() {\n\n\t\tvar targetObject = this.node,\n\t\t\tparsedPath = this.parsedPath,\n\n\t\t\tobjectName = parsedPath.objectName,\n\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = THREE.PropertyBinding.findNode(\n\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n \t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tvar versioning = this.Versioning.None;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tvar bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( nodeProperty.length !== undefined ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t},\n\n\tunbind: function() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n};\n\nObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable: function() {},\n\t_setValue_unavailable: function() {},\n\n\t// initial state of these methods that calls 'bind'\n\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\n\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\n\n\tBindingType: {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t},\n\n\tVersioning: {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t},\n\n\tGetterByBindingType: [\n\n\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t},\n\n\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\tvar source = this.resolvedProperty;\n\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t},\n\n\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t}\n\n\t],\n\n\tSetterByBindingTypeAndVersioning: [\n\n\t\t[\n\t\t\t// Direct\n\n\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// EntireArray\n\n\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// ArrayElement\n\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// HasToFromArray\n\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t]\n\n\t]\n\n} );\n\nTHREE.PropertyBinding.Composite =\n\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\n\tvar parsedPath = optionalParsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis._targetGroup = targetGroup;\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n};\n\nTHREE.PropertyBinding.Composite.prototype = {\n\n\tconstructor: THREE.PropertyBinding.Composite,\n\n\tgetValue: function( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t},\n\n\tsetValue: function( array, offset ) {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t},\n\n\tbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t},\n\n\tunbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\n\n\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\n\n\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\n\n\t} else {\n\n\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\n\n\t}\n\n};\n\nTHREE.PropertyBinding.parseTrackName = function( trackName ) {\n\n\t// matches strings in the form of:\n\t//    nodeName.property\n\t//    nodeName.property[accessor]\n\t//    nodeName.material.property[accessor]\n\t//    uuid.property[accessor]\n\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t//    parentName/nodeName.property\n\t//    parentName/parentName/nodeName.property[index]\n\t//\t  .bone[Armature.DEF_cog].position\n\t// created and tested via https://regex101.com/#javascript\n\n\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\n\tvar matches = re.exec( trackName );\n\n\tif ( ! matches ) {\n\n\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\n\t}\n\n\tif ( matches.index === re.lastIndex ) {\n\n\t\tre.lastIndex++;\n\n\t}\n\n\tvar results = {\n\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\tnodeName: matches[ 3 ], \t// allowed to be null, specified root node.\n\t\tobjectName: matches[ 5 ],\n\t\tobjectIndex: matches[ 7 ],\n\t\tpropertyName: matches[ 9 ],\n\t\tpropertyIndex: matches[ 11 ]\t// allowed to be null, specifies that the whole property is set.\n\t};\n\n\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n\t}\n\n\treturn results;\n\n};\n\nTHREE.PropertyBinding.findNode = function( root, nodeName ) {\n\n\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\treturn root;\n\n\t}\n\n\t// search into skeleton bones.\n\tif ( root.skeleton ) {\n\n\t\tvar searchSkeleton = function( skeleton ) {\n\n\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n\t\t\t\tvar bone = skeleton.bones[ i ];\n\n\t\t\t\tif ( bone.name === nodeName ) {\n\n\t\t\t\t\treturn bone;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar bone = searchSkeleton( root.skeleton );\n\n\t\tif ( bone ) {\n\n\t\t\treturn bone;\n\n\t\t}\n\t}\n\n\t// search into node subtree.\n\tif ( root.children ) {\n\n\t\tvar searchNodeSubtree = function( children ) {\n\n\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\treturn childNode;\n\n\t\t\t\t}\n\n\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\tif ( result ) return result;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\tif ( subTreeNode ) {\n\n\t\t\treturn subTreeNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\n// File:src/animation/PropertyMixer.js\n\n/**\n *\n * Buffered scene graph property that allows weighted accumulation.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tvar bufferType = Float64Array,\n\t\tmixFunction;\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\n\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\n\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\n\t}\n\n\tthis.buffer = new bufferType( valueSize * 4 );\n\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\n\tthis._mixBufferRegion = mixFunction;\n\n\tthis.cumulativeWeight = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n};\n\nTHREE.PropertyMixer.prototype = {\n\n\tconstructor: THREE.PropertyMixer,\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tvar mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function( accuIndex ) {\n\n\t\tvar stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function() {\n\n\t\tvar binding = this.binding;\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * 3;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\tthis.cumulativeWeight = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function() {\n\n\t\tvar originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tvar s = 1 - t;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tvar j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/tracks/BooleanKeyframeTrack.js\n\n/**\n *\n * A Track of Boolean keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values );\n\n};\n\nTHREE.BooleanKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.BooleanKeyframeTrack,\n\n\tValueTypeName: 'bool',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\tInterpolantFactoryMethodSmooth: undefined\n\n\t// Note: Actually this track could have a optimized / compressed\n\t// representation of a single value and a custom interpolant that\n\t// computes \"firstValue ^ isOdd( index )\".\n\n} );\n\n// File:src/animation/tracks/ColorKeyframeTrack.js\n\n/**\n *\n * A Track of keyframe values that represent color.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.ColorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.ColorKeyframeTrack,\n\n\tValueTypeName: 'color'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n\n\t// Note: Very basic implementation and nothing special yet.\n\t// However, this is the place for color space parameterization.\n\n} );\n\n// File:src/animation/tracks/NumberKeyframeTrack.js\n\n/**\n *\n * A Track of numeric keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.NumberKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.NumberKeyframeTrack,\n\n\tValueTypeName: 'number',\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/animation/tracks/QuaternionKeyframeTrack.js\n\n/**\n *\n * A Track of quaternion keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.QuaternionKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.QuaternionKeyframeTrack,\n\n\tValueTypeName: 'quaternion',\n\n\t// ValueBufferType is inherited\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.QuaternionLinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n} );\n\n// File:src/animation/tracks/StringKeyframeTrack.js\n\n/**\n *\n * A Track that interpolates Strings\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.StringKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.StringKeyframeTrack,\n\n\tValueTypeName: 'string',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\n\tInterpolantFactoryMethodSmooth: undefined\n\n} );\n\n// File:src/animation/tracks/VectorKeyframeTrack.js\n\n/**\n *\n * A Track of vectored keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.VectorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.VectorKeyframeTrack,\n\n\tValueTypeName: 'vector'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/audio/Audio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.Audio = function ( listener ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Audio';\n\n\tthis.context = listener.context;\n\tthis.source = this.context.createBufferSource();\n\tthis.source.onended = this.onEnded.bind( this );\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( listener.getInput() );\n\n\tthis.autoplay = false;\n\n\tthis.startTime = 0;\n\tthis.playbackRate = 1;\n\tthis.isPlaying = false;\n\tthis.hasPlaybackControl = true;\n\tthis.sourceType = 'empty';\n\n\tthis.filters = [];\n\n};\n\nTHREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Audio,\n\n\tgetOutput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tsetNodeSource: function ( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t},\n\n\tsetBuffer: function ( audioBuffer ) {\n\n\t\tthis.source.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t},\n\n\tplay: function () {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar source = this.context.createBufferSource();\n\n\t\tsource.buffer = this.source.buffer;\n\t\tsource.loop = this.source.loop;\n\t\tsource.onended = this.source.onended;\n\t\tsource.start( 0, this.startTime );\n\t\tsource.playbackRate.value = this.playbackRate;\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\treturn this.connect();\n\n\t},\n\n\tpause: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = this.context.currentTime;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = 0;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdisconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilters: function () {\n\n\t\treturn this.filters;\n\n\t},\n\n\tsetFilters: function ( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value;\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t},\n\n\tsetFilter: function ( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t},\n\n\tsetPlaybackRate: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetPlaybackRate: function () {\n\n\t\treturn this.playbackRate;\n\n\t},\n\n\tonEnded: function () {\n\n\t\tthis.isPlaying = false;\n\n\t},\n\n\tgetLoop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.source.loop;\n\n\t},\n\n\tsetLoop: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.loop = value;\n\n\t},\n\n\tgetVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\n\tsetVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/audio/AudioAnalyser.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioAnalyser = function ( audio, fftSize ) {\n\n\tthis.analyser = audio.context.createAnalyser();\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\taudio.getOutput().connect( this.analyser );\n\n};\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\n\tgetFrequencyData: function () {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t},\n\n\tgetAverageFrequency: function () {\n\n\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n} );\n\n// File:src/audio/AudioContext.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.defineProperty( THREE, 'AudioContext', {\n\n\tget: ( function () {\n\n\t\tvar context;\n\n\t\treturn function get() {\n\n\t\t\tif ( context === undefined ) {\n\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t\t}\n\n\t\t\treturn context;\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/audio/PositionalAudio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PositionalAudio = function ( listener ) {\n\n\tTHREE.Audio.call( this, listener );\n\n\tthis.panner = this.context.createPanner();\n\tthis.panner.connect( this.gain );\n\n};\n\nTHREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {\n\n\tconstructor: THREE.PositionalAudio,\n\n\tgetOutput: function () {\n\n\t\treturn this.panner;\n\n\t},\n\n\tgetRefDistance: function () {\n\n\t\treturn this.panner.refDistance;\n\n\t},\n\n\tsetRefDistance: function ( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t},\n\n\tgetRolloffFactor: function () {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t},\n\n\tsetRolloffFactor: function ( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t},\n\n\tgetDistanceModel: function () {\n\n\t\treturn this.panner.distanceModel;\n\n\t},\n\n\tsetDistanceModel: function ( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t},\n\n\tgetMaxDistance: function () {\n\n\t\treturn this.panner.maxDistance;\n\n\t},\n\n\tsetMaxDistance: function ( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t};\n\n\t} )()\n\n\n} );\n\n// File:src/audio/AudioListener.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioListener = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'AudioListener';\n\n\tthis.context = THREE.AudioContext;\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( this.context.destination );\n\n\tthis.filter = null;\n\n};\n\nTHREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.AudioListener,\n\n\tgetInput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tremoveFilter: function ( ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.filter;\n\n\t},\n\n\tsetFilter: function ( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t},\n\n\tgetMasterVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\tsetMasterVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar scale = new THREE.Vector3();\n\n\t\tvar orientation = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tvar listener = this.context.listener;\n\t\t\tvar up = this.up;\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/cameras/Camera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.Camera = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Camera';\n\n\tthis.matrixWorldInverse = new THREE.Matrix4();\n\tthis.projectionMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Camera.prototype.constructor = THREE.Camera;\n\nTHREE.Camera.prototype.getWorldDirection = function () {\n\n\tvar quaternion = new THREE.Quaternion();\n\n\treturn function getWorldDirection( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.getWorldQuaternion( quaternion );\n\n\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.lookAt = function () {\n\n\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\tvar m1 = new THREE.Matrix4();\n\n\treturn function lookAt( vector ) {\n\n\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.clone = function () {\n\n\treturn new this.constructor().copy( this );\n\n};\n\nTHREE.Camera.prototype.copy = function ( source ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\treturn this;\n\n};\n\n// File:src/cameras/CubeCamera.js\n\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'CubeCamera';\n\n\tvar fov = 90, aspect = 1;\n\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, - 1, 0 );\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, - 1, 0 );\n\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, - 1 );\n\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, - 1, 0 );\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, - 1, 0 );\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\n\tthis.add( cameraNZ );\n\n\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\n\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderTarget.activeCubeFace = 0;\n\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 1;\n\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 2;\n\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 3;\n\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 4;\n\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderTarget.activeCubeFace = 5;\n\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\trenderer.setRenderTarget( null );\n\n\t};\n\n};\n\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\n\n// File:src/cameras/OrthographicCamera.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author arose / http://github.com/arose\n */\n\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'OrthographicCamera';\n\n\tthis.zoom = 1;\n\tthis.view = null;\n\n\tthis.left = left;\n\tthis.right = right;\n\tthis.top = top;\n\tthis.bottom = bottom;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.OrthographicCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t},\n\n\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tvar cx = ( this.right + this.left ) / 2;\n\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\tvar left = cx - dx;\n\t\tvar right = cx + dx;\n\t\tvar top = cy + dy;\n\t\tvar bottom = cy - dy;\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/PerspectiveCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author tschw\n */\n\nTHREE.PerspectiveCamera = function( fov, aspect, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'PerspectiveCamera';\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.zoom = 1;\n\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\tthis.focus = 10;\n\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.view = null;\n\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.PerspectiveCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength: function ( focalLength ) {\n\n\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength: function () {\n\n\t\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t},\n\n\tgetEffectiveFOV: function () {\n\n\t\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t},\n\n\tgetFilmWidth: function () {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t},\n\n\tgetFilmHeight: function () {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t},\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   var w = 1920;\n\t *   var h = 1080;\n\t *   var fullWidth = w * 3;\n\t *   var fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar near = this.near,\n\t\t\ttop = near * Math.tan(\n\t\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\theight = 2 * top,\n\t\t\twidth = this.aspect * height,\n\t\t\tleft = - 0.5 * width,\n\t\t\tview = this.view;\n\n\t\tif ( view !== null ) {\n\n\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tvar skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/StereoCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.StereoCamera = function () {\n\n\tthis.type = 'StereoCamera';\n\n\tthis.aspect = 1;\n\n\tthis.cameraL = new THREE.PerspectiveCamera();\n\tthis.cameraL.layers.enable( 1 );\n\tthis.cameraL.matrixAutoUpdate = false;\n\n\tthis.cameraR = new THREE.PerspectiveCamera();\n\tthis.cameraR.layers.enable( 2 );\n\tthis.cameraR.matrixAutoUpdate = false;\n\n};\n\nObject.assign( THREE.StereoCamera.prototype, {\n\n\tupdate: ( function () {\n\n\t\tvar focus, fov, aspect, near, far;\n\n\t\tvar eyeRight = new THREE.Matrix4();\n\t\tvar eyeLeft = new THREE.Matrix4();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\tfocus = camera.focus;\n\t\t\t\tfov = camera.fov;\n\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\tnear = camera.near;\n\t\t\t\tfar = camera.far;\n\n\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\tvar eyeSep = 0.064 / 2;\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t// translate xOffset\n\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t// for left eye\n\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t// for right eye\n\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t}\n\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/lights/Light.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Light = function ( color, intensity ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Light';\n\n\tthis.color = new THREE.Color( color );\n\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\tthis.receiveShadow = undefined;\n\n};\n\nTHREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Light,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/lights/LightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LightShadow = function ( camera ) {\n\n\tthis.camera = camera;\n\n\tthis.bias = 0;\n\tthis.radius = 1;\n\n\tthis.mapSize = new THREE.Vector2( 512, 512 );\n\n\tthis.map = null;\n\tthis.matrix = new THREE.Matrix4();\n\n};\n\nObject.assign( THREE.LightShadow.prototype, {\n\n\tcopy: function ( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\n// File:src/lights/AmbientLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AmbientLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'AmbientLight';\n\n\tthis.castShadow = undefined;\n\n};\n\nTHREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.AmbientLight\n\n} );\n\n// File:src/lights/DirectionalLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DirectionalLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'DirectionalLight';\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tthis.shadow = new THREE.DirectionalLightShadow();\n\n};\n\nTHREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.DirectionalLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/DirectionalLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectionalLightShadow = function ( light ) {\n\n\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n};\n\nTHREE.DirectionalLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.DirectionalLightShadow\n\n} );\n\n// File:src/lights/HemisphereLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\n\n\tTHREE.Light.call( this, skyColor, intensity );\n\n\tthis.type = 'HemisphereLight';\n\n\tthis.castShadow = undefined;\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.groundColor = new THREE.Color( groundColor );\n\n};\n\nTHREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.HemisphereLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/PointLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'PointLight';\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n};\n\nTHREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.PointLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'SpotLight';\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * Math.PI;\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / Math.PI;\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.SpotLightShadow();\n\n};\n\nTHREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.SpotLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SpotLightShadow = function () {\n\n\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n};\n\nTHREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.SpotLightShadow,\n\n\tupdate: function ( light ) {\n\n\t\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\n\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\tvar far = light.distance || 500;\n\n\t\tvar camera = this.camera;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/AudioLoader.js\n\n/**\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.AudioLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.AudioLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar context = THREE.AudioContext;\n\n\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t} );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n} );\n\n// File:src/loaders/Cache.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\n// File:src/loaders/Loader.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Loader = function () {\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function () {};\n\tthis.onLoadComplete = function () {};\n\n};\n\nTHREE.Loader.prototype = {\n\n\tconstructor: THREE.Loader,\n\n\tcrossOrigin: undefined,\n\n\textractUrlBase: function ( url ) {\n\n\t\tvar parts = url.split( '/' );\n\n\t\tif ( parts.length === 1 ) return './';\n\n\t\tparts.pop();\n\n\t\treturn parts.join( '/' ) + '/';\n\n\t},\n\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\tvar array = [];\n\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tcreateMaterial: ( function () {\n\n\t\tvar color, textureLoader, materialLoader;\n\n\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\tif ( color === undefined ) color = new THREE.Color();\n\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\n\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\n\n\t\t\t// convert from old material format\n\n\t\t\tvar textures = {};\n\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\n\n\t\t\t\tvar texture;\n\n\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t}\n\n\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t}\n\n\t\t\t\tvar uuid = THREE.Math.generateUUID();\n\n\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\treturn uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar json = {\n\t\t\t\tuuid: THREE.Math.generateUUID(),\n\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t};\n\n\t\t\tfor ( var name in m ) {\n\n\t\t\t\tvar value = m[ name ];\n\n\t\t\t\tswitch ( name ) {\n\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\tjson.blending = THREE[ value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\tjson.side = THREE.BackSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\tjson.side = THREE.DoubleSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\tcase 'opacity':\n\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\tcase 'visible':\n\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\treturn materialLoader.parse( json );\n\n\t\t};\n\n\t} )()\n\n};\n\nTHREE.Loader.Handlers = {\n\n\thandlers: [],\n\n\tadd: function ( regex, loader ) {\n\n\t\tthis.handlers.push( regex, loader );\n\n\t},\n\n\tget: function ( file ) {\n\n\t\tvar handlers = this.handlers;\n\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\tvar regex = handlers[ i ];\n\t\t\tvar loader  = handlers[ i + 1 ];\n\n\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n};\n\n// File:src/loaders/XHRLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.XHRLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.XHRLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\tvar scope = this;\n\n\t\tvar cached = THREE.Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tif ( onLoad ) {\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tonLoad( cached );\n\n\t\t\t\t}, 0 );\n\n\t\t\t}\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tvar request = new XMLHttpRequest();\n\t\trequest.overrideMimeType( 'text/plain' );\n\t\trequest.open( 'GET', url, true );\n\n\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\tvar response = event.target.response;\n\n\t\t\tTHREE.Cache.add( url, response );\n\n\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else {\n\n\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, false );\n\n\t\tif ( onProgress !== undefined ) {\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tonProgress( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}, false );\n\n\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\trequest.send( null );\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn request;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetResponseType: function ( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t},\n\n\tsetWithCredentials: function ( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/FontLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.FontLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.FontLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t}\n\n\t\t\tvar font = scope.parse( json );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\treturn new THREE.Font( json );\n\n\t}\n\n} );\n\n// File:src/loaders/ImageLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.ImageLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\timage.onload = function () {\n\n\t\t\tURL.revokeObjectURL( image.src );\n\t\t\tif ( onLoad ) onLoad( image );\n\n\t\t};\n\n\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\n\t\t\timage.src = url;\n\n\t\t} else {\n\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'blob' );\n\t\t\tloader.load( url, function ( blob ) {\n\n\t\t\t\timage.src = URL.createObjectURL( blob );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn image;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/JSONLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.JSONLoader = function ( manager ) {\n\n\tif ( typeof manager === 'boolean' ) {\n\n\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\tmanager = undefined;\n\n\t}\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\tthis.withCredentials = false;\n\n};\n\nObject.assign( THREE.JSONLoader.prototype, {\n\n\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json = JSON.parse( text );\n\t\t\tvar metadata = json.metadata;\n\n\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\tvar type = metadata.type;\n\n\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tparse: function ( json, texturePath ) {\n\n\t\tvar geometry = new THREE.Geometry(),\n\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\tparseModel( scale );\n\n\t\tparseSkin();\n\t\tparseMorphing( scale );\n\t\tparseAnimations();\n\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeBoundingSphere();\n\n\t\tfunction parseModel( scale ) {\n\n\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t}\n\n\t\t\tvar i, j, fi,\n\n\t\t\toffset, zLength,\n\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\ttype,\n\t\t\tisQuad,\n\t\t\thasMaterial,\n\t\t\thasFaceVertexUv,\n\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\tuvLayer, uv, u, v,\n\n\t\t\tfaces = json.faces,\n\t\t\tvertices = json.vertices,\n\t\t\tnormals = json.normals,\n\t\t\tcolors = json.colors,\n\n\t\t\tnUvLayers = 0;\n\n\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t// disregard empty arrays\n\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = vertices.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\tvertex = new THREE.Vector3();\n\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = faces.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\tfaceA = new THREE.Face3();\n\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\tfaceB = new THREE.Face3();\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\toffset += 4;\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface = new THREE.Face3();\n\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseSkin() {\n\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.bones = json.bones;\n\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseMorphing( scale ) {\n\n\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimations() {\n\n\t\t\tvar outputAnimations = [];\n\n\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\tvar animations = [];\n\n\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\tanimations.push( json.animation );\n\n\t\t\t}\n\n\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t}\n\n\t\t\t// parse implicit morph animations\n\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t}\n\n\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t}\n\n\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\treturn { geometry: geometry };\n\n\t\t} else {\n\n\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/LoadingManager.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n\tthis.onStart = undefined;\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\titemsTotal ++;\n\n\t\tif ( isLoading === false ) {\n\n\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLoading = true;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\titemsLoaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t}\n\n\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\tisLoading = false;\n\n\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\tscope.onLoad();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.itemError = function ( url ) {\n\n\t\tif ( scope.onError !== undefined ) {\n\n\t\t\tscope.onError( url );\n\n\t\t}\n\n\t};\n\n};\n\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\n\n// File:src/loaders/BufferGeometryLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometryLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.BufferGeometryLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar index = json.data.index;\n\n\t\tvar TYPED_ARRAYS = {\n\t\t\t'Int8Array': Int8Array,\n\t\t\t'Uint8Array': Uint8Array,\n\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t'Int16Array': Int16Array,\n\t\t\t'Uint16Array': Uint16Array,\n\t\t\t'Int32Array': Int32Array,\n\t\t\t'Uint32Array': Uint32Array,\n\t\t\t'Float32Array': Float32Array,\n\t\t\t'Float64Array': Float64Array\n\t\t};\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tvar attributes = json.data.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t}\n\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tvar center = new THREE.Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/loaders/MaterialLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MaterialLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.textures = {};\n\n};\n\nObject.assign( THREE.MaterialLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTextures: function ( value ) {\n\n\t\tthis.textures = value;\n\n\t},\n\n\tgetTexture: function ( name ) {\n\n\t\tvar textures = this.textures;\n\n\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t}\n\n\t\treturn textures[ name ];\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar material = new THREE[ json.type ];\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\n\t\t// for PointsMaterial\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\n\n\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\n\t\t\tmaterial.transparent = true;\n\n\t\t}\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tvar normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\n\n\t\tif ( json.envMap !== undefined ) {\n\n\t\t\tmaterial.envMap = this.getTexture( json.envMap );\n\t\t\tmaterial.combine = THREE.MultiplyOperation;\n\n\t\t}\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t// MultiMaterial\n\n\t\tif ( json.materials !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n} );\n\n// File:src/loaders/ObjectLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ObjectLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.texturePath = '';\n\n};\n\nObject.assign( THREE.ObjectLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.texturePath === '' ) {\n\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t}\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tparse: function ( json, onLoad ) {\n\n\t\tvar geometries = this.parseGeometries( json.geometries );\n\n\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\tif ( json.animations ) {\n\n\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t}\n\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t},\n\n\tparseGeometries: function ( json ) {\n\n\t\tvar geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE [ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\tcase 'TetrahedronGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t},\n\n\tparseMaterials: function ( json, textures ) {\n\n\t\tvar materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar loader = new THREE.MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t},\n\n\tparseAnimations: function ( json ) {\n\n\t\tvar animations = [];\n\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t},\n\n\tparseImages: function ( json, onLoad ) {\n\n\t\tvar scope = this;\n\t\tvar images = {};\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tvar manager = new THREE.LoadingManager( onLoad );\n\n\t\t\tvar loader = new THREE.ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar image = json[ i ];\n\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t},\n\n\tparseTextures: function ( json, images ) {\n\n\t\tfunction parseConstant( value ) {\n\n\t\t\tif ( typeof( value ) === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn THREE[ value ];\n\n\t\t}\n\n\t\tvar textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\n\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\t\t\t\tif ( Array.isArray( data.wrap ) ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t},\n\n\tparseObject: function () {\n\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\treturn function parseObject( data, geometries, materials ) {\n\n\t\t\tvar object;\n\n\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometries[ name ];\n\n\t\t\t}\n\n\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn materials[ name ];\n\n\t\t\t}\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'Scene':\n\n\t\t\t\t\tobject = new THREE.Scene();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LOD':\n\n\t\t\t\t\tobject = new THREE.LOD();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Line':\n\n\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointCloud':\n\t\t\t\tcase 'Points':\n\n\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Group':\n\n\t\t\t\t\tobject = new THREE.Group();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t} else {\n\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t}\n\n\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\tvar levels = data.levels;\n\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t};\n\n\t}()\n\n} );\n\n// File:src/loaders/TextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.TextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.TextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.Texture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/CubeTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.CubeTextureLoader.prototype, {\n\n\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.CubeTexture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tvar loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/BinaryTextureLoader.js\n\n/**\n * @author Nikos M. / https://github.com/foo123/\n *\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n */\n\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.BinaryTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new THREE.DataTexture();\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\n\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t}\n\n\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n// File:src/loaders/CompressedTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n */\n\nTHREE.CompressedTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.CompressedTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar images = [];\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/materials/Material.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Material = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Material';\n\n\tthis.fog = true;\n\tthis.lights = true;\n\n\tthis.blending = THREE.NormalBlending;\n\tthis.side = THREE.FrontSide;\n\tthis.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\tthis.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blendSrc = THREE.SrcAlphaFactor;\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\tthis.blendEquation = THREE.AddEquation;\n\tthis.blendSrcAlpha = null;\n\tthis.blendDstAlpha = null;\n\tthis.blendEquationAlpha = null;\n\n\tthis.depthFunc = THREE.LessEqualDepth;\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.clippingPlanes = null;\n\tthis.clipShadows = false;\n\n\tthis.colorWrite = true;\n\n\tthis.precision = null; // override the renderer's default precision for this material\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.alphaTest = 0;\n\tthis.premultipliedAlpha = false;\n\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\tthis.visible = true;\n\n\tthis._needsUpdate = true;\n\n};\n\nTHREE.Material.prototype = {\n\n\tconstructor: THREE.Material,\n\n\tget needsUpdate() {\n\n\t\treturn this._needsUpdate;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.update();\n\t\tthis._needsUpdate = value;\n\n\t},\n\n\tsetValues: function ( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( var key in values ) {\n\n\t\t\tvar newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue instanceof THREE.Color ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar isRoot = meta === undefined;\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\n\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\n\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\tif ( this.bumpMap instanceof THREE.Texture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\t\tif ( this.normalMap instanceof THREE.Texture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\t\tif ( this.displacementMap instanceof THREE.Texture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap instanceof THREE.Texture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t}\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;\n\t\tif ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;\n\t\tif ( this.side !== THREE.FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.shading = source.shading;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.alphaTest = source.alphaTest;\n\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\tthis.overdraw = source.overdraw;\n\n\t\tthis.visible = source.visible;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\tdstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tvar n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\n\t\treturn this;\n\n\t},\n\n\tupdate: function () {\n\n\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nObject.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.MaterialIdCount = 0;\n\n// File:src/materials/LineBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nTHREE.LineBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\n\nTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\tthis.linecap = source.linecap;\n\tthis.linejoin = source.linejoin;\n\n\treturn this;\n\n};\n\n// File:src/materials/LineDashedMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nTHREE.LineDashedMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineDashedMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\n\tthis.scale = 1;\n\tthis.dashSize = 3;\n\tthis.gapSize = 1;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\n\nTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\n\tthis.scale = source.scale;\n\tthis.dashSize = source.dashSize;\n\tthis.gapSize = source.gapSize;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>\n * }\n */\n\nTHREE.MeshBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\n\nTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshDepthMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / https://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshDepthMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshDepthMaterial';\n\n\tthis.depthPacking = THREE.BasicDepthPacking;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.map = null;\n\n\tthis.alphaMap = null;\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\n\nTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.depthPacking = source.depthPacking;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\tthis.map = source.map;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshLambertMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshLambertMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshLambertMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\n\nTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshNormalMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshNormalMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this, parameters );\n\n\tthis.type = 'MeshNormalMaterial';\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\n\nTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhongMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshPhongMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshPhongMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.specular = new THREE.Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\n\nTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.specular.copy( source.specular );\n\tthis.shininess = source.shininess;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshStandardMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshStandardMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.type = 'MeshStandardMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.roughness = 0.5;\n\tthis.metalness = 0.5;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.roughnessMap = null;\n\n\tthis.metalnessMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.envMapIntensity = 1.0;\n\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\n\nTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.color.copy( source.color );\n\tthis.roughness = source.roughness;\n\tthis.metalness = source.metalness;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.roughnessMap = source.roughnessMap;\n\n\tthis.metalnessMap = source.metalnessMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.envMapIntensity = source.envMapIntensity;\n\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhysicalMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  reflectivity: <float>\n * }\n */\n\nTHREE.MeshPhysicalMaterial = function ( parameters ) {\n\n\tTHREE.MeshStandardMaterial.call( this );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.type = 'MeshPhysicalMaterial';\n\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\tthis.clearCoat = 0.0;\n\tthis.clearCoatRoughness = 0.0;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\nTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\n\nTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.reflectivity = source.reflectivity;\n\n\tthis.clearCoat = source.clearCoat;\n\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\treturn this;\n\n};\n\n// File:src/materials/MultiMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MultiMaterial = function ( materials ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.type = 'MultiMaterial';\n\n\tthis.materials = materials instanceof Array ? materials : [];\n\n\tthis.visible = true;\n\n};\n\nTHREE.MultiMaterial.prototype = {\n\n\tconstructor: THREE.MultiMaterial,\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.2,\n\t\t\t\ttype: 'material',\n\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t},\n\t\t\tuuid: this.uuid,\n\t\t\ttype: this.type,\n\t\t\tmaterials: []\n\t\t};\n\n\t\tvar materials = this.materials;\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\tdelete material.metadata;\n\n\t\t\toutput.materials.push( material );\n\n\t\t}\n\n\t\toutput.visible = this.visible;\n\n\t\treturn output;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar material = new this.constructor();\n\n\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t\t}\n\n\t\tmaterial.visible = this.visible;\n\n\t\treturn material;\n\n\t}\n\n};\n\n// File:src/materials/PointsMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nTHREE.PointsMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'PointsMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\n\nTHREE.PointsMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.size = source.size;\n\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShaderMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.ShaderMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'ShaderMaterial';\n\n\tthis.defines = {};\n\tthis.uniforms = {};\n\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\tthis.lights = false; // set to use scene lights\n\tthis.clipping = false; // set to use user-defined clipping planes\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.extensions = {\n\t\tderivatives: false, // set to use derivatives\n\t\tfragDepth: false, // set to use fragment depth values\n\t\tdrawBuffers: false, // set to use draw buffers\n\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t};\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t'color': [ 1, 1, 1 ],\n\t\t'uv': [ 0, 0 ],\n\t\t'uv2': [ 0, 0 ]\n\t};\n\n\tthis.index0AttributeName = undefined;\n\n\tif ( parameters !== undefined ) {\n\n\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n};\n\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\n\nTHREE.ShaderMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.fragmentShader = source.fragmentShader;\n\tthis.vertexShader = source.vertexShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\n\n\tthis.defines = source.defines;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.lights = source.lights;\n\tthis.clipping = source.clipping;\n\n\tthis.skinning = source.skinning;\n\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.extensions = source.extensions;\n\n\treturn this;\n\n};\n\nTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\n\n\tdata.uniforms = this.uniforms;\n\tdata.vertexShader = this.vertexShader;\n\tdata.fragmentShader = this.fragmentShader;\n\n\treturn data;\n\n};\n\n// File:src/materials/RawShaderMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RawShaderMaterial = function ( parameters ) {\n\n\tTHREE.ShaderMaterial.call( this, parameters );\n\n\tthis.type = 'RawShaderMaterial';\n\n};\n\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\n\n// File:src/materials/SpriteMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *\tuvOffset: new THREE.Vector2(),\n *\tuvScale: new THREE.Vector2()\n * }\n */\n\nTHREE.SpriteMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'SpriteMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.map = null;\n\n\tthis.rotation = 0;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\n\nTHREE.SpriteMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.map = source.map;\n\n\tthis.rotation = source.rotation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShadowMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ShadowMaterial = function () {\n\n\tTHREE.ShaderMaterial.call( this, {\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\t\tvertexShader: THREE.ShaderChunk[ 'shadow_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]\n\t} );\n\n\tthis.lights = true;\n\tthis.transparent = true;\n\n\tObject.defineProperties( this, {\n\t\topacity: {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t}\n\t\t}\n\t} );\n\n};\n\nTHREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;\n\n// File:src/textures/Texture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.sourceFile = '';\n\n\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t//\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\n\n\tthis.version = 0;\n\tthis.onUpdate = null;\n\n};\n\nTHREE.Texture.DEFAULT_IMAGE = undefined;\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\n\nTHREE.Texture.prototype = {\n\n\tconstructor: THREE.Texture,\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tfunction getDataURL( image ) {\n\n\t\t\tvar canvas;\n\n\t\t\tif ( image.toDataURL !== undefined ) {\n\n\t\t\t\tcanvas = image;\n\n\t\t\t} else {\n\n\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = image.width;\n\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t} else {\n\n\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tvar image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tmeta.textures[ this.uuid ] = output;\n\n\t\treturn output;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t},\n\n\ttransformUv: function ( uv ) {\n\n\t\tif ( this.mapping !== THREE.UVMapping )  return;\n\n\t\tuv.multiply( this.repeat );\n\t\tuv.add( this.offset );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.TextureIdCount = 0;\n\n// File:src/textures/DepthTexture.js\n\n/**\n * @author Matt DesLauriers / @mattdesl\n */\n\nTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\n\n  this.image = { width: width, height: height };\n\n  this.type = type !== undefined ? type : THREE.UnsignedShortType;\n\n  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n  this.flipY = false;\n  this.generateMipmaps  = false;\n\n};\n\nTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\n\n// File:src/textures/CanvasTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.needsUpdate = true;\n\n};\n\nTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\n\n// File:src/textures/CubeTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\timages = images !== undefined ? images : [];\n\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\n\n\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.flipY = false;\n\n};\n\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\n\nObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\n\n\tget: function () {\n\n\t\treturn this.image;\n\n\t},\n\n\tset: function ( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n} );\n\n// File:src/textures/CompressedTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n\t// no flipping for cube textures\n\t// (also flipping doesn't work for compressed textures )\n\n\tthis.flipY = false;\n\n\t// can't generate mipmaps for compressed textures\n\t// mips must be embedded in DDS files\n\n\tthis.generateMipmaps = false;\n\n};\n\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\n\n// File:src/textures/DataTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { data: data, width: width, height: height };\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n\tthis.flipY = false;\n\tthis.generateMipmaps  = false;\n\n};\n\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\n\n// File:src/textures/VideoTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.generateMipmaps = false;\n\n\tvar scope = this;\n\n\tfunction update() {\n\n\t\trequestAnimationFrame( update );\n\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tscope.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tupdate();\n\n};\n\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\n\n// File:src/objects/Group.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Group = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Group';\n\n};\n\nTHREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Group\n\n} );\n\n// File:src/objects/Points.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Points = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Points';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Points,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar object = this;\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\tvar position = new THREE.Vector3();\n\n\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Line.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Line = function ( geometry, material, mode ) {\n\n\tif ( mode === 1 ) {\n\n\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\treturn new THREE.LineSegments( geometry, material );\n\n\t}\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Line';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Line,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar precision = raycaster.linePrecision;\n\t\t\tvar precisionSq = precision * precision;\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar vStart = new THREE.Vector3();\n\t\t\tvar vEnd = new THREE.Vector3();\n\t\t\tvar interSegment = new THREE.Vector3();\n\t\t\tvar interRay = new THREE.Vector3();\n\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LineSegments.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LineSegments = function ( geometry, material ) {\n\n\tTHREE.Line.call( this, geometry, material );\n\n\tthis.type = 'LineSegments';\n\n};\n\nTHREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {\n\n\tconstructor: THREE.LineSegments\n\n} );\n\n// File:src/objects/Mesh.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */\n\nTHREE.Mesh = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Mesh';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.drawMode = THREE.TrianglesDrawMode;\n\n\tthis.updateMorphTargets();\n\n};\n\nTHREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Mesh,\n\n\tsetDrawMode: function ( value ) {\n\n\t\tthis.drawMode = value;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.drawMode = source.drawMode;\n\n\t\treturn this;\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\n\n\t\t\tthis.morphTargetBase = - 1;\n\t\t\tthis.morphTargetInfluences = [];\n\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tgetMorphTargetIndexByName: function ( name ) {\n\n\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\n\t\t\treturn this.morphTargetDictionary[ name ];\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\n\n\t\treturn 0;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\tvar vA = new THREE.Vector3();\n\t\tvar vB = new THREE.Vector3();\n\t\tvar vC = new THREE.Vector3();\n\n\t\tvar tempA = new THREE.Vector3();\n\t\tvar tempB = new THREE.Vector3();\n\t\tvar tempC = new THREE.Vector3();\n\n\t\tvar uvA = new THREE.Vector2();\n\t\tvar uvB = new THREE.Vector2();\n\t\tvar uvC = new THREE.Vector2();\n\n\t\tvar barycoord = new THREE.Vector3();\n\n\t\tvar intersectionPoint = new THREE.Vector3();\n\t\tvar intersectionPointWorld = new THREE.Vector3();\n\n\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\treturn uv1.clone();\n\n\t\t}\n\n\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\tvar intersect;\n\t\t\tvar material = object.material;\n\n\t\t\tif ( material.side === THREE.BackSide ) {\n\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t} else {\n\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\n\n\t\t\t}\n\n\t\t\tif ( intersect === null ) return null;\n\n\t\t\tintersectionPointWorld.copy( point );\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\treturn {\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\tobject: object\n\t\t\t};\n\n\t\t}\n\n\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\tif ( intersection ) {\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n\t\t\t\t}\n\n\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\n\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t}\n\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar material = this.material;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\tif ( material === undefined ) return;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t// Check boundingBox before continuing\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t}\n\n\t\t\tvar uvs, intersection;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar a, b, c;\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\tuvs = attributes.uv.array;\n\n\t\t\t\t}\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\tc = indices[ i + 2 ];\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\n\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\tc = a + 2;\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\n\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Bone.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.Bone = function ( skin ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Bone';\n\n\tthis.skin = skin;\n\n};\n\nTHREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Bone,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.skin = source.skin;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/objects/Skeleton.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author michael guerrero / http://realitymeltdown.com\n * @author ikerr / http://verold.com\n */\n\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\n\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\tthis.identityMatrix = new THREE.Matrix4();\n\n\t// copy the bone array\n\n\tbones = bones || [];\n\n\tthis.bones = bones.slice( 0 );\n\n\t// create a bone texture or an array of floats\n\n\tif ( this.useVertexTexture ) {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\tsize = Math.max( size, 4 );\n\n\t\tthis.boneTextureWidth = size;\n\t\tthis.boneTextureHeight = size;\n\n\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\n\t} else {\n\n\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n\t}\n\n\t// use the supplied bone inverses or calculate the inverses\n\n\tif ( boneInverses === undefined ) {\n\n\t\tthis.calculateInverses();\n\n\t} else {\n\n\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Skeleton.prototype, {\n\n\tcalculateInverses: function () {\n\n\t\tthis.boneInverses = [];\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tvar inverse = new THREE.Matrix4();\n\n\t\t\tif ( this.bones[ b ] ) {\n\n\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t},\n\n\tpose: function () {\n\n\t\tvar bone;\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdate: ( function () {\n\n\t\tvar offsetMatrix = new THREE.Matrix4();\n\n\t\treturn function update() {\n\n\t\t\t// flatten bone matrices to array\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n\t\t\t}\n\n\t\t\tif ( this.useVertexTexture ) {\n\n\t\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )(),\n\n\tclone: function () {\n\n\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n\t}\n\n} );\n\n// File:src/objects/SkinnedMesh.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.type = 'SkinnedMesh';\n\n\tthis.bindMode = \"attached\";\n\tthis.bindMatrix = new THREE.Matrix4();\n\tthis.bindMatrixInverse = new THREE.Matrix4();\n\n\t// init bones\n\n\t// TODO: remove bone creation as there is no reason (other than\n\t// convenience) for THREE.SkinnedMesh to do this.\n\n\tvar bones = [];\n\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\tvar bone, gbone;\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tbone = new THREE.Bone( this );\n\t\t\tbones.push( bone );\n\n\t\t\tbone.name = gbone.name;\n\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t}\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\n\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\n\t\t\t} else {\n\n\t\t\t\tthis.add( bones[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.normalizeSkinWeights();\n\n\tthis.updateMatrixWorld( true );\n\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n};\n\n\nTHREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\n\n\tconstructor: THREE.SkinnedMesh,\n\n\tbind: function( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t},\n\n\tpose: function () {\n\n\t\tthis.skeleton.pose();\n\n\t},\n\n\tnormalizeSkinWeights: function () {\n\n\t\tif ( this.geometry instanceof THREE.Geometry ) {\n\n\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar vec = new THREE.Vector4();\n\n\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdateMatrixWorld: function( force ) {\n\n\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\n\n\t\tif ( this.bindMode === \"attached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t} else if ( this.bindMode === \"detached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t},\n\n\tclone: function() {\n\n\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LOD.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LOD = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'LOD';\n\n\tObject.defineProperties( this, {\n\t\tlevels: {\n\t\t\tenumerable: true,\n\t\t\tvalue: []\n\t\t}\n\t} );\n\n};\n\n\nTHREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LOD,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\n\n\t\tvar levels = source.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\taddLevel: function ( object, distance ) {\n\n\t\tif ( distance === undefined ) distance = 0;\n\n\t\tdistance = Math.abs( distance );\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\tthis.add( object );\n\n\t},\n\n\tgetObjectForDistance: function ( distance ) {\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn levels[ i - 1 ].object;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t};\n\n\t}() ),\n\n\tupdate: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.levels = [];\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/objects/Sprite.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Sprite = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Sprite';\n\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\n};\n\nTHREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Sprite,\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\n\t\t\tif ( distanceSq > guessSizeSq ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tintersects.push( {\n\n\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\tpoint: this.position,\n\t\t\t\tface: null,\n\t\t\t\tobject: this\n\n\t\t\t} );\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LensFlare.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.lensFlares = [];\n\n\tthis.positionScreen = new THREE.Vector3();\n\tthis.customUpdateCallback = undefined;\n\n\tif ( texture !== undefined ) {\n\n\t\tthis.add( texture, size, distance, blending, color );\n\n\t}\n\n};\n\nTHREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LensFlare,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.positionScreen.copy( source.positionScreen );\n\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\n\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\n\t\tif ( size === undefined ) size = - 1;\n\t\tif ( distance === undefined ) distance = 0;\n\t\tif ( opacity === undefined ) opacity = 1;\n\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\n\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\n\n\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\t\tthis.lensFlares.push( {\n\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\tscale: 1, \t\t// scale\n\t\t\trotation: 0, \t\t// rotation\n\t\t\topacity: opacity,\t// opacity\n\t\t\tcolor: color,\t\t// color\n\t\t\tblending: blending\t// blending\n\t\t} );\n\n\t},\n\n\t/*\n\t * Update lens flares update positions on all flares based on the screen position\n\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t */\n\n\tupdateLensFlares: function () {\n\n\t\tvar f, fl = this.lensFlares.length;\n\t\tvar flare;\n\t\tvar vecX = - this.positionScreen.x * 2;\n\t\tvar vecY = - this.positionScreen.y * 2;\n\n\t\tfor ( f = 0; f < fl; f ++ ) {\n\n\t\t\tflare = this.lensFlares[ f ];\n\n\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/scenes/Scene.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Scene = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Scene';\n\n\tthis.background = null;\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.autoUpdate = true; // checked by the renderer\n\n};\n\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Scene.prototype.constructor = THREE.Scene;\n\nTHREE.Scene.prototype.copy = function ( source, recursive ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\n\n\tif ( source.background !== null ) this.background = source.background.clone();\n\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\tthis.autoUpdate = source.autoUpdate;\n\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\treturn this;\n\n};\n\n// File:src/scenes/Fog.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Fog = function ( color, near, far ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n};\n\nTHREE.Fog.prototype.clone = function () {\n\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\n};\n\n// File:src/scenes/FogExp2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FogExp2 = function ( color, density ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n};\n\nTHREE.FogExp2.prototype.clone = function () {\n\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\n};\n\n// File:src/renderers/shaders/ShaderChunk.js\n\nTHREE.ShaderChunk = {};\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\n\nTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\n\nTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/common.glsl\n\nTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\n\nTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\n\nTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\n\nTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#include <normal_flip>\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#include <normal_flip>\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t\tfloat clearCoat;\\n\t\tfloat clearCoatRoughness;\\n\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\t#ifndef STANDARD\\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\t#ifndef STANDARD\\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\n\nTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\t#ifndef STANDARD\\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\t#else\\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\t#endif\\n\t\t\\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_flip.glsl\n\nTHREE.ShaderChunk[ 'normal_flip' ] = \"#ifdef DOUBLE_SIDED\\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\n\nTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/packing.glsl\n\nTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\n\nTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\n\nTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\n\nTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/UniformsUtils.js\n\n/**\n * Uniform Utilities\n */\n\nTHREE.UniformsUtils = {\n\n\tmerge: function ( uniforms ) {\n\n\t\tvar merged = {};\n\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn merged;\n\n\t},\n\n\tclone: function ( uniforms_src ) {\n\n\t\tvar uniforms_dst = {};\n\n\t\tfor ( var u in uniforms_src ) {\n\n\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uniforms_dst;\n\n\t}\n\n};\n\n// File:src/renderers/shaders/UniformsLib.js\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nTHREE.UniformsLib = {\n\n\tcommon: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\n\t\t\"specularMap\": { value: null },\n\t\t\"alphaMap\": { value: null },\n\n\t\t\"envMap\": { value: null },\n\t\t\"flipEnvMap\": { value: - 1 },\n\t\t\"reflectivity\": { value: 1.0 },\n\t\t\"refractionRatio\": { value: 0.98 }\n\n\t},\n\n\taomap: {\n\n\t\t\"aoMap\": { value: null },\n\t\t\"aoMapIntensity\": { value: 1 }\n\n\t},\n\n\tlightmap: {\n\n\t\t\"lightMap\": { value: null },\n\t\t\"lightMapIntensity\": { value: 1 }\n\n\t},\n\n\temissivemap: {\n\n\t\t\"emissiveMap\": { value: null }\n\n\t},\n\n\tbumpmap: {\n\n\t\t\"bumpMap\": { value: null },\n\t\t\"bumpScale\": { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\t\"normalMap\": { value: null },\n\t\t\"normalScale\": { value: new THREE.Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\t\"displacementMap\": { value: null },\n\t\t\"displacementScale\": { value: 1 },\n\t\t\"displacementBias\": { value: 0 }\n\n\t},\n\n\troughnessmap: {\n\n\t\t\"roughnessMap\": { value: null }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\t\"metalnessMap\": { value: null }\n\n\t},\n\n\tfog: {\n\n\t\t\"fogDensity\": { value: 0.00025 },\n\t\t\"fogNear\": { value: 1 },\n\t\t\"fogFar\": { value: 2000 },\n\t\t\"fogColor\": { value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\t\"ambientLightColor\": { value: [] },\n\n\t\t\"directionalLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"color\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"directionalShadowMap\": { value: [] },\n\t\t\"directionalShadowMatrix\": { value: [] },\n\n\t\t\"spotLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"direction\": {},\n\t\t\t\"distance\": {},\n\t\t\t\"coneCos\": {},\n\t\t\t\"penumbraCos\": {},\n\t\t\t\"decay\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"spotShadowMap\": { value: [] },\n\t\t\"spotShadowMatrix\": { value: [] },\n\n\t\t\"pointLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"decay\": {},\n\t\t\t\"distance\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"pointShadowMap\": { value: [] },\n\t\t\"pointShadowMatrix\": { value: [] },\n\n\t\t\"hemisphereLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"skyColor\": {},\n\t\t\t\"groundColor\": {}\n\t\t} }\n\n\t},\n\n\tpoints: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\t\t\"size\": { value: 1.0 },\n\t\t\"scale\": { value: 1.0 },\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) }\n\n\t}\n\n};\n\n// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\n\nTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\n\nTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\n\nTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\n\nTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\n\nTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\n\nTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\n\nTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\n\nTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\tuniform float clearCoat;\\n\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\n\nTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\n\nTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_frag.glsl\n\nTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_vert.glsl\n\nTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl\n\nTHREE.ShaderChunk[ 'shadow_frag' ] = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl\n\nTHREE.ShaderChunk[ 'shadow_vert' ] = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib.js\n\n/**\n * Webgl Shader Library for three.js\n *\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\n\nTHREE.ShaderLib = {\n\n\t'basic': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\n\n\t},\n\n\t'lambert': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\n\n\t},\n\n\t'phong': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"specular\" : { value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"shininess\": { value: 30 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\n\n\t},\n\n\t'standard': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"roughness\": { value: 0.5 },\n\t\t\t\t\"metalness\": { value: 0 },\n\t\t\t\t\"envMapIntensity\" : { value: 1 }, // temporary\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n\t},\n\n\t'points': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'points' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\n\n\t},\n\n\t'dashed': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\n\t\t\t{\n\t\t\t\t\"scale\"    : { value: 1 },\n\t\t\t\t\"dashSize\" : { value: 1 },\n\t\t\t\t\"totalSize\": { value: 2 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\n\n\t},\n\n\t'depth': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\n\n\t},\n\n\t'normal': {\n\n\t\tuniforms: {\n\n\t\t\t\"opacity\" : { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'cube': {\n\n\t\tuniforms: {\n\t\t\t\"tCube\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'equirect': {\n\n\t\tuniforms: {\n\t\t\t\"tEquirect\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\n\n\t},\n\n\t'distanceRGBA': {\n\n\t\tuniforms: {\n\n\t\t\t\"lightPos\": { value: new THREE.Vector3() }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\n\n\t}\n\n};\n\nTHREE.ShaderLib[ 'physical' ] = {\n\n\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\n\n\t\t{\n\t\t\t\"clearCoat\": { value: 0 },\n\t\t\t\"clearCoatRoughness\": { value: 0 }\n\t\t}\n\n\t] ),\n\n\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n};\n\n// File:src/renderers/WebGLRenderer.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n * @author tschw\n */\n\nTHREE.WebGLRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n\tvar lights = [];\n\n\tvar opaqueObjects = [];\n\tvar opaqueObjectsLastIndex = - 1;\n\tvar transparentObjects = [];\n\tvar transparentObjectsLastIndex = - 1;\n\n\tvar morphInfluences = new Float32Array( 8 );\n\n\tvar sprites = [];\n\tvar lensFlares = [];\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\t// user-defined clipping\n\n\tthis.clippingPlanes = [];\n\tthis.localClippingEnabled = false;\n\n\t// physically based shading\n\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\n\t// physical lights\n\n\tthis.physicallyCorrectLights = false;\n\n\t// tone mapping\n\n\tthis.toneMapping = THREE.LinearToneMapping;\n\tthis.toneMappingExposure = 1.0;\n\tthis.toneMappingWhitePoint = 1.0;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t// internal state cache\n\n\t_currentProgram = null,\n\t_currentRenderTarget = null,\n\t_currentFramebuffer = null,\n\t_currentMaterialId = - 1,\n\t_currentGeometryProgram = '',\n\t_currentCamera = null,\n\n\t_currentScissor = new THREE.Vector4(),\n\t_currentScissorTest = null,\n\n\t_currentViewport = new THREE.Vector4(),\n\n\t//\n\n\t_usedTextureUnits = 0,\n\n\t//\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearAlpha = 0,\n\n\t_width = _canvas.width,\n\t_height = _canvas.height,\n\n\t_pixelRatio = 1,\n\n\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\n\t_scissorTest = false,\n\n\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\n\n\t// frustum\n\n\t_frustum = new THREE.Frustum(),\n\n\t// clipping\n\n\t_clipping = new THREE.WebGLClipping(),\n\t_clippingEnabled = false,\n\t_localClippingEnabled = false,\n\n\t_sphere = new THREE.Sphere(),\n\n\t// camera matrices cache\n\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_vector3 = new THREE.Vector3(),\n\n\t// light arrays cache\n\n\t_lights = {\n\n\t\thash: '',\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tdirectional: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotShadowMap: [],\n\t\tspotShadowMatrix: [],\n\t\tpoint: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: [],\n\n\t\tshadows: []\n\n\t},\n\n\t// info\n\n\t_infoRender = {\n\n\t\tcalls: 0,\n\t\tvertices: 0,\n\t\tfaces: 0,\n\t\tpoints: 0\n\n\t};\n\n\tthis.info = {\n\n\t\trender: _infoRender,\n\t\tmemory: {\n\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\n\t\t},\n\t\tprograms: null\n\n\t};\n\n\n\t// initialize\n\n\tvar _gl;\n\n\ttry {\n\n\t\tvar attributes = {\n\t\t\talpha: _alpha,\n\t\t\tdepth: _depth,\n\t\t\tstencil: _stencil,\n\t\t\tantialias: _antialias,\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t};\n\n\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\tif ( _gl === null ) {\n\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\n\t\t\t} else {\n\n\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t};\n\n\t\t}\n\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t} catch ( error ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\n\t}\n\n\tvar extensions = new THREE.WebGLExtensions( _gl );\n\n\textensions.get( 'WEBGL_depth_texture' );\n\textensions.get( 'OES_texture_float' );\n\textensions.get( 'OES_texture_float_linear' );\n\textensions.get( 'OES_texture_half_float' );\n\textensions.get( 'OES_texture_half_float_linear' );\n\textensions.get( 'OES_standard_derivatives' );\n\textensions.get( 'ANGLE_instanced_arrays' );\n\n\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\n\n\t}\n\n\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\n\n\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\n\tvar properties = new THREE.WebGLProperties();\n\tvar textures = new THREE.WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\n\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\n\tvar lightCache = new THREE.WebGLLights();\n\n\tthis.info.programs = programCache.programs;\n\n\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\n\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t//\n\n\tvar backgroundCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\tvar backgroundCamera2 = new THREE.PerspectiveCamera();\n\tvar backgroundPlaneMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry( 2, 2 ),\n\t\tnew THREE.MeshBasicMaterial( { depthTest: false, depthWrite: false } )\n\t);\n\tvar backgroundBoxShader = THREE.ShaderLib[ 'cube' ];\n\tvar backgroundBoxMesh = new THREE.Mesh(\n\t\tnew THREE.BoxBufferGeometry( 5, 5, 5 ),\n\t\tnew THREE.ShaderMaterial( {\n\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\tside: THREE.BackSide\n\t\t} )\n\t);\n\tobjects.update( backgroundPlaneMesh );\n\tobjects.update( backgroundBoxMesh );\n\n\t//\n\n\tfunction getTargetPixelRatio() {\n\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t}\n\n\tfunction glClearColor( r, g, b, a ) {\n\n\t\tif ( _premultipliedAlpha === true ) {\n\n\t\t\tr *= a; g *= a; b *= a;\n\n\t\t}\n\n\t\tstate.clearColor( r, g, b, a );\n\n\t}\n\n\tfunction setDefaultGLState() {\n\n\t\tstate.init();\n\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t}\n\n\tfunction resetGLState() {\n\n\t\t_currentProgram = null;\n\t\t_currentCamera = null;\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\n\t\tstate.reset();\n\n\t}\n\n\tsetDefaultGLState();\n\n\tthis.context = _gl;\n\tthis.capabilities = capabilities;\n\tthis.extensions = extensions;\n\tthis.properties = properties;\n\tthis.state = state;\n\n\t// shadow map\n\n\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\n\n\tthis.shadowMap = shadowMap;\n\n\n\t// Plugins\n\n\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\n\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _gl.getContextAttributes();\n\n\t};\n\n\tthis.forceContextLoss = function () {\n\n\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\n\t};\n\n\tthis.getMaxAnisotropy = function () {\n\n\t\treturn capabilities.getMaxAnisotropy();\n\n\t};\n\n\tthis.getPrecision = function () {\n\n\t\treturn capabilities.precision;\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value === undefined ) return;\n\n\t\t_pixelRatio = value;\n\n\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\n\t};\n\n\tthis.getSize = function () {\n\n\t\treturn {\n\t\t\twidth: _width,\n\t\t\theight: _height\n\t\t};\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_canvas.width = width * _pixelRatio;\n\t\t_canvas.height = height * _pixelRatio;\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t};\n\n\t// Clearing\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\n\t};\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.set( color );\n\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\n\t};\n\n\tthis.setClearAlpha = function ( alpha ) {\n\n\t\t_clearAlpha = alpha;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\tthis.clear( true, false, false );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\tthis.clear( false, true, false );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\tthis.clear( false, false, true );\n\n\t};\n\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t};\n\n\t// Reset\n\n\tthis.resetGLState = resetGLState;\n\n\tthis.dispose = function() {\n\n\t\ttransparentObjects = [];\n\t\ttransparentObjectsLastIndex = -1;\n\t\topaqueObjects = [];\n\t\topaqueObjectsLastIndex = -1;\n\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n\t};\n\n\t// Events\n\n\tfunction onContextLost( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tresetGLState();\n\t\tsetDefaultGLState();\n\n\t\tproperties.clear();\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tvar material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t}\n\n\t// Buffer deallocation\n\n\tfunction deallocateMaterial( material ) {\n\n\t\treleaseMaterialProgramReference( material );\n\n\t\tproperties.delete( material );\n\n\t}\n\n\n\tfunction releaseMaterialProgramReference( material ) {\n\n\t\tvar programInfo = properties.get( material ).program;\n\n\t\tmaterial.program = undefined;\n\n\t\tif ( programInfo !== undefined ) {\n\n\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t}\n\n\t}\n\n\t// Buffer rendering\n\n\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\tstate.initAttributes();\n\n\t\tvar buffers = properties.get( object );\n\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\n\n\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.normal );\n\n\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.uv );\n\n\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.color );\n\n\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\tsetMaterial( material );\n\n\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\tvar updateBuffers = false;\n\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphTargetInfluences !== undefined ) {\n\n\t\t\tvar activeInfluences = [];\n\n\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\n\t\t\t}\n\n\t\t\tactiveInfluences.sort( absNumericalSort );\n\n\t\t\tif ( activeInfluences.length > 8 ) {\n\n\t\t\t\tactiveInfluences.length = 8;\n\n\t\t\t}\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\n\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\n\t\t\t\t\tvar index = influence[ 1 ];\n\n\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t//\n\n\t\tvar index = geometry.index;\n\t\tvar position = geometry.attributes.position;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tindex = objects.getWireframeAttribute( geometry );\n\n\t\t}\n\n\t\tvar renderer;\n\n\t\tif ( index !== null ) {\n\n\t\t\trenderer = indexedBufferRenderer;\n\t\t\trenderer.setIndex( index );\n\n\t\t} else {\n\n\t\t\trenderer = bufferRenderer;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar dataStart = 0;\n\t\tvar dataCount = Infinity;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdataCount = index.count;\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\tdataCount = position.count;\n\n\t\t}\n\n\t\tvar rangeStart = geometry.drawRange.start;\n\t\tvar rangeCount = geometry.drawRange.count;\n\n\t\tvar groupStart = group !== null ? group.start : 0;\n\t\tvar groupCount = group !== null ? group.count : Infinity;\n\n\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\n\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t//\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\tcase THREE.TrianglesDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleStripDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleFanDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\tif ( object instanceof THREE.LineSegments ) {\n\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Points ) {\n\n\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t}\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t}\n\n\t};\n\n\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\tvar extension;\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\tstate.initAttributes();\n\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( var name in programAttributes ) {\n\n\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\n\t\t\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\t\t\ttype = _gl.FLOAT;\n\n\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\n\n\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\t\t\ttype = _gl.SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\n\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\t\t\ttype = _gl.INT;\n\n\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\t\t\ttype = _gl.BYTE;\n\n\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\n\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t}\n\n\t// Sorting\n\n\tfunction absNumericalSort( a, b ) {\n\n\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\treturn a.material.id - b.material.id;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn a.z - b.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\tfunction reversePainterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar fog = scene.fog;\n\n\t\t// reset caching for this frame\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\t\t_currentCamera = null;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\tlights.length = 0;\n\n\t\topaqueObjectsLastIndex = - 1;\n\t\ttransparentObjectsLastIndex = - 1;\n\n\t\tsprites.length = 0;\n\t\tlensFlares.length = 0;\n\n\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\tprojectObject( scene, camera );\n\n\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\n\t\tif ( _this.sortObjects === true ) {\n\n\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\tsetupShadows( lights );\n\n\t\tshadowMap.render( scene, camera );\n\n\t\tsetupLights( lights, camera );\n\n\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t//\n\n\t\t_infoRender.calls = 0;\n\t\t_infoRender.vertices = 0;\n\t\t_infoRender.faces = 0;\n\t\t_infoRender.points = 0;\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = null;\n\n\t\t}\n\n\t\tthis.setRenderTarget( renderTarget );\n\n\t\t//\n\n\t\tvar background = scene.background;\n\n\t\tif ( background === null ) {\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t} else if ( background instanceof THREE.Color ) {\n\n\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\n\t\t}\n\n\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background instanceof THREE.CubeTexture ) {\n\n\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\n\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n\t\t} else if ( background instanceof THREE.Texture ) {\n\n\t\t\tbackgroundPlaneMesh.material.map = background;\n\n\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\n\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\n\n\t\t} else {\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\t\t\trenderObjects( opaqueObjects, camera, fog );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\trenderObjects( transparentObjects, camera, fog );\n\n\t\t}\n\n\t\t// custom render plugins (post pass)\n\n\t\tspritePlugin.render( scene, camera );\n\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\tif ( renderTarget ) {\n\n\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tstate.setDepthTest( true );\n\t\tstate.setDepthWrite( true );\n\t\tstate.setColorWrite( true );\n\n\t\t// _gl.finish();\n\n\t};\n\n\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\n\t\tvar array, index;\n\n\t\t// allocate the next position in the appropriate array\n\n\t\tif ( material.transparent ) {\n\n\t\t\tarray = transparentObjects;\n\t\t\tindex = ++ transparentObjectsLastIndex;\n\n\t\t} else {\n\n\t\t\tarray = opaqueObjects;\n\t\t\tindex = ++ opaqueObjectsLastIndex;\n\n\t\t}\n\n\t\t// recycle existing render item or grow the array\n\n\t\tvar renderItem = array[ index ];\n\n\t\tif ( renderItem !== undefined ) {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.z = _vector3.z;\n\t\t\trenderItem.group = group;\n\n\t\t} else {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tz: _vector3.z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\t// assert( index === array.length );\n\t\t\tarray.push( renderItem );\n\n\t\t}\n\n\t}\n\n\t// TODO Duplicated code (Frustum)\n\n\tfunction isObjectViewable( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometry.boundingSphere === null )\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSpriteViewable( sprite ) {\n\n\t\t_sphere.center.set( 0, 0, 0 );\n\t\t_sphere.radius = 0.7071067811865476;\n\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSphereViewable( sphere ) {\n\n\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\tif ( numPlanes === 0 ) return true;\n\n\t\tvar planes = _this.clippingPlanes,\n\n\t\t\tcenter = sphere.center,\n\t\t\tnegRad = - sphere.radius,\n\t\t\ti = 0;\n\n\t\tdo {\n\n\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t} while ( ++ i !== numPlanes );\n\n\t\treturn true;\n\n\t}\n\n\tfunction projectObject( object, camera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\tlights.push( object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n\t\t\t\t\tsprites.push( object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\t\tlensFlares.push( object );\n\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\n\n\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar geometry = objects.update( object );\n\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera );\n\n\t\t}\n\n\t}\n\n\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\n\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\tvar object = renderItem.object;\n\t\t\tvar geometry = renderItem.geometry;\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\tvar group = renderItem.group;\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tsetMaterial( material );\n\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initMaterial( material, fog, object ) {\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tvar parameters = programCache.getParameters(\n\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, object );\n\n\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\tvar program = materialProperties.program;\n\t\tvar programChange = true;\n\n\t\tif ( program === undefined ) {\n\n\t\t\t// new material\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t} else if ( program.code !== code ) {\n\n\t\t\t// changed glsl or parameters\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t// same glsl and uniform list\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// only rebuild uniform list\n\t\t\tprogramChange = false;\n\n\t\t}\n\n\t\tif ( programChange ) {\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\n\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\n\t\t\tmaterialProperties.program = program;\n\t\t\tmaterial.program = program;\n\n\t\t}\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\n\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\n\t\t\t\tmaterial.clipping === true ) {\n\n\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t}\n\n\t\tif ( material.lights ) {\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\n\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\n\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\n\t\t}\n\n\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\tuniformsList =\n\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\tmaterialProperties.uniformsList = uniformsList;\n\t\tmaterialProperties.dynamicUniforms =\n\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\n\n\t}\n\n\tfunction setMaterial( material ) {\n\n\t\tif ( material.side !== THREE.DoubleSide )\n\t\t\tstate.enable( _gl.CULL_FACE );\n\t\telse\n\t\t\tstate.disable( _gl.CULL_FACE );\n\n\t\tstate.setFlipSided( material.side === THREE.BackSide );\n\n\t\tif ( material.transparent === true ) {\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\t} else {\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\n\t\t}\n\n\t\tstate.setDepthFunc( material.depthFunc );\n\t\tstate.setDepthTest( material.depthTest );\n\t\tstate.setDepthWrite( material.depthWrite );\n\t\tstate.setColorWrite( material.colorWrite );\n\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t}\n\n\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t_usedTextureUnits = 0;\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tif ( _clippingEnabled ) {\n\n\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\tvar useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t// (#8465, #8379)\n\t\t\t\t_clipping.setState(\n\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\n\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t}\n\n\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\tmaterialProperties.numClippingPlanes !== _clipping.numPlanes ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( materialProperties.lightsHash !== undefined &&\n\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tinitMaterial( material, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tvar refreshProgram = false;\n\t\tvar refreshMaterial = false;\n\t\tvar refreshLights = false;\n\n\t\tvar program = materialProperties.program,\n\t\t\tp_uniforms = program.getUniforms(),\n\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( program.id !== _currentProgram ) {\n\n\t\t\t_gl.useProgram( program.program );\n\t\t\t_currentProgram = program.id;\n\n\t\t\trefreshProgram = true;\n\t\t\trefreshMaterial = true;\n\t\t\trefreshLights = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t}\n\n\n\t\t\tif ( camera !== _currentCamera ) {\n\n\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t}\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material.envMap ) {\n\n\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material.skinning ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\tvar skeleton = object.skeleton;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t// values\n\t\t\t\t//\n\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t// the GL state when required\n\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t}\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t}\n\n\t\t\t// refresh single material specific uniforms\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\n\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\n\n\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\tTHREE.WebGLUniforms.upload(\n\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t}\n\n\n\t\t// common matrices\n\n\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\n\t\t// dynamic uniforms\n\n\t\tvar dynUniforms = materialProperties.dynamicUniforms;\n\n\t\tif ( dynUniforms !== null ) {\n\n\t\t\tTHREE.WebGLUniforms.evalDynamic(\n\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\n\n\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon ( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tuniforms.diffuse.value = material.color;\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tuniforms.map.value = material.map;\n\t\tuniforms.specularMap.value = material.specularMap;\n\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. specular map\n\t\t// 3. normal map\n\t\t// 4. bump map\n\t\t// 5. alpha map\n\t\t// 6. emissive map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.displacementMap ) {\n\n\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t} else if ( material.roughnessMap ) {\n\n\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t} else if ( material.metalnessMap ) {\n\n\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t} else if ( material.emissiveMap ) {\n\n\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tvar offset = uvScaleMap.offset;\n\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t\tuniforms.envMap.value = material.envMap;\n\n\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;\n\n\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t}\n\n\tfunction refreshUniformsLine ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\n\t}\n\n\tfunction refreshUniformsDash ( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\n\n\t\tuniforms.map.value = material.map;\n\n\t\tif ( material.map !== null ) {\n\n\t\t\tvar offset = material.map.offset;\n\t\t\tvar repeat = material.map.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsFog ( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value = fog.color;\n\n\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLambert ( uniforms, material ) {\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong ( uniforms, material ) {\n\n\t\tuniforms.specular.value = material.specular;\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard ( uniforms, material ) {\n\n\t\tuniforms.roughness.value = material.roughness;\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t}\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical ( uniforms, material ) {\n\n\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\trefreshUniformsStandard( uniforms, material );\n\n\t}\n\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\n\n\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\tuniforms.directionalLights.needsUpdate = value;\n\t\tuniforms.pointLights.needsUpdate = value;\n\t\tuniforms.spotLights.needsUpdate = value;\n\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t}\n\n\t// Lighting\n\n\tfunction setupShadows ( lights ) {\n\n\t\tvar lightShadowsLength = 0;\n\n\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tvar light = lights[ i ];\n\n\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.shadows.length = lightShadowsLength;\n\n\t}\n\n\tfunction setupLights ( lights, camera ) {\n\n\t\tvar l, ll, light,\n\t\tr = 0, g = 0, b = 0,\n\t\tcolor,\n\t\tintensity,\n\t\tdistance,\n\t\tshadowMap,\n\n\t\tviewMatrix = camera.matrixWorldInverse,\n\n\t\tdirectionalLength = 0,\n\t\tpointLength = 0,\n\t\tspotLength = 0,\n\t\themiLength = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tcolor = light.color;\n\t\t\tintensity = light.intensity;\n\t\t\tdistance = light.distance;\n\n\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\n\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\n\n\t\t\t\t}\n\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.ambient[ 0 ] = r;\n\t\t_lights.ambient[ 1 ] = g;\n\t\t_lights.ambient[ 2 ] = b;\n\n\t\t_lights.directional.length = directionalLength;\n\t\t_lights.spot.length = spotLength;\n\t\t_lights.point.length = pointLength;\n\t\t_lights.hemi.length = hemiLength;\n\n\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n\t}\n\n\t// GL state setting\n\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\tstate.setCullFace( cullFace );\n\t\tstate.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );\n\n\t};\n\n\t// Textures\n\n\tfunction allocTextureUnit() {\n\n\t\tvar textureUnit = _usedTextureUnits;\n\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t}\n\n\t\t_usedTextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\tthis.allocTextureUnit = allocTextureUnit;\n\n\t// this.setTexture2D = setTexture2D;\n\tthis.setTexture2D = ( function() {\n\n\t\tvar warned = false;\n\n\t\t// backwards compatibility: peel texture.texture\n\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\tif ( texture instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTexture = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTexture( texture, slot ) {\n\n\t\t\tif ( ! warned ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\twarned = true;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTextureCube = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\tif ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t// TODO: unify these code paths\n\t\t\tif ( texture instanceof THREE.CubeTexture ||\n\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t} else {\n\n\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tthis.getCurrentRenderTarget = function() {\n\n\t\treturn _currentRenderTarget;\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t_currentRenderTarget = renderTarget;\n\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t}\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar framebuffer;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\n\t\t\t}\n\n\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t_currentViewport.copy( renderTarget.viewport );\n\n\t\t} else {\n\n\t\t\tframebuffer = null;\n\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n\t\t}\n\n\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\tstate.scissor( _currentScissor );\n\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\tstate.viewport( _currentViewport );\n\n\t\tif ( isCube ) {\n\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t}\n\n\t};\n\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\tif ( framebuffer ) {\n\n\t\t\tvar restore = false;\n\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\trestore = true;\n\n\t\t\t}\n\n\t\t\ttry {\n\n\t\t\t\tvar texture = renderTarget.texture;\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\n\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\n\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\n\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t}\n\n\t\t\t} finally {\n\n\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Map three.js constants to WebGL constants\n\n\tfunction paramThreeToGL ( p ) {\n\n\t\tvar extension;\n\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\n\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\n\n\t\t}\n\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\n\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\n\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n};\n\n// File:src/renderers/WebGLRenderTarget.js\n\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n * @author Marius Kintel / https://github.com/kintel\n */\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\n\tthis.scissorTest = false;\n\n\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\n\n\toptions = options || {};\n\n\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\n\n\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\tthis.depthTexture = null;\n\n};\n\nObject.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {\n\n\tsetSize: function ( width, height ) {\n\n\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.texture = source.texture.clone();\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\tthis.depthTexture = source.depthTexture;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/renderers/WebGLRenderTargetCube.js\n\n/**\n * @author alteredq / http://alteredqualia.com\n */\n\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\tthis.activeMipMapLevel = 0;\n\n};\n\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\n\n// File:src/renderers/webgl/WebGLBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawArrays( mode, start, count );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar position = geometry.attributes.position;\n\n\t\tvar count = 0;\n\n\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tcount = position.data.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t} else {\n\n\t\t\tcount = position.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t}\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t}\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLClipping.js\n\nTHREE.WebGLClipping = function() {\n\n\tvar scope = this,\n\n\t\tglobalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false,\n\n\t\tplane = new THREE.Plane(),\n\t\tviewNormalMatrix = new THREE.Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\n\tthis.init = function( planes, enableLocalClipping, camera ) {\n\n\t\tvar enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function() {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function() {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function( planes, clipShadows, camera, cache, fromCache ) {\n\n\t\tif ( ! localClippingEnabled ||\n\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tcache.clippingState = dstArray;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\tdstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\treturn dstArray;\n\n\t}\n\n};\n\n\n// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tvar type, size;\n\n\tfunction setIndex( index ) {\n\n\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\ttype = _gl.UNSIGNED_INT;\n\t\t\tsize = 4;\n\n\t\t} else {\n\n\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\t\tsize = 2;\n\n\t\t}\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawElements( mode, count, type, start * size );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry, start, count ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t}\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLExtensions.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLExtensions = function ( gl ) {\n\n\tvar extensions = {};\n\n\tthis.get = function ( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tvar extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLCapabilities.js\n\nTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\n\n\tvar maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tthis.getMaxAnisotropy = getMaxAnisotropy;\n\tthis.getMaxPrecision = getMaxPrecision;\n\n\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\n\n\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\tthis.vertexTextures = this.maxVertexTextures > 0;\n\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\n\n\tvar _maxPrecision = getMaxPrecision( this.precision );\n\n\tif ( _maxPrecision !== this.precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\n\t\tthis.precision = _maxPrecision;\n\n\t}\n\n\tif ( this.logarithmicDepthBuffer ) {\n\n\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLGeometries.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLGeometries = function ( gl, properties, info ) {\n\n\tvar geometries = {};\n\n\tfunction get( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\n\t\t\treturn geometries[ geometry.id ];\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tvar buffergeometry;\n\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tbuffergeometry = geometry;\n\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\n\n\t\t\t}\n\n\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t}\n\n\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tvar geometry = event.target;\n\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\tdeleteAttribute( buffergeometry.index );\n\n\t\t}\n\n\t\tdeleteAttributes( buffergeometry.attributes );\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\t// TODO\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe ) {\n\n\t\t\tdeleteAttribute( property.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( geometry );\n\n\t\tvar bufferproperty = properties.get( buffergeometry );\n\n\t\tif ( bufferproperty.wireframe ) {\n\n\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( buffergeometry );\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction deleteAttribute( attribute ) {\n\n\t\tvar buffer = getAttributeBuffer( attribute );\n\n\t\tif ( buffer !== undefined ) {\n\n\t\t\tgl.deleteBuffer( buffer );\n\t\t\tremoveAttributeBuffer( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction deleteAttributes( attributes ) {\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tdeleteAttribute( attributes[ name ] );\n\n\t\t}\n\n\t}\n\n\tfunction removeAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tproperties.delete( attribute.data );\n\n\t\t} else {\n\n\t\t\tproperties.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tthis.get = get;\n\n};\n\n// File:src/renderers/webgl/WebGLLights.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLLights = function () {\n\n\tvar lights = {};\n\n\tthis.get = function ( light ) {\n\n\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\treturn lights[ light.id ];\n\n\t\t}\n\n\t\tvar uniforms;\n\n\t\tswitch ( light.type ) {\n\n\t\t\tcase 'DirectionalLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tconeCos: 0,\n\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tskyColor: new THREE.Color(),\n\t\t\t\t\tgroundColor: new THREE.Color()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tlights[ light.id ] = uniforms;\n\n\t\treturn uniforms;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLObjects.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLObjects = function ( gl, properties, info ) {\n\n\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\n\n\t//\n\n\tfunction update( object ) {\n\n\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n\t\tvar geometry = geometries.get( object );\n\n\t\tif ( object.geometry instanceof THREE.Geometry ) {\n\n\t\t\tgeometry.updateFromObject( object );\n\n\t\t}\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\n\t\tif ( index !== null ) {\n\n\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction updateAttribute( attribute, bufferType ) {\n\n\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\n\n\t\tvar attributeProperties = properties.get( data );\n\n\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\n\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\n\t\t} else if ( attributeProperties.version !== data.version ) {\n\n\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\n\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\tgl.bufferData( bufferType, data.array, usage );\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\n\t\t} else if ( data.updateRange.count === 0 ) {\n\n\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t} else {\n\n\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n\t\t\tdata.updateRange.count = 0; // reset range\n\n\t\t}\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe !== undefined ) {\n\n\t\t\treturn property.wireframe;\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\t\tvar position = attributes.position;\n\n\t\t// console.time( 'wireframe' );\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar edges = {};\n\t\t\tvar array = index.array;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\n\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\n\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar array = attributes.position.array;\n\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tvar a = i + 0;\n\t\t\t\tvar b = i + 1;\n\t\t\t\tvar c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// console.timeEnd( 'wireframe' );\n\n\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\n\n\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\tproperty.wireframe = attribute;\n\n\t\treturn attribute;\n\n\t}\n\n\tfunction checkEdge( edges, a, b ) {\n\n\t\tif ( a > b ) {\n\n\t\t\tvar tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\n\t\t}\n\n\t\tvar list = edges[ a ];\n\n\t\tif ( list === undefined ) {\n\n\t\t\tedges[ a ] = [ b ];\n\t\t\treturn true;\n\n\t\t} else if ( list.indexOf( b ) === -1 ) {\n\n\t\t\tlist.push( b );\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tthis.getAttributeBuffer = getAttributeBuffer;\n\tthis.getWireframeAttribute = getWireframeAttribute;\n\n\tthis.update = update;\n\n};\n\n// File:src/renderers/webgl/WebGLProgram.js\n\nTHREE.WebGLProgram = ( function () {\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase THREE.LinearEncoding:\n\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\tcase THREE.sRGBEncoding:\n\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\tcase THREE.RGBEEncoding:\n\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\tcase THREE.RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\tcase THREE.RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\tcase THREE.RGBDEncoding:\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\tcase THREE.GammaEncoding:\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase THREE.LinearToneMapping:\n\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.ReinhardToneMapping:\n\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.CineonToneMapping:\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = THREE.ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\treturn function WebGLProgram( renderer, code, material, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar extensions = material.extensions;\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeReflectionMapping:\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.CubeUVReflectionMapping:\n\t\t\t\tcase THREE.CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.EquirectangularReflectionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase THREE.MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material instanceof THREE.RawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\n\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\n\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\t}\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function() {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms =\n\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function() {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function() {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLPrograms.js\n\nTHREE.WebGLPrograms = function ( renderer, capabilities ) {\n\n\tvar programs = [];\n\n\tvar shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points'\n\t};\n\n\tvar parameterNames = [\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\n\t];\n\n\n\tfunction allocateBones ( object ) {\n\n\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t//\n\t\t\t//  - leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t}\n\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\tvar encoding;\n\n\t\tif ( ! map ) {\n\n\t\t\tencoding = THREE.LinearEncoding;\n\n\t\t} else if ( map instanceof THREE.Texture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\tencoding = map.texture.encoding;\n\n\t\t}\n\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\tencoding = THREE.GammaEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\n\n\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tvar maxBones = allocateBones( object );\n\t\tvar precision = renderer.getPrecision();\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\n\t\tvar parameters = {\n\n\t\t\tshaderID: shaderID,\n\n\t\t\tprecision: precision,\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\tmap: !! material.map,\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\tenvMap: !! material.envMap,\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\n\t\t\tlightMap: !! material.lightMap,\n\t\t\taoMap: !! material.aoMap,\n\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\tbumpMap: !! material.bumpMap,\n\t\t\tnormalMap: !! material.normalMap,\n\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\tspecularMap: !! material.specularMap,\n\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\tcombine: material.combine,\n\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\n\t\t\tflatShading: material.shading === THREE.FlatShading,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\tskinning: material.skinning,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumClippingPlanes: nClipPlanes,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\tflipSided: material.side === THREE.BackSide,\n\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t};\n\n\t\treturn parameters;\n\n\t};\n\n\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\tvar array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( material.fragmentShader );\n\t\t\tarray.push( material.vertexShader );\n\n\t\t}\n\n\t\tif ( material.defines !== undefined ) {\n\n\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t}\n\n\t\treturn array.join();\n\n\t};\n\n\tthis.acquireProgram = function ( material, parameters, code ) {\n\n\t\tvar program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\tprogram = programInfo;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\tthis.releaseProgram = function( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tvar i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t};\n\n\t// Exposed for resource monitoring & error feedback via renderer.info:\n\tthis.programs = programs;\n\n};\n\n// File:src/renderers/webgl/WebGLProperties.js\n\n/**\n* @author fordacious / fordacious.github.io\n*/\n\nTHREE.WebGLProperties = function () {\n\n\tvar properties = {};\n\n\tthis.get = function ( object ) {\n\n\t\tvar uuid = object.uuid;\n\t\tvar map = properties[ uuid ];\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties[ uuid ] = map;\n\n\t\t}\n\n\t\treturn map;\n\n\t};\n\n\tthis.delete = function ( object ) {\n\n\t\tdelete properties[ object.uuid ];\n\n\t};\n\n\tthis.clear = function () {\n\n\t\tproperties = {};\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLShader.js\n\nTHREE.WebGLShader = ( function () {\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\treturn function WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLShadowMap.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\n\n\tvar _gl = _renderer.context,\n\t_state = _renderer.state,\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_lightShadows = _lights.shadows,\n\n\t_shadowMapSize = new THREE.Vector2(),\n\n\t_lookTarget = new THREE.Vector3(),\n\t_lightPositionWorld = new THREE.Vector3(),\n\n\t_renderList = [],\n\n\t_MorphingFlag = 1,\n\t_SkinningFlag = 2,\n\n\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t_materialCache = {};\n\n\tvar cubeDirections = [\n\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\n\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\n\t];\n\n\tvar cubeUps = [\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\n\t];\n\n\tvar cube2DViewPorts = [\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\n\t];\n\n\t// init\n\n\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\n\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\n\tdepthMaterialTemplate.clipping = true;\n\n\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\n\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\n\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\tdepthMaterial.morphTargets = useMorphing;\n\t\tdepthMaterial.skinning = useSkinning;\n\n\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\n\t\t\tdefines: {\n\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t},\n\t\t\tuniforms: distanceUniforms,\n\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\tmorphTargets: useMorphing,\n\t\t\tskinning: useSkinning,\n\t\t\tclipping: true\n\t\t} );\n\n\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t}\n\n\t//\n\n\tvar scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = THREE.PCFShadowMap;\n\n\tthis.renderReverseSided = true;\n\tthis.renderSingleSided = true;\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( _lightShadows.length === 0 ) return;\n\n\t\t// Set GL state for depth map.\n\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t_state.disable( _gl.BLEND );\n\t\t_state.setDepthTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tvar faceCount, isPointLight;\n\n\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n\t\t\tvar light = _lightShadows[ i ];\n\t\t\tvar shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tif ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tfaceCount = 6;\n\t\t\t\tisPointLight = true;\n\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t// following orientation:\n\t\t\t\t//\n\t\t\t\t//  xzXZ\n\t\t\t\t//   y Y\n\t\t\t\t//\n\t\t\t\t// X - Positive x direction\n\t\t\t\t// x - Negative x direction\n\t\t\t\t// Y - Positive y direction\n\t\t\t\t// y - Negative y direction\n\t\t\t\t// Z - Positive z direction\n\t\t\t\t// z - Negative z direction\n\n\t\t\t\t// positive X\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative X\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Z\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative Z\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Y\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t// negative Y\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t} else {\n\n\t\t\t\tfaceCount = 1;\n\t\t\t\tisPointLight = false;\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\n\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\n\n\t\t\t\tshadow.update( light );\n\n\t\t\t}\n\n\t\t\tvar shadowMap = shadow.map;\n\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t// run a single pass if not\n\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t}\n\n\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\t\t// compute shadow matrix\n\n\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t);\n\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t_renderList.length = 0;\n\n\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\n\t\t\t\t// render shadow map\n\t\t\t\t// render regular objects\n\n\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Restore GL state.\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\n\t\tscope.needsUpdate = false;\n\n\t};\n\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tvar result = null;\n\n\t\tvar materialVariants = _depthMaterials;\n\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\tif ( isPointLight ) {\n\n\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t}\n\n\t\tif ( ! customMaterial ) {\n\n\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\n\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\n\n\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\n\n\t\t\tvar variantIndex = 0;\n\n\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t} else {\n\n\t\t\tresult = customMaterial;\n\n\t\t}\n\n\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t material.clipShadows === true &&\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tvar side = material.side;\n\n\t\tif ( scope.renderSingleSided && side == THREE.DoubleSide ) {\n\n\t\t\tside = THREE.FrontSide;\n\n\t\t}\n\n\t\tif ( scope.renderReverseSided ) {\n\n\t\t\tif ( side === THREE.FrontSide ) side = THREE.BackSide;\n\t\t\telse if ( side === THREE.BackSide ) side = THREE.FrontSide;\n\n\t\t}\n\n\t\tresult.side = side;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction projectObject( object, camera, shadowCamera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\n\n\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t_renderList.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLState.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\n\n\tvar _this = this;\n\n\tthis.buffers = {\n\t\tcolor: new THREE.WebGLColorBuffer( gl, this ),\n\t\tdepth: new THREE.WebGLDepthBuffer( gl, this ),\n\t\tstencil: new THREE.WebGLStencilBuffer( gl, this )\n\t};\n\n\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\tvar capabilities = {};\n\n\tvar compressedTextureFormats = null;\n\n\tvar currentBlending = null;\n\tvar currentBlendEquation = null;\n\tvar currentBlendSrc = null;\n\tvar currentBlendDst = null;\n\tvar currentBlendEquationAlpha = null;\n\tvar currentBlendSrcAlpha = null;\n\tvar currentBlendDstAlpha = null;\n\tvar currentPremultipledAlpha = false;\n\n\tvar currentFlipSided = null;\n\tvar currentCullFace = null;\n\n\tvar currentLineWidth = null;\n\n\tvar currentPolygonOffsetFactor = null;\n\tvar currentPolygonOffsetUnits = null;\n\n\tvar currentScissorTest = null;\n\n\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n\tvar currentTextureSlot = null;\n\tvar currentBoundTextures = {};\n\n\tvar currentScissor = new THREE.Vector4();\n\tvar currentViewport = new THREE.Vector4();\n\n\tfunction createTexture( type, target, count ) {\n\n\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tvar texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tvar emptyTextures = {};\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t//\n\n\tthis.init = function () {\n\n\t\tthis.clearColor( 0, 0, 0, 1 );\n\t\tthis.clearDepth( 1 );\n\t\tthis.clearStencil( 0 );\n\n\t\tthis.enable( gl.DEPTH_TEST );\n\t\tthis.setDepthFunc( THREE.LessEqualDepth );\n\n\t\tthis.setFlipSided( false );\n\t\tthis.setCullFace( THREE.CullFaceBack );\n\t\tthis.enable( gl.CULL_FACE );\n\n\t\tthis.enable( gl.BLEND );\n\t\tthis.setBlending( THREE.NormalBlending );\n\n\t};\n\n\tthis.initAttributes = function () {\n\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttribute = function ( attribute ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t};\n\n\tthis.disableUnusedAttributes = function () {\n\n\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.enable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tcapabilities[ id ] = true;\n\n\t\t}\n\n\t};\n\n\tthis.disable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tcapabilities[ id ] = false;\n\n\t\t}\n\n\t};\n\n\tthis.getCompressedTextureFormats = function () {\n\n\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\tcompressedTextureFormats = [];\n\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn compressedTextureFormats;\n\n\t};\n\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending !== THREE.NoBlending ) {\n\n\t\t\tthis.enable( gl.BLEND );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.BLEND );\n\t\t\tcurrentBlending = blending; // no blending, that is\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\tif ( blending === THREE.AdditiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentBlending = blending;\n\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t}\n\n\t\tif ( blending === THREE.CustomBlending ) {\n\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t}\n\n\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tcurrentBlendEquation = null;\n\t\t\tcurrentBlendSrc = null;\n\t\t\tcurrentBlendDst = null;\n\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.setColorWrite = function ( colorWrite ) {\n\n\t\tthis.buffers.color.setMask( colorWrite );\n\n\t};\n\n\tthis.setDepthTest = function ( depthTest ) {\n\n\t\tthis.buffers.depth.setTest( depthTest );\n\n\t};\n\n\tthis.setDepthWrite = function ( depthWrite ) {\n\n\t\tthis.buffers.depth.setMask( depthWrite );\n\n\t};\n\n\tthis.setDepthFunc = function ( depthFunc ) {\n\n\t\tthis.buffers.depth.setFunc( depthFunc );\n\n\t};\n\n\tthis.setStencilTest = function ( stencilTest ) {\n\n\t\tthis.buffers.stencil.setTest( stencilTest );\n\n\t};\n\n\tthis.setStencilWrite = function ( stencilWrite ) {\n\n\t\tthis.buffers.stencil.setMask( stencilWrite );\n\n\t};\n\n\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tthis.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );\n\n\t};\n\n\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tthis.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );\n\n\t};\n\n\t//\n\n\tthis.setFlipSided = function ( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t};\n\n\tthis.setCullFace = function ( cullFace ) {\n\n\t\tif ( cullFace !== THREE.CullFaceNone ) {\n\n\t\t\tthis.enable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t};\n\n\tthis.setLineWidth = function ( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tgl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t};\n\n\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t};\n\n\tthis.getScissorTest = function () {\n\n\t\treturn currentScissorTest;\n\n\t};\n\n\tthis.setScissorTest = function ( scissorTest ) {\n\n\t\tcurrentScissorTest = scissorTest;\n\n\t\tif ( scissorTest ) {\n\n\t\t\tthis.enable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t};\n\n\t// texture\n\n\tthis.activeTexture = function ( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t};\n\n\tthis.bindTexture = function ( webglType, webglTexture ) {\n\n\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t_this.activeTexture();\n\n\t\t}\n\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t};\n\n\tthis.compressedTexImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\tthis.texImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.clearColor = function ( r, g, b, a ) {\n\n\t\tthis.buffers.color.setClear( r, g, b, a );\n\n\t};\n\n\tthis.clearDepth = function ( depth ) {\n\n\t\tthis.buffers.depth.setClear( depth );\n\n\t};\n\n\tthis.clearStencil = function ( stencil ) {\n\n\t\tthis.buffers.stencil.setClear( stencil );\n\n\t};\n\n\t//\n\n\tthis.scissor = function ( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t};\n\n\tthis.viewport = function ( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tthis.reset = function () {\n\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcapabilities = {};\n\n\t\tcompressedTextureFormats = null;\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentBlending = null;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tthis.buffers.color.reset();\n\t\tthis.buffers.depth.reset();\n\t\tthis.buffers.stencil.reset();\n\n\t};\n\n};\n\nTHREE.WebGLColorBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar color = new THREE.Vector4();\n\tvar currentColorMask = null;\n\tvar currentColorClear = new THREE.Vector4();\n\n\tthis.setMask = function ( colorMask ) {\n\n\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\tcurrentColorMask = colorMask;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( r, g, b, a ) {\n\n\t\tcolor.set( r, g, b, a );\n\n\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\tgl.clearColor( r, g, b, a );\n\t\t\tcurrentColorClear.copy( color );\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentColorMask = null;\n\t\tcurrentColorClear = new THREE.Vector4();\n\n\t};\n\n};\n\nTHREE.WebGLDepthBuffer = function( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentDepthMask = null;\n\tvar currentDepthFunc = null;\n\tvar currentDepthClear = null;\n\n\tthis.setTest = function ( depthTest ) {\n\n\t\tif ( depthTest ) {\n\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function( depthMask ){\n\n\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\tgl.depthMask( depthMask );\n\t\t\tcurrentDepthMask = depthMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( depthFunc ) {\n\n\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\tif ( depthFunc ) {\n\n\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\tcase THREE.NeverDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.AlwaysDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.EqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.NotEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t}\n\n\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( depth ) {\n\n\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\tgl.clearDepth( depth );\n\t\t\tcurrentDepthClear = depth;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentDepthMask = null;\n\t\tcurrentDepthFunc = null;\n\t\tcurrentDepthClear = null;\n\n\t};\n\n};\n\nTHREE.WebGLStencilBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentStencilMask = null;\n\tvar currentStencilFunc = null;\n\tvar currentStencilRef = null;\n\tvar currentStencilFuncMask = null;\n\tvar currentStencilFail  = null;\n\tvar currentStencilZFail = null;\n\tvar currentStencilZPass = null;\n\tvar currentStencilClear = null;\n\n\tthis.setTest = function ( stencilTest ) {\n\n\t\tif ( stencilTest ) {\n\n\t\t\tstate.enable( gl.STENCIL_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.STENCIL_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function ( stencilMask ) {\n\n\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\tgl.stencilMask( stencilMask );\n\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\n\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setOp\t = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t     currentStencilZFail !== stencilZFail ||\n\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\n\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( stencil ) {\n\n\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\tgl.clearStencil( stencil );\n\t\t\tcurrentStencilClear = stencil;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentStencilMask = null;\n\t\tcurrentStencilFunc = null;\n\t\tcurrentStencilRef = null;\n\t\tcurrentStencilFuncMask = null;\n\t\tcurrentStencilFail = null;\n\t\tcurrentStencilZFail = null;\n\t\tcurrentStencilZPass = null;\n\t\tcurrentStencilClear = null;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLTextures.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLTextures = function ( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n\tvar _infoMemory = info.memory;\n\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n\t//\n\n\tfunction clampToMaxSize ( image, maxSize ) {\n\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t// premultiplied alpha.\n\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction isPowerOfTwo( image ) {\n\n\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\n\n\t}\n\n\tfunction makePowerOfTwo( image ) {\n\n\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\n\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\n\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\n\n\t\treturn false;\n\n\t}\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback ( f ) {\n\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\n\t\t\treturn _gl.NEAREST;\n\n\t\t}\n\n\t\treturn _gl.LINEAR;\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tvar texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\t_infoMemory.textures --;\n\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tvar renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t_infoMemory.textures --;\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t// cube texture\n\n\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t} else {\n\n\t\t\t// 2D texture\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\t// remove all webgl properties\n\t\tproperties.delete( texture );\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\tif ( ! renderTarget ) return;\n\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t}\n\n\t\tproperties.delete( renderTarget.texture );\n\t\tproperties.delete( renderTarget );\n\n\t}\n\n\t//\n\n\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tvar image = texture.image;\n\n\t\t\tif ( image === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTextureCube ( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t} else {\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setTextureCubeDynamic ( texture, slot ) {\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t}\n\n\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\n\n\t\tvar extension;\n\n\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension ) {\n\n\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t_infoMemory.textures ++;\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\timage = makePowerOfTwo( image );\n\n\t\t}\n\n\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\tglFormat = paramThreeToGL( texture.format ),\n\t\tglType = paramThreeToGL( texture.type );\n\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\tif ( texture instanceof THREE.DepthTexture ) {\n\n\t\t\t// populate depth texture with dummy data\n\n\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\tif ( texture.type === THREE.FloatType ) {\n\n\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t}\n\n\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t} else if ( texture instanceof THREE.DataTexture ) {\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t}\n\n\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\n\n\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t_infoMemory.textures ++;\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tvar texture = renderTarget.texture;\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\n\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t_gl.generateMipmap( target );\n\t\t\tstate.bindTexture( target, null );\n\n\t\t}\n\n\t}\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n};\n\n// File:src/renderers/webgl/WebGLUniforms.js\n\n/**\n *\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [renderer] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'renderer' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (renderer factorizations):\n *\n * .upload( gl, seq, values, renderer )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n * .splitDynamic( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\n *\n *\n * Methods of the top-level container (renderer factorizations):\n *\n * .setValue( gl, name, value )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .set( gl, obj, prop )\n *\n * \t\tsets uniform from object and property with same name than uniform\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n *\n * @author tschw\n *\n */\n\nTHREE.WebGLUniforms = ( function() { // scope\n\n\tvar emptyTexture = new THREE.Texture();\n\tvar emptyCubeTexture = new THREE.CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tvar UniformContainer = function() {\n\n\t\t\tthis.seq = [];\n\t\t\tthis.map = {};\n\n\t\t},\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\t\tarrayCacheF32 = [],\n\t\tarrayCacheI32 = [],\n\n\t\tuncacheTemporaryArrays = function() {\n\n\t\t\tarrayCacheF32.length = 0;\n\t\t\tarrayCacheI32.length = 0;\n\n\t\t},\n\n\t// Flattening for arrays of vectors and matrices\n\n\t\tflatten = function( array, nBlocks, blockSize ) {\n\n\t\t\tvar firstElem = array[ 0 ];\n\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t// see http://jacksondunstan.com/articles/983\n\n\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\tr = arrayCacheF32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Float32Array( n );\n\t\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tif ( nBlocks !== 0 ) {\n\n\t\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\t\toffset += blockSize;\n\t\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// Texture unit allocation\n\n\t\tallocTexUnits = function( renderer, n ) {\n\n\t\t\tvar r = arrayCacheI32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Int32Array( n );\n\t\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t\t// Single scalar\n\n\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\n\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\n\n\t\t// Single float vector (from flat array or THREE.VectorN)\n\n\t\tsetValue2fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\n\t\t},\n\n\t\tsetValue3fv = function( gl, v ) {\n\n\t\t\tif ( v.x !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\t\telse if ( v.r !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\t\telse\n\t\t\t\tgl.uniform3fv( this.addr, v );\n\n\t\t},\n\n\t\tsetValue4fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t},\n\n\t\t// Single matrix (from flat array or MatrixN)\n\n\t\tsetValue2fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue3fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue4fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\t// Single texture (2D / Cube)\n\n\t\tsetValueT1 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t\t},\n\n\t\tsetValueT6 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t\t},\n\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\n\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\n\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\n\n\t\t// Helper to pick the right setter for the singular case\n\n\t\tgetSingularSetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Array of scalars\n\n\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\n\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\n\n\t\t// Array of vectors (flat or from THREE classes)\n\n\t\tsetValueV2a = function( gl, v ) {\n\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t\t},\n\n\t\tsetValueV3a = function( gl, v ) {\n\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t\t},\n\n\t\tsetValueV4a = function( gl, v ) {\n\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\t// Array of matrices (flat or from THREE clases)\n\n\t\tsetValueM2a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\tsetValueM3a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t\t},\n\n\t\tsetValueM4a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t\t},\n\n\t\t// Array of textures (2D / Cube)\n\n\t\tsetValueT1a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetValueT6a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\t\tgetPureArraySetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t// --- Uniform Classes ---\n\n\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tPureArrayUniform = function( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.size = activeInfo.size;\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tStructuredUniform = function( id ) {\n\n\t\t\tthis.id = id;\n\n\t\t\tUniformContainer.call( this ); // mix-in\n\n\t\t};\n\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\n\t\t// extracts\n\t\t// \t- the identifier (member name or array index)\n\t\t//  - followed by an optional right bracket (found when array index)\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t//\n\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t// in the uniform names.\n\n\t\taddUniform = function( container, uniformObject ) {\n\n\t\t\tcontainer.seq.push( uniformObject );\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t\t},\n\n\t\tparseUniform = function( activeInfo, addr, container ) {\n\n\t\t\tvar path = activeInfo.name,\n\t\t\t\tpathLength = path.length;\n\n\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\tRePathPart.lastIndex = 0;\n\n\t\t\tfor (; ;) {\n\n\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\t\tif ( subscript === undefined ||\n\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\t\tvar map = container.map,\n\t\t\t\t\t\tnext = map[ id ];\n\n\t\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer = next;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t// Root Container\n\n\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\n\n\t\t\tUniformContainer.call( this );\n\n\t\t\tthis.renderer = renderer;\n\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\tpath = info.name,\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\t\tparseUniform( info, addr, this );\n\n\t\t\t}\n\n\t\t};\n\n\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.splitDynamic = function( seq, values ) {\n\n\t\tvar r = null,\n\t\t\tn = seq.length,\n\t\t\tw = 0;\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v && v.dynamic === true ) {\n\n\t\t\t\tif ( r === null ) r = [];\n\t\t\t\tr.push( u );\n\n\t\t\t} else {\n\n\t\t\t\t// in-place compact 'seq', removing the matches\n\t\t\t\tif ( w < i ) seq[ w ] = u;\n\t\t\t\t++ w;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( w < n ) seq.length = w;\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar v = values[ seq[ i ].id ],\n\t\t\t\tf = v.onUpdateCallback;\n\n\t\t\tif ( f !== undefined ) f.call( v, object, camera );\n\n\t\t}\n\n\t};\n\n\treturn WebGLUniforms;\n\n} )();\n\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar shader, program, attributes, uniforms;\n\n\tvar tempTexture, occlusionTexture;\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 1, - 1,  0, 0,\n\t\t\t 1, - 1,  1, 0,\n\t\t\t 1,  1,  1, 1,\n\t\t\t- 1,  1,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\t// buffers\n\n\t\tvertexBuffer     = gl.createBuffer();\n\t\telementBuffer    = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t// textures\n\n\t\ttempTexture      = gl.createTexture();\n\t\tocclusionTexture = gl.createTexture();\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tshader = {\n\n\t\t\tvertexShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\"uniform float rotation;\",\n\n\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\n\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" ),\n\n\t\t\tfragmentShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t// pink square\n\n\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t\t// restore\n\n\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t\t// flare\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" )\n\n\t\t};\n\n\t\tprogram = createProgram( shader );\n\n\t\tattributes = {\n\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t};\n\n\t\tuniforms = {\n\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t};\n\n\t}\n\n\t/*\n\t * Render lens flares\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t *         reads these back and calculates occlusion.\n\t */\n\n\tthis.render = function ( scene, camera, viewport ) {\n\n\t\tif ( flares.length === 0 ) return;\n\n\t\tvar tempPosition = new THREE.Vector3();\n\n\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\thalfViewportHeight = viewport.w * 0.5;\n\n\t\tvar size = 16 / viewport.w,\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\n\t\tvar validArea = new THREE.Box2();\n\n\t\tvalidArea.min.set( 0, 0 );\n\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.vertex );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\t// loop through all lens flares to update their occlusion and positions\n\t\t// setup gl and common used attribs/uniforms\n\n\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\tgl.uniform1i( uniforms.map, 1 );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.setDepthWrite( false );\n\n\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n\t\t\tsize = 16 / viewport.w;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t// calc object screen position\n\n\t\t\tvar flare = flares[ i ];\n\n\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t// setup arrays for gl programs\n\n\t\t\tscreenPosition.copy( tempPosition );\n\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t// screen cull\n\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// render pink quad\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// restore graphics\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// update object positions\n\n\t\t\t\tflare.positionScreen.copy( screenPosition );\n\n\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t}\n\n\t\t\t\t// render flares\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\tstate.enable( gl.BLEND );\n\n\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\n\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\t\tstate.enable( gl.DEPTH_TEST );\n\t\tstate.setDepthWrite( true );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram ( shader ) {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\tgl.compileShader( fragmentShader );\n\t\tgl.compileShader( vertexShader );\n\n\t\tgl.attachShader( program, fragmentShader );\n\t\tgl.attachShader( program, vertexShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n};\n\n// File:src/renderers/webgl/plugins/SpritePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpritePlugin = function ( renderer, sprites ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar program, attributes, uniforms;\n\n\tvar texture;\n\n\t// decompose matrixWorld\n\n\tvar spritePosition = new THREE.Vector3();\n\tvar spriteRotation = new THREE.Quaternion();\n\tvar spriteScale = new THREE.Vector3();\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t- 0.5,   0.5,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\tvertexBuffer  = gl.createBuffer();\n\t\telementBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\tprogram = createProgram();\n\n\t\tattributes = {\n\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t};\n\n\t\tuniforms = {\n\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\n\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\n\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t};\n\n\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tcanvas.width = 8;\n\t\tcanvas.height = 8;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = 'white';\n\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\ttexture = new THREE.Texture( canvas );\n\t\ttexture.needsUpdate = true;\n\n\t}\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( sprites.length === 0 ) return;\n\n\t\t// setup gl\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.position );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.enable( gl.BLEND );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\tvar oldFogType = 0;\n\t\tvar sceneFogType = 0;\n\t\tvar fog = scene.fog;\n\n\t\tif ( fog ) {\n\n\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\toldFogType = 1;\n\t\t\t\tsceneFogType = 1;\n\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\toldFogType = 2;\n\t\t\t\tsceneFogType = 2;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\toldFogType = 0;\n\t\t\tsceneFogType = 0;\n\n\t\t}\n\n\n\t\t// update positions and sort\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\n\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t}\n\n\t\tsprites.sort( painterSortStable );\n\n\t\t// render all sprites\n\n\t\tvar scale = [];\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\t\t\tvar material = sprite.material;\n\n\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\tvar fogType = 0;\n\n\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\tfogType = sceneFogType;\n\n\t\t\t}\n\n\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\toldFogType = fogType;\n\n\t\t\t}\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t}\n\n\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setTexture2D( texture, 0 );\n\n\t\t\t}\n\n\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram () {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform float rotation;',\n\t\t\t'uniform vec2 scale;',\n\t\t\t'uniform vec2 uvOffset;',\n\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t'attribute vec2 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D map;',\n\t\t\t'uniform float opacity;',\n\n\t\t\t'uniform int fogType;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t\t'uniform float fogDensity;',\n\t\t\t'uniform float fogNear;',\n\t\t\t'uniform float fogFar;',\n\t\t\t'uniform float alphaTest;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t'}',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.compileShader( vertexShader );\n\t\tgl.compileShader( fragmentShader );\n\n\t\tgl.attachShader( program, vertexShader );\n\t\tgl.attachShader( program, fragmentShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\t\t\n\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn b.id - a.id;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/Three.Legacy.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.assign( THREE, {\n\tFace4: function ( a, b, c, d, normal, color, materialIndex ) {\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\n\t},\n\tLineStrip: 0,\n\tLinePieces: 1,\n\tMeshFaceMaterial: THREE.MultiMaterial,\n\tPointCloud: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tParticle: THREE.Sprite,\n\tParticleSystem: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tPointCloudMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleBasicMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleSystemMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tVertex: function ( x, y, z ) {\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new THREE.Vector3( x, y, z );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Box2.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t}\n} );\n\nObject.assign( THREE.Box3.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Matrix3.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\treturn vector.applyMatrix3( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t}\n} );\n\nObject.assign( THREE.Matrix4.prototype, {\n\textractPosition: function ( m ) {\n\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\treturn this.copyPosition( m );\n\t},\n\tsetRotationFromQuaternion: function ( q ) {\n\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\treturn this.makeRotationFromQuaternion( q );\n\t},\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\treturn vector.applyProjection( this );\n\t},\n\tmultiplyVector4: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t},\n\trotateAxis: function ( v ) {\n\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\tv.transformDirection( this );\n\t},\n\tcrossVector: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\ttranslate: function ( v ) {\n\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t},\n\trotateX: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t},\n\trotateY: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t},\n\trotateZ: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t},\n\trotateByAxis: function ( axis, angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t}\n} );\n\nObject.assign( THREE.Plane.prototype, {\n\tisIntersectionLine: function ( line ) {\n\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\treturn this.intersectsLine( line );\n\t}\n} );\n\nObject.assign( THREE.Quaternion.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\treturn vector.applyQuaternion( this );\n\t}\n} );\n\nObject.assign( THREE.Ray.prototype, {\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionPlane: function ( plane ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\treturn this.intersectsPlane( plane );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Vector3.prototype, {\n\tsetEulerFromRotationMatrix: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t},\n\tsetEulerFromQuaternion: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t},\n\tgetPositionFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\treturn this.setFromMatrixPosition( m );\n\t},\n\tgetScaleFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\treturn this.setFromMatrixScale( m );\n\t},\n\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\treturn this.setFromMatrixColumn( matrix, index );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Object3D.prototype, {\n\tgetChildByName: function ( name ) {\n\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\treturn this.getObjectByName( name );\n\t},\n\trenderDepth: function ( value ) {\n\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t},\n\ttranslate: function ( distance, axis ) {\n\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\treturn this.translateOnAxis( axis, distance );\n\t}\n} );\n\nObject.defineProperties( THREE.Object3D.prototype, {\n\teulerOrder: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\treturn this.rotation.order;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\tthis.rotation.order = value;\n\t\t}\n\t},\n\tuseQuaternion: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.LOD.prototype, {\n\tobjects: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\treturn this.levels;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\tthis.setFocalLength( focalLength );\n\n};\n\n//\n\nObject.defineProperties( THREE.Light.prototype, {\n\tonlyShadow: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t}\n\t},\n\tshadowCameraFov: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\tthis.shadow.camera.fov = value;\n\t\t}\n\t},\n\tshadowCameraLeft: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\tthis.shadow.camera.left = value;\n\t\t}\n\t},\n\tshadowCameraRight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\tthis.shadow.camera.right = value;\n\t\t}\n\t},\n\tshadowCameraTop: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\tthis.shadow.camera.top = value;\n\t\t}\n\t},\n\tshadowCameraBottom: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\tthis.shadow.camera.bottom = value;\n\t\t}\n\t},\n\tshadowCameraNear: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\tthis.shadow.camera.near = value;\n\t\t}\n\t},\n\tshadowCameraFar: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\tthis.shadow.camera.far = value;\n\t\t}\n\t},\n\tshadowCameraVisible: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t}\n\t},\n\tshadowBias: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\tthis.shadow.bias = value;\n\t\t}\n\t},\n\tshadowDarkness: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t}\n\t},\n\tshadowMapWidth: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\tthis.shadow.mapSize.width = value;\n\t\t}\n\t},\n\tshadowMapHeight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\tthis.shadow.mapSize.height = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.BufferAttribute.prototype, {\n\tlength: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\treturn this.array.length;\n\t\t}\n\t}\n} );\n\nObject.assign( THREE.BufferGeometry.prototype, {\n\taddIndex: function ( index ) {\n\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\tthis.setIndex( index );\n\t},\n\taddDrawCall: function ( start, count, indexOffset ) {\n\t\tif ( indexOffset !== undefined ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t}\n\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\tthis.addGroup( start, count );\n\t},\n\tclearDrawCalls: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\tthis.clearGroups();\n\t},\n\tcomputeTangents: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t},\n\tcomputeOffsets: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.BufferGeometry.prototype, {\n\tdrawcalls: {\n\t\tget: function () {\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t},\n\toffsets: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.Material.prototype, {\n\twrapAround: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t}\n\t},\n\twrapRGB: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\treturn new THREE.Color();\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\n\tmetal: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\treturn false;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.ShaderMaterial.prototype, {\n\tderivatives: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\treturn this.extensions.derivatives;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\tthis.extensions.derivatives = value;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.EventDispatcher.prototype = Object.assign( Object.create( {\n\n\t// Note: Extra base ensures these properties are not 'assign'ed.\n\n\tconstructor: THREE.EventDispatcher,\n\n\tapply: function ( target ) {\n\n\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\n\t\tObject.assign( target, this );\n\n\t}\n\n} ), THREE.EventDispatcher.prototype );\n\n//\n\nObject.assign( THREE.WebGLRenderer.prototype, {\n\tsupportsFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_float' );\n\t},\n\tsupportsHalfFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t},\n\tsupportsStandardDerivatives: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t},\n\tsupportsCompressedTextureS3TC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t},\n\tsupportsCompressedTexturePVRTC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t},\n\tsupportsBlendMinMax: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t},\n\tsupportsVertexTextures: function () {\n\t\treturn this.capabilities.vertexTextures;\n\t},\n\tsupportsInstancedArrays: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t},\n\tenableScissorTest: function ( boolean ) {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\tthis.setScissorTest( boolean );\n\t},\n\tinitMaterial: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t},\n\taddPrePlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t},\n\taddPostPlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t},\n\tupdateShadowMap: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLRenderer.prototype, {\n\tshadowMapEnabled: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.enabled;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\tthis.shadowMap.enabled = value;\n\t\t}\n\t},\n\tshadowMapType: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\tthis.shadowMap.type = value;\n\t\t}\n\t},\n\tshadowMapCullFace: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.cullFace;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\tthis.shadowMap.cullFace = value;\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLShadowMap.prototype, {\n\tcullFace: {\n\t\tget: function () {\n\t\t\treturn this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;\n\t\t},\n\t\tset: function ( cullFace ) {\n\t\t\tvar value = ( cullFace !== THREE.CullFaceBack );\n\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\tthis.renderReverseSided = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\n\twrapS: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\treturn this.texture.wrapS;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\tthis.texture.wrapS = value;\n\t\t}\n\t},\n\twrapT: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\treturn this.texture.wrapT;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\tthis.texture.wrapT = value;\n\t\t}\n\t},\n\tmagFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\treturn this.texture.magFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\tthis.texture.magFilter = value;\n\t\t}\n\t},\n\tminFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\treturn this.texture.minFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\tthis.texture.minFilter = value;\n\t\t}\n\t},\n\tanisotropy: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\treturn this.texture.anisotropy;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\tthis.texture.anisotropy = value;\n\t\t}\n\t},\n\toffset: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\treturn this.texture.offset;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\tthis.texture.offset = value;\n\t\t}\n\t},\n\trepeat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\treturn this.texture.repeat;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\tthis.texture.repeat = value;\n\t\t}\n\t},\n\tformat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\treturn this.texture.format;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\tthis.texture.format = value;\n\t\t}\n\t},\n\ttype: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\treturn this.texture.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\tthis.texture.type = value;\n\t\t}\n\t},\n\tgenerateMipmaps: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\treturn this.texture.generateMipmaps;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\tthis.texture.generateMipmaps = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.assign( THREE.Audio.prototype, {\n\tload: function ( file ) {\n\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\tvar scope = this;\n\t\tvar audioLoader = new THREE.AudioLoader();\n\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\tscope.setBuffer( buffer );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\tgetData: function ( file ) {\n\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\treturn this.getFrequencyData();\n\t}\n} );\n\n//\n\nTHREE.GeometryUtils = {\n\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\tvar matrix;\n\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\n\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\tmatrix = geometry2.matrix;\n\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t}\n\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t},\n\n\tcenter: function ( geometry ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\treturn geometry.center();\n\n\t}\n\n};\n\nTHREE.ImageUtils = {\n\n\tcrossOrigin: undefined,\n\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\tvar loader = new THREE.TextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\tvar loader = new THREE.CubeTextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTexture: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t},\n\n\tloadCompressedTextureCube: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t}\n\n};\n\n//\n\nTHREE.Projector = function () {\n\n\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\tvector.project( camera );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\tvector.unproject( camera );\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t};\n\n};\n\n//\n\nTHREE.CanvasRenderer = function () {\n\n\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\tthis.clear = function () {};\n\tthis.render = function () {};\n\tthis.setClearColor = function () {};\n\tthis.setSize = function () {};\n\n};\n\n// File:src/extras/CurveUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.CurveUtils = {\n\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t},\n\n\t// Puay Bing, thanks for helping with this derivative!\n\n\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\n\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t3 * t * t * p3;\n\n\t},\n\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t// To check if my formulas are correct\n\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\n\t\treturn h00 + h10 + h01 + h11;\n\n\t},\n\n\t// Catmull-Rom\n\n\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\tvar t2 = t * t;\n\t\tvar t3 = t * t2;\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/extras/SceneUtils.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\tvar group = new THREE.Group();\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t},\n\n\tdetach: function ( child, parent, scene ) {\n\n\t\tchild.applyMatrix( parent.matrixWorld );\n\t\tparent.remove( child );\n\t\tscene.add( child );\n\n\t},\n\n\tattach: function ( child, scene, parent ) {\n\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\tscene.remove( child );\n\t\tparent.add( child );\n\n\t}\n\n};\n\n// File:src/extras/ShapeUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.ShapeUtils = {\n\n\t// calculate area of the contour polygon\n\n\tarea: function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t},\n\n\ttriangulate: ( function () {\n\n\t\t/**\n\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t * See original code and more information here:\n\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t *\n\t\t * ported to actionscript by Zevan Rosser\n\t\t * www.actionsnippet.com\n\t\t *\n\t\t * ported to javascript by Joshua Koo\n\t\t * http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t */\n\n\t\tfunction snip( contour, u, v, w, n, verts ) {\n\n\t\t\tvar p;\n\t\t\tvar ax, ay, bx, by;\n\t\t\tvar cx, cy, px, py;\n\n\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\tay = contour[ verts[ u ] ].y;\n\n\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\tby = contour[ verts[ v ] ].y;\n\n\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\tcy = contour[ verts[ w ] ].y;\n\n\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\n\n\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\tcX = bx - ax;  cY = by - ay;\n\n\t\t\tfor ( p = 0; p < n; p ++ ) {\n\n\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\tpy = contour[ verts[ p ] ].y;\n\n\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\n\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t\t// see if p is inside triangle abc\n\n\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\n\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// takes in an contour array and returns\n\n\t\treturn function triangulate( contour, indices ) {\n\n\t\t\tvar n = contour.length;\n\n\t\t\tif ( n < 3 ) return null;\n\n\t\t\tvar result = [],\n\t\t\t\tverts = [],\n\t\t\t\tvertIndices = [];\n\n\t\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\t\tvar u, v, w;\n\n\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t\t}\n\n\t\t\tvar nv = n;\n\n\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\t\tvar count = 2 * nv;   /* error detection */\n\n\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\n\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\t\tif ( ( count -- ) <= 0 ) {\n\n\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t//return null;\n\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\treturn result;\n\n\t\t\t\t}\n\n\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t\t/* true names of the vertices */\n\n\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\tc = verts[ w ];\n\n\t\t\t\t\t/* output Triangle */\n\n\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnv --;\n\n\t\t\t\t\t/* reset error detection counter */\n\n\t\t\t\t\tcount = 2 * nv;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( indices ) return vertIndices;\n\t\t\treturn result;\n\n\t\t}\n\n\t} )(),\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\n\t\t\t\t// not parallel\n\n\t\t\t\tvar perpSeg2;\n\t\t\t\tif ( limit > 0 ) {\n\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\n\t\t\t\t}\n\n\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\tif ( perpSeg2 === 0 ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\tif ( perpSeg2 === limit ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt2 ];\n\n\t\t\t\t}\n\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\n\t\t\t\t// return real intersection point\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n\t\t\t} else {\n\n\t\t\t\t// parallel or collinear\n\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\n\t\t\t\t// they are collinear or degenerate\n\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t// both segments are points\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\n\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\n\t\t\t\t}\n\t\t\t\t// segment#1  is a single point\n\t\t\t\tif ( seg1Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\t// segment#2  is a single point\n\t\t\t\tif ( seg2Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\treturn [ inSeg2Pt1 ];\n\n\t\t\t\t}\n\n\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\tif ( seg1dx !== 0 ) {\n\n\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg2min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg1min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n\t\t\t// The order of legs is important\n\n\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n\t\t\t\t// angle != 180 deg.\n\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n\t\t\t\tif ( from2toAngle > 0 ) {\n\n\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// angle == 180 deg.\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\treturn\t( from2otherAngle > 0 );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction removeHoles( contour, holes ) {\n\n\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\tvar hole;\n\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\treturn\ttrue;\n\n\t\t\t}\n\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with shape edges\n\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t}\n\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar indepHoles = [];\n\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with hole edges\n\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\tshapePt, holePt,\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\ttmpHole1, tmpHole2;\n\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tindepHoles.push( h );\n\n\t\t\t}\n\n\t\t\tvar minShapeIndex = 0;\n\t\t\tvar counter = indepHoles.length * 2;\n\t\t\twhile ( indepHoles.length > 0 ) {\n\n\t\t\t\tcounter --;\n\t\t\t\tif ( counter < 0 ) {\n\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t// which can be connected without intersections\n\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\tholeIndex\t= - 1;\n\n\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\n\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\n\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\n\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\n\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn shape; \t\t\t/* shape with no holes */\n\n\t\t}\n\n\n\t\tvar i, il, f, face,\n\t\t\tkey, index,\n\t\t\tallPointsMap = {};\n\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\tvar allpoints = contour.concat();\n\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\n\t\t}\n\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\t// prepare all points map\n\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\n\n\t\t\t}\n\n\t\t\tallPointsMap[ key ] = i;\n\n\t\t}\n\n\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\n\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t//console.log( \"triangles\",triangles, triangles.length );\n\n\t\t// check all face vertices against all points map\n\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\tface = triangles[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangles.concat();\n\n\t},\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn THREE.ShapeUtils.area( pts ) < 0;\n\n\t},\n\n\t// Bezier Curves formulas obtained from\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t// Quad Bezier Functions\n\n\tb2: ( function () {\n\n\t\tfunction b2p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * p;\n\n\t\t}\n\n\t\tfunction b2p1( t, p ) {\n\n\t\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t\t}\n\n\t\tfunction b2p2( t, p ) {\n\n\t\t\treturn t * t * p;\n\n\t\t}\n\n\t\treturn function b2( t, p0, p1, p2 ) {\n\n\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\n\t\t};\n\n\t} )(),\n\n\t// Cubic Bezier Functions\n\n\tb3: ( function () {\n\n\t\tfunction b3p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * k * p;\n\n\t\t}\n\n\t\tfunction b3p1( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * k * t * p;\n\n\t\t}\n\n\t\tfunction b3p2( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * t * t * p;\n\n\t\t}\n\n\t\tfunction b3p3( t, p ) {\n\n\t\t\treturn t * t * t * p;\n\n\t\t}\n\n\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\n\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\n\t\t};\n\n\t} )()\n\n};\n\n// File:src/extras/core/Curve.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of Curve methods\n * .getPoint(t), getTangent(t)\n * .getPointAt(u), getTagentAt(u)\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following classes subclasses THREE.Curve:\n *\n * -- 2d classes --\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.CubicBezierCurve\n * THREE.SplineCurve\n * THREE.ArcCurve\n * THREE.EllipseCurve\n *\n * -- 3d classes --\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n * THREE.CubicBezierCurve3\n * THREE.SplineCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nTHREE.Curve = function () {\n\n};\n\nTHREE.Curve.prototype = {\n\n\tconstructor: THREE.Curve,\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint: function ( t ) {\n\n\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\treturn null;\n\n\t},\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t );\n\n\t},\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar d, pts = [];\n\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpts.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn pts;\n\n\t},\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar d, pts = [];\n\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpts.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn pts;\n\n\t},\n\n\t// Get total curve arc length\n\n\tgetLength: function () {\n\n\t\tvar lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t},\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n\t\tif ( this.cacheArcLengths\n\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t&& ! this.needsUpdate ) {\n\n\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tvar cache = [];\n\t\tvar current, last = this.getPoint( 0 );\n\t\tvar p, sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n\t},\n\n\tupdateArcLengths: function() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping: function ( u, distance ) {\n\n\t\tvar arcLengths = this.getLengths();\n\n\t\tvar i = 0, il = arcLengths.length;\n\n\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t//var time = Date.now();\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tvar low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\t//console.log('b' , i, low, high, Date.now()- time);\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\tvar t = i / ( il - 1 );\n\t\t\treturn t;\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tvar lengthBefore = arcLengths[ i ];\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t},\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent: function( t ) {\n\n\t\tvar delta = 0.0001;\n\t\tvar t1 = t - delta;\n\t\tvar t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tvar pt1 = this.getPoint( t1 );\n\t\tvar pt2 = this.getPoint( t2 );\n\n\t\tvar vec = pt2.clone().sub( pt1 );\n\t\treturn vec.normalize();\n\n\t},\n\n\tgetTangentAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t );\n\n\t}\n\n};\n\n// TODO: Transformation for Curves?\n\n/**************************************************************\n *\t3D Curves\n **************************************************************/\n\n// A Factory method for creating new curve subclasses\n\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\tconstructor.prototype.constructor = constructor;\n\tconstructor.prototype.getPoint = getPointFunc;\n\n\treturn constructor;\n\n};\n\n// File:src/extras/core/CurvePath.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nTHREE.CurvePath = function () {\n\n\tthis.curves = [];\n\n\tthis.autoClose = false; // Automatically closes the path\n\n};\n\nTHREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {\n\n\tconstructor: THREE.CurvePath,\n\n\tadd: function ( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t},\n\n\tclosePath: function () {\n\n\t\t// TODO Test\n\t\t// and verify for vector3 (needs to implement equals)\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\n\n\t\t}\n\n\t},\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint: function ( t ) {\n\n\t\tvar d = t * this.getLength();\n\t\tvar curveLengths = this.getCurveLengths();\n\t\tvar i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\tvar u = 1 - diff / curve.getLength();\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t},\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength: function () {\n\n\t\tvar lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t},\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths: function () {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tvar lengths = [], sums = 0;\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t},\n\n\t/**************************************************************\n\t *\tCreate Geometries Helpers\n\t **************************************************************/\n\n\t/// Generate geometry from path points (for Line or Points objects)\n\n\tcreatePointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\t// Generate geometry from equidistant sampling along the path\n\n\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getSpacedPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\tcreateGeometry: function ( points ) {\n\n\t\tvar geometry = new THREE.Geometry();\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/extras/core/Font.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Font = function ( data ) {\n\n\tthis.data = data;\n\n};\n\nObject.assign( THREE.Font.prototype, {\n\n\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\tfunction createPaths( text ) {\n\n\t\t\tvar chars = String( text ).split( '' );\n\t\t\tvar scale = size / data.resolution;\n\t\t\tvar offset = 0;\n\n\t\t\tvar paths = [];\n\n\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\toffset += ret.offset;\n\n\t\t\t\tpaths.push( ret.path );\n\n\t\t\t}\n\n\t\t\treturn paths;\n\n\t\t}\n\n\t\tfunction createPath( c, scale, offset ) {\n\n\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n\t\t\tif ( ! glyph ) return;\n\n\t\t\tvar path = new THREE.Path();\n\n\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\n\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n\t\t\tif ( glyph.o ) {\n\n\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn { offset: glyph.ha * scale, path: path };\n\n\t\t}\n\n\t\t//\n\n\t\tif ( size === undefined ) size = 100;\n\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\tvar data = this.data;\n\n\t\tvar paths = createPaths( text );\n\t\tvar shapes = [];\n\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n// File:src/extras/core/Path.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n *\n **/\n\nTHREE.Path = function ( points ) {\n\n\tTHREE.CurvePath.call( this );\n\n\tthis.actions = [];\n\n\tif ( points ) {\n\n\t\tthis.fromPoints( points );\n\n\t}\n\n};\n\nTHREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {\n\n\tconstructor: THREE.Path,\n\n\t// TODO Clean up PATH API\n\n\t// Create path using straight lines to connect all points\n\t// - vectors: array of Vector2\n\n\tfromPoints: function ( vectors ) {\n\n\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n\t\t}\n\n\t},\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.QuadraticBezierCurve(\n\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.CubicBezierCurve(\n\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\n\n\t},\n\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\tvar args = Array.prototype.slice.call( arguments );\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\n\t\tArray.prototype.push.apply( npts, pts );\n\n\t\tvar curve = new THREE.SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = pts[ pts.length - 1 ];\n\t\targs.push( lastPoint.x );\n\t\targs.push( lastPoint.y );\n\n\t\tthis.actions.push( { action: 'splineThru', args: args } );\n\n\t},\n\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t},\n\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar args = [\n\t\t\taX, aY,\n\t\t\txRadius, yRadius,\n\t\t\taStartAngle, aEndAngle,\n\t\t\taClockwise,\n\t\t\taRotation || 0 // aRotation is optional.\n\t\t];\n\n\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = curve.getPoint( 1 );\n\t\targs.push( lastPoint.x );\n\t\targs.push( lastPoint.y );\n\n\t\tthis.actions.push( { action: 'ellipse', args: args } );\n\n\t},\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 40;\n\n\t\tvar points = [];\n\n\t\tfor ( var i = 0; i < divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tgetPoints: function ( divisions ) {\n\n\t\tdivisions = divisions || 12;\n\n\t\tvar b2 = THREE.ShapeUtils.b2;\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\n\t\tvar points = [];\n\n\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\n\t\t\tlaste, tx, ty;\n\n\t\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\n\n\t\t\tvar item = this.actions[ i ];\n\n\t\t\tvar action = item.action;\n\t\t\tvar args = item.args;\n\n\t\t\tswitch ( action ) {\n\n\t\t\tcase 'moveTo':\n\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'lineTo':\n\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'quadraticCurveTo':\n\n\t\t\t\tcpx  = args[ 2 ];\n\t\t\t\tcpy  = args[ 3 ];\n\n\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\tcpy1 = args[ 1 ];\n\n\t\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / divisions;\n\n\t\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\n\t\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'bezierCurveTo':\n\n\t\t\t\tcpx  = args[ 4 ];\n\t\t\t\tcpy  = args[ 5 ];\n\n\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\tcpy1 = args[ 1 ];\n\n\t\t\t\tcpx2 = args[ 2 ];\n\t\t\t\tcpy2 = args[ 3 ];\n\n\t\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t\t}\n\n\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / divisions;\n\n\t\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'splineThru':\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\n\t\t\t\tvar spts = [ last ];\n\n\t\t\t\tvar n = divisions * args[ 0 ].length;\n\n\t\t\t\tspts = spts.concat( args[ 0 ] );\n\n\t\t\t\tvar spline = new THREE.SplineCurve( spts );\n\n\t\t\t\tfor ( var j = 1; j <= n; j ++ ) {\n\n\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'arc':\n\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\taRadius = args[ 2 ],\n\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\n\t\t\t\t\taClockwise = !! args[ 5 ];\n\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\tvar angle;\n\t\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / tdivisions;\n\n\t\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\n\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\n\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\t//console.log(points);\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ellipse':\n\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\txRadius = args[ 2 ],\n\t\t\t\t\tyRadius = args[ 3 ],\n\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\n\t\t\t\t\taClockwise = !! args[ 6 ],\n\t\t\t\t\taRotation = args[ 7 ];\n\n\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\tvar angle;\n\t\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\t\tvar cos, sin;\n\t\t\t\tif ( aRotation !== 0 ) {\n\n\t\t\t\t\tcos = Math.cos( aRotation );\n\t\t\t\t\tsin = Math.sin( aRotation );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / tdivisions;\n\n\t\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\n\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\n\n\t\t\t\t\tif ( aRotation !== 0 ) {\n\n\t\t\t\t\t\tvar x = tx, y = ty;\n\n\t\t\t\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\n\t\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\t//console.log(points);\n\n\t\t\t\tbreak;\n\n\t\t\t} // end switch\n\n\t\t}\n\n\n\n\t\t// Normalize to remove the closing point by default.\n\t\tvar lastPoint = points[ points.length - 1 ];\n\t\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\n\t\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\n\t\t\tpoints.splice( points.length - 1, 1 );\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\tfunction extractSubpaths( inActions ) {\n\n\t\t\tvar subPaths = [], lastPath = new THREE.Path();\n\n\t\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\n\n\t\t\t\tvar item = inActions[ i ];\n\n\t\t\t\tvar args = item.args;\n\t\t\t\tvar action = item.action;\n\n\t\t\t\tif ( action === 'moveTo' ) {\n\n\t\t\t\t\tif ( lastPath.actions.length !== 0 ) {\n\n\t\t\t\t\t\tsubPaths.push( lastPath );\n\t\t\t\t\t\tlastPath = new THREE.Path();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlastPath[ action ].apply( lastPath, args );\n\n\t\t\t}\n\n\t\t\tif ( lastPath.actions.length !== 0 ) {\n\n\t\t\t\tsubPaths.push( lastPath );\n\n\t\t\t}\n\n\t\t\t// console.log(subPaths);\n\n\t\t\treturn\tsubPaths;\n\n\t\t}\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\tvar tmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\t//console.log(\"shape\", shapes);\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tvar inside = false;\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\n\n\t\tvar subPaths = extractSubpaths( this.actions );\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new THREE.Shape();\n\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tvar betterShapeHoles = [];\n\t\tvar newShapes = [];\n\t\tvar newShapeHoles = [];\n\t\tvar mainIdx = 0;\n\t\tvar tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tvar ambiguous = false;\n\t\t\tvar toChange = [];\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmpHoles;\n\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n// File:src/extras/core/Shape.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nTHREE.Shape = function () {\n\n\tTHREE.Path.apply( this, arguments );\n\n\tthis.holes = [];\n\n};\n\nTHREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {\n\n\tconstructor: THREE.Shape,\n\n\t// Convenience method to return ExtrudeGeometry\n\n\textrude: function ( options ) {\n\n\t\treturn new THREE.ExtrudeGeometry( this, options );\n\n\t},\n\n\t// Convenience method to return ShapeGeometry\n\n\tmakeGeometry: function ( options ) {\n\n\t\treturn new THREE.ShapeGeometry( this, options );\n\n\t},\n\n\tgetPointsHoles: function ( divisions ) {\n\n\t\tvar holesPts = [];\n\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t},\n\n\t// Get points of shape and holes (keypoints based on segments parameter)\n\n\textractAllPoints: function ( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t},\n\n\textractPoints: function ( divisions ) {\n\n\t\treturn this.extractAllPoints( divisions );\n\n\t}\n\n} );\n\n// File:src/extras/curves/LineCurve.js\n\n/**************************************************************\n *\tLine\n **************************************************************/\n\nTHREE.LineCurve = function ( v1, v2 ) {\n\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\n\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\n\tvar point = this.v2.clone().sub( this.v1 );\n\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\n\treturn this.getPoint( u );\n\n};\n\nTHREE.LineCurve.prototype.getTangent = function( t ) {\n\n\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\treturn tangent.normalize();\n\n};\n\n// File:src/extras/curves/QuadraticBezierCurve.js\n\n/**************************************************************\n *\tQuadratic Bezier curve\n **************************************************************/\n\n\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\n\n\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b2 = THREE.ShapeUtils.b2;\n\n\treturn new THREE.Vector2(\n\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t);\n\n};\n\n\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\n\n\treturn new THREE.Vector2(\n\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/CubicBezierCurve.js\n\n/**************************************************************\n *\tCubic Bezier curve\n **************************************************************/\n\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\tthis.v3 = v3;\n\n};\n\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\n\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b3 = THREE.ShapeUtils.b3;\n\n\treturn new THREE.Vector2( \n\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t);\n\n};\n\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\n\n\treturn new THREE.Vector2( \n\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/SplineCurve.js\n\n/**************************************************************\n *\tSpline curve\n **************************************************************/\n\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\n\tthis.points = ( points == undefined ) ? [] : points;\n\n};\n\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\n\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\n\tvar points = this.points;\n\tvar point = ( points.length - 1 ) * t;\n\n\tvar intPoint = Math.floor( point );\n\tvar weight = point - intPoint;\n\n\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\tvar point1 = points[ intPoint ];\n\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\treturn new THREE.Vector2(\n\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t);\n\n};\n\n// File:src/extras/curves/EllipseCurve.js\n\n/**************************************************************\n *\tEllipse curve\n **************************************************************/\n\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\tthis.aX = aX;\n\tthis.aY = aY;\n\n\tthis.xRadius = xRadius;\n\tthis.yRadius = yRadius;\n\n\tthis.aStartAngle = aStartAngle;\n\tthis.aEndAngle = aEndAngle;\n\n\tthis.aClockwise = aClockwise;\n\t\n\tthis.aRotation = aRotation || 0;\n\n};\n\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\n\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\n\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\n\n\tvar angle;\n\n\tif ( this.aClockwise === true ) {\n\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\n\n\t} else {\n\n\t\tangle = this.aStartAngle + t * deltaAngle;\n\n\t}\n\t\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\tif ( this.aRotation !== 0 ) {\n\n\t\tvar cos = Math.cos( this.aRotation );\n\t\tvar sin = Math.sin( this.aRotation );\n\n\t\tvar tx = x, ty = y;\n\n\t\t// Rotate the point about the center of the ellipse.\n\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\n\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\n\n\t}\n\n\treturn new THREE.Vector2( x, y );\n\n};\n\n// File:src/extras/curves/ArcCurve.js\n\n/**************************************************************\n *\tArc curve\n **************************************************************/\n\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n};\n\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\n\n// File:src/extras/curves/LineCurve3.js\n\n/**************************************************************\n *\tLine3D\n **************************************************************/\n\nTHREE.LineCurve3 = THREE.Curve.create(\n\n\tfunction ( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\tvector.multiplyScalar( t );\n\t\tvector.add( this.v1 );\n\n\t\treturn vector;\n\n\t}\n\n);\n\n// File:src/extras/curves/QuadraticBezierCurve3.js\n\n/**************************************************************\n *\tQuadratic Bezier 3D curve\n **************************************************************/\n\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\n\n\t\treturn new THREE.Vector3(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CubicBezierCurve3.js\n\n/**************************************************************\n *\tCubic Bezier 3D curve\n **************************************************************/\n\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\n\t\treturn new THREE.Vector3(\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/SplineCurve3.js\n\n/**************************************************************\n *\tSpline 3D curve\n **************************************************************/\n\n\nTHREE.SplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */ ) {\n\n\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\tthis.points = ( points == undefined ) ? [] : points;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\t\treturn new THREE.Vector3(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CatmullRomCurve3.js\n\n/**\n * @author zz85 https://github.com/zz85\n *\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\nTHREE.CatmullRomCurve3 = ( function() {\n\n\tvar\n\t\ttmp = new THREE.Vector3(),\n\t\tpx = new CubicPoly(),\n\t\tpy = new CubicPoly(),\n\t\tpz = new CubicPoly();\n\n\t/*\n\tBased on an optimized c++ solution in\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t - http://ideone.com/NoEbVM\n\n\tThis CubicPoly class could be used for reusing some variables and calculations,\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\twhich can be placed in CurveUtils.\n\t*/\n\n\tfunction CubicPoly() {\n\n\t}\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\n\t\tthis.c0 = x0;\n\t\tthis.c1 = t0;\n\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t};\n\n\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t// compute tangents when parameterized in [t1,t2]\n\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t// rescale tangents for parametrization in [0,1]\n\t\tt1 *= dt1;\n\t\tt2 *= dt1;\n\n\t\t// initCubicPoly\n\t\tthis.init( x1, x2, t1, t2 );\n\n\t};\n\n\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\n\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t};\n\n\tCubicPoly.prototype.calc = function( t ) {\n\n\t\tvar t2 = t * t;\n\t\tvar t3 = t2 * t;\n\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\n\t};\n\n\t// Subclass Three.js curve\n\treturn THREE.Curve.create(\n\n\t\tfunction ( p /* array of Vector3 */ ) {\n\n\t\t\tthis.points = p || [];\n\t\t\tthis.closed = false;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar points = this.points,\n\t\t\t\tpoint, intPoint, weight, l;\n\n\t\t\tl = points.length;\n\n\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tif ( this.closed ) {\n\n\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\t\tintPoint = l - 2;\n\t\t\t\tweight = 1;\n\n\t\t\t}\n\n\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate first point\n\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\tp0 = tmp;\n\n\t\t\t}\n\n\t\t\tp1 = points[ intPoint % l ];\n\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate last point\n\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\tp3 = tmp;\n\n\t\t\t}\n\n\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t\t// safety check for repeated points\n\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t\t} else if ( this.type === 'catmullrom' ) {\n\n\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n\t\t\t}\n\n\t\t\tvar v = new THREE.Vector3(\n\t\t\t\tpx.calc( weight ),\n\t\t\t\tpy.calc( weight ),\n\t\t\t\tpz.calc( weight )\n\t\t\t);\n\n\t\t\treturn v;\n\n\t\t}\n\n\t);\n\n} )();\n\n// File:src/extras/curves/ClosedSplineCurve3.js\n\n/**************************************************************\n *\tClosed Spline 3D curve\n **************************************************************/\n\n\nTHREE.ClosedSplineCurve3 = function ( points ) {\n\n\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\n\tTHREE.CatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\tthis.closed = true;\n\n};\n\nTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\n\n// File:src/extras/geometries/BoxGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n */\n\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'BoxGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\n\nTHREE.CubeGeometry = THREE.BoxGeometry;\n\n// File:src/extras/geometries/BoxBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'BoxBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tvar scope = this;\n\n\t// segments\n\twidthSegments = Math.floor( widthSegments ) || 1;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\tvar numberOfVertices = 0;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// build each side of the box geometry\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\t// helper functions\n\n\tfunction calculateVertexCount ( w, h, d ) {\n\n\t\tvar vertices = 0;\n\n\t\t// calculate the amount of vertices for each side (plane)\n\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\n\t\treturn vertices;\n\n\t}\n\n\tfunction calculateIndexCount ( w, h, d ) {\n\n\t\tvar index = 0;\n\n\t\t// calculate the amount of squares for each side\n\t\tindex += w * h * 2; // xy\n\t\tindex += w * d * 2; // xz\n\t\tindex += d * h * 2; // zy\n\n\t\treturn index * 6; // two triangles per square => six vertices per square\n\n\t}\n\n\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\tvar segmentWidth\t= width / gridX;\n\t\tvar segmentHeight = height / gridY;\n\n\t\tvar widthHalf = width / 2;\n\t\tvar heightHalf = height / 2;\n\t\tvar depthHalf = depth / 2;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar vertexCounter = 0;\n\t\tvar groupCount = 0;\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = 0;\n\t\t\t\tvector[ v ] = 0;\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t// now apply vector to normal buffer\n\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// uvs\n\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\t\t\t\tvertexCounter += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 1. you need three indices to draw a single face\n\t\t// 2. a single segment consists of two faces\n\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tindexBufferOffset += 6;\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t\t// update total number of vertices\n\t\tnumberOfVertices += vertexCounter;\n\n\t}\n\n};\n\nTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\n\n// File:src/extras/geometries/CircleGeometry.js\n\n/**\n * @author hughes\n */\n\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CircleGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\n\n// File:src/extras/geometries/CircleBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CircleBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tvar vertices = segments + 2;\n\n\tvar positions = new Float32Array( vertices * 3 );\n\tvar normals = new Float32Array( vertices * 3 );\n\tvar uvs = new Float32Array( vertices * 2 );\n\n\t// center data is already zero, but need to set a few extras\n\tnormals[ 2 ] = 1.0;\n\tuvs[ 0 ] = 0.5;\n\tuvs[ 1 ] = 0.5;\n\n\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\n\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\n\t\tnormals[ i + 2 ] = 1; // normal z\n\n\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var i = 1; i <= segments; i ++ ) {\n\n\t\tindices.push( i, i + 1, 0 );\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\n\n// File:src/extras/geometries/CylinderBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CylinderBufferGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tvar scope = this;\n\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\theight = height !== undefined ? height : 100;\n\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\n\topenEnded = openEnded !== undefined ? openEnded : false;\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n\t// used to calculate buffer length\n\n\tvar nbCap = 0;\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\tif ( radiusBottom > 0 ) nbCap ++;\n\n\t}\n\n\tvar vertexCount = calculateVertexCount();\n\tvar indexCount = calculateIndexCount();\n\n\t// buffers\n\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\n\tvar index = 0,\n\t    indexOffset = 0,\n\t    indexArray = [],\n\t    halfHeight = height / 2;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// generate geometry\n\n\tgenerateTorso();\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// helper functions\n\n\tfunction calculateVertexCount() {\n\n\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction calculateIndexCount() {\n\n\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += radialSegments * nbCap * 3;\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction generateTorso() {\n\n\t\tvar x, y;\n\t\tvar normal = new THREE.Vector3();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\t// this will be used to calculate the normal\n\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar indexRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\t// calculate the radius of the current row\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\n\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormal.copy( vertex );\n\n\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\n\n\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\n\n\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\n\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\n\n\t\t\t\t}\n\n\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\t// save index of vertex in respective row\n\t\t\t\tindexRow.push( index );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// now save vertices of the row in our index array\n\t\t\tindexArray.push( indexRow );\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n\tfunction generateCap( top ) {\n\n\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\tvar uv = new THREE.Vector2();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t// save the index of the first center vertex\n\t\tcenterIndexStart = index;\n\n\t\t// first we generate the center vertex data of the cap.\n\t\t// because the geometry needs one set of uvs per face,\n\t\t// we must generate a center vertex per face/segment\n\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = 0.5;\n\t\t\tuv.y = 0.5;\n\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// save the index of the last center vertex\n\t\tcenterIndexEnd = index;\n\n\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\tvar u = x / radialSegments;\n\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * sinTheta;\n\t\t\tvertex.y = halfHeight * sign;\n\t\t\tvertex.z = radius * cosTheta;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar c = centerIndexStart + x;\n\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\tif ( top === true ) {\n\n\t\t\t\t// face top\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t} else {\n\n\t\t\t\t// face bottom\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t}\n\n\t\t\t// update counters\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n};\n\nTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\n\n// File:src/extras/geometries/CylinderGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CylinderGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\n\n// File:src/extras/geometries/ConeBufferGeometry.js\n\n/*\n * @author: abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeBufferGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderBufferGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;\n\n// File:src/extras/geometries/ConeGeometry.js\n\n/**\n * @author abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );\nTHREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;\n\n// File:src/extras/geometries/EdgesGeometry.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tvar geometry2;\n\n\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tgeometry2 = new THREE.Geometry();\n\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry2 = geometry.clone();\n\n\t}\n\n\tgeometry2.mergeVertices();\n\tgeometry2.computeFaceNormals();\n\n\tvar vertices = geometry2.vertices;\n\tvar faces = geometry2.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\tedge.sort( sortFunction );\n\n\t\t\tvar key = edge.toString();\n\n\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t} else {\n\n\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvar coords = [];\n\n\tfor ( var key in hash ) {\n\n\t\tvar h = hash[ key ];\n\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t}\n\n\t}\n\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\n\n};\n\nTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\n\n// File:src/extras/geometries/ExtrudeGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  amount: <int>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n *\n *  uvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\n\tif ( typeof( shapes ) === \"undefined\" ) {\n\n\t\tshapes = [];\n\t\treturn;\n\n\t}\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ExtrudeGeometry';\n\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n\t// can't really use automatic vertex normals\n\t// as then front and back sides get smoothed too\n\t// should do separate smoothing just for sides\n\n\t//this.computeVertexNormals();\n\n\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n};\n\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\n\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tvar sl = shapes.length;\n\n\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\tvar shape = shapes[ s ];\n\t\tthis.addShape( shape, options );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\tvar extrudePath = options.extrudePath;\n\tvar extrudePts, extrudeByPath = false;\n\n\t// Use default WorldUVGenerator if no UV generators are specified.\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\n\tvar splineTube, binormal, normal, position2;\n\tif ( extrudePath ) {\n\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\textrudeByPath = true;\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t// SETUP TNB variables\n\n\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t// TODO1 - have a .isClosed in spline?\n\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\n\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\tbinormal = new THREE.Vector3();\n\t\tnormal = new THREE.Vector3();\n\t\tposition2 = new THREE.Vector3();\n\n\t}\n\n\t// Safeguards if bevels are not enabled\n\n\tif ( ! bevelEnabled ) {\n\n\t\tbevelSegments = 0;\n\t\tbevelThickness = 0;\n\t\tbevelSize = 0;\n\n\t}\n\n\t// Variables initialization\n\n\tvar ahole, h, hl; // looping of holes\n\tvar scope = this;\n\n\tvar shapesOffset = this.vertices.length;\n\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t}\n\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t/* Vertices */\n\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\tvertices = vertices.concat( ahole );\n\n\t}\n\n\n\tfunction scalePt2 ( pt, vec, size ) {\n\n\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t}\n\n\tvar b, bs, t, z,\n\t\tvert, vlen = vertices.length,\n\t\tface, flen = faces.length;\n\n\n\t// Find directions for point movement\n\n\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t//\n\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\n\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t// check for collinear edges\n\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t// not collinear\n\n\t\t\t// length of vectors for normalizing\n\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t// vector from inPt to intersection point\n\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t//  but prevent crazy spikes\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\n\n\t\t\t} else {\n\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// handle special case of collinear edges\n\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( direction_eq ) {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t} else {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t}\n\n\n\tvar contourMovements = [];\n\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\tif ( j === il ) j = 0;\n\t\tif ( k === il ) k = 0;\n\n\t\t//  (j)---(i)---(k)\n\t\t// console.log('i,j,k', i, j , k)\n\n\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t}\n\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\toneHoleMovements = [];\n\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t}\n\n\t\tholesMovements.push( oneHoleMovements );\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t}\n\n\n\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\n\t\t//z = bevelThickness * t;\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\n\t\t//bs = bevelSize * t; // linear\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbs = bevelSize;\n\n\t// Back facing vertices\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\tif ( ! extrudeByPath ) {\n\n\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t} else {\n\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t}\n\n\t}\n\n\t// Add stepped vertices...\n\t// Including front facing vertices\n\n\tvar s;\n\n\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Add bevel segments planes\n\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Faces */\n\n\t// Top and bottom faces\n\n\tbuildLidFaces();\n\n\t// Sides faces\n\n\tbuildSideFaces();\n\n\n\t/////  Internal functions\n\n\tfunction buildLidFaces() {\n\n\t\tif ( bevelEnabled ) {\n\n\t\t\tvar layer = 0; // steps + 1\n\t\t\tvar offset = vlen * layer;\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t}\n\n\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\toffset = vlen * layer;\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t}\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Create faces for the z-sides of the shape\n\n\tfunction buildSideFaces() {\n\n\t\tvar layeroffset = 0;\n\t\tsidewalls( contour, layeroffset );\n\t\tlayeroffset += contour.length;\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t//, true\n\t\t\tlayeroffset += ahole.length;\n\n\t\t}\n\n\t}\n\n\tfunction sidewalls( contour, layeroffset ) {\n\n\t\tvar j, k;\n\t\ti = contour.length;\n\n\t\twhile ( -- i >= 0 ) {\n\n\t\t\tj = i;\n\t\t\tk = i - 1;\n\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\tfunction v( x, y, z ) {\n\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t}\n\n\tfunction f3( a, b, c ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\n\n\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\n\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\t\td += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\n\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\n\n\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\n\t\treturn [\n\t\t\tnew THREE.Vector2( a.x, a.y ),\n\t\t\tnew THREE.Vector2( b.x, b.y ),\n\t\t\tnew THREE.Vector2( c.x, c.y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\t\tvar d = vertices[ indexD ];\n\n\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\n\t\t\t];\n\n\t\t}\n\n\t}\n};\n\n// File:src/extras/geometries/ShapeGeometry.js\n\n/**\n * @author jonobr1 / http://jonobr1.com\n *\n * Creates a one-sided polygonal geometry from a path shape. Similar to\n * ExtrudeGeometry.\n *\n * parameters = {\n *\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n *\n *\tmaterial: <int> // material index for front and back faces\n *\tuvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ShapeGeometry = function ( shapes, options ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ShapeGeometry';\n\n\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\n\n/**\n * Add an array of shapes to THREE.ShapeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\tthis.addShape( shapes[ i ], options );\n\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tif ( options === undefined ) options = {};\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar material = options.material;\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\t//\n\n\tvar i, l, hole;\n\n\tvar shapesOffset = this.vertices.length;\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\thole = holes[ i ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\n\n\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false;\n\n\t}\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t// Vertices\n\n\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\thole = holes[ i ];\n\t\tvertices = vertices.concat( hole );\n\n\t}\n\n\t//\n\n\tvar vert, vlen = vertices.length;\n\tvar face, flen = faces.length;\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = vertices[ i ];\n\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\n\t}\n\n\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\tface = faces[ i ];\n\n\t\tvar a = face[ 0 ] + shapesOffset;\n\t\tvar b = face[ 1 ] + shapesOffset;\n\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\n\t}\n\n};\n\n// File:src/extras/geometries/LatheBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n // points - to create a closed torus, one must use a set of points\n //    like so: [ a, b, c, d, a ], see first is the same as last.\n // segments - the number of circumference segments to create\n // phiStart - the starting radian\n // phiLength - the radian (0 to 2PI) range of the lathed section\n //    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'LatheBufferGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tsegments = Math.floor( segments ) || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || Math.PI * 2;\n\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( segments + 1 ) * points.length;\n\tvar indexCount = segments * points.length * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar index = 0, indexOffset = 0, base;\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\tvar inverseSegments = 1.0 / segments;\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar i, j;\n\n\t// generate vertices and uvs\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar sin = Math.sin( phi );\n\t\tvar cos = Math.cos( phi );\n\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\tvertex.y = points[ j ].y;\n\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / segments;\n\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\tbase = j + i * points.length;\n\n\t\t\t// indices\n\t\t\tvar a = base;\n\t\t\tvar b = base + points.length;\n\t\t\tvar c = base + points.length + 1;\n\t\t\tvar d = base + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// generate normals\n\n\tthis.computeVertexNormals();\n\n\t// if the geometry is closed, we need to average the normals along the seam.\n\t// because the corresponding vertices are identical (but still have different UVs).\n\n\tif( phiLength === Math.PI * 2 ) {\n\n\t\tvar normals = this.attributes.normal.array;\n\t\tvar n1 = new THREE.Vector3();\n\t\tvar n2 = new THREE.Vector3();\n\t\tvar n = new THREE.Vector3();\n\n\t\t// this is the buffer offset for the last line of vertices\n\t\tbase = segments * points.length * 3;\n\n\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t// select the normal of the vertex in the first line\n\t\t\tn1.x = normals[ j + 0 ];\n\t\t\tn1.y = normals[ j + 1 ];\n\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t// select the normal of the vertex in the last line\n\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t// average normals\n\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t// assign the new values to both normals\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t} // next row\n\n\t}\n\n};\n\nTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\n\n// File:src/extras/geometries/LatheGeometry.js\n\n/**\n * @author astrodud / http://astrodud.isgreat.org/\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n */\n\n// points - to create a closed torus, one must use a set of points\n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2PI) range of the lathed section\n//    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'LatheGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\n\n// File:src/extras/geometries/PlaneGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PlaneGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n};\n\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\n\n// File:src/extras/geometries/PlaneBufferGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'PlaneBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tvar width_half = width / 2;\n\tvar height_half = height / 2;\n\n\tvar gridX = Math.floor( widthSegments ) || 1;\n\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\tvar gridX1 = gridX + 1;\n\tvar gridY1 = gridY + 1;\n\n\tvar segment_width = width / gridX;\n\tvar segment_height = height / gridY;\n\n\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\n\tvar offset = 0;\n\tvar offset2 = 0;\n\n\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\tvar y = iy * segment_height - height_half;\n\n\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\tvertices[ offset ] = x;\n\t\t\tvertices[ offset + 1 ] = - y;\n\n\t\t\tnormals[ offset + 2 ] = 1;\n\n\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\n\t\t\toffset += 3;\n\t\t\toffset2 += 2;\n\n\t\t}\n\n\t}\n\n\toffset = 0;\n\n\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\n\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\n\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iy;\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\tindices[ offset ] = a;\n\t\t\tindices[ offset + 1 ] = b;\n\t\t\tindices[ offset + 2 ] = d;\n\n\t\t\tindices[ offset + 3 ] = b;\n\t\t\tindices[ offset + 4 ] = c;\n\t\t\tindices[ offset + 5 ] = d;\n\n\t\t\toffset += 6;\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\n\n// File:src/extras/geometries/RingBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'RingBufferGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tinnerRadius = innerRadius || 20;\n\touterRadius = outerRadius || 50;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// some helper variables\n\tvar index = 0, indexOffset = 0, segment;\n\tvar radius = innerRadius;\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\t// values are generate from the inside of the ring to the outside\n\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex++;\n\n\t\t}\n\n\t\t// increase the radius for next row of vertices\n\t\tradius += radiusStep;\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t// indices\n\t\t\tvar a = segment;\n\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\tvar d = segment + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n};\n\nTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\n\n// File:src/extras/geometries/RingGeometry.js\n\n/**\n * @author Kaleb Murphy\n */\n\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'RingGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\n\n// File:src/extras/geometries/SphereGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'SphereGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n};\n\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\n\n// File:src/extras/geometries/SphereBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n * based on THREE.SphereGeometry\n */\n\nTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'SphereBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tphiStart = phiStart !== undefined ? phiStart : 0;\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar thetaEnd = thetaStart + thetaLength;\n\n\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\n\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\tvar index = 0, vertices = [], normal = new THREE.Vector3();\n\n\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\n\t\tvar verticesRow = [];\n\n\t\tvar v = y / heightSegments;\n\n\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\tvar u = x / widthSegments;\n\n\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tnormal.set( px, py, pz ).normalize();\n\n\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\tverticesRow.push( index );\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\n\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\n\tthis.addAttribute( 'position', positions );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\n\n// File:src/extras/geometries/TextGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float> // how far from text outline is bevel\n * }\n */\n\nTHREE.TextGeometry = function ( text, parameters ) {\n\n\tparameters = parameters || {};\n\n\tvar font = parameters.font;\n\n\tif ( font instanceof THREE.Font === false ) {\n\n\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\treturn new THREE.Geometry();\n\n\t}\n\n\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\n\n\tthis.type = 'TextGeometry';\n\n};\n\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\n\n// File:src/extras/geometries/TorusBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\tarc = arc || Math.PI * 2;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\n\t// helper variables\n\tvar center = new THREE.Vector3();\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / tubularSegments * arc;\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t// vertex\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\n\t\t\t// this vector is used to calculate the normal\n\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\tcenter.y = radius * Math.sin( u );\n\n\t\t\t// normal\n\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\n\t\t\t// uv\n\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\n\t\t\t// update offsets\n\t\t\tvertexBufferOffset += 3;\n\t\t\tuvBufferOffset += 2;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t// face one\n\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t// face two\n\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t// update offset\n\t\t\tindexBufferOffset += 6;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\n\n// File:src/extras/geometries/TorusGeometry.js\n\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n */\n\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n};\n\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\n\n// File:src/extras/geometries/TorusKnotBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * see: http://www.blackpawn.com/texts/pqtorus/\n */\nTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusKnotBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\tp = p || 2;\n\tq = q || 3;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar i, j, index = 0, indexOffset = 0;\n\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\n\tvar P1 = new THREE.Vector3();\n\tvar P2 = new THREE.Vector3();\n\n\tvar B = new THREE.Vector3();\n\tvar T = new THREE.Vector3();\n\tvar N = new THREE.Vector3();\n\n\t// generate vertices, normals and uvs\n\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t// calculate orthonormal basis\n\n\t\tT.subVectors( P2, P1 );\n\t\tN.addVectors( P2, P1 );\n\t\tB.crossVectors( T, N );\n\t\tN.crossVectors( B, T );\n\n\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\tB.normalize();\n\t\tN.normalize();\n\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t// now calculate the final vertex position.\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / tubularSegments;\n\t\t\tuv.y = j / radialSegments;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// this function calculates the current position on the torus curve\n\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = q / p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t}\n\n};\n\nTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\n\n// File:src/extras/geometries/TorusKnotGeometry.js\n\n/**\n * @author oosmoxiecode\n */\n\nTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusKnotGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\n\n// File:src/extras/geometries/TubeGeometry.js\n\n/**\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n * @author jonobr1 / https://github.com/jonobr1\n *\n * Modified from the TorusKnotGeometry by @oosmoxiecode\n *\n * Creates a tube which extrudes along a 3d spline\n *\n * Uses parallel transport frames as described in\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n */\n\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TubeGeometry';\n\n\tthis.parameters = {\n\t\tpath: path,\n\t\tsegments: segments,\n\t\tradius: radius,\n\t\tradialSegments: radialSegments,\n\t\tclosed: closed,\n\t\ttaper: taper\n\t};\n\n\tsegments = segments || 64;\n\tradius = radius || 1;\n\tradialSegments = radialSegments || 8;\n\tclosed = closed || false;\n\ttaper = taper || THREE.TubeGeometry.NoTaper;\n\n\tvar grid = [];\n\n\tvar scope = this,\n\n\t\ttangent,\n\t\tnormal,\n\t\tbinormal,\n\n\t\tnumpoints = segments + 1,\n\n\t\tu, v, r,\n\n\t\tcx, cy,\n\t\tpos, pos2 = new THREE.Vector3(),\n\t\ti, j,\n\t\tip, jp,\n\t\ta, b, c, d,\n\t\tuva, uvb, uvc, uvd;\n\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\n\t\ttangents = frames.tangents,\n\t\tnormals = frames.normals,\n\t\tbinormals = frames.binormals;\n\n\t// proxy internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\t// construct the grid\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tgrid[ i ] = [];\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\tpos = path.getPointAt( u );\n\n\t\ttangent = tangents[ i ];\n\t\tnormal = normals[ i ];\n\t\tbinormal = binormals[ i ];\n\n\t\tr = radius * taper( u );\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tv = j / radialSegments * 2 * Math.PI;\n\n\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = r * Math.sin( v );\n\n\t\t\tpos2.copy( pos );\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\n\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\n\t\t}\n\n\t}\n\n\n\t// construct the mesh\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\n\t\t\tjp = ( j + 1 ) % radialSegments;\n\n\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\tb = grid[ ip ][ j ];\n\t\t\tc = grid[ ip ][ jp ];\n\t\t\td = grid[ i ][ jp ];\n\n\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\n\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\n\nTHREE.TubeGeometry.NoTaper = function ( u ) {\n\n\treturn 1;\n\n};\n\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\n\n\treturn Math.sin( Math.PI * u );\n\n};\n\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\n\n\tvar\tnormal = new THREE.Vector3(),\n\n\t\ttangents = [],\n\t\tnormals = [],\n\t\tbinormals = [],\n\n\t\tvec = new THREE.Vector3(),\n\t\tmat = new THREE.Matrix4(),\n\n\t\tnumpoints = segments + 1,\n\t\ttheta,\n\t\tsmallest,\n\n\t\ttx, ty, tz,\n\t\ti, u;\n\n\n\t// expose internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\t// compute the tangent vectors for each segment on the path\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\ttangents[ i ] = path.getTangentAt( u );\n\t\ttangents[ i ].normalize();\n\n\t}\n\n\tinitialNormal3();\n\n\t/*\n\tfunction initialNormal1(lastBinormal) {\n\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t}\n\n\tfunction initialNormal2() {\n\n\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\tvar t2 = path.getTangentAt( epsilon );\n\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\n\t}\n\t*/\n\n\tfunction initialNormal3() {\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the smallest tangent xyz component\n\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tsmallest = Number.MAX_VALUE;\n\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\tty = Math.abs( tangents[ 0 ].y );\n\t\ttz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= smallest ) {\n\n\t\t\tsmallest = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= smallest ) {\n\n\t\t\tsmallest = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= smallest ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t}\n\n\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\n\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\tvec.normalize();\n\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t}\n\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t}\n\n\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\tif ( closed ) {\n\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\n\t\ttheta /= ( numpoints - 1 );\n\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\n\n\t\t\ttheta = - theta;\n\n\t\t}\n\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\t\t// twist a little...\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/extras/geometries/PolyhedronGeometry.js\n\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PolyhedronGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\tvar that = this;\n\n\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\n\n\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\n\n\t}\n\n\tvar p = this.vertices;\n\n\tvar faces = [];\n\n\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\n\n\t\tvar v1 = p[ indices[ i ] ];\n\t\tvar v2 = p[ indices[ i + 1 ] ];\n\t\tvar v3 = p[ indices[ i + 2 ] ];\n\n\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\n\t}\n\n\tvar centroid = new THREE.Vector3();\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tsubdivide( faces[ i ], detail );\n\n\t}\n\n\n\t// Handle case when face straddles the seam\n\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\n\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\tvar x0 = uvs[ 0 ].x;\n\t\tvar x1 = uvs[ 1 ].x;\n\t\tvar x2 = uvs[ 2 ].x;\n\n\t\tvar max = Math.max( x0, x1, x2 );\n\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\n\n\t\t}\n\n\t}\n\n\n\t// Apply radius\n\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\tthis.vertices[ i ].multiplyScalar( radius );\n\n\t}\n\n\n\t// Merge vertices\n\n\tthis.mergeVertices();\n\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n\n\t// Project vector onto sphere's surface\n\n\tfunction prepare( vector ) {\n\n\t\tvar vertex = vector.normalize().clone();\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\n\t\treturn vertex;\n\n\t}\n\n\n\t// Approximate a curved face with recursively sub-divided triangles.\n\n\tfunction make( v1, v2, v3 ) {\n\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\tthat.faces.push( face );\n\n\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\n\t\tvar azi = azimuth( centroid );\n\n\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t] );\n\n\t}\n\n\n\t// Analytically subdivide a face to the required detail level.\n\n\tfunction subdivide( face, detail ) {\n\n\t\tvar cols = Math.pow( 2, detail );\n\t\tvar a = prepare( that.vertices[ face.a ] );\n\t\tvar b = prepare( that.vertices[ face.b ] );\n\t\tvar c = prepare( that.vertices[ face.c ] );\n\t\tvar v = [];\n\n\t\t// Construct all of the vertices for this subdivision.\n\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\n\n\t\t\tv[ i ] = [];\n\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\n\t\t\tvar rows = cols - i;\n\n\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\n\n\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Construct all of the faces.\n\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ],\n\t\t\t\t\t\tv[ i ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n\n\t// Texture fixing helper. Spheres have some odd behaviours.\n\n\tfunction correctUV( uv, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\t\treturn uv.clone();\n\n\t}\n\n\n};\n\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\n\n// File:src/extras/geometries/DodecahedronGeometry.js\n\n/**\n * @author Abe Pazos / https://hamoid.com\n */\n\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\tvar r = 1 / t;\n\n\tvar vertices = [\n\n\t\t// (±1, ±1, ±1)\n\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t 1,  1, - 1,     1,  1,  1,\n\n\t\t// (0, ±1/φ, ±φ)\n\t\t 0, - r, - t,     0, - r,  t,\n\t\t 0,  r, - t,     0,  r,  t,\n\n\t\t// (±1/φ, ±φ, 0)\n\t\t- r, - t,  0,    - r,  t,  0,\n\t\t r, - t,  0,     r,  t,  0,\n\n\t\t// (±φ, 0, ±1/φ)\n\t\t- t,  0, - r,     t,  0, - r,\n\t\t- t,  0,  r,     t,  0,  r\n\t];\n\n\tvar indices = [\n\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'DodecahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\n\n// File:src/extras/geometries/IcosahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t];\n\n\tvar indices = [\n\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'IcosahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\n\n// File:src/extras/geometries/OctahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.OctahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t];\n\n\tvar indices = [\n\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'OctahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\n\n// File:src/extras/geometries/TetrahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t];\n\n\tvar indices = [\n\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'TetrahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\n\n// File:src/extras/geometries/ParametricGeometry.js\n\n/**\n * @author zz85 / https://github.com/zz85\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n *\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\n *\n */\n\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ParametricGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\tvar verts = this.vertices;\n\tvar faces = this.faces;\n\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\tvar i, j, p;\n\tvar u, v;\n\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tv = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tu = j / slices;\n\n\t\t\tp = func( u, v );\n\t\t\tverts.push( p );\n\n\t\t}\n\n\t}\n\n\tvar a, b, c, d;\n\tvar uva, uvb, uvc, uvd;\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\ta = i * sliceCount + j;\n\t\t\tb = i * sliceCount + j + 1;\n\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\td = ( i + 1 ) * sliceCount + j;\n\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\n\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\t// console.log(this);\n\n\t// magic bullet\n\t// var diff = this.mergeVertices();\n\t// console.log('removed ', diff, ' vertices by merging');\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\n\n// File:src/extras/geometries/WireframeGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeGeometry = function ( geometry ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\tvar vertices = geometry.vertices;\n\t\tvar faces = geometry.faces;\n\t\tvar numEdges = 0;\n\n\t\t// allocate maximal size\n\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\n\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\t// Indexed BufferGeometry\n\n\t\t\tvar indices = geometry.index.array;\n\t\t\tvar vertices = geometry.attributes.position;\n\t\t\tvar groups = geometry.groups;\n\t\t\tvar numEdges = 0;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t}\n\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\tvar start = group.start;\n\t\t\t\tvar count = group.count;\n\n\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\n\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t} else {\n\n\t\t\t// non-indexed BufferGeometry\n\n\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\tvar numEdges = vertices.length / 3;\n\t\t\tvar numTris = numEdges / 3;\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\n\n// File:src/extras/helpers/AxisHelper.js\n\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AxisHelper = function ( size ) {\n\n\tsize = size || 1;\n\n\tvar vertices = new Float32Array( [\n\t\t0, 0, 0,  size, 0, 0,\n\t\t0, 0, 0,  0, size, 0,\n\t\t0, 0, 0,  0, 0, size\n\t] );\n\n\tvar colors = new Float32Array( [\n\t\t1, 0, 0,  1, 0.6, 0,\n\t\t0, 1, 0,  0.6, 1, 0,\n\t\t0, 0, 1,  0, 0.6, 1\n\t] );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\n\n// File:src/extras/helpers/ArrowHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / http://github.com/zz85\n * @author bhouston / http://clara.io\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  color - color in hex value\n *  headLength - Number\n *  headWidth - Number\n */\n\nTHREE.ArrowHelper = ( function () {\n\n\tvar lineGeometry = new THREE.BufferGeometry();\n\tlineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\tvar coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tTHREE.Object3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\n\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\n\n\tvar axis = new THREE.Vector3();\n\tvar radians;\n\n\treturn function setDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tradians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t}\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\tthis.line.updateMatrix();\n\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\tthis.cone.position.y = length;\n\tthis.cone.updateMatrix();\n\n};\n\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\n\n\tthis.line.material.color.copy( color );\n\tthis.cone.material.color.copy( color );\n\n};\n\n// File:src/extras/helpers/BoxHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BoxHelper = function ( object, color ) {\n\t\n\tif ( color === undefined ) color = 0xffff00;\n\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\tvar positions = new Float32Array( 8 * 3 );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ) );\n\n\tif ( object !== undefined ) {\n\n\t\tthis.update( object );\n\n\t}\n\n};\n\nTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\n\nTHREE.BoxHelper.prototype.update = ( function () {\n\n\tvar box = new THREE.Box3();\n\n\treturn function update( object ) {\n\n\t\tif ( object instanceof THREE.Box3 ) {\n\n\t\t\tbox.copy( object );\n\n\t\t} else {\n\n\t\t\tbox.setFromObject( object );\n\n\t\t}\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tvar min = box.min;\n\t\tvar max = box.max;\n\n\t\t/*\n\t\t  5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tvar position = this.geometry.attributes.position;\n\t\tvar array = position.array;\n\n\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t};\n\n} )();\n\n// File:src/extras/helpers/BoundingBoxHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\n// a helper to show the world-axis-aligned bounding box for an object\n\nTHREE.BoundingBoxHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\tthis.object = object;\n\n\tthis.box = new THREE.Box3();\n\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n};\n\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\n\nTHREE.BoundingBoxHelper.prototype.update = function () {\n\n\tthis.box.setFromObject( this.object );\n\n\tthis.box.size( this.scale );\n\n\tthis.box.center( this.position );\n\n};\n\n// File:src/extras/helpers/CameraHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nTHREE.CameraHelper = function ( camera ) {\n\n\tvar geometry = new THREE.Geometry();\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\n\tvar pointMap = {};\n\n\t// colors\n\n\tvar hexFrustum = 0xffaa00;\n\tvar hexCone = 0xff0000;\n\tvar hexUp = 0x00aaff;\n\tvar hexTarget = 0xffffff;\n\tvar hexCross = 0x333333;\n\n\t// near\n\n\taddLine( \"n1\", \"n2\", hexFrustum );\n\taddLine( \"n2\", \"n4\", hexFrustum );\n\taddLine( \"n4\", \"n3\", hexFrustum );\n\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t// far\n\n\taddLine( \"f1\", \"f2\", hexFrustum );\n\taddLine( \"f2\", \"f4\", hexFrustum );\n\taddLine( \"f4\", \"f3\", hexFrustum );\n\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t// sides\n\n\taddLine( \"n1\", \"f1\", hexFrustum );\n\taddLine( \"n2\", \"f2\", hexFrustum );\n\taddLine( \"n3\", \"f3\", hexFrustum );\n\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t// cone\n\n\taddLine( \"p\", \"n1\", hexCone );\n\taddLine( \"p\", \"n2\", hexCone );\n\taddLine( \"p\", \"n3\", hexCone );\n\taddLine( \"p\", \"n4\", hexCone );\n\n\t// up\n\n\taddLine( \"u1\", \"u2\", hexUp );\n\taddLine( \"u2\", \"u3\", hexUp );\n\taddLine( \"u3\", \"u1\", hexUp );\n\n\t// target\n\n\taddLine( \"c\", \"t\", hexTarget );\n\taddLine( \"p\", \"c\", hexCross );\n\n\t// cross\n\n\taddLine( \"cn1\", \"cn2\", hexCross );\n\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\taddLine( \"cf1\", \"cf2\", hexCross );\n\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\tfunction addLine( a, b, hex ) {\n\n\t\taddPoint( a, hex );\n\t\taddPoint( b, hex );\n\n\t}\n\n\tfunction addPoint( id, hex ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\n\n\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\tpointMap[ id ] = [];\n\n\t\t}\n\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t}\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.camera = camera;\n\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\tthis.matrix = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = pointMap;\n\n\tthis.update();\n\n};\n\nTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\n\nTHREE.CameraHelper.prototype.update = function () {\n\n\tvar geometry, pointMap;\n\n\tvar vector = new THREE.Vector3();\n\tvar camera = new THREE.Camera();\n\n\tfunction setPoint( point, x, y, z ) {\n\n\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\tvar points = pointMap[ point ];\n\n\t\tif ( points !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn function update() {\n\n\t\tgeometry = this.geometry;\n\t\tpointMap = this.pointMap;\n\n\t\tvar w = 1, h = 1;\n\n\t\t// we need just camera projection matrix\n\t\t// world matrix must be identity\n\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t// center / target\n\n\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t// near\n\n\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\tsetPoint( \"f4\",   w,   h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\n\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/DirectionalLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.DirectionalLightHelper = function ( light, size ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tif ( size === undefined ) size = 1;\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [\n\t\t- size,   size, 0,\n\t\t  size,   size, 0,\n\t\t  size, - size, 0,\n\t\t- size, - size, 0,\n\t\t- size,   size, 0\n\t], 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.add( new THREE.Line( geometry, material ) );\n\n\tgeometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\tthis.add( new THREE.Line( geometry, material ));\n\n\tthis.update();\n\n};\n\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\n\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\n\n\tvar lightPlane = this.children[ 0 ];\n\tvar targetLine = this.children[ 1 ];\n\n\tlightPlane.geometry.dispose();\n\tlightPlane.material.dispose();\n\ttargetLine.geometry.dispose();\n\ttargetLine.material.dispose();\n\n};\n\nTHREE.DirectionalLightHelper.prototype.update = function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar v3 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\tv3.subVectors( v2, v1 );\n\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\n\t\tlightPlane.lookAt( v3 );\n\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\ttargetLine.lookAt( v3 );\n\t\ttargetLine.scale.z = v3.length();\n\n\t};\n\n}();\n\n// File:src/extras/helpers/EdgesHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @param object THREE.Mesh whose geometry will be used\n * @param hex line color\n * @param thresholdAngle the minimum angle (in degrees),\n * between the face normals of adjacent faces,\n * that is required to render an edge. A value of 10 means\n * an edge is only rendered if the angle is at least 10 degrees.\n */\n\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\n\n// File:src/extras/helpers/FaceNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\t// FaceNormalsHelper only supports THREE.Geometry\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length;\n\n\t} else {\n\n\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\tthis.update();\n\n};\n\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\n\nTHREE.FaceNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tvar vertices = objGeometry.vertices;\n\n\t\tvar faces = objGeometry.faces;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar normal = face.normal;\n\n\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t.divideScalar( 3 )\n\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/GridHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.GridHelper = function ( size, step, color1, color2 ) {\n\n\tcolor1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );\n\tcolor2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );\n\n\tvar vertices = [];\n\tvar colors = [];\n\n\tfor ( var i = - size, j = 0; i <= size; i += step ) {\n\n\t\tvertices.push( - size, 0, i, size, 0, i );\n\t\tvertices.push( i, 0, - size, i, 0, size );\n\n\t\tvar color = i === 0 ? color1 : color2;\n\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\n\t}\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\n\nTHREE.GridHelper.prototype.setColors = function () {\n\n\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n};\n\n// File:src/extras/helpers/HemisphereLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\n\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\tgeometry.rotateX( - Math.PI / 2 );\n\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t}\n\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\n\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\n\tthis.add( this.lightSphere );\n\n\tthis.update();\n\n};\n\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\n\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\n\n\tthis.lightSphere.geometry.dispose();\n\tthis.lightSphere.material.dispose();\n\n};\n\nTHREE.HemisphereLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/PointLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLightHelper = function ( light, sphereSize ) {\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tvar geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.matrix = this.light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\t/*\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tvar d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n};\n\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\n\nTHREE.PointLightHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n\n};\n\nTHREE.PointLightHelper.prototype.update = function () {\n\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t/*\n\tvar d = this.light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.visible = true;\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\t*/\n\n};\n\n// File:src/extras/helpers/SkeletonHelper.js\n\n/**\n * @author Sean Griffin / http://twitter.com/sgrif\n * @author Michael Guerrero / http://realitymeltdown.com\n * @author mrdoob / http://mrdoob.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkeletonHelper = function ( object ) {\n\n\tthis.bones = this.getBoneList( object );\n\n\tvar geometry = new THREE.Geometry();\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dynamic = true;\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.root = object;\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\n\nTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\n\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\n\n\tvar boneList = [];\n\n\tif ( object instanceof THREE.Bone ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n};\n\nTHREE.SkeletonHelper.prototype.update = function () {\n\n\tvar geometry = this.geometry;\n\n\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\n\n\tvar boneMatrix = new THREE.Matrix4();\n\n\tvar j = 0;\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tj += 2;\n\n\t\t}\n\n\t}\n\n\tgeometry.verticesNeedUpdate = true;\n\n\tgeometry.computeBoundingSphere();\n\n};\n\n// File:src/extras/helpers/SpotLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.SpotLightHelper = function ( light ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = [\n\t\t0, 0, 0,   0,   0,   1,\n\t\t0, 0, 0,   1,   0,   1,\n\t\t0, 0, 0, - 1,   0,   1,\n\t\t0, 0, 0,   0,   1,   1,\n\t\t0, 0, 0,   0, - 1,   1\n\t];\n\n\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\tpositions.push(\n\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t);\n\n\t}\n\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.cone = new THREE.LineSegments( geometry, material );\n\tthis.add( this.cone );\n\n\tthis.update();\n\n};\n\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\n\nTHREE.SpotLightHelper.prototype.dispose = function () {\n\n\tthis.cone.geometry.dispose();\n\tthis.cone.material.dispose();\n\n};\n\nTHREE.SpotLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\tvar vector2 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t};\n\n}();\n\n// File:src/extras/helpers/VertexNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length * 3;\n\n\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\n\nTHREE.VertexNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\tvar idx = 0;\n\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/WireframeHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\n\n// File:src/extras/objects/ImmediateRenderObject.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ImmediateRenderObject = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.material = material;\n\tthis.render = function ( renderCallback ) {};\n\n};\n\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\n\n// File:src/extras/objects/MorphBlendMesh.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphBlendMesh = function( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.animationsMap = {};\n\tthis.animationsList = [];\n\n\t// prepare default animation\n\t// (all frames played together in 1 second)\n\n\tvar numFrames = this.geometry.morphTargets.length;\n\n\tvar name = \"__default\";\n\n\tvar startFrame = 0;\n\tvar endFrame = numFrames - 1;\n\n\tvar fps = numFrames / 1;\n\n\tthis.createAnimation( name, startFrame, endFrame, fps );\n\tthis.setAnimationWeight( name, 1 );\n\n};\n\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\n\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\n\tvar animation = {\n\n\t\tstart: start,\n\t\tend: end,\n\n\t\tlength: end - start + 1,\n\n\t\tfps: fps,\n\t\tduration: ( end - start ) / fps,\n\n\t\tlastFrame: 0,\n\t\tcurrentFrame: 0,\n\n\t\tactive: false,\n\n\t\ttime: 0,\n\t\tdirection: 1,\n\t\tweight: 1,\n\n\t\tdirectionBackwards: false,\n\t\tmirroredLoop: false\n\n\t};\n\n\tthis.animationsMap[ name ] = animation;\n\tthis.animationsList.push( animation );\n\n};\n\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\n\tvar pattern = /([a-z]+)_?(\\d+)/i;\n\n\tvar firstAnimation, frameRanges = {};\n\n\tvar geometry = this.geometry;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar chunks = morph.name.match( pattern );\n\n\t\tif ( chunks && chunks.length > 1 ) {\n\n\t\t\tvar name = chunks[ 1 ];\n\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\n\n\t\t\tvar range = frameRanges[ name ];\n\n\t\t\tif ( i < range.start ) range.start = i;\n\t\t\tif ( i > range.end ) range.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\n\t\t}\n\n\t}\n\n\tfor ( var name in frameRanges ) {\n\n\t\tvar range = frameRanges[ name ];\n\t\tthis.createAnimation( name, range.start, range.end, fps );\n\n\t}\n\n\tthis.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = 1;\n\t\tanimation.directionBackwards = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = - 1;\n\t\tanimation.directionBackwards = true;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.fps = fps;\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.duration = duration;\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.weight = weight;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = time;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\n\tvar time = 0;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\ttime = animation.time;\n\n\t}\n\n\treturn time;\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\n\tvar duration = - 1;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tduration = animation.duration;\n\n\t}\n\n\treturn duration;\n\n};\n\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = 0;\n\t\tanimation.active = true;\n\n\t} else {\n\n\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.active = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\n\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\n\t\tvar animation = this.animationsList[ i ];\n\n\t\tif ( ! animation.active ) continue;\n\n\t\tvar frameTime = animation.duration / animation.length;\n\n\t\tanimation.time += animation.direction * delta;\n\n\t\tif ( animation.mirroredLoop ) {\n\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\n\t\t\t\tanimation.direction *= - 1;\n\n\t\t\t\tif ( animation.time > animation.duration ) {\n\n\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\tanimation.directionBackwards = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( animation.time < 0 ) {\n\n\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\tanimation.directionBackwards = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tanimation.time = animation.time % animation.duration;\n\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\n\t\t}\n\n\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\tvar weight = animation.weight;\n\n\t\tif ( keyframe !== animation.currentFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\tanimation.currentFrame = keyframe;\n\n\t\t}\n\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\n\t\tif ( animation.currentFrame !== animation.lastFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\n\t\t} else {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\n\n\t\t}\n\n\t}\n\n};\n\n\n},{}]},{},[1])\n\n","'use strict';\r\n\r\nvar config = {};\r\n\r\nmodule.exports = config;\r\n","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.BloomPass = function ( strength, kernelSize, sigma, resolution ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tstrength = ( strength !== undefined ) ? strength : 1;\r\n\tkernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;\r\n\tsigma = ( sigma !== undefined ) ? sigma : 4.0;\r\n\tresolution = ( resolution !== undefined ) ? resolution : 256;\r\n\r\n\t// render targets\r\n\r\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\r\n\r\n\tthis.renderTargetX = new THREE.WebGLRenderTarget( resolution, resolution, pars );\r\n\tthis.renderTargetY = new THREE.WebGLRenderTarget( resolution, resolution, pars );\r\n\r\n\t// copy material\r\n\r\n\tif ( THREE.CopyShader === undefined )\r\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.CopyShader\" );\r\n\r\n\tvar copyShader = THREE.CopyShader;\r\n\r\n\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\r\n\r\n\tthis.copyUniforms[ \"opacity\" ].value = strength;\r\n\r\n\tthis.materialCopy = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.copyUniforms,\r\n\t\tvertexShader: copyShader.vertexShader,\r\n\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\tblending: THREE.AdditiveBlending,\r\n\t\ttransparent: true\r\n\r\n\t} );\r\n\r\n\t// convolution material\r\n\r\n\tif ( THREE.ConvolutionShader === undefined )\r\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.ConvolutionShader\" );\r\n\r\n\tvar convolutionShader = THREE.ConvolutionShader;\r\n\r\n\tthis.convolutionUniforms = THREE.UniformsUtils.clone( convolutionShader.uniforms );\r\n\r\n\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurX;\r\n\tthis.convolutionUniforms[ \"cKernel\" ].value = THREE.ConvolutionShader.buildKernel( sigma );\r\n\r\n\tthis.materialConvolution = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.convolutionUniforms,\r\n\t\tvertexShader:  convolutionShader.vertexShader,\r\n\t\tfragmentShader: convolutionShader.fragmentShader,\r\n\t\tdefines: {\r\n\t\t\t\"KERNEL_SIZE_FLOAT\": kernelSize.toFixed( 1 ),\r\n\t\t\t\"KERNEL_SIZE_INT\": kernelSize.toFixed( 0 )\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.BloomPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.BloomPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 1)\r\n\r\n\t\tthis.quad.material = this.materialConvolution;\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurX;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetX, true );\r\n\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 2)\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = this.renderTargetX.texture;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurY;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetY, true );\r\n\r\n\t\t// Render original scene with superimposed blur to texture\r\n\r\n\t\tthis.quad.material = this.materialCopy;\r\n\r\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetY.texture;\r\n\r\n\t\tif ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );\r\n\r\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.BloomPass.blurX = new THREE.Vector2( 0.001953125, 0.0 );\r\nTHREE.BloomPass.blurY = new THREE.Vector2( 0.0, 0.001953125 );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.EffectComposer = function ( renderer, renderTarget ) {\r\n\r\n\tthis.renderer = renderer;\r\n\r\n\tif ( renderTarget === undefined ) {\r\n\r\n\t\tvar parameters = {\r\n\t\t\tminFilter: THREE.LinearFilter,\r\n\t\t\tmagFilter: THREE.LinearFilter,\r\n\t\t\tformat: THREE.RGBAFormat,\r\n\t\t\tstencilBuffer: false\r\n\t\t};\r\n\t\tvar size = renderer.getSize();\r\n\t\trenderTarget = new THREE.WebGLRenderTarget( size.width, size.height, parameters );\r\n\r\n\t}\r\n\r\n\tthis.renderTarget1 = renderTarget;\r\n\tthis.renderTarget2 = renderTarget.clone();\r\n\r\n\tthis.writeBuffer = this.renderTarget1;\r\n\tthis.readBuffer = this.renderTarget2;\r\n\r\n\tthis.passes = [];\r\n\r\n\tif ( THREE.CopyShader === undefined )\r\n\t\tconsole.error( \"THREE.EffectComposer relies on THREE.CopyShader\" );\r\n\r\n\tthis.copyPass = new THREE.ShaderPass( THREE.CopyShader );\r\n\r\n};\r\n\r\nObject.assign( THREE.EffectComposer.prototype, {\r\n\r\n\tswapBuffers: function() {\r\n\r\n\t\tvar tmp = this.readBuffer;\r\n\t\tthis.readBuffer = this.writeBuffer;\r\n\t\tthis.writeBuffer = tmp;\r\n\r\n\t},\r\n\r\n\taddPass: function ( pass ) {\r\n\r\n\t\tthis.passes.push( pass );\r\n\r\n\t\tvar size = this.renderer.getSize();\r\n\t\tpass.setSize( size.width, size.height );\r\n\r\n\t},\r\n\r\n\tinsertPass: function ( pass, index ) {\r\n\r\n\t\tthis.passes.splice( index, 0, pass );\r\n\r\n\t},\r\n\r\n\trender: function ( delta ) {\r\n\r\n\t\tvar maskActive = false;\r\n\r\n\t\tvar pass, i, il = this.passes.length;\r\n\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tpass = this.passes[ i ];\r\n\r\n\t\t\tif ( pass.enabled === false ) continue;\r\n\r\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );\r\n\r\n\t\t\tif ( pass.needsSwap ) {\r\n\r\n\t\t\t\tif ( maskActive ) {\r\n\r\n\t\t\t\t\tvar context = this.renderer.context;\r\n\r\n\t\t\t\t\tcontext.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );\r\n\r\n\t\t\t\t\tcontext.stencilFunc( context.EQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.swapBuffers();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( THREE.MaskPass !== undefined ) {\r\n\r\n\t\t\t\tif ( pass instanceof THREE.MaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = true;\r\n\r\n\t\t\t\t} else if ( pass instanceof THREE.ClearMaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\treset: function ( renderTarget ) {\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\tvar size = this.renderer.getSize();\r\n\r\n\t\t\trenderTarget = this.renderTarget1.clone();\r\n\t\t\trenderTarget.setSize( size.width, size.height );\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTarget1.dispose();\r\n\t\tthis.renderTarget2.dispose();\r\n\t\tthis.renderTarget1 = renderTarget;\r\n\t\tthis.renderTarget2 = renderTarget.clone();\r\n\r\n\t\tthis.writeBuffer = this.renderTarget1;\r\n\t\tthis.readBuffer = this.renderTarget2;\r\n\r\n\t},\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tthis.renderTarget1.setSize( width, height );\r\n\t\tthis.renderTarget2.setSize( width, height );\r\n\r\n\t\tfor ( var i = 0; i < this.passes.length; i ++ ) {\r\n\r\n\t\t\tthis.passes[i].setSize( width, height );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\nTHREE.Pass = function () {\r\n\r\n\t// if set to true, the pass is processed by the composer\r\n\tthis.enabled = true;\r\n\r\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\r\n\tthis.needsSwap = true;\r\n\r\n\t// if set to true, the pass clears its buffer before rendering\r\n\tthis.clear = false;\r\n\r\n\t// if set to true, the result of the pass is rendered to screen\r\n\tthis.renderToScreen = false;\r\n\r\n};\r\n\r\nObject.assign( THREE.Pass.prototype, {\r\n\r\n\tsetSize: function( width, height ) {},\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tconsole.error( \"THREE.Pass: .render() must be implemented in derived pass.\" );\r\n\r\n\t}\r\n\r\n} );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tif ( THREE.FilmShader === undefined )\r\n\t\tconsole.error( \"THREE.FilmPass relies on THREE.FilmShader\" );\r\n\r\n\tvar shader = THREE.FilmShader;\r\n\r\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\tthis.material = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.uniforms,\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t} );\r\n\r\n\tif ( grayscale !== undefined )\tthis.uniforms.grayscale.value = grayscale;\r\n\tif ( noiseIntensity !== undefined ) this.uniforms.nIntensity.value = noiseIntensity;\r\n\tif ( scanlinesIntensity !== undefined ) this.uniforms.sIntensity.value = scanlinesIntensity;\r\n\tif ( scanlinesCount !== undefined ) this.uniforms.sCount.value = scanlinesCount;\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.FilmPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.FilmPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.uniforms[ \"time\" ].value += delta;\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MaskPass = function ( scene, camera ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.clear = true;\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.inverse = false;\r\n\r\n};\r\n\r\nTHREE.MaskPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.MaskPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tvar context = renderer.context;\r\n\t\tvar state = renderer.state;\r\n\r\n\t\t// don't update color or depth\r\n\r\n\t\tstate.buffers.color.setMask( false );\r\n\t\tstate.buffers.depth.setMask( false );\r\n\r\n\t\t// lock buffers\r\n\r\n\t\tstate.buffers.color.setLocked( true );\r\n\t\tstate.buffers.depth.setLocked( true );\r\n\r\n\t\t// set up stencil\r\n\r\n\t\tvar writeValue, clearValue;\r\n\r\n\t\tif ( this.inverse ) {\r\n\r\n\t\t\twriteValue = 0;\r\n\t\t\tclearValue = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\twriteValue = 1;\r\n\t\t\tclearValue = 0;\r\n\r\n\t\t}\r\n\r\n\t\tstate.buffers.stencil.setTest( true );\r\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\r\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\r\n\t\tstate.buffers.stencil.setClear( clearValue );\r\n\r\n\t\t// draw into the stencil buffer\r\n\r\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\r\n\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t// unlock color and depth buffer for subsequent rendering\r\n\r\n\t\tstate.buffers.color.setLocked( false );\r\n\t\tstate.buffers.depth.setLocked( false );\r\n\r\n\t\t// only render where stencil is set to 1\r\n\r\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1\r\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\nTHREE.ClearMaskPass = function () {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n};\r\n\r\nTHREE.ClearMaskPass.prototype = Object.create( THREE.Pass.prototype );\r\n\r\nObject.assign( THREE.ClearMaskPass.prototype, {\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\trenderer.state.buffers.stencil.setTest( false );\r\n\r\n\t}\r\n\r\n} );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n/*global THREE, console */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\r\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\r\n// supported.\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\r\n//\r\n// This is a drop-in replacement for (most) TrackballControls used in examples.\r\n// That is, include this js file and wherever you see:\r\n//    \tcontrols = new THREE.TrackballControls( camera );\r\n//      controls.target.z = 150;\r\n// Simple substitute \"OrbitControls\" and the control should work as-is.\r\n\r\nTHREE.OrbitControls = function ( object, domElement ) {\r\n\r\n    this.object = object;\r\n    this.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n    // API\r\n\r\n    // Set to false to disable this control\r\n    this.enabled = true;\r\n\r\n    // \"target\" sets the location of focus, where the control orbits around\r\n    // and where it pans with respect to.\r\n    this.target = new THREE.Vector3();\r\n    // center is old, deprecated; use \"target\" instead\r\n    this.center = this.target;\r\n\r\n    // This option actually enables dollying in and out; left as \"zoom\" for\r\n    // backwards compatibility\r\n    this.noZoom = false;\r\n    this.zoomSpeed = 1.0;\r\n    // Limits to how far you can dolly in and out\r\n    this.minDistance = 0;\r\n    this.maxDistance = Infinity;\r\n\r\n    // Set to true to disable this control\r\n    this.noRotate = false;\r\n    this.rotateSpeed = 1.0;\r\n\r\n    // Set to true to disable this control\r\n    this.noPan = false;\r\n    this.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n    // Set to true to automatically rotate around the target\r\n    this.autoRotate = false;\r\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n    // How far you can orbit vertically, upper and lower limits.\r\n    // Range is 0 to Math.PI radians.\r\n    this.minPolarAngle = 0; // radians\r\n    this.maxPolarAngle = Math.PI; // radians\r\n\r\n    // Set to true to disable use of the keys\r\n    this.noKeys = false;\r\n    // The four arrow keys\r\n    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n    ////////////\r\n    // internals\r\n\r\n    var scope = this;\r\n\r\n    var EPS = 0.000001;\r\n\r\n    var rotateStart = new THREE.Vector2();\r\n    var rotateEnd = new THREE.Vector2();\r\n    var rotateDelta = new THREE.Vector2();\r\n\r\n    var panStart = new THREE.Vector2();\r\n    var panEnd = new THREE.Vector2();\r\n    var panDelta = new THREE.Vector2();\r\n\r\n    var dollyStart = new THREE.Vector2();\r\n    var dollyEnd = new THREE.Vector2();\r\n    var dollyDelta = new THREE.Vector2();\r\n\r\n    var phiDelta = 0;\r\n    var thetaDelta = 0;\r\n    var scale = 1;\r\n    var pan = new THREE.Vector3();\r\n\r\n    var lastPosition = new THREE.Vector3();\r\n\r\n    var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\r\n    var state = STATE.NONE;\r\n\r\n    // events\r\n\r\n    var changeEvent = { type: 'change' };\r\n\r\n\r\n    this.rotateLeft = function ( angle ) {\r\n\r\n        if ( angle === undefined ) {\r\n\r\n            angle = getAutoRotationAngle();\r\n\r\n        }\r\n\r\n        thetaDelta -= angle;\r\n\r\n    };\r\n\r\n    this.rotateUp = function ( angle ) {\r\n\r\n        if ( angle === undefined ) {\r\n\r\n            angle = getAutoRotationAngle();\r\n\r\n        }\r\n\r\n        phiDelta -= angle;\r\n\r\n    };\r\n\r\n    // pass in distance in world space to move left\r\n    this.panLeft = function ( distance ) {\r\n\r\n        var panOffset = new THREE.Vector3();\r\n        var te = this.object.matrix.elements;\r\n        // get X column of matrix\r\n        panOffset.set( te[0], te[1], te[2] );\r\n        panOffset.multiplyScalar(-distance);\r\n\r\n        pan.add( panOffset );\r\n\r\n    };\r\n\r\n    // pass in distance in world space to move up\r\n    this.panUp = function ( distance ) {\r\n\r\n        var panOffset = new THREE.Vector3();\r\n        var te = this.object.matrix.elements;\r\n        // get Y column of matrix\r\n        panOffset.set( te[4], te[5], te[6] );\r\n        panOffset.multiplyScalar(distance);\r\n\r\n        pan.add( panOffset );\r\n    };\r\n\r\n    // main entry point; pass in Vector2 of change desired in pixel space,\r\n    // right and down are positive\r\n    this.pan = function ( delta ) {\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        if ( scope.object.fov !== undefined ) {\r\n\r\n            // perspective\r\n            var position = scope.object.position;\r\n            var offset = position.clone().sub( scope.target );\r\n            var targetDistance = offset.length();\r\n\r\n            // half of the fov is center to top of screen\r\n            targetDistance *= Math.tan( (scope.object.fov/2) * Math.PI / 180.0 );\r\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n            scope.panLeft( 2 * delta.x * targetDistance / element.clientHeight );\r\n            scope.panUp( 2 * delta.y * targetDistance / element.clientHeight );\r\n\r\n        } else if ( scope.object.top !== undefined ) {\r\n\r\n            // orthographic\r\n            scope.panLeft( delta.x * (scope.object.right - scope.object.left) / element.clientWidth );\r\n            scope.panUp( delta.y * (scope.object.top - scope.object.bottom) / element.clientHeight );\r\n\r\n        } else {\r\n\r\n            // camera neither orthographic or perspective - warn user\r\n            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n\r\n        }\r\n\r\n    };\r\n\r\n    this.dollyIn = function ( dollyScale ) {\r\n\r\n        if ( dollyScale === undefined ) {\r\n\r\n            dollyScale = getZoomScale();\r\n\r\n        }\r\n\r\n        scale /= dollyScale;\r\n\r\n    };\r\n\r\n    this.dollyOut = function ( dollyScale ) {\r\n\r\n        if ( dollyScale === undefined ) {\r\n\r\n            dollyScale = getZoomScale();\r\n\r\n        }\r\n\r\n        scale *= dollyScale;\r\n\r\n    };\r\n\r\n    this.update = function () {\r\n\r\n        var position = this.object.position;\r\n        var offset = position.clone().sub( this.target );\r\n\r\n        // angle from z-axis around y-axis\r\n\r\n        var theta = Math.atan2( offset.x, offset.z );\r\n\r\n        // angle from y-axis\r\n\r\n        var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\r\n\r\n        if ( this.autoRotate ) {\r\n\r\n            this.rotateLeft( getAutoRotationAngle() );\r\n\r\n        }\r\n\r\n        theta += thetaDelta;\r\n        phi += phiDelta;\r\n\r\n        // restrict phi to be between desired limits\r\n        phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\r\n\r\n        // restrict phi to be betwee EPS and PI-EPS\r\n        phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\r\n\r\n        var radius = offset.length() * scale;\r\n\r\n        // restrict radius to be between desired limits\r\n        radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\r\n\r\n        // move target to panned location\r\n        this.target.add( pan );\r\n\r\n        offset.x = radius * Math.sin( phi ) * Math.sin( theta );\r\n        offset.y = radius * Math.cos( phi );\r\n        offset.z = radius * Math.sin( phi ) * Math.cos( theta );\r\n\r\n        position.copy( this.target ).add( offset );\r\n\r\n        this.object.lookAt( this.target );\r\n\r\n        thetaDelta = 0;\r\n        phiDelta = 0;\r\n        scale = 1;\r\n        pan.set(0,0,0);\r\n\r\n        if ( lastPosition.distanceTo( this.object.position ) > 0 ) {\r\n\r\n            this.dispatchEvent( changeEvent );\r\n\r\n            lastPosition.copy( this.object.position );\r\n\r\n        }\r\n\r\n    };\r\n\r\n\r\n    function getAutoRotationAngle() {\r\n\r\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n    }\r\n\r\n    function getZoomScale() {\r\n\r\n        return Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n    }\r\n\r\n    function onMouseDown( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n        event.preventDefault();\r\n\r\n        if ( event.button === 0 ) {\r\n            if ( scope.noRotate === true ) { return; }\r\n\r\n            state = STATE.ROTATE;\r\n\r\n            rotateStart.set( event.clientX, event.clientY );\r\n\r\n        } else if ( event.button === 1 ) {\r\n            if ( scope.noZoom === true ) { return; }\r\n\r\n            state = STATE.DOLLY;\r\n\r\n            dollyStart.set( event.clientX, event.clientY );\r\n\r\n        } else if ( event.button === 2 ) {\r\n            if ( scope.noPan === true ) { return; }\r\n\r\n            state = STATE.PAN;\r\n\r\n            panStart.set( event.clientX, event.clientY );\r\n\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.domElement.addEventListener( 'mousemove', onMouseMove, false );\r\n        scope.domElement.addEventListener( 'mouseup', onMouseUp, false );\r\n\r\n    }\r\n\r\n    function onMouseMove( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        if ( state === STATE.ROTATE ) {\r\n\r\n            if ( scope.noRotate === true ) return;\r\n\r\n            rotateEnd.set( event.clientX, event.clientY );\r\n            rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n            // rotating across whole screen goes 360 degrees around\r\n            scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n            scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n            rotateStart.copy( rotateEnd );\r\n\r\n        } else if ( state === STATE.DOLLY ) {\r\n\r\n            if ( scope.noZoom === true ) return;\r\n\r\n            dollyEnd.set( event.clientX, event.clientY );\r\n            dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n            if ( dollyDelta.y > 0 ) {\r\n\r\n                scope.dollyIn();\r\n\r\n            } else {\r\n\r\n                scope.dollyOut();\r\n\r\n            }\r\n\r\n            dollyStart.copy( dollyEnd );\r\n\r\n        } else if ( state === STATE.PAN ) {\r\n\r\n            if ( scope.noPan === true ) return;\r\n\r\n            panEnd.set( event.clientX, event.clientY );\r\n            panDelta.subVectors( panEnd, panStart );\r\n\r\n            scope.pan( panDelta );\r\n\r\n            panStart.copy( panEnd );\r\n\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function onMouseUp( /* event */ ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.domElement.removeEventListener( 'mousemove', onMouseMove, false );\r\n        scope.domElement.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n        state = STATE.NONE;\r\n\r\n    }\r\n\r\n    function onMouseWheel( event ) {\r\n\r\n        if ( scope.enabled === false || scope.noZoom === true ) return;\r\n\r\n        var delta = 0;\r\n\r\n        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\r\n\r\n            delta = event.wheelDelta;\r\n\r\n        } else if ( event.detail ) { // Firefox\r\n\r\n            delta = - event.detail;\r\n\r\n        }\r\n\r\n        if ( delta > 0 ) {\r\n\r\n            scope.dollyOut();\r\n\r\n        } else {\r\n\r\n            scope.dollyIn();\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onKeyDown( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n        if ( scope.noKeys === true ) { return; }\r\n        if ( scope.noPan === true ) { return; }\r\n\r\n        // pan a pixel - I guess for precise positioning?\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        var needUpdate = false;\r\n\r\n        switch ( event.keyCode ) {\r\n\r\n            case scope.keys.UP:\r\n                scope.pan( new THREE.Vector2( 0, scope.keyPanSpeed ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.BOTTOM:\r\n                scope.pan( new THREE.Vector2( 0, -scope.keyPanSpeed ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.LEFT:\r\n                scope.pan( new THREE.Vector2( scope.keyPanSpeed, 0 ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.RIGHT:\r\n                scope.pan( new THREE.Vector2( -scope.keyPanSpeed, 0 ) );\r\n                needUpdate = true;\r\n                break;\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        if ( needUpdate ) {\r\n\r\n            scope.update();\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function touchstart( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1:\t// one-fingered touch: rotate\r\n                if ( scope.noRotate === true ) { return; }\r\n\r\n                state = STATE.TOUCH_ROTATE;\r\n\r\n                rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                break;\r\n\r\n            case 2:\t// two-fingered touch: dolly\r\n                if ( scope.noZoom === true ) { return; }\r\n\r\n                state = STATE.TOUCH_DOLLY;\r\n\r\n                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n                var distance = Math.sqrt( dx * dx + dy * dy );\r\n                dollyStart.set( 0, distance );\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n                if ( scope.noPan === true ) { return; }\r\n\r\n                state = STATE.TOUCH_PAN;\r\n\r\n                panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                break;\r\n\r\n            default:\r\n                state = STATE.NONE;\r\n\r\n        }\r\n    }\r\n\r\n    function touchmove( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1: // one-fingered touch: rotate\r\n                if ( scope.noRotate === true ) { return; }\r\n                if ( state !== STATE.TOUCH_ROTATE ) { return; }\r\n\r\n                rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n                // rotating across whole screen goes 360 degrees around\r\n                scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n                scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n                rotateStart.copy( rotateEnd );\r\n                break;\r\n\r\n            case 2: // two-fingered touch: dolly\r\n                if ( scope.noZoom === true ) { return; }\r\n                if ( state !== STATE.TOUCH_DOLLY ) { return; }\r\n\r\n                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n                var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n                dollyEnd.set( 0, distance );\r\n                dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n                if ( dollyDelta.y > 0 ) {\r\n\r\n                    scope.dollyOut();\r\n\r\n                } else {\r\n\r\n                    scope.dollyIn();\r\n\r\n                }\r\n\r\n                dollyStart.copy( dollyEnd );\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n                if ( scope.noPan === true ) { return; }\r\n                if ( state !== STATE.TOUCH_PAN ) { return; }\r\n\r\n                panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                panDelta.subVectors( panEnd, panStart );\r\n\r\n                scope.pan( panDelta );\r\n\r\n                panStart.copy( panEnd );\r\n                break;\r\n\r\n            default:\r\n                state = STATE.NONE;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function touchend( /* event */ ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        state = STATE.NONE;\r\n    }\r\n\r\n    this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\r\n    this.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n    this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\r\n    this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\r\n\r\n    this.domElement.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n    this.domElement.addEventListener( 'touchstart', touchstart, false );\r\n    this.domElement.addEventListener( 'touchend', touchend, false );\r\n    this.domElement.addEventListener( 'touchmove', touchmove, false );\r\n\r\n};\r\n\r\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.overrideMaterial = overrideMaterial;\r\n\r\n\tthis.clearColor = clearColor;\r\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\r\n\r\n\tthis.clear = true;\r\n\tthis.needsSwap = false;\r\n\r\n};\r\n\r\nTHREE.RenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.RenderPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.scene.overrideMaterial = this.overrideMaterial;\r\n\r\n\t\tvar oldClearColor, oldClearAlpha;\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\toldClearColor = renderer.getClearColor().getHex();\r\n\t\t\toldClearAlpha = renderer.getClearAlpha();\r\n\r\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\r\n\r\n\t\t}\r\n\r\n\t\tthis.scene.overrideMaterial = null;\r\n\r\n\t}\r\n\r\n} );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ShaderPass = function ( shader, textureID ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.textureID = ( textureID !== undefined ) ? textureID : \"tDiffuse\";\r\n\r\n\tif ( shader instanceof THREE.ShaderMaterial ) {\r\n\r\n\t\tthis.uniforms = shader.uniforms;\r\n\r\n\t\tthis.material = shader;\r\n\r\n\t} else if ( shader ) {\r\n\r\n\t\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\tthis.material = new THREE.ShaderMaterial( {\r\n\r\n\t\t\tdefines: shader.defines || {},\r\n\t\t\tuniforms: this.uniforms,\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.ShaderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.ShaderPass,\r\n\r\n\trender: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( this.uniforms[ this.textureID ] ) {\r\n\r\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\r\n\r\n\t\t}\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );","'use strict';\r\n\r\nvar uniforms;\r\n\r\nvar THREE = require('three');\r\n\r\nvar OrbitControls = require('../libs/OrbitControls.js');\r\n\r\nvar CopyShader = require('../shaders/CopyShader.js');\r\nvar FilmShader = require('../shaders/FilmShader.js');\r\nvar ConvolutionShader = require('../shaders/ConvolutionShader.js');\r\nvar BadTv = require('../shaders/BadTv.js');\r\n\r\nvar EffectComposer = require('../libs/EffectComposer.js');\r\nvar RenderPass = require('../libs/RenderPass.js');\r\nvar FilmPass = require('../libs/FilmPass.js');\r\nvar BloomPass = require('../libs/BloomPass.js');\r\nvar MaskPass = require('../libs/MaskPass.js');\r\nvar ShaderPass = require('../libs/ShaderPass.js');\r\n\r\nvar Stage = function() {\r\n  \r\n  this.renderer = new THREE.WebGLRenderer({alpha: true});\r\n  this.renderer.setPixelRatio(window.devicePixelRatio);\r\n  this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n\r\n  // document.body.appendChild(this.renderer.domElement);\r\n\r\n  this.camera = new THREE.PerspectiveCamera(35, ((window.innerWidth / 2) / (window.innerHeight / 2)), 1, 3000);\r\n  this.camera.position.z = 4;\r\n\r\n  this.scene = new THREE.Scene();\r\n\r\n  this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);\r\n  this.controls.autoRotate = true;\r\n\r\n  this.visualElement;\r\n\r\n};\r\n\r\nStage.prototype.init = function() {\r\n\r\n  this.getAudio();\r\n\r\n  requestAnimationFrame(this.animate.bind(this));\r\n\r\n  // on resize\r\n  window.addEventListener('resize', this._onResize.bind(this));\r\n\r\n  TweenMax.to(document.querySelector('.bg'), 2000, {\r\n    rotation: -1080,\r\n    yoyo: true,\r\n    repeat: -1,\r\n    ease: Power1.easeOut\r\n  });\r\n\r\n  this.renderModel = new THREE.RenderPass( this.scene, this.camera );\r\n  this.effectBloom = new THREE.BloomPass( 1.25 );\r\n  this.effectFilm = new THREE.FilmPass( 0.35, 0.95, 2048, false );\r\n\r\n  this.effectFilm.renderToScreen = true;\r\n\r\n  this.composer = new THREE.EffectComposer( this.renderer );\r\n\r\n  this.composer.addPass(this.renderModel);\r\n  this.composer.addPass(this.effectBloom);\r\n  this.composer.addPass(this.effectFilm);\r\n\r\n  this.badTVEffect = new THREE.ShaderPass(THREE.BadTVShader);\r\n  this.badTVEffect.uniforms['speed'].value = 10;\r\n  this.badTVEffect.uniforms['rollSpeed'].value = 20;\r\n  // this.badTVEffect.renderToScreen = true;\r\n  this.composer.addPass(this.badTVEffect);\r\n\r\n  this.clock = new THREE.Clock();\r\n\r\n  uniforms = {\r\n\r\n    fogDensity: { value: 0.1 },\r\n    fogColor:   { value: new THREE.Vector3( 0, 0, 0 ) },\r\n    time:       { value: 1.0 },\r\n    resolution: { value: new THREE.Vector2() },\r\n    uvScale:    { value: new THREE.Vector2( 3.0, 1.0 ) },\r\n    texture1:   { value: new THREE.TextureLoader().load( \"images/cloud.png\" ) },\r\n    texture2:   { value: new THREE.TextureLoader().load( \"images/lavatile.jpg\" ) }\r\n\r\n  };\r\n\r\n  uniforms.texture1.value.wrapS = uniforms.texture1.value.wrapT = THREE.RepeatWrapping;\r\n  uniforms.texture2.value.wrapS = uniforms.texture2.value.wrapT = THREE.RepeatWrapping;\r\n\r\n  var size = 0.65;\r\n\r\n  this.visualMaterial = new THREE.ShaderMaterial( {\r\n\r\n    uniforms: uniforms,\r\n    vertexShader: document.getElementById( 'vertexShader' ).textContent,\r\n    fragmentShader: document.getElementById( 'fragmentShader' ).textContent\r\n\r\n  } );\r\n\r\n  this.visualMesh = new THREE.Mesh( new THREE.TorusGeometry( size, 0.3, 30, 30 ), this.visualMaterial);\r\n  this.visualMesh.rotation.x = 0.3;\r\n  this.scene.add(this.visualMesh);\r\n\r\n  this.renderer = new THREE.WebGLRenderer({antialias: true});\r\n  this.renderer.setPixelRatio(window.devicePixelRatio);\r\n  document.body.appendChild(this.renderer.domElement);\r\n  this.renderer.autoClear = false;\r\n\r\n  this._onResize();\r\n};\r\n\r\nStage.prototype.animate = function() {\r\n  requestAnimationFrame(this.animate.bind(this));\r\n  var time = Date.now();\r\n\r\n  this.update(time);\r\n\r\n  this.renderer.render(this.scene, this.camera);\r\n\r\n};\r\n\r\nStage.prototype.update = function(time) {\r\n  var diff = time - this.lastTime;\r\n  this.lastTime = time;\r\n\r\n  if (!this.lastTime) {\r\n    this.lastTime = time;\r\n    \r\n    return;\r\n  }  \r\n\r\n  // this.object.rotation.x += 0.0025;\r\n  // this.object.rotation.y += 0.001;\r\n  //this.partSystem.rotation.y = time * 0.0005;\r\n\r\n  var delta = 5 * this.clock.getDelta();\r\n\r\n  // uniforms.time.value += 0.2 * delta;\r\n  // this.visualMaterial.uniforms['time'].value += 0.2 * delta;\r\n\r\n  this.visualMesh.rotation.y += 0.0125 * delta;\r\n  this.visualMesh.rotation.x += 0.05 * delta;\r\n\r\n  this.renderer.clear();\r\n  this.composer.render(0.1);\r\n\r\n  this.controls.update()\r\n\r\n  this.updateVisual();\r\n\r\n};\r\n\r\nStage.prototype.updateVisual = function() {\r\n  var array = new Uint8Array(this.analyser.frequencyBinCount);\r\n  var frequencyArray = new Float32Array(this.analyser.frequencyBinCount);\r\n\r\n  var frequencyData = new Uint8Array(this.barsAnalyser.frequencyBinCount);\r\n  \r\n  this.analyser.getByteFrequencyData(array);\r\n  this.analyser.getFloatFrequencyData(frequencyArray);\r\n  \r\n  var average = this._getAverageVolume(array);\r\n  var frequencyAverage = this._getAverageVolume(frequencyArray);\r\n  var frequencyDataArray = this._getAverageVolume(frequencyData);\r\n\r\n  this.visualMaterial.uniforms['fogDensity'].value = frequencyAverage / 200;\r\n  this.visualMaterial.uniforms['time'].value = average / 50;\r\n\r\n  this.barsArray.forEach(function(bar, index) {\r\n    bar.style.height = Math.abs(frequencyArray[index]) + 'px';\r\n  });\r\n\r\n};\r\n\r\nStage.prototype.soundBars = function() {\r\n\r\n  this.soundBars = document.querySelector('#soundBars');\r\n\r\n  this.barsArray = [];\r\n\r\n  var barSpacingPercent = this.barsAnalyser.frequencyBinCount / 100;\r\n  \r\n  for (var i = 0; i < this.barsAnalyser.frequencyBinCount; i++) {\r\n\r\n    this.newBars = document.createElement('div');\r\n    this.soundBars.appendChild(this.newBars);\r\n    this.barsArray.push(this.newBars);\r\n\r\n  };\r\n\r\n};\r\n\r\nStage.prototype.getAudio = function() {\r\n  var context = new AudioContext();\r\n  this.analyser = context.createAnalyser();\r\n  this.analyser.smoothingTimeConstant = 0.4;\r\n  this.analyser.fftSize = 1024;\r\n\r\n  this.analyser2 = context.createAnalyser();\r\n  this.analyser2.smoothingTimeConstant = 0.4;\r\n  this.analyser2.fftSize = 1024;\r\n\r\n  this.barsAnalyser = context.createAnalyser();\r\n  this.barsAnalyser.fftSize = 64;\r\n\r\n  var sourceNode = context.createBufferSource();\r\n  var splitter = context.createChannelSplitter();\r\n\r\n  sourceNode.connect(splitter);\r\n\r\n  splitter.connect(this.analyser, 0);\r\n  splitter.connect(this.analyser2, 1);\r\n\r\n  sourceNode.connect(context.destination);\r\n\r\n  var request = new XMLHttpRequest();\r\n  request.open('GET', 'audio/sasha.mp3', true);\r\n  request.responseType = 'arraybuffer';\r\n\r\n  var songBuffer;\r\n  \r\n  request.onload = function() {\r\n    context.decodeAudioData(request.response, function(buffer) {\r\n      songBuffer = buffer;\r\n\r\n      var dur = buffer.duration;\r\n\r\n      sourceNode.buffer = buffer;\r\n      sourceNode.start(0);\r\n      sourceNode.loop = true;\r\n      sourceNode.muted = true;\r\n\r\n    }, this._onError);\r\n  }.bind(this);\r\n\r\n  request.send();\r\n\r\n  this.soundBars();\r\n};\r\n\r\nStage.prototype._getAverageVolume = function(array) {\r\n  var values = 0;\r\n  var average;\r\n  var length = array.length;\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    values += array[i];\r\n  }\r\n\r\n  average = values / length;\r\n\r\n  return average;\r\n};\r\n\r\nStage.prototype._onResize = function() {\r\n  this.camera.aspect = window.innerWidth / window.innerHeight;\r\n  this.camera.updateProjectionMatrix();\r\n  \r\n  this.renderer.setSize( window.innerWidth, window.innerHeight );\r\n  \r\n  this.composer.setSize( window.innerWidth, window.innerHeight );\r\n  this.composer.reset();\r\n\r\n  uniforms.resolution.value.x = window.innerWidth;\r\n  uniforms.resolution.value.y = window.innerHeight;\r\n};\r\n\r\nStage.prototype._onError = function(e) {\r\n  console.log(e);\r\n};\r\n\r\nmodule.exports = Stage;","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author Felix Turner / www.airtight.cc / @felixturner\r\n *\r\n * Bad TV Shader\r\n * Simulates a bad TV via horizontal distortion and vertical roll\r\n * Uses Ashima WebGl Noise: https://github.com/ashima/webgl-noise\r\n *\r\n * time: steadily increasing float passed in\r\n * distortion: amount of thick distortion\r\n * distortion2: amount of fine grain distortion\r\n * speed: distortion vertical travel speed\r\n * rollSpeed: vertical roll speed\r\n *\r\n * The MIT License\r\n *\r\n * Copyright (c) 2014 Felix Turner\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n *\r\n */\r\n\r\nTHREE.BadTVShader = {\r\n  uniforms: {\r\n    \"tDiffuse\":    { type: \"t\", value: null },\r\n    \"time\":        { type: \"f\", value: 0.0 },\r\n    \"distortion\":  { type: \"f\", value: 0.5 },\r\n    \"distortion2\": { type: \"f\", value: 1.5 },\r\n    \"speed\":       { type: \"f\", value: 0.5 },\r\n    \"rollSpeed\":   { type: \"f\", value: 0.0 },\r\n  },\r\n\r\n  vertexShader: [\r\n    \"varying vec2 vUv;\",\r\n    \"void main() {\",\r\n    \"vUv = uv;\",\r\n    \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n    \"}\"\r\n\r\n  ].join(\"\\n\"),\r\n\r\n  fragmentShader: [\r\n\r\n    \"uniform sampler2D tDiffuse;\",\r\n    \"uniform float time;\",\r\n    \"uniform float distortion;\",\r\n    \"uniform float distortion2;\",\r\n    \"uniform float speed;\",\r\n    \"uniform float rollSpeed;\",\r\n    \"varying vec2 vUv;\",\r\n\r\n    // Start Ashima 2D Simplex Noise\r\n\r\n    \"vec3 mod289(vec3 x) {\",\r\n    \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\",\r\n    \"}\",\r\n\r\n    \"vec2 mod289(vec2 x) {\",\r\n    \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\",\r\n    \"}\",\r\n\r\n    \"vec3 permute(vec3 x) {\",\r\n    \"  return mod289(((x*34.0)+1.0)*x);\",\r\n    \"}\",\r\n\r\n    \"float snoise(vec2 v)\",\r\n    \"  {\",\r\n    \"  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\",\r\n    \"                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\",\r\n    \"                     -0.577350269189626,  // -1.0 + 2.0 * C.x\",\r\n    \"                      0.024390243902439); // 1.0 / 41.0\",\r\n    \"  vec2 i  = floor(v + dot(v, C.yy) );\",\r\n    \"  vec2 x0 = v -   i + dot(i, C.xx);\",\r\n\r\n    \"  vec2 i1;\",\r\n    \"  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\",\r\n    \"  vec4 x12 = x0.xyxy + C.xxzz;\",\r\n    \" x12.xy -= i1;\",\r\n\r\n    \"  i = mod289(i); // Avoid truncation effects in permutation\",\r\n    \"  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\",\r\n    \"   + i.x + vec3(0.0, i1.x, 1.0 ));\",\r\n\r\n    \"  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\",\r\n    \"  m = m*m ;\",\r\n    \"  m = m*m ;\",\r\n\r\n    \"  vec3 x = 2.0 * fract(p * C.www) - 1.0;\",\r\n    \"  vec3 h = abs(x) - 0.5;\",\r\n    \"  vec3 ox = floor(x + 0.5);\",\r\n    \"  vec3 a0 = x - ox;\",\r\n\r\n    \"  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\",\r\n\r\n    \"  vec3 g;\",\r\n    \"  g.x  = a0.x  * x0.x  + h.x  * x0.y;\",\r\n    \"  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\",\r\n    \"  return 130.0 * dot(m, g);\",\r\n    \"}\",\r\n\r\n    // End Ashima 2D Simplex Noise\r\n\r\n    \"void main() {\",\r\n\r\n      \"vec2 p = vUv;\",\r\n      \"float ty = time*speed;\",\r\n      \"float yt = p.y - ty;\",\r\n\r\n      //smooth distortion\r\n      \"float offset = snoise(vec2(yt*3.0,0.0))*0.2;\",\r\n      // boost distortion\r\n      \"offset = pow( offset*distortion,3.0)/distortion;\",\r\n      //add fine grain distortion\r\n      \"offset += snoise(vec2(yt*50.0,0.0))*distortion2*0.001;\",\r\n      //combine distortion on X with roll on Y\r\n      \"gl_FragColor = texture2D(tDiffuse,  vec2(fract(p.x + offset),fract(p.y-time*rollSpeed) ));\",\r\n\r\n    \"}\"\r\n\r\n  ].join(\"\\n\")\r\n\r\n};","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Convolution shader\r\n * ported from o3d sample to WebGL / GLSL\r\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\r\n */\r\n\r\nTHREE.ConvolutionShader = {\r\n\r\n\tdefines: {\r\n\r\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\r\n\t\t\"KERNEL_SIZE_INT\": \"25\",\r\n\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":        { value: null },\r\n\t\t\"uImageIncrement\": { value: new THREE.Vector2( 0.001953125, 0.0 ) },\r\n\t\t\"cKernel\":         { value: [] }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 imageCoord = vUv;\",\r\n\t\t\t\"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\r\n\r\n\t\t\t\"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\r\n\r\n\t\t\t\t\"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\r\n\t\t\t\t\"imageCoord += uImageIncrement;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\"}\"\r\n\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tbuildKernel: function ( sigma ) {\r\n\r\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\r\n\r\n\t\tfunction gauss( x, sigma ) {\r\n\r\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\r\n\r\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\r\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\r\n\r\n\t\tvalues = new Array( kernelSize );\r\n\t\tsum = 0.0;\r\n\t\tfor ( i = 0; i < kernelSize; ++ i ) {\r\n\r\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\r\n\t\t\tsum += values[ i ];\r\n\r\n\t\t}\r\n\r\n\t\t// normalize the kernel\r\n\r\n\t\tfor ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\r\n\r\n\t\treturn values;\r\n\r\n\t}\r\n\r\n};","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Full-screen textured quad shader\r\n */\r\n\r\nTHREE.CopyShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"opacity\":  { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float opacity;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\"gl_FragColor = opacity * texel;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};","'use strict';\n\nvar THREE = require('three');\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\n\nTHREE.FilmShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { value: null },\n\t\t\"time\":       { value: 0.0 },\n\t\t\"nIntensity\": { value: 0.5 },\n\t\t\"sIntensity\": { value: 0.05 },\n\t\t\"sCount\":     { value: 4096 },\n\t\t\"grayscale\":  { value: 1 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"#include <common>\",\n\t\t\n\t\t// control parameter\n\t\t\"uniform float time;\",\n\n\t\t\"uniform bool grayscale;\",\n\n\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float nIntensity;\",\n\n\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float sIntensity;\",\n\n\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\t\"uniform float sCount;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t// sample the source\n\t\t\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// make some noise\n\t\t\t\"float dx = rand( vUv + time );\",\n\n\t\t\t// add noise\n\t\t\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\",\n\n\t\t\t// get us a sine and cosine\n\t\t\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t\t\t// add scanlines\n\t\t\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t\t\t// interpolate between source and result by intensity\n\t\t\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t\t\t// convert to grayscale if desired\n\t\t\t\"if( grayscale ) {\",\n\n\t\t\t\t\"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor =  vec4( cResult, cTextureScreen.a );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n","// File:src/Three.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar THREE = { REVISION: '78' };\n\n//\n\nif ( typeof define === 'function' && define.amd ) {\n\n\tdefine( 'three', THREE );\n\n} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\n\n\tmodule.exports = THREE;\n\n}\n\n// Polyfills\n\nif ( Number.EPSILON === undefined ) {\n\n\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n}\n\n//\n\nif ( Math.sign === undefined ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\tMath.sign = function ( x ) {\n\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t};\n\n}\n\nif ( Function.prototype.name === undefined ) {\n\n\t// Missing in IE9-11.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\tget: function () {\n\n\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\n\t\t}\n\n\t} );\n\n}\n\nif ( Object.assign === undefined ) {\n\n\t// Missing in IE.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t( function () {\n\n\t\tObject.assign = function ( target ) {\n\n\t\t\t'use strict';\n\n\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t}\n\n\t\t\tvar output = Object( target );\n\n\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t};\n\n\t} )();\n\n}\n\n//\n\nObject.assign( THREE, {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\n\n\tMOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },\n\n\t// GL STATE CONSTANTS\n\n\tCullFaceNone: 0,\n\tCullFaceBack: 1,\n\tCullFaceFront: 2,\n\tCullFaceFrontBack: 3,\n\n\tFrontFaceDirectionCW: 0,\n\tFrontFaceDirectionCCW: 1,\n\n\t// SHADOWING TYPES\n\n\tBasicShadowMap: 0,\n\tPCFShadowMap: 1,\n\tPCFSoftShadowMap: 2,\n\n\t// MATERIAL CONSTANTS\n\n\t// side\n\n\tFrontSide: 0,\n\tBackSide: 1,\n\tDoubleSide: 2,\n\n\t// shading\n\n\tFlatShading: 1,\n\tSmoothShading: 2,\n\n\t// colors\n\n\tNoColors: 0,\n\tFaceColors: 1,\n\tVertexColors: 2,\n\n\t// blending modes\n\n\tNoBlending: 0,\n\tNormalBlending: 1,\n\tAdditiveBlending: 2,\n\tSubtractiveBlending: 3,\n\tMultiplyBlending: 4,\n\tCustomBlending: 5,\n\n\t// custom blending equations\n\t// (numbers start from 100 not to clash with other\n\t// mappings to OpenGL constants defined in Texture.js)\n\n\tAddEquation: 100,\n\tSubtractEquation: 101,\n\tReverseSubtractEquation: 102,\n\tMinEquation: 103,\n\tMaxEquation: 104,\n\n\t// custom blending destination factors\n\n\tZeroFactor: 200,\n\tOneFactor: 201,\n\tSrcColorFactor: 202,\n\tOneMinusSrcColorFactor: 203,\n\tSrcAlphaFactor: 204,\n\tOneMinusSrcAlphaFactor: 205,\n\tDstAlphaFactor: 206,\n\tOneMinusDstAlphaFactor: 207,\n\n\t// custom blending source factors\n\n\t//ZeroFactor: 200,\n\t//OneFactor: 201,\n\t//SrcAlphaFactor: 204,\n\t//OneMinusSrcAlphaFactor: 205,\n\t//DstAlphaFactor: 206,\n\t//OneMinusDstAlphaFactor: 207,\n\tDstColorFactor: 208,\n\tOneMinusDstColorFactor: 209,\n\tSrcAlphaSaturateFactor: 210,\n\n\t// depth modes\n\n\tNeverDepth: 0,\n\tAlwaysDepth: 1,\n\tLessDepth: 2,\n\tLessEqualDepth: 3,\n\tEqualDepth: 4,\n\tGreaterEqualDepth: 5,\n\tGreaterDepth: 6,\n\tNotEqualDepth: 7,\n\n\n\t// TEXTURE CONSTANTS\n\n\tMultiplyOperation: 0,\n\tMixOperation: 1,\n\tAddOperation: 2,\n\n\t// Tone Mapping modes\n\n\tNoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)\n\tLinearToneMapping: 1, // only apply exposure.\n\tReinhardToneMapping: 2,\n\tUncharted2ToneMapping: 3, // John Hable\n\tCineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\n\t// Mapping modes\n\n\tUVMapping: 300,\n\n\tCubeReflectionMapping: 301,\n\tCubeRefractionMapping: 302,\n\n\tEquirectangularReflectionMapping: 303,\n\tEquirectangularRefractionMapping: 304,\n\n\tSphericalReflectionMapping: 305,\n\tCubeUVReflectionMapping: 306,\n\tCubeUVRefractionMapping: 307,\n\n\t// Wrapping modes\n\n\tRepeatWrapping: 1000,\n\tClampToEdgeWrapping: 1001,\n\tMirroredRepeatWrapping: 1002,\n\n\t// Filters\n\n\tNearestFilter: 1003,\n\tNearestMipMapNearestFilter: 1004,\n\tNearestMipMapLinearFilter: 1005,\n\tLinearFilter: 1006,\n\tLinearMipMapNearestFilter: 1007,\n\tLinearMipMapLinearFilter: 1008,\n\n\t// Data types\n\n\tUnsignedByteType: 1009,\n\tByteType: 1010,\n\tShortType: 1011,\n\tUnsignedShortType: 1012,\n\tIntType: 1013,\n\tUnsignedIntType: 1014,\n\tFloatType: 1015,\n\tHalfFloatType: 1025,\n\n\t// Pixel types\n\n\t//UnsignedByteType: 1009,\n\tUnsignedShort4444Type: 1016,\n\tUnsignedShort5551Type: 1017,\n\tUnsignedShort565Type: 1018,\n\n\t// Pixel formats\n\n\tAlphaFormat: 1019,\n\tRGBFormat: 1020,\n\tRGBAFormat: 1021,\n\tLuminanceFormat: 1022,\n\tLuminanceAlphaFormat: 1023,\n\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\n\tRGBEFormat: THREE.RGBAFormat, //1024;\n\tDepthFormat: 1026,\n\n\t// DDS / ST3C Compressed texture formats\n\n\tRGB_S3TC_DXT1_Format: 2001,\n\tRGBA_S3TC_DXT1_Format: 2002,\n\tRGBA_S3TC_DXT3_Format: 2003,\n\tRGBA_S3TC_DXT5_Format: 2004,\n\n\t// PVRTC compressed texture formats\n\n\tRGB_PVRTC_4BPPV1_Format: 2100,\n\tRGB_PVRTC_2BPPV1_Format: 2101,\n\tRGBA_PVRTC_4BPPV1_Format: 2102,\n\tRGBA_PVRTC_2BPPV1_Format: 2103,\n\n\t// ETC compressed texture formats\n\n\tRGB_ETC1_Format: 2151,\n\n\t// Loop styles for AnimationAction\n\n\tLoopOnce: 2200,\n\tLoopRepeat: 2201,\n\tLoopPingPong: 2202,\n\n\t// Interpolation\n\n\tInterpolateDiscrete: 2300,\n\tInterpolateLinear: 2301,\n\tInterpolateSmooth: 2302,\n\n\t// Interpolant ending modes\n\n\tZeroCurvatureEnding: 2400,\n\tZeroSlopeEnding: 2401,\n\tWrapAroundEnding: 2402,\n\n\t// Triangle Draw modes\n\n\tTrianglesDrawMode: 0,\n\tTriangleStripDrawMode: 1,\n\tTriangleFanDrawMode: 2,\n\n\t// Texture Encodings\n\n\tLinearEncoding: 3000, // No encoding at all.\n\tsRGBEncoding: 3001,\n\tGammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\n\n\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\n\t// These encodings should not specified as output encodings except in rare situations.\n\tRGBEEncoding: 3002, // AKA Radiance.\n\tLogLuvEncoding: 3003,\n\tRGBM7Encoding: 3004,\n\tRGBM16Encoding: 3005,\n\tRGBDEncoding: 3006, // MaxRange is 256.\n\n\t// Depth packing strategies\n\n\tBasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers\n\tRGBADepthPacking: 3201 // for packing into RGBA buffers.\n\n} );\n\n// File:src/math/Color.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Color = function ( r, g, b ) {\n\n\tif ( g === undefined && b === undefined ) {\n\n\t\t// r is THREE.Color, hex or string\n\t\treturn this.set( r );\n\n\t}\n\n\treturn this.setRGB( r, g, b );\n\n};\n\nTHREE.Color.prototype = {\n\n\tconstructor: THREE.Color,\n\n\tr: 1, g: 1, b: 1,\n\n\tset: function ( value ) {\n\n\t\tif ( value instanceof THREE.Color ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSL: function () {\n\n\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\tif ( t < 0 ) t += 1;\n\t\t\tif ( t > 1 ) t -= 1;\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\treturn p;\n\n\t\t}\n\n\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\th = THREE.Math.euclideanModulo( h, 1 );\n\t\t\ts = THREE.Math.clamp( s, 0, 1 );\n\t\t\tl = THREE.Math.clamp( l, 0, 1 );\n\n\t\t\tif ( s === 0 ) {\n\n\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t} else {\n\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetStyle: function ( style ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar m;\n\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tvar color;\n\t\t\tvar name = m[ 1 ];\n\t\t\tvar components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tvar hex = m[ 1 ];\n\t\t\tvar size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( style && style.length > 0 ) {\n\n\t\t\t// color keywords\n\t\t\tvar hex = THREE.ColorKeywords[ style ];\n\n\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t// red\n\t\t\t\tthis.setHex( hex );\n\n\t\t\t} else {\n\n\t\t\t\t// unknown color\n\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t},\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function () {\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tthis.r = r * r;\n\t\tthis.g = g * g;\n\t\tthis.b = b * b;\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function () {\n\n\t\tthis.r = Math.sqrt( this.r );\n\t\tthis.g = Math.sqrt( this.g );\n\t\tthis.b = Math.sqrt( this.b );\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetHexString: function () {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t},\n\n\tgetHSL: function ( optionalTarget ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tvar max = Math.max( r, g, b );\n\t\tvar min = Math.min( r, g, b );\n\n\t\tvar hue, saturation;\n\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tvar delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\thsl.h = hue;\n\t\thsl.s = saturation;\n\t\thsl.l = lightness;\n\n\t\treturn hsl;\n\n\t},\n\n\tgetStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\toffsetHSL: function ( h, s, l ) {\n\n\t\tvar hsl = this.getHSL();\n\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t},\n\n\taddColors: function ( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n};\n\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n// File:src/math/Quaternion.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Quaternion = function ( x, y, z, w ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Quaternion.prototype = {\n\n\tconstructor: THREE.Quaternion,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget w () {\n\n\t\treturn this._w;\n\n\t},\n\n\tset w ( value ) {\n\n\t\tthis._w = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t},\n\n\tcopy: function ( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( euler, update ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\tvar order = euler.order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromUnitVectors: function () {\n\n\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tvar v1, r;\n\n\t\tvar EPS = 0.000001;\n\n\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\tif ( r < EPS ) {\n\n\t\t\t\tr = 0;\n\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t}\n\n\t\t\tthis._x = v1.x;\n\t\t\tthis._y = v1.y;\n\t\t\tthis._z = v1.z;\n\t\t\tthis._w = r;\n\n\t\t\treturn this.normalize();\n\n\t\t};\n\n\t}(),\n\n\tinverse: function () {\n\n\t\treturn this.conjugate().normalize();\n\n\t},\n\n\tconjugate: function () {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t},\n\n\tpremultiply: function ( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t},\n\n\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tslerp: function ( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\nObject.assign( THREE.Quaternion, {\n\n\tslerp: function( qa, qb, qm, t ) {\n\n\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t},\n\n\tslerpFlat: function(\n\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tvar s = 1 - t,\n\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tvar tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n} );\n\n// File:src/math/Vector2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Vector2 = function ( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n};\n\nTHREE.Vector2.prototype = {\n\n\tconstructor: THREE.Vector2,\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t},\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t},\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t},\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t},\n\n\t//\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector2();\n\t\t\t\tmax = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t},\n\n\tlengthManhattan: function() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tangle: function () {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\treturn angle;\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\trotateAround: function ( center, angle ) {\n\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tvar x = this.x - center.x;\n\t\tvar y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author *kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector3 = function ( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n};\n\nTHREE.Vector3.prototype = {\n\n\tconstructor: THREE.Vector3,\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVectors: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyEuler: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyEuler( euler ) {\n\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyAxisAngle: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\tapplyProjection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 projection matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\n\t\treturn this;\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t},\n\n\tproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function project( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\tunproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function unproject( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\ttransformDirection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector3();\n\t\t\t\tmax = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tcross: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tthis.x = y * v.z - z * v.y;\n\t\tthis.y = z * v.x - x * v.z;\n\t\tthis.z = x * v.y - y * v.x;\n\n\t\treturn this;\n\n\t},\n\n\tcrossVectors: function ( a, b ) {\n\n\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t},\n\n\tprojectOnVector: function ( vector ) {\n\n\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\n\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\n\t},\n\n\tprojectOnPlane: function () {\n\n\t\tvar v1;\n\n\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( v1 );\n\n\t\t};\n\n\t}(),\n\n\treflect: function () {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\tvar v1;\n\n\t\treturn function reflect( normal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t};\n\n\t}(),\n\n\tangleTo: function ( v ) {\n\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t},\n\n\tsetFromSpherical: function( s ) {\n\n\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixPosition: function ( m ) {\n\n\t\treturn this.setFromMatrixColumn( m, 3 );\n\n\t},\n\n\tsetFromMatrixScale: function ( m ) {\n\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\tif ( typeof m === 'number' ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\tvar temp = m\n\t\t\tm = index;\n\t\t\tindex = temp;\n\n\t\t}\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector4.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector4 = function ( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Vector4.prototype = {\n\n\tconstructor: THREE.Vector4,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\tthis.w *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\t this.x = 1;\n\t\t\t this.y = 0;\n\t\t\t this.z = 0;\n\n\t\t} else {\n\n\t\t\t this.x = q.x / s;\n\t\t\t this.y = q.y / s;\n\t\t\t this.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector4();\n\t\t\t\tmax = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\t\tthis.w = attribute.array[ index + 3 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Euler.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Euler = function ( x, y, z, order ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._order = order || THREE.Euler.DefaultOrder;\n\n};\n\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nTHREE.Euler.DefaultOrder = 'XYZ';\n\nTHREE.Euler.prototype = {\n\n\tconstructor: THREE.Euler,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget order () {\n\n\t\treturn this._order;\n\n\t},\n\n\tset order ( value ) {\n\n\t\tthis._order = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order || this._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t},\n\n\tcopy: function ( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\tvar clamp = THREE.Math.clamp;\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._y = 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromQuaternion: function () {\n\n\t\tvar matrix;\n\n\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t};\n\n\t}(),\n\n\tsetFromVector3: function ( v, order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t},\n\n\treorder: function () {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\tvar q = new THREE.Quaternion();\n\n\t\treturn function reorder( newOrder ) {\n\n\t\t\tq.setFromEuler( this );\n\t\t\t\n\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t},\n\n\ttoVector3: function ( optionalResult ) {\n\n\t\tif ( optionalResult ) {\n\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t} else {\n\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\n\n\t\t}\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\n// File:src/math/Line3.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Line3 = function ( start, end ) {\n\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\n\n};\n\nTHREE.Line3.prototype = {\n\n\tconstructor: THREE.Line3,\n\n\tset: function ( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t},\n\n\tdelta: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.end, this.start );\n\n\t},\n\n\tdistanceSq: function () {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t},\n\n\tdistance: function () {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tclosestPointToPointParameter: function () {\n\n\t\tvar startP = new THREE.Vector3();\n\t\tvar startEnd = new THREE.Vector3();\n\n\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\tstartP.subVectors( point, this.start );\n\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\tif ( clampToLine ) {\n\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\n\n\t\t\t}\n\n\t\t\treturn t;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n};\n\n// File:src/math/Box2.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Box2 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\n\n};\n\nTHREE.Box2.prototype = {\n\n\tconstructor: THREE.Box2,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Box3.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Box3 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\n\n};\n\nTHREE.Box3.prototype = {\n\n\tconstructor: THREE.Box3,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromArray: function ( array ) {\n\n\t\tvar minX = + Infinity;\n\t\tvar minY = + Infinity;\n\t\tvar minZ = + Infinity;\n\n\t\tvar maxX = - Infinity;\n\t\tvar maxY = - Infinity;\n\t\tvar maxZ = - Infinity;\n\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tvar x = array[ i ];\n\t\t\tvar y = array[ i + 1 ];\n\t\t\tvar z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function () {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromObject( object ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\n\n\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\n\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\tv1.fromArray( positions, i );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsSphere: ( function () {\n\n\t\tvar closestPoint;\n\n\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\n\n\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t};\n\n\t} )(),\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tvar min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tgetBoundingSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\n\t\t\tresult.center = this.center();\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar points = [\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3()\n\t\t];\n\n\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t// transform of empty box is an empty box.\n\t\t\tif( this.isEmpty() ) return this;\n\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Matrix3.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n * @author tschw\n */\n\nTHREE.Matrix3 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0,\n\t\t0, 1, 0,\n\t\t0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix3.prototype = {\n\n\tconstructor: THREE.Matrix3,\n\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix4: function( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t},\n\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\tif ( matrix instanceof THREE.Matrix4 ) {\n\n\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n\t\t}\n\n\t\tvar me = matrix.elements,\n\t\t\tte = this.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t},\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Matrix4.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Matrix4 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix4.prototype = {\n\n\tconstructor: THREE.Matrix4,\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Matrix4().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tthis.elements.set( m.elements );\n\n\t\treturn this;\n\n\t},\n\n\tcopyPosition: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0,       0,       0,       1\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function () {\n\n\t\tvar v1;\n\n\t\treturn function extractRotation( m ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeRotationFromEuler: function ( euler ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\tte[ 4 ] = xy - wz;\n\t\tte[ 8 ] = xz + wy;\n\n\t\tte[ 1 ] = xy + wz;\n\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\tte[ 9 ] = yz - wx;\n\n\t\tte[ 2 ] = xz - wy;\n\t\tte[ 6 ] = yz + wx;\n\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function () {\n\n\t\tvar x, y, z;\n\n\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\tif ( x === undefined ) {\n\n\t\t\t\tx = new THREE.Vector3();\n\t\t\t\ty = new THREE.Vector3();\n\t\t\t\tz = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\tz.z = 1;\n\n\t\t\t}\n\n\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\tz.z += 0.0001;\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t}\n\n\t\t\ty.crossVectors( z, x );\n\n\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tpremultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyToArray: function ( a, b, r ) {\n\n\t\tvar te = this.elements;\n\n\t\tthis.multiplyMatrices( a, b );\n\n\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetPosition: function () {\n\n\t\tvar v1;\n\n\t\treturn function getPosition() {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t};\n\n\t}(),\n\n\tsetPosition: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 12 ] = v.x;\n\t\tte[ 13 ] = v.y;\n\t\tte[ 14 ] = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements,\n\t\t\tme = m.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t},\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0,  0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s,  c, 0,\n\t\t\t0, 0,  0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts,  c, 0, 0,\n\t\t\t0,  0, 1, 0,\n\t\t\t0,  0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function ( position, quaternion, scale ) {\n\n\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\tthis.scale( scale );\n\t\tthis.setPosition( position );\n\n\t\treturn this;\n\n\t},\n\n\tdecompose: function () {\n\n\t\tvar vector, matrix;\n\n\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tvector = new THREE.Vector3();\n\t\t\t\tmatrix = new THREE.Matrix4();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t// if determine is negative, we need to invert one scale\n\t\t\tvar det = this.determinant();\n\t\t\tif ( det < 0 ) {\n\n\t\t\t\tsx = - sx;\n\n\t\t\t}\n\n\t\t\tposition.x = te[ 12 ];\n\t\t\tposition.y = te[ 13 ];\n\t\t\tposition.z = te[ 14 ];\n\n\t\t\t// scale the rotation part\n\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\tvar invSX = 1 / sx;\n\t\t\tvar invSY = 1 / sy;\n\t\t\tvar invSZ = 1 / sz;\n\n\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\tvar ymin = - ymax;\n\t\tvar xmin = ymin * aspect;\n\t\tvar xmax = ymax * aspect;\n\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = 1.0 / ( right - left );\n\t\tvar h = 1.0 / ( top - bottom );\n\t\tvar p = 1.0 / ( far - near );\n\n\t\tvar x = ( right + left ) * w;\n\t\tvar y = ( top + bottom ) * h;\n\t\tvar z = ( far + near ) * p;\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( matrix ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = matrix.elements;\n\n\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Ray.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Ray = function ( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\n};\n\nTHREE.Ray.prototype = {\n\n\tconstructor: THREE.Ray,\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\tlookAt: function ( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\trecast: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function recast( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.subVectors( point, this.origin );\n\t\tvar directionDistance = result.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn result.copy( this.origin );\n\n\t\t}\n\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t},\n\n\tdistanceSqToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t// point behind the ray\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t}\n\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\treturn v1.distanceToSquared( point );\n\n\t\t};\n\n\t}(),\n\n\tdistanceSqToSegment: function () {\n\n\t\tvar segCenter = new THREE.Vector3();\n\t\tvar segDir = new THREE.Vector3();\n\t\tvar diff = new THREE.Vector3();\n\n\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\tvar c = diff.lengthSq();\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\tif ( det > 0 ) {\n\n\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\n\t\t};\n\n\t}(),\n\n\tintersectSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\tvar tca = v1.dot( this.direction );\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\tvar t0 = tca - thc;\n\n\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\tvar t1 = tca + thc;\n\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t// test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t :  null;\n\n\t},\n\n\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\tvar t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, optionalTarget );\n\n\t},\n\n\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tintersectBox: function ( box, optionalTarget ) {\n\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tvar invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tvar origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t},\n\n\tintersectsBox: ( function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t};\n\n\t} )(),\n\n\tintersectTriangle: function () {\n\n\t\t// Compute the offset origin, edges, and normal.\n\t\tvar diff = new THREE.Vector3();\n\t\tvar edge1 = new THREE.Vector3();\n\t\tvar edge2 = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\n\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\tedge1.subVectors( b, a );\n\t\t\tedge2.subVectors( c, a );\n\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\tvar sign;\n\n\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\tsign = 1;\n\n\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\tsign = - 1;\n\t\t\t\tDdN = - DdN;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tdiff.subVectors( this.origin, a );\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t// b1 < 0, no intersection\n\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t// b2 < 0, no intersection\n\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// b1+b2 > 1, no intersection\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Line intersects triangle, check if ray does.\n\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t// t < 0, no intersection\n\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Ray intersects triangle.\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.sub( this.origin );\n\t\tthis.direction.normalize();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n};\n\n// File:src/math/Sphere.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Sphere = function ( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n};\n\nTHREE.Sphere.prototype = {\n\n\tconstructor: THREE.Sphere,\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function () {\n\n\t\tvar box = new THREE.Box3();\n\n\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\tvar center = this.center;\n\n\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromPoints( points ).center( center );\n\n\t\t\t}\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We use the following equation to compute the signed distance from\n\t\t// the center of the sphere to the plane.\n\t\t//\n\t\t// distance = q * n - d\n\t\t//\n\t\t// If this distance is greater than the radius of the sphere,\n\t\t// then there is no intersection.\n\n\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tresult.sub( this.center ).normalize();\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\tvar box = optionalTarget || new THREE.Box3();\n\n\t\tbox.set( this.center, this.center );\n\t\tbox.expandByScalar( this.radius );\n\n\t\treturn box;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n};\n\n// File:src/math/Frustum.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://clara.io\n */\n\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\n\tthis.planes = [\n\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\n\t];\n\n};\n\nTHREE.Frustum.prototype = {\n\n\tconstructor: THREE.Frustum,\n\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tvar planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( frustum ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix: function ( m ) {\n\n\t\tvar planes = this.planes;\n\t\tvar me = m.elements;\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\tintersectsObject: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsObject( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSprite: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar planes = this.planes;\n\t\tvar center = sphere.center;\n\t\tvar negRadius = - sphere.radius;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsBox: function () {\n\n\t\tvar p1 = new THREE.Vector3(),\n\t\t\tp2 = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\n\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t}(),\n\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n};\n\n// File:src/math/Plane.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Plane = function ( normal, constant ) {\n\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n};\n\nTHREE.Plane.prototype = {\n\n\tconstructor: THREE.Plane,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t},\n\n\torthoPoint: function ( point, optionalTarget ) {\n\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t},\n\n\tintersectLine: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tvar direction = line.delta( v1 );\n\n\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t};\n\n\t}(),\n\n\tintersectsLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t},\n\n\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar m1 = new THREE.Matrix3();\n\n\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t// transform normal based on theory here:\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n};\n\n// File:src/math/Spherical.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The poles (phi) are at the positive and negative y axis.\n * The equator starts at positive z.\n */\n\nTHREE.Spherical = function ( radius, phi, theta ) {\n\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\treturn this;\n\n};\n\nTHREE.Spherical.prototype = {\n\n\tconstructor: THREE.Spherical,\n\n\tset: function ( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( other ) {\n\n\t\tthis.radius.copy( other.radius );\n\t\tthis.phi.copy( other.phi );\n\t\tthis.theta.copy( other.theta );\n\n\t\treturn this;\n\n\t},\n\n\t// restrict phi to be betwee EPS and PI-EPS\n\tmakeSafe: function() {\n\n\t\tvar EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromVector3: function( vec3 ) {\n\n\t\tthis.radius = vec3.length();\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n};\n\n// File:src/math/Math.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Math = {\n\n\tDEG2RAD: Math.PI / 180,\n\tRAD2DEG: 180 / Math.PI,\n\n\tgenerateUUID: function () {\n\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\tvar uuid = new Array( 36 );\n\t\tvar rnd = 0, r;\n\n\t\treturn function generateUUID() {\n\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n\t\t\t\t\tuuid[ i ] = '-';\n\n\t\t\t\t} else if ( i === 14 ) {\n\n\t\t\t\t\tuuid[ i ] = '4';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uuid.join( '' );\n\n\t\t};\n\n\t}(),\n\n\tclamp: function ( value, min, max ) {\n\n\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t},\n\n\t// compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\teuclideanModulo: function ( n, m ) {\n\n\t\treturn ( ( n % m ) + m ) % m;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * ( 3 - 2 * x );\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t},\n\n\trandom16: function () {\n\n\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\treturn Math.random();\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tdegToRad: function ( degrees ) {\n\n\t\treturn degrees * THREE.Math.DEG2RAD;\n\n\t},\n\n\tradToDeg: function ( radians ) {\n\n\t\treturn radians * THREE.Math.RAD2DEG;\n\n\t},\n\n\tisPowerOfTwo: function ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t},\n\n\tnearestPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n\t},\n\n\tnextPowerOfTwo: function ( value ) {\n\n\t\tvalue --;\n\t\tvalue |= value >> 1;\n\t\tvalue |= value >> 2;\n\t\tvalue |= value >> 4;\n\t\tvalue |= value >> 8;\n\t\tvalue |= value >> 16;\n\t\tvalue ++;\n\n\t\treturn value;\n\n\t}\n\n};\n\n// File:src/math/Spline.js\n\n/**\n * Spline from Tween.js, slightly optimized (and trashed)\n * http://sole.github.com/tween.js/examples/05_spline.html\n *\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Spline = function ( points ) {\n\n\tthis.points = points;\n\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tthis.initFromArray = function ( a ) {\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t}\n\n\t};\n\n\tthis.getPoint = function ( k ) {\n\n\t\tpoint = ( this.points.length - 1 ) * k;\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\tpa = this.points[ c[ 0 ] ];\n\t\tpb = this.points[ c[ 1 ] ];\n\t\tpc = this.points[ c[ 2 ] ];\n\t\tpd = this.points[ c[ 3 ] ];\n\n\t\tw2 = weight * weight;\n\t\tw3 = weight * w2;\n\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\treturn v3;\n\n\t};\n\n\tthis.getControlPointsArray = function () {\n\n\t\tvar i, p, l = this.points.length,\n\t\t\tcoords = [];\n\n\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\tp = this.points[ i ];\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t}\n\n\t\treturn coords;\n\n\t};\n\n\t// approximate length by summing linear segments\n\n\tthis.getLength = function ( nSubDivisions ) {\n\n\t\tvar i, index, nSamples, position,\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\toldPosition = new THREE.Vector3(),\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tchunkLengths = [],\n\t\t\ttotalLength = 0;\n\n\t\t// first point has 0 length\n\n\t\tchunkLengths[ 0 ] = 0;\n\n\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\n\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\tindex = i / nSamples;\n\n\t\t\tposition = this.getPoint( index );\n\t\t\ttmpVec.copy( position );\n\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\toldPosition.copy( position );\n\n\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\tintPoint = Math.floor( point );\n\n\t\t\tif ( intPoint !== oldIntPoint ) {\n\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// last point ends with total length\n\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t};\n\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\tvar i, j,\n\t\t\tindex, indexCurrent, indexNext,\n\t\t\trealDistance,\n\t\t\tsampling, position,\n\t\t\tnewpoints = [],\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tsl = this.getLength();\n\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t}\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t}\n\n\t\tthis.points = newpoints;\n\n\t};\n\n\t// Catmull-Rom\n\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/math/Triangle.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Triangle = function ( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\n};\n\nTHREE.Triangle.normal = function () {\n\n\tvar v0 = new THREE.Vector3();\n\n\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.subVectors( c, b );\n\t\tv0.subVectors( a, b );\n\t\tresult.cross( v0 );\n\n\t\tvar resultLengthSq = result.lengthSq();\n\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t}\n\n\t\treturn result.set( 0, 0, 0 );\n\n\t};\n\n}();\n\n// static/instance method to calculate barycentric coordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\nTHREE.Triangle.barycoordFromPoint = function () {\n\n\tvar v0 = new THREE.Vector3();\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\n\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\tv0.subVectors( c, a );\n\t\tv1.subVectors( b, a );\n\t\tv2.subVectors( point, a );\n\n\t\tvar dot00 = v0.dot( v0 );\n\t\tvar dot01 = v0.dot( v1 );\n\t\tvar dot02 = v0.dot( v2 );\n\t\tvar dot11 = v1.dot( v1 );\n\t\tvar dot12 = v1.dot( v2 );\n\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tvar invDenom = 1 / denom;\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn result.set( 1 - u - v, v, u );\n\n\t};\n\n}();\n\nTHREE.Triangle.containsPoint = function () {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function containsPoint( point, a, b, c ) {\n\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t};\n\n}();\n\nTHREE.Triangle.prototype = {\n\n\tconstructor: THREE.Triangle,\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tarea: function () {\n\n\t\tvar v0 = new THREE.Vector3();\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function area() {\n\n\t\t\tv0.subVectors( this.c, this.b );\n\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t};\n\n\t}(),\n\n\tmidpoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tnormal: function ( optionalTarget ) {\n\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tplane: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Plane();\n\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tclosestPointToPoint: function () {\n\n\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\n\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\tif ( plane === undefined ) {\n\n\t\t\t\tplane = new THREE.Plane();\n\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\n\t\t\t\tprojectedPoint = new THREE.Vector3();\n\t\t\t\tclosestPoint = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\tvar minDistance = Infinity;\n\n\t\t\t// project the point onto the plane of the triangle\n\n\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t// check if the projection lies within the triangle\n\n\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t// if so, this is the closest point\n\n\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t} else {\n\n\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\tif( distance < minDistance ) {\n\n\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n};\n\n// File:src/math/Interpolant.js\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n * @author tschw\n */\n\nTHREE.Interpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tthis.parameterPositions = parameterPositions;\n\tthis._cachedIndex = 0;\n\n\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\tthis.sampleValues = sampleValues;\n\tthis.valueSize = sampleSize;\n\n};\n\nTHREE.Interpolant.prototype = {\n\n\tconstructor: THREE.Interpolant,\n\n\tevaluate: function( t ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\ti1 = this._cachedIndex,\n\n\t\t\tt1 = pp[   i1   ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tvar right;\n\n\t\t\t\tlinear_scan: {\n//- See http://jsperf.com/comparison-to-undefined/3\n//- slower code:\n//-\n//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n//- slower code:\n//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t},\n\n\tsettings: null, // optional, subclass-specific settings structure\n\t// Note: The indirection allows central control of many interpolants.\n\n\t// --- Protected interface\n\n\tDefaultSettings_: {},\n\n\tgetSettings_: function() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t},\n\n\tcopySampleValue_: function( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Template methods for derived classes:\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tthrow new Error( \"call to abstract method\" );\n\t\t// implementations shall return this.resultBuffer\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t// empty\n\n\t}\n\n};\n\nObject.assign( THREE.Interpolant.prototype, {\n\n\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_,\n\n\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_\n\n} );\n\n// File:src/math/interpolants/CubicInterpolant.js\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n *\n * @author tschw\n */\n\nTHREE.CubicInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\tthis._weightPrev = -0;\n\tthis._offsetPrev = -0;\n\tthis._weightNext = -0;\n\tthis._offsetNext = -0;\n\n};\n\nTHREE.CubicInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.CubicInterpolant,\n\n\tDefaultSettings_: {\n\n\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\tiPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t},\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/DiscreteInterpolant.js\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n *\n * @author tschw\n */\n\nTHREE.DiscreteInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.DiscreteInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.DiscreteInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n} );\n\n// File:src/math/interpolants/LinearInterpolant.js\n\n/**\n * @author tschw\n */\n\nTHREE.LinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.LinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.LinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/QuaternionLinearInterpolant.js\n\n/**\n * Spherical linear unit quaternion interpolant.\n *\n * @author tschw\n */\n\nTHREE.QuaternionLinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.QuaternionLinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.QuaternionLinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset = i1 * stride,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\n\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/core/Clock.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Clock = function ( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n};\n\nTHREE.Clock.prototype = {\n\n\tconstructor: THREE.Clock,\n\n\tstart: function () {\n\n\t\tthis.startTime = ( performance || Date ).now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.running = true;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\n\t},\n\n\tgetElapsedTime: function () {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t},\n\n\tgetDelta: function () {\n\n\t\tvar diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tvar newTime = ( performance || Date ).now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n};\n\n// File:src/core/EventDispatcher.js\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nTHREE.EventDispatcher = function () {};\n\nObject.assign( THREE.EventDispatcher.prototype, {\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function ( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\tvar array = [], i = 0;\n\t\t\tvar length = listenerArray.length;\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/core/Layers.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Layers = function () {\n\n\tthis.mask = 1;\n\n};\n\nTHREE.Layers.prototype = {\n\n\tconstructor: THREE.Layers,\n\n\tset: function ( channel ) {\n\n\t\tthis.mask = 1 << channel;\n\n\t},\n\n\tenable: function ( channel ) {\n\n\t\tthis.mask |= 1 << channel;\n\n\t},\n\n\ttoggle: function ( channel ) {\n\n\t\tthis.mask ^= 1 << channel;\n\n\t},\n\n\tdisable: function ( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel );\n\n\t},\n\n\ttest: function ( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n};\n\n// File:src/core/Raycaster.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://clara.io/\n * @author stephomi / http://stephaneginier.com/\n */\n\n( function ( THREE ) {\n\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\n\t\tthis.ray = new THREE.Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t};\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tTHREE.Raycaster.prototype = {\n\n\t\tconstructor: THREE.Raycaster,\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t};\n\n}( THREE ) );\n\n// File:src/core/Object3D.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author elephantatwork / www.elephantatwork.ch\n */\n\nTHREE.Object3D = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Object3D';\n\n\tthis.parent = null;\n\tthis.children = [];\n\n\tthis.up = THREE.Object3D.DefaultUp.clone();\n\n\tvar position = new THREE.Vector3();\n\tvar rotation = new THREE.Euler();\n\tvar quaternion = new THREE.Quaternion();\n\tvar scale = new THREE.Vector3( 1, 1, 1 );\n\n\tfunction onRotationChange() {\n\n\t\tquaternion.setFromEuler( rotation, false );\n\n\t}\n\n\tfunction onQuaternionChange() {\n\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t}\n\n\trotation.onChange( onRotationChange );\n\tquaternion.onChange( onQuaternionChange );\n\n\tObject.defineProperties( this, {\n\t\tposition: {\n\t\t\tenumerable: true,\n\t\t\tvalue: position\n\t\t},\n\t\trotation: {\n\t\t\tenumerable: true,\n\t\t\tvalue: rotation\n\t\t},\n\t\tquaternion: {\n\t\t\tenumerable: true,\n\t\t\tvalue: quaternion\n\t\t},\n\t\tscale: {\n\t\t\tenumerable: true,\n\t\t\tvalue: scale\n\t\t},\n\t\tmodelViewMatrix: {\n\t\t\tvalue: new THREE.Matrix4()\n\t\t},\n\t\tnormalMatrix: {\n\t\t\tvalue: new THREE.Matrix3()\n\t\t}\n\t} );\n\n\tthis.matrix = new THREE.Matrix4();\n\tthis.matrixWorld = new THREE.Matrix4();\n\n\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\n\tthis.matrixWorldNeedsUpdate = false;\n\n\tthis.layers = new THREE.Layers();\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\tthis.renderOrder = 0;\n\n\tthis.userData = {};\n\n};\n\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\n\nObject.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t},\n\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t},\n\n\tsetRotationFromEuler: function ( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t},\n\n\tsetRotationFromMatrix: function ( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t},\n\n\trotateOnAxis: function () {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar q1 = new THREE.Quaternion();\n\n\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\ttranslateOnAxis: function () {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function translateX( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function translateY( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function translateZ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function () {\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function worldToLocal( vector ) {\n\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object instanceof THREE.Object3D ) {\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\tthis.children.push( object );\n\n\t\t} else {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t}\n\n\t},\n\n\tgetObjectById: function ( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t},\n\n\tgetObjectByName: function ( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t},\n\n\tgetObjectByProperty: function ( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t},\n\n\tgetWorldQuaternion: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar scale = new THREE.Vector3();\n\n\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Quaternion();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldRotation: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Euler();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t};\n\n\t}(),\n\n\tgetWorldScale: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldDirection: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t};\n\n\t}(),\n\n\traycast: function () {},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseVisible: function ( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseAncestors: function ( callback ) {\n\n\t\tvar parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\t// meta is '' when called from JSON.stringify\n\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\n\t\tvar output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tvar object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\n\t\tobject.matrix = this.matrix.toArray();\n\n\t\t//\n\n\t\tif ( this.geometry !== undefined ) {\n\n\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.geometry = this.geometry.uuid;\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\n\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.material = this.material.uuid;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\t\t\treturn values;\n\n\t\t}\n\n\t},\n\n\tclone: function ( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t},\n\n\tcopy: function ( source, recursive ) {\n\n\t\tif ( recursive === undefined ) recursive = true;\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tvar child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\nTHREE.Object3DIdCount = 0;\n\n// File:src/core/Face3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n};\n\nTHREE.Face3.prototype = {\n\n\tconstructor: THREE.Face3,\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.a = source.a;\n\t\tthis.b = source.b;\n\t\tthis.c = source.c;\n\n\t\tthis.normal.copy( source.normal );\n\t\tthis.color.copy( source.color );\n\n\t\tthis.materialIndex = source.materialIndex;\n\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/BufferAttribute.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.itemSize = itemSize;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\tthis.normalized = normalized === true;\n\n};\n\nTHREE.BufferAttribute.prototype = {\n\n\tconstructor: THREE.BufferAttribute,\n\n\tget count() {\n\n\t\treturn this.array.length / this.itemSize;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyArray: function ( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t},\n\n\tcopyColorsArray: function ( colors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\tvar color = colors[ i ];\n\n\t\t\tif ( color === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\tcolor = new THREE.Color();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = color.r;\n\t\t\tarray[ offset ++ ] = color.g;\n\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyIndicesArray: function ( indices ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tvar index = indices[ i ];\n\n\t\t\tarray[ offset ++ ] = index.a;\n\t\t\tarray[ offset ++ ] = index.b;\n\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector2sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector3sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector4sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize ];\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n//\n\nTHREE.Int8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\n};\n\nTHREE.Int16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\n\n};\n\nTHREE.Uint16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\n\n};\n\nTHREE.Int32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\n\n};\n\nTHREE.Uint32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\n\n};\n\nTHREE.Float32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\n\n};\n\nTHREE.Float64Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\n\n};\n\n\n// Deprecated\n\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\n\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\n\n};\n\n// File:src/core/InstancedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\n\n\tTHREE.BufferAttribute.call( this, array, itemSize );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\n\nTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\n\n\tTHREE.BufferAttribute.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBuffer = function ( array, stride ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.stride = stride;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n};\n\nTHREE.InterleavedBuffer.prototype = {\n\n\tconstructor: THREE.InterleavedBuffer,\n\n\tget length () {\n\n\t\treturn this.array.length;\n\n\t},\n\n\tget count () {\n\n\t\treturn this.array.length / this.stride;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.stride = source.stride;\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n// File:src/core/InstancedInterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\n\n\tTHREE.InterleavedBuffer.call( this, array, stride );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\n\nTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.data = interleavedBuffer;\n\tthis.itemSize = itemSize;\n\tthis.offset = offset;\n\n};\n\n\nTHREE.InterleavedBufferAttribute.prototype = {\n\n\tconstructor: THREE.InterleavedBufferAttribute,\n\n\tget length() {\n\n\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\treturn this.array.length;\n\n\t},\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/Geometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://clara.io\n */\n\nTHREE.Geometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [ [] ];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.elementsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tvar scope = this;\n\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tvar tempNormals = [];\n\t\tvar tempUVs = [];\n\t\tvar tempUVs2 = [];\n\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( indices !== undefined ) {\n\n\t\t\tvar groups = geometry.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tvar center = this.boundingSphere.center;\n\t\tvar radius = this.boundingSphere.radius;\n\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tvar matrix = new THREE.Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\tvertices = new Array( this.vertices.length );\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new THREE.Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t},\n\n\tcomputeLineDistances: function () {\n\n\t\tvar d = 0;\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tif ( i > 0 ) {\n\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\tif ( geometry instanceof THREE.Geometry === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalMatrix,\n\t\tvertexOffset = this.vertices.length,\n\t\tvertices1 = this.vertices,\n\t\tvertices2 = geometry.vertices,\n\t\tfaces1 = this.faces,\n\t\tfaces2 = geometry.faces,\n\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tif ( uv === undefined ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( mesh instanceof THREE.Mesh === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i, il, face;\n\t\tvar indices, j, jl;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\tvar dupIndex = - 1;\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tdupIndex = n;\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tvar faces = this.faces;\n\t\tvar length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tvar newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tvar faces = [];\n\t\tvar normals = [];\n\t\tvar normalsHash = {};\n\t\tvar colors = [];\n\t\tvar colorsHash = {};\n\t\tvar uvs = [];\n\t\tvar uvsHash = {};\n\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tvar hasMaterial = true;\n\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tvar faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.vertices = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\n\t\tvar vertices = source.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\tvar faces = source.faces;\n\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.GeometryIdCount = 0;\n\n// File:src/core/DirectGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'DirectGeometry';\n\n\tthis.indices = [];\n\tthis.vertices = [];\n\tthis.normals = [];\n\tthis.colors = [];\n\tthis.uvs = [];\n\tthis.uvs2 = [];\n\n\tthis.groups = [];\n\n\tthis.morphTargets = {};\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\t// this.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\n\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\n\n\tcomputeFaceNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeGroups: function ( geometry ) {\n\n\t\tvar group;\n\t\tvar groups = [];\n\t\tvar materialIndex;\n\n\t\tvar faces = geometry.faces;\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tvar faces = geometry.faces;\n\t\tvar vertices = geometry.vertices;\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tvar morphTargets = geometry.morphTargets;\n\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\tvar morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tvar morphNormals = geometry.morphNormals;\n\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\tvar morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tvar skinIndices = geometry.skinIndices;\n\t\tvar skinWeights = geometry.skinWeights;\n\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/core/BufferGeometry.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n};\n\nObject.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tthis.index = index;\n\n\t},\n\n\taddAttribute: function ( name, attribute ) {\n\n\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( name === 'index' ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\tthis.setIndex( attribute );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tremoveAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tvar normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tsetFromObject: function ( object ) {\n\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\n\n\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\n\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tupdateFromObject: function ( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\tif ( direct === undefined ) {\n\n\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\tgeometry = direct;\n\n\t\t}\n\n\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.position;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.normal;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.color;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\tvar attribute = this.attributes.uv;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\tvar attribute = this.attributes.lineDistance;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\n\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t},\n\n\tfromDirectGeometry: function ( geometry ) {\n\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tthis.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tvar positions = this.attributes.position.array;\n\n\t\tif ( positions !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromArray( positions );\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar box = new THREE.Box3();\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function computeBoundingSphere() {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes.position;\n\n\t\t\tif ( positions ) {\n\n\t\t\t\tvar array = positions.array;\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tbox.setFromArray( array );\n\t\t\t\tbox.center( center );\n\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tvar index = this.index;\n\t\tvar attributes = this.attributes;\n\t\tvar groups = this.groups;\n\n\t\tif ( attributes.position ) {\n\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar normals = attributes.normal.array;\n\n\t\t\tvar vA, vB, vC,\n\n\t\t\tpA = new THREE.Vector3(),\n\t\t\tpB = new THREE.Vector3(),\n\t\t\tpC = new THREE.Vector3(),\n\n\t\t\tcb = new THREE.Vector3(),\n\t\t\tab = new THREE.Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tvar attribute1 = attributes[ key ];\n\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar normals = this.attributes.normal.array;\n\n\t\tvar x, y, z, n;\n\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\tx = normals[ i ];\n\t\t\ty = normals[ i + 1 ];\n\t\t\tz = normals[ i + 2 ];\n\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\tnormals[ i ] *= n;\n\t\t\tnormals[ i + 1 ] *= n;\n\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t}\n\n\t},\n\n\ttoNonIndexed: function () {\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar geometry2 = new THREE.BufferGeometry();\n\n\t\tvar indices = this.index.array;\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tvar index = 0, index2 = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tdata.data = { attributes: {} };\n\n\t\tvar index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: array\n\t\t\t};\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: attribute.normalized\n\t\t\t};\n\n\t\t}\n\n\t\tvar groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tvar boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.BufferGeometry.MaxIndex = 65535;\n\n// File:src/core/InstancedBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferGeometry = function () {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'InstancedBufferGeometry';\n\tthis.maxInstancedCount = undefined;\n\n};\n\nTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\n\nTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\n\n\tthis.groups.push( {\n\n\t\tstart: start,\n\t\tcount: count,\n\t\tinstances: instances\n\n\t} );\n\n};\n\nTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\n\n\tvar index = source.index;\n\n\tif ( index !== null ) {\n\n\t\tthis.setIndex( index.clone() );\n\n\t}\n\n\tvar attributes = source.attributes;\n\n\tfor ( var name in attributes ) {\n\n\t\tvar attribute = attributes[ name ];\n\t\tthis.addAttribute( name, attribute.clone() );\n\n\t}\n\n\tvar groups = source.groups;\n\n\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tvar group = groups[ i ];\n\t\tthis.addGroup( group.start, group.count, group.instances );\n\n\t}\n\n\treturn this;\n\n};\n\n// File:src/core/Uniform.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Uniform = function ( value ) {\n\n\tif ( typeof value === 'string' ) {\n\n\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\tvalue = arguments[ 1 ];\n\n\t}\n\n\tthis.value = value;\n\n\tthis.dynamic = false;\n\n};\n\nTHREE.Uniform.prototype = {\n\n\tconstructor: THREE.Uniform,\n\n\tonUpdate: function ( callback ) {\n\n\t\tthis.dynamic = true;\n\t\tthis.onUpdateCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/animation/AnimationAction.js\n\n/**\n *\n * Action provided by AnimationMixer for scheduling clip playback on specific\n * objects.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n *\n */\n\nTHREE.AnimationAction = function() {\n\n\tthrow new Error( \"THREE.AnimationAction: \" +\n\t\t\t\"Use mixer.clipAction for construction.\" );\n\n};\n\nTHREE.AnimationAction._new =\n\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\tthis._mixer = mixer;\n\tthis._clip = clip;\n\tthis._localRoot = localRoot || null;\n\n\tvar tracks = clip.tracks,\n\t\tnTracks = tracks.length,\n\t\tinterpolants = new Array( nTracks );\n\n\tvar interpolantSettings = {\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\t};\n\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\tinterpolants[ i ] = interpolant;\n\t\tinterpolant.settings = interpolantSettings;\n\n\t}\n\n\tthis._interpolantSettings = interpolantSettings;\n\n\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t// inside: PropertyMixer (managed by the mixer)\n\tthis._propertyBindings = new Array( nTracks );\n\n\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\tthis._timeScaleInterpolant = null;\n\tthis._weightInterpolant = null;\n\n\tthis.loop = THREE.LoopRepeat;\n\tthis._loopCount = -1;\n\n\t// global mixer time when the action is to be started\n\t// it's set back to 'null' upon start of the action\n\tthis._startTime = null;\n\n\t// scaled local time of the action\n\t// gets clamped or wrapped to 0..clip.duration according to loop\n\tthis.time = 0;\n\n\tthis.timeScale = 1;\n\tthis._effectiveTimeScale = 1;\n\n\tthis.weight = 1;\n\tthis._effectiveWeight = 1;\n\n\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\n\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n};\n\nTHREE.AnimationAction._new.prototype = {\n\n\tconstructor: THREE.AnimationAction._new,\n\n\t// State & Scheduling\n\n\tplay: function() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t},\n\n\tstop: function() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t},\n\n\treset: function() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0;\t\t\t// restart clip\n\t\tthis._loopCount = -1;\t// forget previous loops\n\t\tthis._startTime = null;\t// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t},\n\n\tisRunning: function() {\n\n\t\tvar start = this._startTime;\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t},\n\n\t// return true when play has been called\n\tisScheduled: function() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t},\n\n\tstartAt: function( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t},\n\n\tsetLoop: function( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t},\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight: function( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t},\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight: function() {\n\n\t\treturn this._effectiveWeight;\n\n\t},\n\n\tfadeIn: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t},\n\n\tfadeOut: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t},\n\n\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n\t\tvar mixer = this._mixer;\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif( warp ) {\n\n\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t},\n\n\tstopFading: function() {\n\n\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Time Scale Control\n\n\t// set the weight stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale: function( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale: function() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t},\n\n\tsetDuration: function( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\tsyncWith: function( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\thalt: function( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t},\n\n\twarp: function( startTimeScale, endTimeScale, duration ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t},\n\n\tstopWarping: function() {\n\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Object Accessors\n\n\tgetMixer: function() {\n\n\t\treturn this._mixer;\n\n\t},\n\n\tgetClip: function() {\n\n\t\treturn this._clip;\n\n\t},\n\n\tgetRoot: function() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t},\n\n\t// Interna\n\n\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t// called by the mixer\n\n\t\tvar startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tvar weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tvar interpolants = this._interpolants;\n\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_updateWeight: function( time ) {\n\n\t\tvar weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t},\n\n\t_updateTimeScale: function( time ) {\n\n\t\tvar timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t},\n\n\t_updateTime: function( deltaTime ) {\n\n\t\tvar time = this.time + deltaTime;\n\n\t\tif ( deltaTime === 0 ) return time;\n\n\t\tvar duration = this._clip.duration,\n\n\t\t\tloop = this.loop,\n\t\t\tloopCount = this._loopCount;\n\n\t\tif ( loop === THREE.LoopOnce ) {\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tthis.loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else break handle_stop;\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tvar pingPong = ( loop === THREE.LoopPingPong );\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t// wrap around\n\n\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\tthis.time = time;\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.time = time;\n\t\treturn time;\n\n\t},\n\n\t_setEndings: function( atStart, atEnd, pingPong ) {\n\n\t\tvar settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\n\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationClip.js\n\n/**\n *\n * Reusable set of Tracks that represent an animation.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationClip = function ( name, duration, tracks ) {\n\n\tthis.name = name;\n\tthis.tracks = tracks;\n\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// this means it should figure out its duration by scanning the tracks\n\tif ( this.duration < 0 ) {\n\n\t\tthis.resetDuration();\n\n\t}\n\n\t// maybe only do these on demand, as doing them here could potentially slow down loading\n\t// but leaving these here during development as this ensures a lot of testing of these functions\n\tthis.trim();\n\tthis.optimize();\n\n};\n\nTHREE.AnimationClip.prototype = {\n\n\tconstructor: THREE.AnimationClip,\n\n\tresetDuration: function() {\n\n\t\tvar tracks = this.tracks,\n\t\t\tduration = 0;\n\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tvar track = this.tracks[ i ];\n\n\t\t\tduration = Math.max(\n\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t},\n\n\ttrim: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\toptimize: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.AnimationClip, {\n\n\tparse: function( json ) {\n\n\t\tvar tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\n\n\t},\n\n\n\ttoJSON: function( clip ) {\n\n\t\tvar tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tvar json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks\n\n\t\t};\n\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t},\n\n\n\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tvar times = [];\n\t\t\tvar values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\ti,\n\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\t\tnew THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\ttimes, values\n\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t}\n\n\t\treturn new THREE.AnimationClip( name, -1, tracks );\n\n\t},\n\n\tfindByName: function( objectOrClipArray, name ) {\n\n\t\tvar clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tvar o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\n\t\tvar animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar clips = [];\n\n\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t},\n\n\t// parse the animation.hierarchy format\n\tparseAnimation: function( animation, bones, nodeName ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar addNonemptyTrack = function(\n\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\tTHREE.AnimationUtils.flattenJSON(\n\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar tracks = [];\n\n\t\tvar clipName = animation.name || 'default';\n\t\t// automatic length determination in AnimationClip.\n\t\tvar duration = animation.length || -1;\n\t\tvar fps = animation.fps || 30;\n\n\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets in a way exactly compatible\n\t\t\t// with AnimationHandler.init( animation )\n\t\t\tif ( animationKeys[0].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tvar morphTargetNames = {};\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\n\n\t\treturn clip;\n\n\t}\n\n} );\n\n// File:src/animation/AnimationMixer.js\n\n/**\n *\n * Player for AnimationClips.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.AnimationMixer = function( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n};\n\nObject.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\tprototypeAction = null;\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tvar existingAction =\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tvar newAction = new THREE.\n\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function() {\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tthis._nActiveActions = 0;\n\t\tthis._nActiveBindings = 0;\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tactions[ i ].reset();\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].useCount = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tvar action = actions[ i ];\n\n\t\t\tif ( action.enabled ) {\n\n\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tvar bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function() {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function( clip ) {\n\n\t\tvar actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function( root ) {\n\n\t\tvar rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function( clip, optionalRoot ) {\n\n\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\nTHREE.AnimationMixer._Action = THREE.AnimationAction._new;\n\n// Implementation details:\n\nObject.assign( THREE.AnimationMixer.prototype, {\n\n\t_bindAction: function( action, prototypeAction ) {\n\n\t\tvar root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar track = tracks[ i ],\n\t\t\t\ttrackName = track.name,\n\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new THREE.PropertyMixer(\n\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\n\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for _Action objects\n\n\t_isActiveAction: function( action ) {\n\n\t\tvar index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\n\t\tvar actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function( action ) {\n\n\t\tvar actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tvar clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function( action ) {\n\n\t\tvar bindings = action._propertyBindings;\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tvar binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tbindings = this._bindings;\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tremove_empty_map: {\n\n\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function() {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new THREE.LinearInterpolant(\n\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function( interpolant ) {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\n} );\n\n// File:src/animation/AnimationObjectGroup.js\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n * \t-\tAdd objects you would otherwise pass as 'root' to the\n * \t\tconstructor or the .clipAction method of AnimationMixer.\n *\n * \t-\tInstead pass this object as 'root'.\n *\n * \t-\tYou can also add and remove objects later when the mixer\n * \t\tis running.\n *\n * Note:\n *\n *  \tObjects of this class appear as one object to the mixer,\n *  \tso cache control of the individual objects must be done\n *  \ton the group.\n *\n * Limitation:\n *\n * \t- \tThe animated properties must be compatible among the\n * \t\tall objects in the group.\n *\n *  -\tA single property can either be controlled through a\n *  \ttarget group or directly, but not both.\n *\n * @author tschw\n */\n\nTHREE.AnimationObjectGroup = function( var_args ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// cached objects followed by the active ones\n\tthis._objects = Array.prototype.slice.call( arguments );\n\n\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t// note: read by PropertyBinding.Composite\n\n\tvar indices = {};\n\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t}\n\n\tthis._paths = [];\t\t\t\t\t// inside: string\n\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\tvar scope = this;\n\n\tthis.stats = {\n\n\t\tobjects: {\n\t\t\tget total() { return scope._objects.length; },\n\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t},\n\n\t\tget bindingsPerObject() { return scope._bindings.length; }\n\n\t};\n\n};\n\nTHREE.AnimationObjectGroup.prototype = {\n\n\tconstructor: THREE.AnimationObjectGroup,\n\n\tadd: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\tnew THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tvar knownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject) {\n\n\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\tremove: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// remove & forget\n\tuncache: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_: function( path, parsedPath ) {\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ],\n\t\t\tbindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tvar paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( var i = nCachedObjects,\n\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\n\t\t\tvar object = objects[ i ];\n\n\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t},\n\n\tunsubscribe_: function( path ) {\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationUtils.js\n\n/**\n * @author tschw\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function( array, from, to ) {\n\n\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tvar n = times.length;\n\t\tvar result = new Array( n );\n\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function( values, stride, order ) {\n\n\t\tvar nValues = values.length;\n\t\tvar result = new values.constructor( nValues );\n\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tvar value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/KeyframeTrack.js\n\n/**\n *\n * A timed sequence of keyframes for a specific property.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\n\tif( times === undefined || times.length === 0 ) {\n\n\t\tthrow new Error( \"no keyframes in track named \" + name );\n\n\t}\n\n\tthis.name = name;\n\n\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\n\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\tthis.validate();\n\tthis.optimize();\n\n};\n\nTHREE.KeyframeTrack.prototype = {\n\n\tconstructor: THREE.KeyframeTrack,\n\n\tTimeBufferType: Float32Array,\n\tValueBufferType: Float32Array,\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodDiscrete: function( result ) {\n\n\t\treturn new THREE.DiscreteInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.LinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: function( result ) {\n\n\t\treturn new THREE.CubicInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tsetInterpolation: function( interpolation ) {\n\n\t\tvar factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase THREE.InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( message );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t},\n\n\tgetInterpolation: function() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn THREE.InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn THREE.InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn THREE.InterpolateSmooth;\n\n\t\t}\n\n\t},\n\n\tgetValueSize: function() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t},\n\n\t// move all keyframes either forwards or backwards in time\n\tshift: function( timeOffset ) {\n\n\t\tif( timeOffset !== 0.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale: function( timeScale ) {\n\n\t\tif( timeScale !== 1.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim: function( startTime, endTime ) {\n\n\t\tvar times = this.times,\n\t\t\tnKeys = times.length,\n\t\t\tfrom = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\n\t\t\tvar stride = this.getValueSize();\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = THREE.AnimationUtils.\n\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate: function() {\n\n\t\tvar valid = true;\n\n\t\tvar valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif( nKeys === 0 ) {\n\n\t\t\tconsole.error( \"track is empty\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar prevTime = null;\n\n\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tvar currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize: function() {\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\t\t\tstride = this.getValueSize(),\n\n\t\t\twriteIndex = 1;\n\n\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\n\n\t\t\tvar keep = false;\n\n\t\t\tvar time = times[ i ];\n\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\t\t\tvar offset = i * stride,\n\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.KeyframeTrack, {\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tparse: function( json ) {\n\n\t\tif( json.type === undefined ) {\n\n\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\n\t\t}\n\n\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\tif ( json.times === undefined ) {\n\n\t\t\tvar times = [], values = [];\n\n\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\tjson.times = times;\n\t\t\tjson.values = values;\n\n\t\t}\n\n\t\t// derived classes can define a static parse method\n\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\treturn trackType.parse( json );\n\n\t\t} else {\n\n\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\treturn new trackType(\n\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function( track ) {\n\n\t\tvar trackType = track.constructor;\n\n\t\tvar json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t},\n\n\t_getTrackTypeForValueTypeName: function( typeName ) {\n\n\t\tswitch( typeName.toLowerCase() ) {\n\n\t\t\tcase \"scalar\":\n\t\t\tcase \"double\":\n\t\t\tcase \"float\":\n\t\t\tcase \"number\":\n\t\t\tcase \"integer\":\n\n\t\t\t\treturn THREE.NumberKeyframeTrack;\n\n\t\t\tcase \"vector\":\n\t\t\tcase \"vector2\":\n\t\t\tcase \"vector3\":\n\t\t\tcase \"vector4\":\n\n\t\t\t\treturn THREE.VectorKeyframeTrack;\n\n\t\t\tcase \"color\":\n\n\t\t\t\treturn THREE.ColorKeyframeTrack;\n\n\t\t\tcase \"quaternion\":\n\n\t\t\t\treturn THREE.QuaternionKeyframeTrack;\n\n\t\t\tcase \"bool\":\n\t\t\tcase \"boolean\":\n\n\t\t\t\treturn THREE.BooleanKeyframeTrack;\n\n\t\t\tcase \"string\":\n\n\t\t\t\treturn THREE.StringKeyframeTrack;\n\n\t\t}\n\n\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\n\t}\n\n} );\n\n// File:src/animation/PropertyBinding.js\n\n/**\n *\n * A reference to a real property in the scene graph.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\n\n\tthis.path = path;\n\tthis.parsedPath = parsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis.node = THREE.PropertyBinding.findNode(\n\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\n\tthis.rootNode = rootNode;\n\n};\n\nTHREE.PropertyBinding.prototype = {\n\n\tconstructor: THREE.PropertyBinding,\n\n\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t// prototype version of these methods with one that represents\n\t\t// the bound state. When the property is not found, the methods\n\t\t// become no-ops.\n\n\t},\n\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t},\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind: function() {\n\n\t\tvar targetObject = this.node,\n\t\t\tparsedPath = this.parsedPath,\n\n\t\t\tobjectName = parsedPath.objectName,\n\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = THREE.PropertyBinding.findNode(\n\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n \t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tvar versioning = this.Versioning.None;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tvar bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( nodeProperty.length !== undefined ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t},\n\n\tunbind: function() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n};\n\nObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable: function() {},\n\t_setValue_unavailable: function() {},\n\n\t// initial state of these methods that calls 'bind'\n\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\n\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\n\n\tBindingType: {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t},\n\n\tVersioning: {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t},\n\n\tGetterByBindingType: [\n\n\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t},\n\n\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\tvar source = this.resolvedProperty;\n\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t},\n\n\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t}\n\n\t],\n\n\tSetterByBindingTypeAndVersioning: [\n\n\t\t[\n\t\t\t// Direct\n\n\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// EntireArray\n\n\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// ArrayElement\n\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// HasToFromArray\n\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t]\n\n\t]\n\n} );\n\nTHREE.PropertyBinding.Composite =\n\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\n\tvar parsedPath = optionalParsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis._targetGroup = targetGroup;\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n};\n\nTHREE.PropertyBinding.Composite.prototype = {\n\n\tconstructor: THREE.PropertyBinding.Composite,\n\n\tgetValue: function( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t},\n\n\tsetValue: function( array, offset ) {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t},\n\n\tbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t},\n\n\tunbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\n\n\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\n\n\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\n\n\t} else {\n\n\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\n\n\t}\n\n};\n\nTHREE.PropertyBinding.parseTrackName = function( trackName ) {\n\n\t// matches strings in the form of:\n\t//    nodeName.property\n\t//    nodeName.property[accessor]\n\t//    nodeName.material.property[accessor]\n\t//    uuid.property[accessor]\n\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t//    parentName/nodeName.property\n\t//    parentName/parentName/nodeName.property[index]\n\t//\t  .bone[Armature.DEF_cog].position\n\t// created and tested via https://regex101.com/#javascript\n\n\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\n\tvar matches = re.exec( trackName );\n\n\tif ( ! matches ) {\n\n\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\n\t}\n\n\tif ( matches.index === re.lastIndex ) {\n\n\t\tre.lastIndex++;\n\n\t}\n\n\tvar results = {\n\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\tnodeName: matches[ 3 ], \t// allowed to be null, specified root node.\n\t\tobjectName: matches[ 5 ],\n\t\tobjectIndex: matches[ 7 ],\n\t\tpropertyName: matches[ 9 ],\n\t\tpropertyIndex: matches[ 11 ]\t// allowed to be null, specifies that the whole property is set.\n\t};\n\n\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n\t}\n\n\treturn results;\n\n};\n\nTHREE.PropertyBinding.findNode = function( root, nodeName ) {\n\n\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\treturn root;\n\n\t}\n\n\t// search into skeleton bones.\n\tif ( root.skeleton ) {\n\n\t\tvar searchSkeleton = function( skeleton ) {\n\n\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n\t\t\t\tvar bone = skeleton.bones[ i ];\n\n\t\t\t\tif ( bone.name === nodeName ) {\n\n\t\t\t\t\treturn bone;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar bone = searchSkeleton( root.skeleton );\n\n\t\tif ( bone ) {\n\n\t\t\treturn bone;\n\n\t\t}\n\t}\n\n\t// search into node subtree.\n\tif ( root.children ) {\n\n\t\tvar searchNodeSubtree = function( children ) {\n\n\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\treturn childNode;\n\n\t\t\t\t}\n\n\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\tif ( result ) return result;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\tif ( subTreeNode ) {\n\n\t\t\treturn subTreeNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\n// File:src/animation/PropertyMixer.js\n\n/**\n *\n * Buffered scene graph property that allows weighted accumulation.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tvar bufferType = Float64Array,\n\t\tmixFunction;\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\n\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\n\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\n\t}\n\n\tthis.buffer = new bufferType( valueSize * 4 );\n\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\n\tthis._mixBufferRegion = mixFunction;\n\n\tthis.cumulativeWeight = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n};\n\nTHREE.PropertyMixer.prototype = {\n\n\tconstructor: THREE.PropertyMixer,\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tvar mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function( accuIndex ) {\n\n\t\tvar stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function() {\n\n\t\tvar binding = this.binding;\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * 3;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\tthis.cumulativeWeight = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function() {\n\n\t\tvar originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tvar s = 1 - t;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tvar j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/tracks/BooleanKeyframeTrack.js\n\n/**\n *\n * A Track of Boolean keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values );\n\n};\n\nTHREE.BooleanKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.BooleanKeyframeTrack,\n\n\tValueTypeName: 'bool',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\tInterpolantFactoryMethodSmooth: undefined\n\n\t// Note: Actually this track could have a optimized / compressed\n\t// representation of a single value and a custom interpolant that\n\t// computes \"firstValue ^ isOdd( index )\".\n\n} );\n\n// File:src/animation/tracks/ColorKeyframeTrack.js\n\n/**\n *\n * A Track of keyframe values that represent color.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.ColorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.ColorKeyframeTrack,\n\n\tValueTypeName: 'color'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n\n\t// Note: Very basic implementation and nothing special yet.\n\t// However, this is the place for color space parameterization.\n\n} );\n\n// File:src/animation/tracks/NumberKeyframeTrack.js\n\n/**\n *\n * A Track of numeric keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.NumberKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.NumberKeyframeTrack,\n\n\tValueTypeName: 'number',\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/animation/tracks/QuaternionKeyframeTrack.js\n\n/**\n *\n * A Track of quaternion keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.QuaternionKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.QuaternionKeyframeTrack,\n\n\tValueTypeName: 'quaternion',\n\n\t// ValueBufferType is inherited\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.QuaternionLinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n} );\n\n// File:src/animation/tracks/StringKeyframeTrack.js\n\n/**\n *\n * A Track that interpolates Strings\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.StringKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.StringKeyframeTrack,\n\n\tValueTypeName: 'string',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\n\tInterpolantFactoryMethodSmooth: undefined\n\n} );\n\n// File:src/animation/tracks/VectorKeyframeTrack.js\n\n/**\n *\n * A Track of vectored keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.VectorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.VectorKeyframeTrack,\n\n\tValueTypeName: 'vector'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/audio/Audio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.Audio = function ( listener ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Audio';\n\n\tthis.context = listener.context;\n\tthis.source = this.context.createBufferSource();\n\tthis.source.onended = this.onEnded.bind( this );\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( listener.getInput() );\n\n\tthis.autoplay = false;\n\n\tthis.startTime = 0;\n\tthis.playbackRate = 1;\n\tthis.isPlaying = false;\n\tthis.hasPlaybackControl = true;\n\tthis.sourceType = 'empty';\n\n\tthis.filters = [];\n\n};\n\nTHREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Audio,\n\n\tgetOutput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tsetNodeSource: function ( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t},\n\n\tsetBuffer: function ( audioBuffer ) {\n\n\t\tthis.source.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t},\n\n\tplay: function () {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar source = this.context.createBufferSource();\n\n\t\tsource.buffer = this.source.buffer;\n\t\tsource.loop = this.source.loop;\n\t\tsource.onended = this.source.onended;\n\t\tsource.start( 0, this.startTime );\n\t\tsource.playbackRate.value = this.playbackRate;\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\treturn this.connect();\n\n\t},\n\n\tpause: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = this.context.currentTime;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = 0;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdisconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilters: function () {\n\n\t\treturn this.filters;\n\n\t},\n\n\tsetFilters: function ( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value;\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t},\n\n\tsetFilter: function ( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t},\n\n\tsetPlaybackRate: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetPlaybackRate: function () {\n\n\t\treturn this.playbackRate;\n\n\t},\n\n\tonEnded: function () {\n\n\t\tthis.isPlaying = false;\n\n\t},\n\n\tgetLoop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.source.loop;\n\n\t},\n\n\tsetLoop: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.loop = value;\n\n\t},\n\n\tgetVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\n\tsetVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/audio/AudioAnalyser.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioAnalyser = function ( audio, fftSize ) {\n\n\tthis.analyser = audio.context.createAnalyser();\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\taudio.getOutput().connect( this.analyser );\n\n};\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\n\tgetFrequencyData: function () {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t},\n\n\tgetAverageFrequency: function () {\n\n\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n} );\n\n// File:src/audio/AudioContext.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.defineProperty( THREE, 'AudioContext', {\n\n\tget: ( function () {\n\n\t\tvar context;\n\n\t\treturn function get() {\n\n\t\t\tif ( context === undefined ) {\n\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t\t}\n\n\t\t\treturn context;\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/audio/PositionalAudio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PositionalAudio = function ( listener ) {\n\n\tTHREE.Audio.call( this, listener );\n\n\tthis.panner = this.context.createPanner();\n\tthis.panner.connect( this.gain );\n\n};\n\nTHREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {\n\n\tconstructor: THREE.PositionalAudio,\n\n\tgetOutput: function () {\n\n\t\treturn this.panner;\n\n\t},\n\n\tgetRefDistance: function () {\n\n\t\treturn this.panner.refDistance;\n\n\t},\n\n\tsetRefDistance: function ( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t},\n\n\tgetRolloffFactor: function () {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t},\n\n\tsetRolloffFactor: function ( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t},\n\n\tgetDistanceModel: function () {\n\n\t\treturn this.panner.distanceModel;\n\n\t},\n\n\tsetDistanceModel: function ( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t},\n\n\tgetMaxDistance: function () {\n\n\t\treturn this.panner.maxDistance;\n\n\t},\n\n\tsetMaxDistance: function ( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t};\n\n\t} )()\n\n\n} );\n\n// File:src/audio/AudioListener.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioListener = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'AudioListener';\n\n\tthis.context = THREE.AudioContext;\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( this.context.destination );\n\n\tthis.filter = null;\n\n};\n\nTHREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.AudioListener,\n\n\tgetInput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tremoveFilter: function ( ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.filter;\n\n\t},\n\n\tsetFilter: function ( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t},\n\n\tgetMasterVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\tsetMasterVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar scale = new THREE.Vector3();\n\n\t\tvar orientation = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tvar listener = this.context.listener;\n\t\t\tvar up = this.up;\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/cameras/Camera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.Camera = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Camera';\n\n\tthis.matrixWorldInverse = new THREE.Matrix4();\n\tthis.projectionMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Camera.prototype.constructor = THREE.Camera;\n\nTHREE.Camera.prototype.getWorldDirection = function () {\n\n\tvar quaternion = new THREE.Quaternion();\n\n\treturn function getWorldDirection( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.getWorldQuaternion( quaternion );\n\n\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.lookAt = function () {\n\n\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\tvar m1 = new THREE.Matrix4();\n\n\treturn function lookAt( vector ) {\n\n\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.clone = function () {\n\n\treturn new this.constructor().copy( this );\n\n};\n\nTHREE.Camera.prototype.copy = function ( source ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\treturn this;\n\n};\n\n// File:src/cameras/CubeCamera.js\n\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'CubeCamera';\n\n\tvar fov = 90, aspect = 1;\n\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, - 1, 0 );\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, - 1, 0 );\n\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, - 1 );\n\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, - 1, 0 );\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, - 1, 0 );\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\n\tthis.add( cameraNZ );\n\n\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\n\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderTarget.activeCubeFace = 0;\n\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 1;\n\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 2;\n\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 3;\n\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 4;\n\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderTarget.activeCubeFace = 5;\n\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\trenderer.setRenderTarget( null );\n\n\t};\n\n};\n\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\n\n// File:src/cameras/OrthographicCamera.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author arose / http://github.com/arose\n */\n\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'OrthographicCamera';\n\n\tthis.zoom = 1;\n\tthis.view = null;\n\n\tthis.left = left;\n\tthis.right = right;\n\tthis.top = top;\n\tthis.bottom = bottom;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.OrthographicCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t},\n\n\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tvar cx = ( this.right + this.left ) / 2;\n\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\tvar left = cx - dx;\n\t\tvar right = cx + dx;\n\t\tvar top = cy + dy;\n\t\tvar bottom = cy - dy;\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/PerspectiveCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author tschw\n */\n\nTHREE.PerspectiveCamera = function( fov, aspect, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'PerspectiveCamera';\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.zoom = 1;\n\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\tthis.focus = 10;\n\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.view = null;\n\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.PerspectiveCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength: function ( focalLength ) {\n\n\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength: function () {\n\n\t\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t},\n\n\tgetEffectiveFOV: function () {\n\n\t\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t},\n\n\tgetFilmWidth: function () {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t},\n\n\tgetFilmHeight: function () {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t},\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   var w = 1920;\n\t *   var h = 1080;\n\t *   var fullWidth = w * 3;\n\t *   var fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar near = this.near,\n\t\t\ttop = near * Math.tan(\n\t\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\theight = 2 * top,\n\t\t\twidth = this.aspect * height,\n\t\t\tleft = - 0.5 * width,\n\t\t\tview = this.view;\n\n\t\tif ( view !== null ) {\n\n\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tvar skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/StereoCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.StereoCamera = function () {\n\n\tthis.type = 'StereoCamera';\n\n\tthis.aspect = 1;\n\n\tthis.cameraL = new THREE.PerspectiveCamera();\n\tthis.cameraL.layers.enable( 1 );\n\tthis.cameraL.matrixAutoUpdate = false;\n\n\tthis.cameraR = new THREE.PerspectiveCamera();\n\tthis.cameraR.layers.enable( 2 );\n\tthis.cameraR.matrixAutoUpdate = false;\n\n};\n\nObject.assign( THREE.StereoCamera.prototype, {\n\n\tupdate: ( function () {\n\n\t\tvar focus, fov, aspect, near, far;\n\n\t\tvar eyeRight = new THREE.Matrix4();\n\t\tvar eyeLeft = new THREE.Matrix4();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\tfocus = camera.focus;\n\t\t\t\tfov = camera.fov;\n\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\tnear = camera.near;\n\t\t\t\tfar = camera.far;\n\n\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\tvar eyeSep = 0.064 / 2;\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t// translate xOffset\n\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t// for left eye\n\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t// for right eye\n\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t}\n\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/lights/Light.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Light = function ( color, intensity ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Light';\n\n\tthis.color = new THREE.Color( color );\n\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\tthis.receiveShadow = undefined;\n\n};\n\nTHREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Light,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/lights/LightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LightShadow = function ( camera ) {\n\n\tthis.camera = camera;\n\n\tthis.bias = 0;\n\tthis.radius = 1;\n\n\tthis.mapSize = new THREE.Vector2( 512, 512 );\n\n\tthis.map = null;\n\tthis.matrix = new THREE.Matrix4();\n\n};\n\nObject.assign( THREE.LightShadow.prototype, {\n\n\tcopy: function ( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\n// File:src/lights/AmbientLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AmbientLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'AmbientLight';\n\n\tthis.castShadow = undefined;\n\n};\n\nTHREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.AmbientLight\n\n} );\n\n// File:src/lights/DirectionalLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DirectionalLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'DirectionalLight';\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tthis.shadow = new THREE.DirectionalLightShadow();\n\n};\n\nTHREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.DirectionalLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/DirectionalLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectionalLightShadow = function ( light ) {\n\n\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n};\n\nTHREE.DirectionalLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.DirectionalLightShadow\n\n} );\n\n// File:src/lights/HemisphereLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\n\n\tTHREE.Light.call( this, skyColor, intensity );\n\n\tthis.type = 'HemisphereLight';\n\n\tthis.castShadow = undefined;\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.groundColor = new THREE.Color( groundColor );\n\n};\n\nTHREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.HemisphereLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/PointLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'PointLight';\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n};\n\nTHREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.PointLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'SpotLight';\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * Math.PI;\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / Math.PI;\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.SpotLightShadow();\n\n};\n\nTHREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.SpotLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SpotLightShadow = function () {\n\n\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n};\n\nTHREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.SpotLightShadow,\n\n\tupdate: function ( light ) {\n\n\t\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\n\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\tvar far = light.distance || 500;\n\n\t\tvar camera = this.camera;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/AudioLoader.js\n\n/**\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.AudioLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.AudioLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar context = THREE.AudioContext;\n\n\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t} );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n} );\n\n// File:src/loaders/Cache.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\n// File:src/loaders/Loader.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Loader = function () {\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function () {};\n\tthis.onLoadComplete = function () {};\n\n};\n\nTHREE.Loader.prototype = {\n\n\tconstructor: THREE.Loader,\n\n\tcrossOrigin: undefined,\n\n\textractUrlBase: function ( url ) {\n\n\t\tvar parts = url.split( '/' );\n\n\t\tif ( parts.length === 1 ) return './';\n\n\t\tparts.pop();\n\n\t\treturn parts.join( '/' ) + '/';\n\n\t},\n\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\tvar array = [];\n\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tcreateMaterial: ( function () {\n\n\t\tvar color, textureLoader, materialLoader;\n\n\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\tif ( color === undefined ) color = new THREE.Color();\n\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\n\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\n\n\t\t\t// convert from old material format\n\n\t\t\tvar textures = {};\n\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\n\n\t\t\t\tvar texture;\n\n\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t}\n\n\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t}\n\n\t\t\t\tvar uuid = THREE.Math.generateUUID();\n\n\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\treturn uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar json = {\n\t\t\t\tuuid: THREE.Math.generateUUID(),\n\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t};\n\n\t\t\tfor ( var name in m ) {\n\n\t\t\t\tvar value = m[ name ];\n\n\t\t\t\tswitch ( name ) {\n\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\tjson.blending = THREE[ value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\tjson.side = THREE.BackSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\tjson.side = THREE.DoubleSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\tcase 'opacity':\n\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\tcase 'visible':\n\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\treturn materialLoader.parse( json );\n\n\t\t};\n\n\t} )()\n\n};\n\nTHREE.Loader.Handlers = {\n\n\thandlers: [],\n\n\tadd: function ( regex, loader ) {\n\n\t\tthis.handlers.push( regex, loader );\n\n\t},\n\n\tget: function ( file ) {\n\n\t\tvar handlers = this.handlers;\n\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\tvar regex = handlers[ i ];\n\t\t\tvar loader  = handlers[ i + 1 ];\n\n\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n};\n\n// File:src/loaders/XHRLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.XHRLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.XHRLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\tvar scope = this;\n\n\t\tvar cached = THREE.Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tif ( onLoad ) {\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tonLoad( cached );\n\n\t\t\t\t}, 0 );\n\n\t\t\t}\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tvar request = new XMLHttpRequest();\n\t\trequest.overrideMimeType( 'text/plain' );\n\t\trequest.open( 'GET', url, true );\n\n\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\tvar response = event.target.response;\n\n\t\t\tTHREE.Cache.add( url, response );\n\n\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else {\n\n\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, false );\n\n\t\tif ( onProgress !== undefined ) {\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tonProgress( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}, false );\n\n\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\trequest.send( null );\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn request;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetResponseType: function ( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t},\n\n\tsetWithCredentials: function ( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/FontLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.FontLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.FontLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t}\n\n\t\t\tvar font = scope.parse( json );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\treturn new THREE.Font( json );\n\n\t}\n\n} );\n\n// File:src/loaders/ImageLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.ImageLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\timage.onload = function () {\n\n\t\t\tURL.revokeObjectURL( image.src );\n\t\t\tif ( onLoad ) onLoad( image );\n\n\t\t};\n\n\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\n\t\t\timage.src = url;\n\n\t\t} else {\n\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'blob' );\n\t\t\tloader.load( url, function ( blob ) {\n\n\t\t\t\timage.src = URL.createObjectURL( blob );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn image;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/JSONLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.JSONLoader = function ( manager ) {\n\n\tif ( typeof manager === 'boolean' ) {\n\n\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\tmanager = undefined;\n\n\t}\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\tthis.withCredentials = false;\n\n};\n\nObject.assign( THREE.JSONLoader.prototype, {\n\n\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json = JSON.parse( text );\n\t\t\tvar metadata = json.metadata;\n\n\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\tvar type = metadata.type;\n\n\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tparse: function ( json, texturePath ) {\n\n\t\tvar geometry = new THREE.Geometry(),\n\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\tparseModel( scale );\n\n\t\tparseSkin();\n\t\tparseMorphing( scale );\n\t\tparseAnimations();\n\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeBoundingSphere();\n\n\t\tfunction parseModel( scale ) {\n\n\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t}\n\n\t\t\tvar i, j, fi,\n\n\t\t\toffset, zLength,\n\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\ttype,\n\t\t\tisQuad,\n\t\t\thasMaterial,\n\t\t\thasFaceVertexUv,\n\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\tuvLayer, uv, u, v,\n\n\t\t\tfaces = json.faces,\n\t\t\tvertices = json.vertices,\n\t\t\tnormals = json.normals,\n\t\t\tcolors = json.colors,\n\n\t\t\tnUvLayers = 0;\n\n\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t// disregard empty arrays\n\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = vertices.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\tvertex = new THREE.Vector3();\n\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = faces.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\tfaceA = new THREE.Face3();\n\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\tfaceB = new THREE.Face3();\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\toffset += 4;\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface = new THREE.Face3();\n\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseSkin() {\n\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.bones = json.bones;\n\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseMorphing( scale ) {\n\n\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimations() {\n\n\t\t\tvar outputAnimations = [];\n\n\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\tvar animations = [];\n\n\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\tanimations.push( json.animation );\n\n\t\t\t}\n\n\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t}\n\n\t\t\t// parse implicit morph animations\n\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t}\n\n\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t}\n\n\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\treturn { geometry: geometry };\n\n\t\t} else {\n\n\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/LoadingManager.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n\tthis.onStart = undefined;\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\titemsTotal ++;\n\n\t\tif ( isLoading === false ) {\n\n\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLoading = true;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\titemsLoaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t}\n\n\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\tisLoading = false;\n\n\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\tscope.onLoad();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.itemError = function ( url ) {\n\n\t\tif ( scope.onError !== undefined ) {\n\n\t\t\tscope.onError( url );\n\n\t\t}\n\n\t};\n\n};\n\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\n\n// File:src/loaders/BufferGeometryLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometryLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.BufferGeometryLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar index = json.data.index;\n\n\t\tvar TYPED_ARRAYS = {\n\t\t\t'Int8Array': Int8Array,\n\t\t\t'Uint8Array': Uint8Array,\n\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t'Int16Array': Int16Array,\n\t\t\t'Uint16Array': Uint16Array,\n\t\t\t'Int32Array': Int32Array,\n\t\t\t'Uint32Array': Uint32Array,\n\t\t\t'Float32Array': Float32Array,\n\t\t\t'Float64Array': Float64Array\n\t\t};\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tvar attributes = json.data.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t}\n\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tvar center = new THREE.Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/loaders/MaterialLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MaterialLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.textures = {};\n\n};\n\nObject.assign( THREE.MaterialLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTextures: function ( value ) {\n\n\t\tthis.textures = value;\n\n\t},\n\n\tgetTexture: function ( name ) {\n\n\t\tvar textures = this.textures;\n\n\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t}\n\n\t\treturn textures[ name ];\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar material = new THREE[ json.type ];\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\n\t\t// for PointsMaterial\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\n\n\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\n\t\t\tmaterial.transparent = true;\n\n\t\t}\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tvar normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\n\n\t\tif ( json.envMap !== undefined ) {\n\n\t\t\tmaterial.envMap = this.getTexture( json.envMap );\n\t\t\tmaterial.combine = THREE.MultiplyOperation;\n\n\t\t}\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t// MultiMaterial\n\n\t\tif ( json.materials !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n} );\n\n// File:src/loaders/ObjectLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ObjectLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.texturePath = '';\n\n};\n\nObject.assign( THREE.ObjectLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.texturePath === '' ) {\n\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t}\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tparse: function ( json, onLoad ) {\n\n\t\tvar geometries = this.parseGeometries( json.geometries );\n\n\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\tif ( json.animations ) {\n\n\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t}\n\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t},\n\n\tparseGeometries: function ( json ) {\n\n\t\tvar geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE [ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\tcase 'TetrahedronGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t},\n\n\tparseMaterials: function ( json, textures ) {\n\n\t\tvar materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar loader = new THREE.MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t},\n\n\tparseAnimations: function ( json ) {\n\n\t\tvar animations = [];\n\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t},\n\n\tparseImages: function ( json, onLoad ) {\n\n\t\tvar scope = this;\n\t\tvar images = {};\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tvar manager = new THREE.LoadingManager( onLoad );\n\n\t\t\tvar loader = new THREE.ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar image = json[ i ];\n\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t},\n\n\tparseTextures: function ( json, images ) {\n\n\t\tfunction parseConstant( value ) {\n\n\t\t\tif ( typeof( value ) === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn THREE[ value ];\n\n\t\t}\n\n\t\tvar textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\n\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\t\t\t\tif ( Array.isArray( data.wrap ) ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t},\n\n\tparseObject: function () {\n\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\treturn function parseObject( data, geometries, materials ) {\n\n\t\t\tvar object;\n\n\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometries[ name ];\n\n\t\t\t}\n\n\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn materials[ name ];\n\n\t\t\t}\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'Scene':\n\n\t\t\t\t\tobject = new THREE.Scene();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LOD':\n\n\t\t\t\t\tobject = new THREE.LOD();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Line':\n\n\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointCloud':\n\t\t\t\tcase 'Points':\n\n\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Group':\n\n\t\t\t\t\tobject = new THREE.Group();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t} else {\n\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t}\n\n\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\tvar levels = data.levels;\n\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t};\n\n\t}()\n\n} );\n\n// File:src/loaders/TextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.TextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.TextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.Texture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/CubeTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.CubeTextureLoader.prototype, {\n\n\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.CubeTexture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tvar loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/BinaryTextureLoader.js\n\n/**\n * @author Nikos M. / https://github.com/foo123/\n *\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n */\n\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.BinaryTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new THREE.DataTexture();\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\n\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t}\n\n\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n// File:src/loaders/CompressedTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n */\n\nTHREE.CompressedTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.CompressedTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar images = [];\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/materials/Material.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Material = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Material';\n\n\tthis.fog = true;\n\tthis.lights = true;\n\n\tthis.blending = THREE.NormalBlending;\n\tthis.side = THREE.FrontSide;\n\tthis.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\tthis.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blendSrc = THREE.SrcAlphaFactor;\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\tthis.blendEquation = THREE.AddEquation;\n\tthis.blendSrcAlpha = null;\n\tthis.blendDstAlpha = null;\n\tthis.blendEquationAlpha = null;\n\n\tthis.depthFunc = THREE.LessEqualDepth;\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.clippingPlanes = null;\n\tthis.clipShadows = false;\n\n\tthis.colorWrite = true;\n\n\tthis.precision = null; // override the renderer's default precision for this material\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.alphaTest = 0;\n\tthis.premultipliedAlpha = false;\n\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\tthis.visible = true;\n\n\tthis._needsUpdate = true;\n\n};\n\nTHREE.Material.prototype = {\n\n\tconstructor: THREE.Material,\n\n\tget needsUpdate() {\n\n\t\treturn this._needsUpdate;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.update();\n\t\tthis._needsUpdate = value;\n\n\t},\n\n\tsetValues: function ( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( var key in values ) {\n\n\t\t\tvar newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue instanceof THREE.Color ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar isRoot = meta === undefined;\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\n\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\n\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\tif ( this.bumpMap instanceof THREE.Texture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\t\tif ( this.normalMap instanceof THREE.Texture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\t\tif ( this.displacementMap instanceof THREE.Texture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap instanceof THREE.Texture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t}\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;\n\t\tif ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;\n\t\tif ( this.side !== THREE.FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.shading = source.shading;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.alphaTest = source.alphaTest;\n\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\tthis.overdraw = source.overdraw;\n\n\t\tthis.visible = source.visible;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\tdstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tvar n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\n\t\treturn this;\n\n\t},\n\n\tupdate: function () {\n\n\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nObject.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.MaterialIdCount = 0;\n\n// File:src/materials/LineBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nTHREE.LineBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\n\nTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\tthis.linecap = source.linecap;\n\tthis.linejoin = source.linejoin;\n\n\treturn this;\n\n};\n\n// File:src/materials/LineDashedMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nTHREE.LineDashedMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineDashedMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\n\tthis.scale = 1;\n\tthis.dashSize = 3;\n\tthis.gapSize = 1;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\n\nTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\n\tthis.scale = source.scale;\n\tthis.dashSize = source.dashSize;\n\tthis.gapSize = source.gapSize;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>\n * }\n */\n\nTHREE.MeshBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\n\nTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshDepthMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / https://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshDepthMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshDepthMaterial';\n\n\tthis.depthPacking = THREE.BasicDepthPacking;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.map = null;\n\n\tthis.alphaMap = null;\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\n\nTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.depthPacking = source.depthPacking;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\tthis.map = source.map;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshLambertMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshLambertMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshLambertMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\n\nTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshNormalMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshNormalMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this, parameters );\n\n\tthis.type = 'MeshNormalMaterial';\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\n\nTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhongMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshPhongMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshPhongMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.specular = new THREE.Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\n\nTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.specular.copy( source.specular );\n\tthis.shininess = source.shininess;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshStandardMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshStandardMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.type = 'MeshStandardMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.roughness = 0.5;\n\tthis.metalness = 0.5;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.roughnessMap = null;\n\n\tthis.metalnessMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.envMapIntensity = 1.0;\n\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\n\nTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.color.copy( source.color );\n\tthis.roughness = source.roughness;\n\tthis.metalness = source.metalness;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.roughnessMap = source.roughnessMap;\n\n\tthis.metalnessMap = source.metalnessMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.envMapIntensity = source.envMapIntensity;\n\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhysicalMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  reflectivity: <float>\n * }\n */\n\nTHREE.MeshPhysicalMaterial = function ( parameters ) {\n\n\tTHREE.MeshStandardMaterial.call( this );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.type = 'MeshPhysicalMaterial';\n\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\tthis.clearCoat = 0.0;\n\tthis.clearCoatRoughness = 0.0;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\nTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\n\nTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.reflectivity = source.reflectivity;\n\n\tthis.clearCoat = source.clearCoat;\n\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\treturn this;\n\n};\n\n// File:src/materials/MultiMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MultiMaterial = function ( materials ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.type = 'MultiMaterial';\n\n\tthis.materials = materials instanceof Array ? materials : [];\n\n\tthis.visible = true;\n\n};\n\nTHREE.MultiMaterial.prototype = {\n\n\tconstructor: THREE.MultiMaterial,\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.2,\n\t\t\t\ttype: 'material',\n\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t},\n\t\t\tuuid: this.uuid,\n\t\t\ttype: this.type,\n\t\t\tmaterials: []\n\t\t};\n\n\t\tvar materials = this.materials;\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\tdelete material.metadata;\n\n\t\t\toutput.materials.push( material );\n\n\t\t}\n\n\t\toutput.visible = this.visible;\n\n\t\treturn output;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar material = new this.constructor();\n\n\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t\t}\n\n\t\tmaterial.visible = this.visible;\n\n\t\treturn material;\n\n\t}\n\n};\n\n// File:src/materials/PointsMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nTHREE.PointsMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'PointsMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\n\nTHREE.PointsMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.size = source.size;\n\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShaderMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.ShaderMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'ShaderMaterial';\n\n\tthis.defines = {};\n\tthis.uniforms = {};\n\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\tthis.lights = false; // set to use scene lights\n\tthis.clipping = false; // set to use user-defined clipping planes\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.extensions = {\n\t\tderivatives: false, // set to use derivatives\n\t\tfragDepth: false, // set to use fragment depth values\n\t\tdrawBuffers: false, // set to use draw buffers\n\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t};\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t'color': [ 1, 1, 1 ],\n\t\t'uv': [ 0, 0 ],\n\t\t'uv2': [ 0, 0 ]\n\t};\n\n\tthis.index0AttributeName = undefined;\n\n\tif ( parameters !== undefined ) {\n\n\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n};\n\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\n\nTHREE.ShaderMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.fragmentShader = source.fragmentShader;\n\tthis.vertexShader = source.vertexShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\n\n\tthis.defines = source.defines;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.lights = source.lights;\n\tthis.clipping = source.clipping;\n\n\tthis.skinning = source.skinning;\n\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.extensions = source.extensions;\n\n\treturn this;\n\n};\n\nTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\n\n\tdata.uniforms = this.uniforms;\n\tdata.vertexShader = this.vertexShader;\n\tdata.fragmentShader = this.fragmentShader;\n\n\treturn data;\n\n};\n\n// File:src/materials/RawShaderMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RawShaderMaterial = function ( parameters ) {\n\n\tTHREE.ShaderMaterial.call( this, parameters );\n\n\tthis.type = 'RawShaderMaterial';\n\n};\n\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\n\n// File:src/materials/SpriteMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *\tuvOffset: new THREE.Vector2(),\n *\tuvScale: new THREE.Vector2()\n * }\n */\n\nTHREE.SpriteMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'SpriteMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.map = null;\n\n\tthis.rotation = 0;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\n\nTHREE.SpriteMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.map = source.map;\n\n\tthis.rotation = source.rotation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShadowMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ShadowMaterial = function () {\n\n\tTHREE.ShaderMaterial.call( this, {\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\t\tvertexShader: THREE.ShaderChunk[ 'shadow_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]\n\t} );\n\n\tthis.lights = true;\n\tthis.transparent = true;\n\n\tObject.defineProperties( this, {\n\t\topacity: {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t}\n\t\t}\n\t} );\n\n};\n\nTHREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;\n\n// File:src/textures/Texture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.sourceFile = '';\n\n\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t//\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\n\n\tthis.version = 0;\n\tthis.onUpdate = null;\n\n};\n\nTHREE.Texture.DEFAULT_IMAGE = undefined;\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\n\nTHREE.Texture.prototype = {\n\n\tconstructor: THREE.Texture,\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tfunction getDataURL( image ) {\n\n\t\t\tvar canvas;\n\n\t\t\tif ( image.toDataURL !== undefined ) {\n\n\t\t\t\tcanvas = image;\n\n\t\t\t} else {\n\n\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = image.width;\n\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t} else {\n\n\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tvar image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tmeta.textures[ this.uuid ] = output;\n\n\t\treturn output;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t},\n\n\ttransformUv: function ( uv ) {\n\n\t\tif ( this.mapping !== THREE.UVMapping )  return;\n\n\t\tuv.multiply( this.repeat );\n\t\tuv.add( this.offset );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.TextureIdCount = 0;\n\n// File:src/textures/DepthTexture.js\n\n/**\n * @author Matt DesLauriers / @mattdesl\n */\n\nTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\n\n  this.image = { width: width, height: height };\n\n  this.type = type !== undefined ? type : THREE.UnsignedShortType;\n\n  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n  this.flipY = false;\n  this.generateMipmaps  = false;\n\n};\n\nTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\n\n// File:src/textures/CanvasTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.needsUpdate = true;\n\n};\n\nTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\n\n// File:src/textures/CubeTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\timages = images !== undefined ? images : [];\n\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\n\n\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.flipY = false;\n\n};\n\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\n\nObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\n\n\tget: function () {\n\n\t\treturn this.image;\n\n\t},\n\n\tset: function ( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n} );\n\n// File:src/textures/CompressedTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n\t// no flipping for cube textures\n\t// (also flipping doesn't work for compressed textures )\n\n\tthis.flipY = false;\n\n\t// can't generate mipmaps for compressed textures\n\t// mips must be embedded in DDS files\n\n\tthis.generateMipmaps = false;\n\n};\n\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\n\n// File:src/textures/DataTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { data: data, width: width, height: height };\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n\tthis.flipY = false;\n\tthis.generateMipmaps  = false;\n\n};\n\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\n\n// File:src/textures/VideoTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.generateMipmaps = false;\n\n\tvar scope = this;\n\n\tfunction update() {\n\n\t\trequestAnimationFrame( update );\n\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tscope.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tupdate();\n\n};\n\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\n\n// File:src/objects/Group.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Group = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Group';\n\n};\n\nTHREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Group\n\n} );\n\n// File:src/objects/Points.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Points = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Points';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Points,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar object = this;\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\tvar position = new THREE.Vector3();\n\n\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Line.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Line = function ( geometry, material, mode ) {\n\n\tif ( mode === 1 ) {\n\n\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\treturn new THREE.LineSegments( geometry, material );\n\n\t}\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Line';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Line,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar precision = raycaster.linePrecision;\n\t\t\tvar precisionSq = precision * precision;\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar vStart = new THREE.Vector3();\n\t\t\tvar vEnd = new THREE.Vector3();\n\t\t\tvar interSegment = new THREE.Vector3();\n\t\t\tvar interRay = new THREE.Vector3();\n\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LineSegments.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LineSegments = function ( geometry, material ) {\n\n\tTHREE.Line.call( this, geometry, material );\n\n\tthis.type = 'LineSegments';\n\n};\n\nTHREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {\n\n\tconstructor: THREE.LineSegments\n\n} );\n\n// File:src/objects/Mesh.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */\n\nTHREE.Mesh = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Mesh';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.drawMode = THREE.TrianglesDrawMode;\n\n\tthis.updateMorphTargets();\n\n};\n\nTHREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Mesh,\n\n\tsetDrawMode: function ( value ) {\n\n\t\tthis.drawMode = value;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.drawMode = source.drawMode;\n\n\t\treturn this;\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\n\n\t\t\tthis.morphTargetBase = - 1;\n\t\t\tthis.morphTargetInfluences = [];\n\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tgetMorphTargetIndexByName: function ( name ) {\n\n\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\n\t\t\treturn this.morphTargetDictionary[ name ];\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\n\n\t\treturn 0;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\tvar vA = new THREE.Vector3();\n\t\tvar vB = new THREE.Vector3();\n\t\tvar vC = new THREE.Vector3();\n\n\t\tvar tempA = new THREE.Vector3();\n\t\tvar tempB = new THREE.Vector3();\n\t\tvar tempC = new THREE.Vector3();\n\n\t\tvar uvA = new THREE.Vector2();\n\t\tvar uvB = new THREE.Vector2();\n\t\tvar uvC = new THREE.Vector2();\n\n\t\tvar barycoord = new THREE.Vector3();\n\n\t\tvar intersectionPoint = new THREE.Vector3();\n\t\tvar intersectionPointWorld = new THREE.Vector3();\n\n\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\treturn uv1.clone();\n\n\t\t}\n\n\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\tvar intersect;\n\t\t\tvar material = object.material;\n\n\t\t\tif ( material.side === THREE.BackSide ) {\n\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t} else {\n\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\n\n\t\t\t}\n\n\t\t\tif ( intersect === null ) return null;\n\n\t\t\tintersectionPointWorld.copy( point );\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\treturn {\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\tobject: object\n\t\t\t};\n\n\t\t}\n\n\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\tif ( intersection ) {\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n\t\t\t\t}\n\n\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\n\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t}\n\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar material = this.material;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\tif ( material === undefined ) return;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t// Check boundingBox before continuing\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t}\n\n\t\t\tvar uvs, intersection;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar a, b, c;\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\tuvs = attributes.uv.array;\n\n\t\t\t\t}\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\tc = indices[ i + 2 ];\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\n\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\tc = a + 2;\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\n\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Bone.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.Bone = function ( skin ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Bone';\n\n\tthis.skin = skin;\n\n};\n\nTHREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Bone,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.skin = source.skin;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/objects/Skeleton.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author michael guerrero / http://realitymeltdown.com\n * @author ikerr / http://verold.com\n */\n\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\n\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\tthis.identityMatrix = new THREE.Matrix4();\n\n\t// copy the bone array\n\n\tbones = bones || [];\n\n\tthis.bones = bones.slice( 0 );\n\n\t// create a bone texture or an array of floats\n\n\tif ( this.useVertexTexture ) {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\tsize = Math.max( size, 4 );\n\n\t\tthis.boneTextureWidth = size;\n\t\tthis.boneTextureHeight = size;\n\n\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\n\t} else {\n\n\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n\t}\n\n\t// use the supplied bone inverses or calculate the inverses\n\n\tif ( boneInverses === undefined ) {\n\n\t\tthis.calculateInverses();\n\n\t} else {\n\n\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Skeleton.prototype, {\n\n\tcalculateInverses: function () {\n\n\t\tthis.boneInverses = [];\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tvar inverse = new THREE.Matrix4();\n\n\t\t\tif ( this.bones[ b ] ) {\n\n\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t},\n\n\tpose: function () {\n\n\t\tvar bone;\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdate: ( function () {\n\n\t\tvar offsetMatrix = new THREE.Matrix4();\n\n\t\treturn function update() {\n\n\t\t\t// flatten bone matrices to array\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n\t\t\t}\n\n\t\t\tif ( this.useVertexTexture ) {\n\n\t\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )(),\n\n\tclone: function () {\n\n\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n\t}\n\n} );\n\n// File:src/objects/SkinnedMesh.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.type = 'SkinnedMesh';\n\n\tthis.bindMode = \"attached\";\n\tthis.bindMatrix = new THREE.Matrix4();\n\tthis.bindMatrixInverse = new THREE.Matrix4();\n\n\t// init bones\n\n\t// TODO: remove bone creation as there is no reason (other than\n\t// convenience) for THREE.SkinnedMesh to do this.\n\n\tvar bones = [];\n\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\tvar bone, gbone;\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tbone = new THREE.Bone( this );\n\t\t\tbones.push( bone );\n\n\t\t\tbone.name = gbone.name;\n\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t}\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\n\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\n\t\t\t} else {\n\n\t\t\t\tthis.add( bones[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.normalizeSkinWeights();\n\n\tthis.updateMatrixWorld( true );\n\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n};\n\n\nTHREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\n\n\tconstructor: THREE.SkinnedMesh,\n\n\tbind: function( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t},\n\n\tpose: function () {\n\n\t\tthis.skeleton.pose();\n\n\t},\n\n\tnormalizeSkinWeights: function () {\n\n\t\tif ( this.geometry instanceof THREE.Geometry ) {\n\n\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar vec = new THREE.Vector4();\n\n\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdateMatrixWorld: function( force ) {\n\n\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\n\n\t\tif ( this.bindMode === \"attached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t} else if ( this.bindMode === \"detached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t},\n\n\tclone: function() {\n\n\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LOD.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LOD = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'LOD';\n\n\tObject.defineProperties( this, {\n\t\tlevels: {\n\t\t\tenumerable: true,\n\t\t\tvalue: []\n\t\t}\n\t} );\n\n};\n\n\nTHREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LOD,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\n\n\t\tvar levels = source.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\taddLevel: function ( object, distance ) {\n\n\t\tif ( distance === undefined ) distance = 0;\n\n\t\tdistance = Math.abs( distance );\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\tthis.add( object );\n\n\t},\n\n\tgetObjectForDistance: function ( distance ) {\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn levels[ i - 1 ].object;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t};\n\n\t}() ),\n\n\tupdate: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.levels = [];\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/objects/Sprite.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Sprite = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Sprite';\n\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\n};\n\nTHREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Sprite,\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\n\t\t\tif ( distanceSq > guessSizeSq ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tintersects.push( {\n\n\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\tpoint: this.position,\n\t\t\t\tface: null,\n\t\t\t\tobject: this\n\n\t\t\t} );\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LensFlare.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.lensFlares = [];\n\n\tthis.positionScreen = new THREE.Vector3();\n\tthis.customUpdateCallback = undefined;\n\n\tif ( texture !== undefined ) {\n\n\t\tthis.add( texture, size, distance, blending, color );\n\n\t}\n\n};\n\nTHREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LensFlare,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.positionScreen.copy( source.positionScreen );\n\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\n\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\n\t\tif ( size === undefined ) size = - 1;\n\t\tif ( distance === undefined ) distance = 0;\n\t\tif ( opacity === undefined ) opacity = 1;\n\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\n\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\n\n\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\t\tthis.lensFlares.push( {\n\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\tscale: 1, \t\t// scale\n\t\t\trotation: 0, \t\t// rotation\n\t\t\topacity: opacity,\t// opacity\n\t\t\tcolor: color,\t\t// color\n\t\t\tblending: blending\t// blending\n\t\t} );\n\n\t},\n\n\t/*\n\t * Update lens flares update positions on all flares based on the screen position\n\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t */\n\n\tupdateLensFlares: function () {\n\n\t\tvar f, fl = this.lensFlares.length;\n\t\tvar flare;\n\t\tvar vecX = - this.positionScreen.x * 2;\n\t\tvar vecY = - this.positionScreen.y * 2;\n\n\t\tfor ( f = 0; f < fl; f ++ ) {\n\n\t\t\tflare = this.lensFlares[ f ];\n\n\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/scenes/Scene.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Scene = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Scene';\n\n\tthis.background = null;\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.autoUpdate = true; // checked by the renderer\n\n};\n\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Scene.prototype.constructor = THREE.Scene;\n\nTHREE.Scene.prototype.copy = function ( source, recursive ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\n\n\tif ( source.background !== null ) this.background = source.background.clone();\n\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\tthis.autoUpdate = source.autoUpdate;\n\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\treturn this;\n\n};\n\n// File:src/scenes/Fog.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Fog = function ( color, near, far ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n};\n\nTHREE.Fog.prototype.clone = function () {\n\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\n};\n\n// File:src/scenes/FogExp2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FogExp2 = function ( color, density ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n};\n\nTHREE.FogExp2.prototype.clone = function () {\n\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\n};\n\n// File:src/renderers/shaders/ShaderChunk.js\n\nTHREE.ShaderChunk = {};\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\n\nTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\n\nTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/common.glsl\n\nTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\n\nTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\n\nTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\n\nTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#include <normal_flip>\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#include <normal_flip>\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t\tfloat clearCoat;\\n\t\tfloat clearCoatRoughness;\\n\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\t#ifndef STANDARD\\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\t#ifndef STANDARD\\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\n\nTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\t#ifndef STANDARD\\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\t#else\\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\t#endif\\n\t\t\\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_flip.glsl\n\nTHREE.ShaderChunk[ 'normal_flip' ] = \"#ifdef DOUBLE_SIDED\\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\n\nTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/packing.glsl\n\nTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\n\nTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\n\nTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\n\nTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/UniformsUtils.js\n\n/**\n * Uniform Utilities\n */\n\nTHREE.UniformsUtils = {\n\n\tmerge: function ( uniforms ) {\n\n\t\tvar merged = {};\n\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn merged;\n\n\t},\n\n\tclone: function ( uniforms_src ) {\n\n\t\tvar uniforms_dst = {};\n\n\t\tfor ( var u in uniforms_src ) {\n\n\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uniforms_dst;\n\n\t}\n\n};\n\n// File:src/renderers/shaders/UniformsLib.js\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nTHREE.UniformsLib = {\n\n\tcommon: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\n\t\t\"specularMap\": { value: null },\n\t\t\"alphaMap\": { value: null },\n\n\t\t\"envMap\": { value: null },\n\t\t\"flipEnvMap\": { value: - 1 },\n\t\t\"reflectivity\": { value: 1.0 },\n\t\t\"refractionRatio\": { value: 0.98 }\n\n\t},\n\n\taomap: {\n\n\t\t\"aoMap\": { value: null },\n\t\t\"aoMapIntensity\": { value: 1 }\n\n\t},\n\n\tlightmap: {\n\n\t\t\"lightMap\": { value: null },\n\t\t\"lightMapIntensity\": { value: 1 }\n\n\t},\n\n\temissivemap: {\n\n\t\t\"emissiveMap\": { value: null }\n\n\t},\n\n\tbumpmap: {\n\n\t\t\"bumpMap\": { value: null },\n\t\t\"bumpScale\": { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\t\"normalMap\": { value: null },\n\t\t\"normalScale\": { value: new THREE.Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\t\"displacementMap\": { value: null },\n\t\t\"displacementScale\": { value: 1 },\n\t\t\"displacementBias\": { value: 0 }\n\n\t},\n\n\troughnessmap: {\n\n\t\t\"roughnessMap\": { value: null }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\t\"metalnessMap\": { value: null }\n\n\t},\n\n\tfog: {\n\n\t\t\"fogDensity\": { value: 0.00025 },\n\t\t\"fogNear\": { value: 1 },\n\t\t\"fogFar\": { value: 2000 },\n\t\t\"fogColor\": { value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\t\"ambientLightColor\": { value: [] },\n\n\t\t\"directionalLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"color\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"directionalShadowMap\": { value: [] },\n\t\t\"directionalShadowMatrix\": { value: [] },\n\n\t\t\"spotLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"direction\": {},\n\t\t\t\"distance\": {},\n\t\t\t\"coneCos\": {},\n\t\t\t\"penumbraCos\": {},\n\t\t\t\"decay\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"spotShadowMap\": { value: [] },\n\t\t\"spotShadowMatrix\": { value: [] },\n\n\t\t\"pointLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"decay\": {},\n\t\t\t\"distance\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"pointShadowMap\": { value: [] },\n\t\t\"pointShadowMatrix\": { value: [] },\n\n\t\t\"hemisphereLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"skyColor\": {},\n\t\t\t\"groundColor\": {}\n\t\t} }\n\n\t},\n\n\tpoints: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\t\t\"size\": { value: 1.0 },\n\t\t\"scale\": { value: 1.0 },\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) }\n\n\t}\n\n};\n\n// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\n\nTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\n\nTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\n\nTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\n\nTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\n\nTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\n\nTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\n\nTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\n\nTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\tuniform float clearCoat;\\n\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\n\nTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\n\nTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_frag.glsl\n\nTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_vert.glsl\n\nTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl\n\nTHREE.ShaderChunk[ 'shadow_frag' ] = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl\n\nTHREE.ShaderChunk[ 'shadow_vert' ] = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib.js\n\n/**\n * Webgl Shader Library for three.js\n *\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\n\nTHREE.ShaderLib = {\n\n\t'basic': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\n\n\t},\n\n\t'lambert': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\n\n\t},\n\n\t'phong': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"specular\" : { value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"shininess\": { value: 30 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\n\n\t},\n\n\t'standard': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"roughness\": { value: 0.5 },\n\t\t\t\t\"metalness\": { value: 0 },\n\t\t\t\t\"envMapIntensity\" : { value: 1 }, // temporary\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n\t},\n\n\t'points': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'points' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\n\n\t},\n\n\t'dashed': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\n\t\t\t{\n\t\t\t\t\"scale\"    : { value: 1 },\n\t\t\t\t\"dashSize\" : { value: 1 },\n\t\t\t\t\"totalSize\": { value: 2 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\n\n\t},\n\n\t'depth': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\n\n\t},\n\n\t'normal': {\n\n\t\tuniforms: {\n\n\t\t\t\"opacity\" : { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'cube': {\n\n\t\tuniforms: {\n\t\t\t\"tCube\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'equirect': {\n\n\t\tuniforms: {\n\t\t\t\"tEquirect\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\n\n\t},\n\n\t'distanceRGBA': {\n\n\t\tuniforms: {\n\n\t\t\t\"lightPos\": { value: new THREE.Vector3() }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\n\n\t}\n\n};\n\nTHREE.ShaderLib[ 'physical' ] = {\n\n\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\n\n\t\t{\n\t\t\t\"clearCoat\": { value: 0 },\n\t\t\t\"clearCoatRoughness\": { value: 0 }\n\t\t}\n\n\t] ),\n\n\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n};\n\n// File:src/renderers/WebGLRenderer.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n * @author tschw\n */\n\nTHREE.WebGLRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n\tvar lights = [];\n\n\tvar opaqueObjects = [];\n\tvar opaqueObjectsLastIndex = - 1;\n\tvar transparentObjects = [];\n\tvar transparentObjectsLastIndex = - 1;\n\n\tvar morphInfluences = new Float32Array( 8 );\n\n\tvar sprites = [];\n\tvar lensFlares = [];\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\t// user-defined clipping\n\n\tthis.clippingPlanes = [];\n\tthis.localClippingEnabled = false;\n\n\t// physically based shading\n\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\n\t// physical lights\n\n\tthis.physicallyCorrectLights = false;\n\n\t// tone mapping\n\n\tthis.toneMapping = THREE.LinearToneMapping;\n\tthis.toneMappingExposure = 1.0;\n\tthis.toneMappingWhitePoint = 1.0;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t// internal state cache\n\n\t_currentProgram = null,\n\t_currentRenderTarget = null,\n\t_currentFramebuffer = null,\n\t_currentMaterialId = - 1,\n\t_currentGeometryProgram = '',\n\t_currentCamera = null,\n\n\t_currentScissor = new THREE.Vector4(),\n\t_currentScissorTest = null,\n\n\t_currentViewport = new THREE.Vector4(),\n\n\t//\n\n\t_usedTextureUnits = 0,\n\n\t//\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearAlpha = 0,\n\n\t_width = _canvas.width,\n\t_height = _canvas.height,\n\n\t_pixelRatio = 1,\n\n\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\n\t_scissorTest = false,\n\n\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\n\n\t// frustum\n\n\t_frustum = new THREE.Frustum(),\n\n\t// clipping\n\n\t_clipping = new THREE.WebGLClipping(),\n\t_clippingEnabled = false,\n\t_localClippingEnabled = false,\n\n\t_sphere = new THREE.Sphere(),\n\n\t// camera matrices cache\n\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_vector3 = new THREE.Vector3(),\n\n\t// light arrays cache\n\n\t_lights = {\n\n\t\thash: '',\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tdirectional: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotShadowMap: [],\n\t\tspotShadowMatrix: [],\n\t\tpoint: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: [],\n\n\t\tshadows: []\n\n\t},\n\n\t// info\n\n\t_infoRender = {\n\n\t\tcalls: 0,\n\t\tvertices: 0,\n\t\tfaces: 0,\n\t\tpoints: 0\n\n\t};\n\n\tthis.info = {\n\n\t\trender: _infoRender,\n\t\tmemory: {\n\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\n\t\t},\n\t\tprograms: null\n\n\t};\n\n\n\t// initialize\n\n\tvar _gl;\n\n\ttry {\n\n\t\tvar attributes = {\n\t\t\talpha: _alpha,\n\t\t\tdepth: _depth,\n\t\t\tstencil: _stencil,\n\t\t\tantialias: _antialias,\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t};\n\n\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\tif ( _gl === null ) {\n\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\n\t\t\t} else {\n\n\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t};\n\n\t\t}\n\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t} catch ( error ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\n\t}\n\n\tvar extensions = new THREE.WebGLExtensions( _gl );\n\n\textensions.get( 'WEBGL_depth_texture' );\n\textensions.get( 'OES_texture_float' );\n\textensions.get( 'OES_texture_float_linear' );\n\textensions.get( 'OES_texture_half_float' );\n\textensions.get( 'OES_texture_half_float_linear' );\n\textensions.get( 'OES_standard_derivatives' );\n\textensions.get( 'ANGLE_instanced_arrays' );\n\n\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\n\n\t}\n\n\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\n\n\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\n\tvar properties = new THREE.WebGLProperties();\n\tvar textures = new THREE.WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\n\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\n\tvar lightCache = new THREE.WebGLLights();\n\n\tthis.info.programs = programCache.programs;\n\n\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\n\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t//\n\n\tvar backgroundCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\tvar backgroundCamera2 = new THREE.PerspectiveCamera();\n\tvar backgroundPlaneMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry( 2, 2 ),\n\t\tnew THREE.MeshBasicMaterial( { depthTest: false, depthWrite: false } )\n\t);\n\tvar backgroundBoxShader = THREE.ShaderLib[ 'cube' ];\n\tvar backgroundBoxMesh = new THREE.Mesh(\n\t\tnew THREE.BoxBufferGeometry( 5, 5, 5 ),\n\t\tnew THREE.ShaderMaterial( {\n\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\tside: THREE.BackSide\n\t\t} )\n\t);\n\tobjects.update( backgroundPlaneMesh );\n\tobjects.update( backgroundBoxMesh );\n\n\t//\n\n\tfunction getTargetPixelRatio() {\n\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t}\n\n\tfunction glClearColor( r, g, b, a ) {\n\n\t\tif ( _premultipliedAlpha === true ) {\n\n\t\t\tr *= a; g *= a; b *= a;\n\n\t\t}\n\n\t\tstate.clearColor( r, g, b, a );\n\n\t}\n\n\tfunction setDefaultGLState() {\n\n\t\tstate.init();\n\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t}\n\n\tfunction resetGLState() {\n\n\t\t_currentProgram = null;\n\t\t_currentCamera = null;\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\n\t\tstate.reset();\n\n\t}\n\n\tsetDefaultGLState();\n\n\tthis.context = _gl;\n\tthis.capabilities = capabilities;\n\tthis.extensions = extensions;\n\tthis.properties = properties;\n\tthis.state = state;\n\n\t// shadow map\n\n\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\n\n\tthis.shadowMap = shadowMap;\n\n\n\t// Plugins\n\n\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\n\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _gl.getContextAttributes();\n\n\t};\n\n\tthis.forceContextLoss = function () {\n\n\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\n\t};\n\n\tthis.getMaxAnisotropy = function () {\n\n\t\treturn capabilities.getMaxAnisotropy();\n\n\t};\n\n\tthis.getPrecision = function () {\n\n\t\treturn capabilities.precision;\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value === undefined ) return;\n\n\t\t_pixelRatio = value;\n\n\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\n\t};\n\n\tthis.getSize = function () {\n\n\t\treturn {\n\t\t\twidth: _width,\n\t\t\theight: _height\n\t\t};\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_canvas.width = width * _pixelRatio;\n\t\t_canvas.height = height * _pixelRatio;\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t};\n\n\t// Clearing\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\n\t};\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.set( color );\n\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\n\t};\n\n\tthis.setClearAlpha = function ( alpha ) {\n\n\t\t_clearAlpha = alpha;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\tthis.clear( true, false, false );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\tthis.clear( false, true, false );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\tthis.clear( false, false, true );\n\n\t};\n\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t};\n\n\t// Reset\n\n\tthis.resetGLState = resetGLState;\n\n\tthis.dispose = function() {\n\n\t\ttransparentObjects = [];\n\t\ttransparentObjectsLastIndex = -1;\n\t\topaqueObjects = [];\n\t\topaqueObjectsLastIndex = -1;\n\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n\t};\n\n\t// Events\n\n\tfunction onContextLost( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tresetGLState();\n\t\tsetDefaultGLState();\n\n\t\tproperties.clear();\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tvar material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t}\n\n\t// Buffer deallocation\n\n\tfunction deallocateMaterial( material ) {\n\n\t\treleaseMaterialProgramReference( material );\n\n\t\tproperties.delete( material );\n\n\t}\n\n\n\tfunction releaseMaterialProgramReference( material ) {\n\n\t\tvar programInfo = properties.get( material ).program;\n\n\t\tmaterial.program = undefined;\n\n\t\tif ( programInfo !== undefined ) {\n\n\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t}\n\n\t}\n\n\t// Buffer rendering\n\n\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\tstate.initAttributes();\n\n\t\tvar buffers = properties.get( object );\n\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\n\n\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.normal );\n\n\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.uv );\n\n\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.color );\n\n\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\tsetMaterial( material );\n\n\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\tvar updateBuffers = false;\n\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphTargetInfluences !== undefined ) {\n\n\t\t\tvar activeInfluences = [];\n\n\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\n\t\t\t}\n\n\t\t\tactiveInfluences.sort( absNumericalSort );\n\n\t\t\tif ( activeInfluences.length > 8 ) {\n\n\t\t\t\tactiveInfluences.length = 8;\n\n\t\t\t}\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\n\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\n\t\t\t\t\tvar index = influence[ 1 ];\n\n\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t//\n\n\t\tvar index = geometry.index;\n\t\tvar position = geometry.attributes.position;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tindex = objects.getWireframeAttribute( geometry );\n\n\t\t}\n\n\t\tvar renderer;\n\n\t\tif ( index !== null ) {\n\n\t\t\trenderer = indexedBufferRenderer;\n\t\t\trenderer.setIndex( index );\n\n\t\t} else {\n\n\t\t\trenderer = bufferRenderer;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar dataStart = 0;\n\t\tvar dataCount = Infinity;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdataCount = index.count;\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\tdataCount = position.count;\n\n\t\t}\n\n\t\tvar rangeStart = geometry.drawRange.start;\n\t\tvar rangeCount = geometry.drawRange.count;\n\n\t\tvar groupStart = group !== null ? group.start : 0;\n\t\tvar groupCount = group !== null ? group.count : Infinity;\n\n\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\n\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t//\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\tcase THREE.TrianglesDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleStripDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleFanDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\tif ( object instanceof THREE.LineSegments ) {\n\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Points ) {\n\n\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t}\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t}\n\n\t};\n\n\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\tvar extension;\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\tstate.initAttributes();\n\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( var name in programAttributes ) {\n\n\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\n\t\t\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\t\t\ttype = _gl.FLOAT;\n\n\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\n\n\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\t\t\ttype = _gl.SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\n\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\t\t\ttype = _gl.INT;\n\n\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\t\t\ttype = _gl.BYTE;\n\n\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\n\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t}\n\n\t// Sorting\n\n\tfunction absNumericalSort( a, b ) {\n\n\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\treturn a.material.id - b.material.id;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn a.z - b.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\tfunction reversePainterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar fog = scene.fog;\n\n\t\t// reset caching for this frame\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\t\t_currentCamera = null;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\tlights.length = 0;\n\n\t\topaqueObjectsLastIndex = - 1;\n\t\ttransparentObjectsLastIndex = - 1;\n\n\t\tsprites.length = 0;\n\t\tlensFlares.length = 0;\n\n\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\tprojectObject( scene, camera );\n\n\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\n\t\tif ( _this.sortObjects === true ) {\n\n\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\tsetupShadows( lights );\n\n\t\tshadowMap.render( scene, camera );\n\n\t\tsetupLights( lights, camera );\n\n\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t//\n\n\t\t_infoRender.calls = 0;\n\t\t_infoRender.vertices = 0;\n\t\t_infoRender.faces = 0;\n\t\t_infoRender.points = 0;\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = null;\n\n\t\t}\n\n\t\tthis.setRenderTarget( renderTarget );\n\n\t\t//\n\n\t\tvar background = scene.background;\n\n\t\tif ( background === null ) {\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t} else if ( background instanceof THREE.Color ) {\n\n\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\n\t\t}\n\n\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background instanceof THREE.CubeTexture ) {\n\n\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\n\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n\t\t} else if ( background instanceof THREE.Texture ) {\n\n\t\t\tbackgroundPlaneMesh.material.map = background;\n\n\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\n\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\n\n\t\t} else {\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\t\t\trenderObjects( opaqueObjects, camera, fog );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\trenderObjects( transparentObjects, camera, fog );\n\n\t\t}\n\n\t\t// custom render plugins (post pass)\n\n\t\tspritePlugin.render( scene, camera );\n\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\tif ( renderTarget ) {\n\n\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tstate.setDepthTest( true );\n\t\tstate.setDepthWrite( true );\n\t\tstate.setColorWrite( true );\n\n\t\t// _gl.finish();\n\n\t};\n\n\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\n\t\tvar array, index;\n\n\t\t// allocate the next position in the appropriate array\n\n\t\tif ( material.transparent ) {\n\n\t\t\tarray = transparentObjects;\n\t\t\tindex = ++ transparentObjectsLastIndex;\n\n\t\t} else {\n\n\t\t\tarray = opaqueObjects;\n\t\t\tindex = ++ opaqueObjectsLastIndex;\n\n\t\t}\n\n\t\t// recycle existing render item or grow the array\n\n\t\tvar renderItem = array[ index ];\n\n\t\tif ( renderItem !== undefined ) {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.z = _vector3.z;\n\t\t\trenderItem.group = group;\n\n\t\t} else {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tz: _vector3.z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\t// assert( index === array.length );\n\t\t\tarray.push( renderItem );\n\n\t\t}\n\n\t}\n\n\t// TODO Duplicated code (Frustum)\n\n\tfunction isObjectViewable( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometry.boundingSphere === null )\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSpriteViewable( sprite ) {\n\n\t\t_sphere.center.set( 0, 0, 0 );\n\t\t_sphere.radius = 0.7071067811865476;\n\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSphereViewable( sphere ) {\n\n\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\tif ( numPlanes === 0 ) return true;\n\n\t\tvar planes = _this.clippingPlanes,\n\n\t\t\tcenter = sphere.center,\n\t\t\tnegRad = - sphere.radius,\n\t\t\ti = 0;\n\n\t\tdo {\n\n\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t} while ( ++ i !== numPlanes );\n\n\t\treturn true;\n\n\t}\n\n\tfunction projectObject( object, camera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\tlights.push( object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n\t\t\t\t\tsprites.push( object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\t\tlensFlares.push( object );\n\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\n\n\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar geometry = objects.update( object );\n\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera );\n\n\t\t}\n\n\t}\n\n\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\n\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\tvar object = renderItem.object;\n\t\t\tvar geometry = renderItem.geometry;\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\tvar group = renderItem.group;\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tsetMaterial( material );\n\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initMaterial( material, fog, object ) {\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tvar parameters = programCache.getParameters(\n\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, object );\n\n\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\tvar program = materialProperties.program;\n\t\tvar programChange = true;\n\n\t\tif ( program === undefined ) {\n\n\t\t\t// new material\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t} else if ( program.code !== code ) {\n\n\t\t\t// changed glsl or parameters\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t// same glsl and uniform list\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// only rebuild uniform list\n\t\t\tprogramChange = false;\n\n\t\t}\n\n\t\tif ( programChange ) {\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\n\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\n\t\t\tmaterialProperties.program = program;\n\t\t\tmaterial.program = program;\n\n\t\t}\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\n\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\n\t\t\t\tmaterial.clipping === true ) {\n\n\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t}\n\n\t\tif ( material.lights ) {\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\n\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\n\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\n\t\t}\n\n\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\tuniformsList =\n\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\tmaterialProperties.uniformsList = uniformsList;\n\t\tmaterialProperties.dynamicUniforms =\n\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\n\n\t}\n\n\tfunction setMaterial( material ) {\n\n\t\tif ( material.side !== THREE.DoubleSide )\n\t\t\tstate.enable( _gl.CULL_FACE );\n\t\telse\n\t\t\tstate.disable( _gl.CULL_FACE );\n\n\t\tstate.setFlipSided( material.side === THREE.BackSide );\n\n\t\tif ( material.transparent === true ) {\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\t} else {\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\n\t\t}\n\n\t\tstate.setDepthFunc( material.depthFunc );\n\t\tstate.setDepthTest( material.depthTest );\n\t\tstate.setDepthWrite( material.depthWrite );\n\t\tstate.setColorWrite( material.colorWrite );\n\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t}\n\n\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t_usedTextureUnits = 0;\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tif ( _clippingEnabled ) {\n\n\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\tvar useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t// (#8465, #8379)\n\t\t\t\t_clipping.setState(\n\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\n\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t}\n\n\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\tmaterialProperties.numClippingPlanes !== _clipping.numPlanes ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( materialProperties.lightsHash !== undefined &&\n\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tinitMaterial( material, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tvar refreshProgram = false;\n\t\tvar refreshMaterial = false;\n\t\tvar refreshLights = false;\n\n\t\tvar program = materialProperties.program,\n\t\t\tp_uniforms = program.getUniforms(),\n\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( program.id !== _currentProgram ) {\n\n\t\t\t_gl.useProgram( program.program );\n\t\t\t_currentProgram = program.id;\n\n\t\t\trefreshProgram = true;\n\t\t\trefreshMaterial = true;\n\t\t\trefreshLights = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t}\n\n\n\t\t\tif ( camera !== _currentCamera ) {\n\n\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t}\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material.envMap ) {\n\n\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material.skinning ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\tvar skeleton = object.skeleton;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t// values\n\t\t\t\t//\n\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t// the GL state when required\n\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t}\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t}\n\n\t\t\t// refresh single material specific uniforms\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\n\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\n\n\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\tTHREE.WebGLUniforms.upload(\n\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t}\n\n\n\t\t// common matrices\n\n\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\n\t\t// dynamic uniforms\n\n\t\tvar dynUniforms = materialProperties.dynamicUniforms;\n\n\t\tif ( dynUniforms !== null ) {\n\n\t\t\tTHREE.WebGLUniforms.evalDynamic(\n\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\n\n\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon ( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tuniforms.diffuse.value = material.color;\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tuniforms.map.value = material.map;\n\t\tuniforms.specularMap.value = material.specularMap;\n\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. specular map\n\t\t// 3. normal map\n\t\t// 4. bump map\n\t\t// 5. alpha map\n\t\t// 6. emissive map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.displacementMap ) {\n\n\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t} else if ( material.roughnessMap ) {\n\n\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t} else if ( material.metalnessMap ) {\n\n\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t} else if ( material.emissiveMap ) {\n\n\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tvar offset = uvScaleMap.offset;\n\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t\tuniforms.envMap.value = material.envMap;\n\n\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;\n\n\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t}\n\n\tfunction refreshUniformsLine ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\n\t}\n\n\tfunction refreshUniformsDash ( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\n\n\t\tuniforms.map.value = material.map;\n\n\t\tif ( material.map !== null ) {\n\n\t\t\tvar offset = material.map.offset;\n\t\t\tvar repeat = material.map.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsFog ( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value = fog.color;\n\n\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLambert ( uniforms, material ) {\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong ( uniforms, material ) {\n\n\t\tuniforms.specular.value = material.specular;\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard ( uniforms, material ) {\n\n\t\tuniforms.roughness.value = material.roughness;\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t}\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical ( uniforms, material ) {\n\n\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\trefreshUniformsStandard( uniforms, material );\n\n\t}\n\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\n\n\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\tuniforms.directionalLights.needsUpdate = value;\n\t\tuniforms.pointLights.needsUpdate = value;\n\t\tuniforms.spotLights.needsUpdate = value;\n\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t}\n\n\t// Lighting\n\n\tfunction setupShadows ( lights ) {\n\n\t\tvar lightShadowsLength = 0;\n\n\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tvar light = lights[ i ];\n\n\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.shadows.length = lightShadowsLength;\n\n\t}\n\n\tfunction setupLights ( lights, camera ) {\n\n\t\tvar l, ll, light,\n\t\tr = 0, g = 0, b = 0,\n\t\tcolor,\n\t\tintensity,\n\t\tdistance,\n\t\tshadowMap,\n\n\t\tviewMatrix = camera.matrixWorldInverse,\n\n\t\tdirectionalLength = 0,\n\t\tpointLength = 0,\n\t\tspotLength = 0,\n\t\themiLength = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tcolor = light.color;\n\t\t\tintensity = light.intensity;\n\t\t\tdistance = light.distance;\n\n\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\n\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\n\n\t\t\t\t}\n\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.ambient[ 0 ] = r;\n\t\t_lights.ambient[ 1 ] = g;\n\t\t_lights.ambient[ 2 ] = b;\n\n\t\t_lights.directional.length = directionalLength;\n\t\t_lights.spot.length = spotLength;\n\t\t_lights.point.length = pointLength;\n\t\t_lights.hemi.length = hemiLength;\n\n\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n\t}\n\n\t// GL state setting\n\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\tstate.setCullFace( cullFace );\n\t\tstate.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );\n\n\t};\n\n\t// Textures\n\n\tfunction allocTextureUnit() {\n\n\t\tvar textureUnit = _usedTextureUnits;\n\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t}\n\n\t\t_usedTextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\tthis.allocTextureUnit = allocTextureUnit;\n\n\t// this.setTexture2D = setTexture2D;\n\tthis.setTexture2D = ( function() {\n\n\t\tvar warned = false;\n\n\t\t// backwards compatibility: peel texture.texture\n\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\tif ( texture instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTexture = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTexture( texture, slot ) {\n\n\t\t\tif ( ! warned ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\twarned = true;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTextureCube = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\tif ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t// TODO: unify these code paths\n\t\t\tif ( texture instanceof THREE.CubeTexture ||\n\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t} else {\n\n\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tthis.getCurrentRenderTarget = function() {\n\n\t\treturn _currentRenderTarget;\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t_currentRenderTarget = renderTarget;\n\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t}\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar framebuffer;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\n\t\t\t}\n\n\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t_currentViewport.copy( renderTarget.viewport );\n\n\t\t} else {\n\n\t\t\tframebuffer = null;\n\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n\t\t}\n\n\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\tstate.scissor( _currentScissor );\n\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\tstate.viewport( _currentViewport );\n\n\t\tif ( isCube ) {\n\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t}\n\n\t};\n\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\tif ( framebuffer ) {\n\n\t\t\tvar restore = false;\n\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\trestore = true;\n\n\t\t\t}\n\n\t\t\ttry {\n\n\t\t\t\tvar texture = renderTarget.texture;\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\n\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\n\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\n\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t}\n\n\t\t\t} finally {\n\n\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Map three.js constants to WebGL constants\n\n\tfunction paramThreeToGL ( p ) {\n\n\t\tvar extension;\n\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\n\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\n\n\t\t}\n\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\n\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\n\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n};\n\n// File:src/renderers/WebGLRenderTarget.js\n\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n * @author Marius Kintel / https://github.com/kintel\n */\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\n\tthis.scissorTest = false;\n\n\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\n\n\toptions = options || {};\n\n\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\n\n\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\tthis.depthTexture = null;\n\n};\n\nObject.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {\n\n\tsetSize: function ( width, height ) {\n\n\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.texture = source.texture.clone();\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\tthis.depthTexture = source.depthTexture;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/renderers/WebGLRenderTargetCube.js\n\n/**\n * @author alteredq / http://alteredqualia.com\n */\n\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\tthis.activeMipMapLevel = 0;\n\n};\n\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\n\n// File:src/renderers/webgl/WebGLBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawArrays( mode, start, count );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar position = geometry.attributes.position;\n\n\t\tvar count = 0;\n\n\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tcount = position.data.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t} else {\n\n\t\t\tcount = position.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t}\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t}\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLClipping.js\n\nTHREE.WebGLClipping = function() {\n\n\tvar scope = this,\n\n\t\tglobalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false,\n\n\t\tplane = new THREE.Plane(),\n\t\tviewNormalMatrix = new THREE.Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\n\tthis.init = function( planes, enableLocalClipping, camera ) {\n\n\t\tvar enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function() {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function() {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function( planes, clipShadows, camera, cache, fromCache ) {\n\n\t\tif ( ! localClippingEnabled ||\n\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tcache.clippingState = dstArray;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\tdstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\treturn dstArray;\n\n\t}\n\n};\n\n\n// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tvar type, size;\n\n\tfunction setIndex( index ) {\n\n\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\ttype = _gl.UNSIGNED_INT;\n\t\t\tsize = 4;\n\n\t\t} else {\n\n\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\t\tsize = 2;\n\n\t\t}\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawElements( mode, count, type, start * size );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry, start, count ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t}\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLExtensions.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLExtensions = function ( gl ) {\n\n\tvar extensions = {};\n\n\tthis.get = function ( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tvar extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLCapabilities.js\n\nTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\n\n\tvar maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tthis.getMaxAnisotropy = getMaxAnisotropy;\n\tthis.getMaxPrecision = getMaxPrecision;\n\n\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\n\n\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\tthis.vertexTextures = this.maxVertexTextures > 0;\n\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\n\n\tvar _maxPrecision = getMaxPrecision( this.precision );\n\n\tif ( _maxPrecision !== this.precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\n\t\tthis.precision = _maxPrecision;\n\n\t}\n\n\tif ( this.logarithmicDepthBuffer ) {\n\n\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLGeometries.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLGeometries = function ( gl, properties, info ) {\n\n\tvar geometries = {};\n\n\tfunction get( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\n\t\t\treturn geometries[ geometry.id ];\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tvar buffergeometry;\n\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tbuffergeometry = geometry;\n\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\n\n\t\t\t}\n\n\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t}\n\n\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tvar geometry = event.target;\n\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\tdeleteAttribute( buffergeometry.index );\n\n\t\t}\n\n\t\tdeleteAttributes( buffergeometry.attributes );\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\t// TODO\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe ) {\n\n\t\t\tdeleteAttribute( property.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( geometry );\n\n\t\tvar bufferproperty = properties.get( buffergeometry );\n\n\t\tif ( bufferproperty.wireframe ) {\n\n\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( buffergeometry );\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction deleteAttribute( attribute ) {\n\n\t\tvar buffer = getAttributeBuffer( attribute );\n\n\t\tif ( buffer !== undefined ) {\n\n\t\t\tgl.deleteBuffer( buffer );\n\t\t\tremoveAttributeBuffer( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction deleteAttributes( attributes ) {\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tdeleteAttribute( attributes[ name ] );\n\n\t\t}\n\n\t}\n\n\tfunction removeAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tproperties.delete( attribute.data );\n\n\t\t} else {\n\n\t\t\tproperties.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tthis.get = get;\n\n};\n\n// File:src/renderers/webgl/WebGLLights.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLLights = function () {\n\n\tvar lights = {};\n\n\tthis.get = function ( light ) {\n\n\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\treturn lights[ light.id ];\n\n\t\t}\n\n\t\tvar uniforms;\n\n\t\tswitch ( light.type ) {\n\n\t\t\tcase 'DirectionalLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tconeCos: 0,\n\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tskyColor: new THREE.Color(),\n\t\t\t\t\tgroundColor: new THREE.Color()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tlights[ light.id ] = uniforms;\n\n\t\treturn uniforms;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLObjects.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLObjects = function ( gl, properties, info ) {\n\n\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\n\n\t//\n\n\tfunction update( object ) {\n\n\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n\t\tvar geometry = geometries.get( object );\n\n\t\tif ( object.geometry instanceof THREE.Geometry ) {\n\n\t\t\tgeometry.updateFromObject( object );\n\n\t\t}\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\n\t\tif ( index !== null ) {\n\n\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction updateAttribute( attribute, bufferType ) {\n\n\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\n\n\t\tvar attributeProperties = properties.get( data );\n\n\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\n\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\n\t\t} else if ( attributeProperties.version !== data.version ) {\n\n\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\n\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\tgl.bufferData( bufferType, data.array, usage );\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\n\t\t} else if ( data.updateRange.count === 0 ) {\n\n\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t} else {\n\n\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n\t\t\tdata.updateRange.count = 0; // reset range\n\n\t\t}\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe !== undefined ) {\n\n\t\t\treturn property.wireframe;\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\t\tvar position = attributes.position;\n\n\t\t// console.time( 'wireframe' );\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar edges = {};\n\t\t\tvar array = index.array;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\n\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\n\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar array = attributes.position.array;\n\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tvar a = i + 0;\n\t\t\t\tvar b = i + 1;\n\t\t\t\tvar c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// console.timeEnd( 'wireframe' );\n\n\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\n\n\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\tproperty.wireframe = attribute;\n\n\t\treturn attribute;\n\n\t}\n\n\tfunction checkEdge( edges, a, b ) {\n\n\t\tif ( a > b ) {\n\n\t\t\tvar tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\n\t\t}\n\n\t\tvar list = edges[ a ];\n\n\t\tif ( list === undefined ) {\n\n\t\t\tedges[ a ] = [ b ];\n\t\t\treturn true;\n\n\t\t} else if ( list.indexOf( b ) === -1 ) {\n\n\t\t\tlist.push( b );\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tthis.getAttributeBuffer = getAttributeBuffer;\n\tthis.getWireframeAttribute = getWireframeAttribute;\n\n\tthis.update = update;\n\n};\n\n// File:src/renderers/webgl/WebGLProgram.js\n\nTHREE.WebGLProgram = ( function () {\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase THREE.LinearEncoding:\n\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\tcase THREE.sRGBEncoding:\n\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\tcase THREE.RGBEEncoding:\n\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\tcase THREE.RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\tcase THREE.RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\tcase THREE.RGBDEncoding:\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\tcase THREE.GammaEncoding:\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase THREE.LinearToneMapping:\n\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.ReinhardToneMapping:\n\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.CineonToneMapping:\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = THREE.ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\treturn function WebGLProgram( renderer, code, material, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar extensions = material.extensions;\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeReflectionMapping:\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.CubeUVReflectionMapping:\n\t\t\t\tcase THREE.CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.EquirectangularReflectionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase THREE.MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material instanceof THREE.RawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\n\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\n\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\t}\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function() {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms =\n\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function() {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function() {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLPrograms.js\n\nTHREE.WebGLPrograms = function ( renderer, capabilities ) {\n\n\tvar programs = [];\n\n\tvar shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points'\n\t};\n\n\tvar parameterNames = [\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\n\t];\n\n\n\tfunction allocateBones ( object ) {\n\n\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t//\n\t\t\t//  - leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t}\n\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\tvar encoding;\n\n\t\tif ( ! map ) {\n\n\t\t\tencoding = THREE.LinearEncoding;\n\n\t\t} else if ( map instanceof THREE.Texture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\tencoding = map.texture.encoding;\n\n\t\t}\n\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\tencoding = THREE.GammaEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\n\n\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tvar maxBones = allocateBones( object );\n\t\tvar precision = renderer.getPrecision();\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\n\t\tvar parameters = {\n\n\t\t\tshaderID: shaderID,\n\n\t\t\tprecision: precision,\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\tmap: !! material.map,\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\tenvMap: !! material.envMap,\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\n\t\t\tlightMap: !! material.lightMap,\n\t\t\taoMap: !! material.aoMap,\n\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\tbumpMap: !! material.bumpMap,\n\t\t\tnormalMap: !! material.normalMap,\n\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\tspecularMap: !! material.specularMap,\n\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\tcombine: material.combine,\n\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\n\t\t\tflatShading: material.shading === THREE.FlatShading,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\tskinning: material.skinning,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumClippingPlanes: nClipPlanes,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\tflipSided: material.side === THREE.BackSide,\n\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t};\n\n\t\treturn parameters;\n\n\t};\n\n\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\tvar array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( material.fragmentShader );\n\t\t\tarray.push( material.vertexShader );\n\n\t\t}\n\n\t\tif ( material.defines !== undefined ) {\n\n\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t}\n\n\t\treturn array.join();\n\n\t};\n\n\tthis.acquireProgram = function ( material, parameters, code ) {\n\n\t\tvar program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\tprogram = programInfo;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\tthis.releaseProgram = function( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tvar i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t};\n\n\t// Exposed for resource monitoring & error feedback via renderer.info:\n\tthis.programs = programs;\n\n};\n\n// File:src/renderers/webgl/WebGLProperties.js\n\n/**\n* @author fordacious / fordacious.github.io\n*/\n\nTHREE.WebGLProperties = function () {\n\n\tvar properties = {};\n\n\tthis.get = function ( object ) {\n\n\t\tvar uuid = object.uuid;\n\t\tvar map = properties[ uuid ];\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties[ uuid ] = map;\n\n\t\t}\n\n\t\treturn map;\n\n\t};\n\n\tthis.delete = function ( object ) {\n\n\t\tdelete properties[ object.uuid ];\n\n\t};\n\n\tthis.clear = function () {\n\n\t\tproperties = {};\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLShader.js\n\nTHREE.WebGLShader = ( function () {\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\treturn function WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLShadowMap.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\n\n\tvar _gl = _renderer.context,\n\t_state = _renderer.state,\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_lightShadows = _lights.shadows,\n\n\t_shadowMapSize = new THREE.Vector2(),\n\n\t_lookTarget = new THREE.Vector3(),\n\t_lightPositionWorld = new THREE.Vector3(),\n\n\t_renderList = [],\n\n\t_MorphingFlag = 1,\n\t_SkinningFlag = 2,\n\n\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t_materialCache = {};\n\n\tvar cubeDirections = [\n\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\n\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\n\t];\n\n\tvar cubeUps = [\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\n\t];\n\n\tvar cube2DViewPorts = [\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\n\t];\n\n\t// init\n\n\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\n\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\n\tdepthMaterialTemplate.clipping = true;\n\n\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\n\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\n\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\tdepthMaterial.morphTargets = useMorphing;\n\t\tdepthMaterial.skinning = useSkinning;\n\n\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\n\t\t\tdefines: {\n\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t},\n\t\t\tuniforms: distanceUniforms,\n\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\tmorphTargets: useMorphing,\n\t\t\tskinning: useSkinning,\n\t\t\tclipping: true\n\t\t} );\n\n\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t}\n\n\t//\n\n\tvar scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = THREE.PCFShadowMap;\n\n\tthis.renderReverseSided = true;\n\tthis.renderSingleSided = true;\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( _lightShadows.length === 0 ) return;\n\n\t\t// Set GL state for depth map.\n\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t_state.disable( _gl.BLEND );\n\t\t_state.setDepthTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tvar faceCount, isPointLight;\n\n\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n\t\t\tvar light = _lightShadows[ i ];\n\t\t\tvar shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tif ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tfaceCount = 6;\n\t\t\t\tisPointLight = true;\n\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t// following orientation:\n\t\t\t\t//\n\t\t\t\t//  xzXZ\n\t\t\t\t//   y Y\n\t\t\t\t//\n\t\t\t\t// X - Positive x direction\n\t\t\t\t// x - Negative x direction\n\t\t\t\t// Y - Positive y direction\n\t\t\t\t// y - Negative y direction\n\t\t\t\t// Z - Positive z direction\n\t\t\t\t// z - Negative z direction\n\n\t\t\t\t// positive X\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative X\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Z\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative Z\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Y\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t// negative Y\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t} else {\n\n\t\t\t\tfaceCount = 1;\n\t\t\t\tisPointLight = false;\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\n\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\n\n\t\t\t\tshadow.update( light );\n\n\t\t\t}\n\n\t\t\tvar shadowMap = shadow.map;\n\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t// run a single pass if not\n\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t}\n\n\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\t\t// compute shadow matrix\n\n\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t);\n\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t_renderList.length = 0;\n\n\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\n\t\t\t\t// render shadow map\n\t\t\t\t// render regular objects\n\n\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Restore GL state.\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\n\t\tscope.needsUpdate = false;\n\n\t};\n\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tvar result = null;\n\n\t\tvar materialVariants = _depthMaterials;\n\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\tif ( isPointLight ) {\n\n\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t}\n\n\t\tif ( ! customMaterial ) {\n\n\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\n\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\n\n\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\n\n\t\t\tvar variantIndex = 0;\n\n\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t} else {\n\n\t\t\tresult = customMaterial;\n\n\t\t}\n\n\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t material.clipShadows === true &&\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tvar side = material.side;\n\n\t\tif ( scope.renderSingleSided && side == THREE.DoubleSide ) {\n\n\t\t\tside = THREE.FrontSide;\n\n\t\t}\n\n\t\tif ( scope.renderReverseSided ) {\n\n\t\t\tif ( side === THREE.FrontSide ) side = THREE.BackSide;\n\t\t\telse if ( side === THREE.BackSide ) side = THREE.FrontSide;\n\n\t\t}\n\n\t\tresult.side = side;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction projectObject( object, camera, shadowCamera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\n\n\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t_renderList.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLState.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\n\n\tvar _this = this;\n\n\tthis.buffers = {\n\t\tcolor: new THREE.WebGLColorBuffer( gl, this ),\n\t\tdepth: new THREE.WebGLDepthBuffer( gl, this ),\n\t\tstencil: new THREE.WebGLStencilBuffer( gl, this )\n\t};\n\n\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\tvar capabilities = {};\n\n\tvar compressedTextureFormats = null;\n\n\tvar currentBlending = null;\n\tvar currentBlendEquation = null;\n\tvar currentBlendSrc = null;\n\tvar currentBlendDst = null;\n\tvar currentBlendEquationAlpha = null;\n\tvar currentBlendSrcAlpha = null;\n\tvar currentBlendDstAlpha = null;\n\tvar currentPremultipledAlpha = false;\n\n\tvar currentFlipSided = null;\n\tvar currentCullFace = null;\n\n\tvar currentLineWidth = null;\n\n\tvar currentPolygonOffsetFactor = null;\n\tvar currentPolygonOffsetUnits = null;\n\n\tvar currentScissorTest = null;\n\n\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n\tvar currentTextureSlot = null;\n\tvar currentBoundTextures = {};\n\n\tvar currentScissor = new THREE.Vector4();\n\tvar currentViewport = new THREE.Vector4();\n\n\tfunction createTexture( type, target, count ) {\n\n\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tvar texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tvar emptyTextures = {};\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t//\n\n\tthis.init = function () {\n\n\t\tthis.clearColor( 0, 0, 0, 1 );\n\t\tthis.clearDepth( 1 );\n\t\tthis.clearStencil( 0 );\n\n\t\tthis.enable( gl.DEPTH_TEST );\n\t\tthis.setDepthFunc( THREE.LessEqualDepth );\n\n\t\tthis.setFlipSided( false );\n\t\tthis.setCullFace( THREE.CullFaceBack );\n\t\tthis.enable( gl.CULL_FACE );\n\n\t\tthis.enable( gl.BLEND );\n\t\tthis.setBlending( THREE.NormalBlending );\n\n\t};\n\n\tthis.initAttributes = function () {\n\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttribute = function ( attribute ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t};\n\n\tthis.disableUnusedAttributes = function () {\n\n\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.enable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tcapabilities[ id ] = true;\n\n\t\t}\n\n\t};\n\n\tthis.disable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tcapabilities[ id ] = false;\n\n\t\t}\n\n\t};\n\n\tthis.getCompressedTextureFormats = function () {\n\n\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\tcompressedTextureFormats = [];\n\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn compressedTextureFormats;\n\n\t};\n\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending !== THREE.NoBlending ) {\n\n\t\t\tthis.enable( gl.BLEND );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.BLEND );\n\t\t\tcurrentBlending = blending; // no blending, that is\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\tif ( blending === THREE.AdditiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentBlending = blending;\n\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t}\n\n\t\tif ( blending === THREE.CustomBlending ) {\n\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t}\n\n\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tcurrentBlendEquation = null;\n\t\t\tcurrentBlendSrc = null;\n\t\t\tcurrentBlendDst = null;\n\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.setColorWrite = function ( colorWrite ) {\n\n\t\tthis.buffers.color.setMask( colorWrite );\n\n\t};\n\n\tthis.setDepthTest = function ( depthTest ) {\n\n\t\tthis.buffers.depth.setTest( depthTest );\n\n\t};\n\n\tthis.setDepthWrite = function ( depthWrite ) {\n\n\t\tthis.buffers.depth.setMask( depthWrite );\n\n\t};\n\n\tthis.setDepthFunc = function ( depthFunc ) {\n\n\t\tthis.buffers.depth.setFunc( depthFunc );\n\n\t};\n\n\tthis.setStencilTest = function ( stencilTest ) {\n\n\t\tthis.buffers.stencil.setTest( stencilTest );\n\n\t};\n\n\tthis.setStencilWrite = function ( stencilWrite ) {\n\n\t\tthis.buffers.stencil.setMask( stencilWrite );\n\n\t};\n\n\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tthis.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );\n\n\t};\n\n\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tthis.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );\n\n\t};\n\n\t//\n\n\tthis.setFlipSided = function ( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t};\n\n\tthis.setCullFace = function ( cullFace ) {\n\n\t\tif ( cullFace !== THREE.CullFaceNone ) {\n\n\t\t\tthis.enable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t};\n\n\tthis.setLineWidth = function ( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tgl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t};\n\n\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t};\n\n\tthis.getScissorTest = function () {\n\n\t\treturn currentScissorTest;\n\n\t};\n\n\tthis.setScissorTest = function ( scissorTest ) {\n\n\t\tcurrentScissorTest = scissorTest;\n\n\t\tif ( scissorTest ) {\n\n\t\t\tthis.enable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t};\n\n\t// texture\n\n\tthis.activeTexture = function ( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t};\n\n\tthis.bindTexture = function ( webglType, webglTexture ) {\n\n\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t_this.activeTexture();\n\n\t\t}\n\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t};\n\n\tthis.compressedTexImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\tthis.texImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.clearColor = function ( r, g, b, a ) {\n\n\t\tthis.buffers.color.setClear( r, g, b, a );\n\n\t};\n\n\tthis.clearDepth = function ( depth ) {\n\n\t\tthis.buffers.depth.setClear( depth );\n\n\t};\n\n\tthis.clearStencil = function ( stencil ) {\n\n\t\tthis.buffers.stencil.setClear( stencil );\n\n\t};\n\n\t//\n\n\tthis.scissor = function ( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t};\n\n\tthis.viewport = function ( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tthis.reset = function () {\n\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcapabilities = {};\n\n\t\tcompressedTextureFormats = null;\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentBlending = null;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tthis.buffers.color.reset();\n\t\tthis.buffers.depth.reset();\n\t\tthis.buffers.stencil.reset();\n\n\t};\n\n};\n\nTHREE.WebGLColorBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar color = new THREE.Vector4();\n\tvar currentColorMask = null;\n\tvar currentColorClear = new THREE.Vector4();\n\n\tthis.setMask = function ( colorMask ) {\n\n\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\tcurrentColorMask = colorMask;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( r, g, b, a ) {\n\n\t\tcolor.set( r, g, b, a );\n\n\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\tgl.clearColor( r, g, b, a );\n\t\t\tcurrentColorClear.copy( color );\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentColorMask = null;\n\t\tcurrentColorClear = new THREE.Vector4();\n\n\t};\n\n};\n\nTHREE.WebGLDepthBuffer = function( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentDepthMask = null;\n\tvar currentDepthFunc = null;\n\tvar currentDepthClear = null;\n\n\tthis.setTest = function ( depthTest ) {\n\n\t\tif ( depthTest ) {\n\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function( depthMask ){\n\n\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\tgl.depthMask( depthMask );\n\t\t\tcurrentDepthMask = depthMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( depthFunc ) {\n\n\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\tif ( depthFunc ) {\n\n\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\tcase THREE.NeverDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.AlwaysDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.EqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.NotEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t}\n\n\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( depth ) {\n\n\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\tgl.clearDepth( depth );\n\t\t\tcurrentDepthClear = depth;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentDepthMask = null;\n\t\tcurrentDepthFunc = null;\n\t\tcurrentDepthClear = null;\n\n\t};\n\n};\n\nTHREE.WebGLStencilBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentStencilMask = null;\n\tvar currentStencilFunc = null;\n\tvar currentStencilRef = null;\n\tvar currentStencilFuncMask = null;\n\tvar currentStencilFail  = null;\n\tvar currentStencilZFail = null;\n\tvar currentStencilZPass = null;\n\tvar currentStencilClear = null;\n\n\tthis.setTest = function ( stencilTest ) {\n\n\t\tif ( stencilTest ) {\n\n\t\t\tstate.enable( gl.STENCIL_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.STENCIL_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function ( stencilMask ) {\n\n\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\tgl.stencilMask( stencilMask );\n\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\n\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setOp\t = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t     currentStencilZFail !== stencilZFail ||\n\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\n\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( stencil ) {\n\n\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\tgl.clearStencil( stencil );\n\t\t\tcurrentStencilClear = stencil;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentStencilMask = null;\n\t\tcurrentStencilFunc = null;\n\t\tcurrentStencilRef = null;\n\t\tcurrentStencilFuncMask = null;\n\t\tcurrentStencilFail = null;\n\t\tcurrentStencilZFail = null;\n\t\tcurrentStencilZPass = null;\n\t\tcurrentStencilClear = null;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLTextures.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLTextures = function ( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n\tvar _infoMemory = info.memory;\n\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n\t//\n\n\tfunction clampToMaxSize ( image, maxSize ) {\n\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t// premultiplied alpha.\n\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction isPowerOfTwo( image ) {\n\n\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\n\n\t}\n\n\tfunction makePowerOfTwo( image ) {\n\n\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\n\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\n\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\n\n\t\treturn false;\n\n\t}\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback ( f ) {\n\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\n\t\t\treturn _gl.NEAREST;\n\n\t\t}\n\n\t\treturn _gl.LINEAR;\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tvar texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\t_infoMemory.textures --;\n\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tvar renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t_infoMemory.textures --;\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t// cube texture\n\n\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t} else {\n\n\t\t\t// 2D texture\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\t// remove all webgl properties\n\t\tproperties.delete( texture );\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\tif ( ! renderTarget ) return;\n\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t}\n\n\t\tproperties.delete( renderTarget.texture );\n\t\tproperties.delete( renderTarget );\n\n\t}\n\n\t//\n\n\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tvar image = texture.image;\n\n\t\t\tif ( image === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTextureCube ( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t} else {\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setTextureCubeDynamic ( texture, slot ) {\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t}\n\n\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\n\n\t\tvar extension;\n\n\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension ) {\n\n\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t_infoMemory.textures ++;\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\timage = makePowerOfTwo( image );\n\n\t\t}\n\n\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\tglFormat = paramThreeToGL( texture.format ),\n\t\tglType = paramThreeToGL( texture.type );\n\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\tif ( texture instanceof THREE.DepthTexture ) {\n\n\t\t\t// populate depth texture with dummy data\n\n\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\tif ( texture.type === THREE.FloatType ) {\n\n\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t}\n\n\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t} else if ( texture instanceof THREE.DataTexture ) {\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t}\n\n\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\n\n\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t_infoMemory.textures ++;\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tvar texture = renderTarget.texture;\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\n\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t_gl.generateMipmap( target );\n\t\t\tstate.bindTexture( target, null );\n\n\t\t}\n\n\t}\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n};\n\n// File:src/renderers/webgl/WebGLUniforms.js\n\n/**\n *\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [renderer] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'renderer' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (renderer factorizations):\n *\n * .upload( gl, seq, values, renderer )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n * .splitDynamic( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\n *\n *\n * Methods of the top-level container (renderer factorizations):\n *\n * .setValue( gl, name, value )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .set( gl, obj, prop )\n *\n * \t\tsets uniform from object and property with same name than uniform\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n *\n * @author tschw\n *\n */\n\nTHREE.WebGLUniforms = ( function() { // scope\n\n\tvar emptyTexture = new THREE.Texture();\n\tvar emptyCubeTexture = new THREE.CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tvar UniformContainer = function() {\n\n\t\t\tthis.seq = [];\n\t\t\tthis.map = {};\n\n\t\t},\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\t\tarrayCacheF32 = [],\n\t\tarrayCacheI32 = [],\n\n\t\tuncacheTemporaryArrays = function() {\n\n\t\t\tarrayCacheF32.length = 0;\n\t\t\tarrayCacheI32.length = 0;\n\n\t\t},\n\n\t// Flattening for arrays of vectors and matrices\n\n\t\tflatten = function( array, nBlocks, blockSize ) {\n\n\t\t\tvar firstElem = array[ 0 ];\n\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t// see http://jacksondunstan.com/articles/983\n\n\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\tr = arrayCacheF32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Float32Array( n );\n\t\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tif ( nBlocks !== 0 ) {\n\n\t\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\t\toffset += blockSize;\n\t\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// Texture unit allocation\n\n\t\tallocTexUnits = function( renderer, n ) {\n\n\t\t\tvar r = arrayCacheI32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Int32Array( n );\n\t\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t\t// Single scalar\n\n\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\n\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\n\n\t\t// Single float vector (from flat array or THREE.VectorN)\n\n\t\tsetValue2fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\n\t\t},\n\n\t\tsetValue3fv = function( gl, v ) {\n\n\t\t\tif ( v.x !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\t\telse if ( v.r !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\t\telse\n\t\t\t\tgl.uniform3fv( this.addr, v );\n\n\t\t},\n\n\t\tsetValue4fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t},\n\n\t\t// Single matrix (from flat array or MatrixN)\n\n\t\tsetValue2fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue3fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue4fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\t// Single texture (2D / Cube)\n\n\t\tsetValueT1 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t\t},\n\n\t\tsetValueT6 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t\t},\n\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\n\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\n\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\n\n\t\t// Helper to pick the right setter for the singular case\n\n\t\tgetSingularSetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Array of scalars\n\n\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\n\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\n\n\t\t// Array of vectors (flat or from THREE classes)\n\n\t\tsetValueV2a = function( gl, v ) {\n\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t\t},\n\n\t\tsetValueV3a = function( gl, v ) {\n\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t\t},\n\n\t\tsetValueV4a = function( gl, v ) {\n\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\t// Array of matrices (flat or from THREE clases)\n\n\t\tsetValueM2a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\tsetValueM3a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t\t},\n\n\t\tsetValueM4a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t\t},\n\n\t\t// Array of textures (2D / Cube)\n\n\t\tsetValueT1a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetValueT6a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\t\tgetPureArraySetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t// --- Uniform Classes ---\n\n\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tPureArrayUniform = function( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.size = activeInfo.size;\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tStructuredUniform = function( id ) {\n\n\t\t\tthis.id = id;\n\n\t\t\tUniformContainer.call( this ); // mix-in\n\n\t\t};\n\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\n\t\t// extracts\n\t\t// \t- the identifier (member name or array index)\n\t\t//  - followed by an optional right bracket (found when array index)\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t//\n\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t// in the uniform names.\n\n\t\taddUniform = function( container, uniformObject ) {\n\n\t\t\tcontainer.seq.push( uniformObject );\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t\t},\n\n\t\tparseUniform = function( activeInfo, addr, container ) {\n\n\t\t\tvar path = activeInfo.name,\n\t\t\t\tpathLength = path.length;\n\n\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\tRePathPart.lastIndex = 0;\n\n\t\t\tfor (; ;) {\n\n\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\t\tif ( subscript === undefined ||\n\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\t\tvar map = container.map,\n\t\t\t\t\t\tnext = map[ id ];\n\n\t\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer = next;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t// Root Container\n\n\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\n\n\t\t\tUniformContainer.call( this );\n\n\t\t\tthis.renderer = renderer;\n\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\tpath = info.name,\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\t\tparseUniform( info, addr, this );\n\n\t\t\t}\n\n\t\t};\n\n\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.splitDynamic = function( seq, values ) {\n\n\t\tvar r = null,\n\t\t\tn = seq.length,\n\t\t\tw = 0;\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v && v.dynamic === true ) {\n\n\t\t\t\tif ( r === null ) r = [];\n\t\t\t\tr.push( u );\n\n\t\t\t} else {\n\n\t\t\t\t// in-place compact 'seq', removing the matches\n\t\t\t\tif ( w < i ) seq[ w ] = u;\n\t\t\t\t++ w;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( w < n ) seq.length = w;\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar v = values[ seq[ i ].id ],\n\t\t\t\tf = v.onUpdateCallback;\n\n\t\t\tif ( f !== undefined ) f.call( v, object, camera );\n\n\t\t}\n\n\t};\n\n\treturn WebGLUniforms;\n\n} )();\n\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar shader, program, attributes, uniforms;\n\n\tvar tempTexture, occlusionTexture;\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 1, - 1,  0, 0,\n\t\t\t 1, - 1,  1, 0,\n\t\t\t 1,  1,  1, 1,\n\t\t\t- 1,  1,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\t// buffers\n\n\t\tvertexBuffer     = gl.createBuffer();\n\t\telementBuffer    = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t// textures\n\n\t\ttempTexture      = gl.createTexture();\n\t\tocclusionTexture = gl.createTexture();\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tshader = {\n\n\t\t\tvertexShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\"uniform float rotation;\",\n\n\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\n\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" ),\n\n\t\t\tfragmentShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t// pink square\n\n\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t\t// restore\n\n\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t\t// flare\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" )\n\n\t\t};\n\n\t\tprogram = createProgram( shader );\n\n\t\tattributes = {\n\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t};\n\n\t\tuniforms = {\n\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t};\n\n\t}\n\n\t/*\n\t * Render lens flares\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t *         reads these back and calculates occlusion.\n\t */\n\n\tthis.render = function ( scene, camera, viewport ) {\n\n\t\tif ( flares.length === 0 ) return;\n\n\t\tvar tempPosition = new THREE.Vector3();\n\n\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\thalfViewportHeight = viewport.w * 0.5;\n\n\t\tvar size = 16 / viewport.w,\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\n\t\tvar validArea = new THREE.Box2();\n\n\t\tvalidArea.min.set( 0, 0 );\n\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.vertex );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\t// loop through all lens flares to update their occlusion and positions\n\t\t// setup gl and common used attribs/uniforms\n\n\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\tgl.uniform1i( uniforms.map, 1 );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.setDepthWrite( false );\n\n\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n\t\t\tsize = 16 / viewport.w;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t// calc object screen position\n\n\t\t\tvar flare = flares[ i ];\n\n\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t// setup arrays for gl programs\n\n\t\t\tscreenPosition.copy( tempPosition );\n\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t// screen cull\n\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// render pink quad\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// restore graphics\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// update object positions\n\n\t\t\t\tflare.positionScreen.copy( screenPosition );\n\n\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t}\n\n\t\t\t\t// render flares\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\tstate.enable( gl.BLEND );\n\n\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\n\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\t\tstate.enable( gl.DEPTH_TEST );\n\t\tstate.setDepthWrite( true );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram ( shader ) {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\tgl.compileShader( fragmentShader );\n\t\tgl.compileShader( vertexShader );\n\n\t\tgl.attachShader( program, fragmentShader );\n\t\tgl.attachShader( program, vertexShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n};\n\n// File:src/renderers/webgl/plugins/SpritePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpritePlugin = function ( renderer, sprites ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar program, attributes, uniforms;\n\n\tvar texture;\n\n\t// decompose matrixWorld\n\n\tvar spritePosition = new THREE.Vector3();\n\tvar spriteRotation = new THREE.Quaternion();\n\tvar spriteScale = new THREE.Vector3();\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t- 0.5,   0.5,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\tvertexBuffer  = gl.createBuffer();\n\t\telementBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\tprogram = createProgram();\n\n\t\tattributes = {\n\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t};\n\n\t\tuniforms = {\n\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\n\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\n\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t};\n\n\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tcanvas.width = 8;\n\t\tcanvas.height = 8;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = 'white';\n\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\ttexture = new THREE.Texture( canvas );\n\t\ttexture.needsUpdate = true;\n\n\t}\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( sprites.length === 0 ) return;\n\n\t\t// setup gl\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.position );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.enable( gl.BLEND );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\tvar oldFogType = 0;\n\t\tvar sceneFogType = 0;\n\t\tvar fog = scene.fog;\n\n\t\tif ( fog ) {\n\n\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\toldFogType = 1;\n\t\t\t\tsceneFogType = 1;\n\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\toldFogType = 2;\n\t\t\t\tsceneFogType = 2;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\toldFogType = 0;\n\t\t\tsceneFogType = 0;\n\n\t\t}\n\n\n\t\t// update positions and sort\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\n\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t}\n\n\t\tsprites.sort( painterSortStable );\n\n\t\t// render all sprites\n\n\t\tvar scale = [];\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\t\t\tvar material = sprite.material;\n\n\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\tvar fogType = 0;\n\n\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\tfogType = sceneFogType;\n\n\t\t\t}\n\n\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\toldFogType = fogType;\n\n\t\t\t}\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t}\n\n\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setTexture2D( texture, 0 );\n\n\t\t\t}\n\n\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram () {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform float rotation;',\n\t\t\t'uniform vec2 scale;',\n\t\t\t'uniform vec2 uvOffset;',\n\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t'attribute vec2 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D map;',\n\t\t\t'uniform float opacity;',\n\n\t\t\t'uniform int fogType;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t\t'uniform float fogDensity;',\n\t\t\t'uniform float fogNear;',\n\t\t\t'uniform float fogFar;',\n\t\t\t'uniform float alphaTest;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t'}',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.compileShader( vertexShader );\n\t\tgl.compileShader( fragmentShader );\n\n\t\tgl.attachShader( program, vertexShader );\n\t\tgl.attachShader( program, fragmentShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\t\t\n\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn b.id - a.id;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/Three.Legacy.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.assign( THREE, {\n\tFace4: function ( a, b, c, d, normal, color, materialIndex ) {\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\n\t},\n\tLineStrip: 0,\n\tLinePieces: 1,\n\tMeshFaceMaterial: THREE.MultiMaterial,\n\tPointCloud: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tParticle: THREE.Sprite,\n\tParticleSystem: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tPointCloudMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleBasicMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleSystemMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tVertex: function ( x, y, z ) {\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new THREE.Vector3( x, y, z );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Box2.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t}\n} );\n\nObject.assign( THREE.Box3.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Matrix3.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\treturn vector.applyMatrix3( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t}\n} );\n\nObject.assign( THREE.Matrix4.prototype, {\n\textractPosition: function ( m ) {\n\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\treturn this.copyPosition( m );\n\t},\n\tsetRotationFromQuaternion: function ( q ) {\n\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\treturn this.makeRotationFromQuaternion( q );\n\t},\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\treturn vector.applyProjection( this );\n\t},\n\tmultiplyVector4: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t},\n\trotateAxis: function ( v ) {\n\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\tv.transformDirection( this );\n\t},\n\tcrossVector: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\ttranslate: function ( v ) {\n\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t},\n\trotateX: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t},\n\trotateY: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t},\n\trotateZ: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t},\n\trotateByAxis: function ( axis, angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t}\n} );\n\nObject.assign( THREE.Plane.prototype, {\n\tisIntersectionLine: function ( line ) {\n\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\treturn this.intersectsLine( line );\n\t}\n} );\n\nObject.assign( THREE.Quaternion.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\treturn vector.applyQuaternion( this );\n\t}\n} );\n\nObject.assign( THREE.Ray.prototype, {\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionPlane: function ( plane ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\treturn this.intersectsPlane( plane );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Vector3.prototype, {\n\tsetEulerFromRotationMatrix: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t},\n\tsetEulerFromQuaternion: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t},\n\tgetPositionFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\treturn this.setFromMatrixPosition( m );\n\t},\n\tgetScaleFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\treturn this.setFromMatrixScale( m );\n\t},\n\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\treturn this.setFromMatrixColumn( matrix, index );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Object3D.prototype, {\n\tgetChildByName: function ( name ) {\n\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\treturn this.getObjectByName( name );\n\t},\n\trenderDepth: function ( value ) {\n\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t},\n\ttranslate: function ( distance, axis ) {\n\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\treturn this.translateOnAxis( axis, distance );\n\t}\n} );\n\nObject.defineProperties( THREE.Object3D.prototype, {\n\teulerOrder: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\treturn this.rotation.order;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\tthis.rotation.order = value;\n\t\t}\n\t},\n\tuseQuaternion: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.LOD.prototype, {\n\tobjects: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\treturn this.levels;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\tthis.setFocalLength( focalLength );\n\n};\n\n//\n\nObject.defineProperties( THREE.Light.prototype, {\n\tonlyShadow: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t}\n\t},\n\tshadowCameraFov: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\tthis.shadow.camera.fov = value;\n\t\t}\n\t},\n\tshadowCameraLeft: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\tthis.shadow.camera.left = value;\n\t\t}\n\t},\n\tshadowCameraRight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\tthis.shadow.camera.right = value;\n\t\t}\n\t},\n\tshadowCameraTop: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\tthis.shadow.camera.top = value;\n\t\t}\n\t},\n\tshadowCameraBottom: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\tthis.shadow.camera.bottom = value;\n\t\t}\n\t},\n\tshadowCameraNear: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\tthis.shadow.camera.near = value;\n\t\t}\n\t},\n\tshadowCameraFar: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\tthis.shadow.camera.far = value;\n\t\t}\n\t},\n\tshadowCameraVisible: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t}\n\t},\n\tshadowBias: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\tthis.shadow.bias = value;\n\t\t}\n\t},\n\tshadowDarkness: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t}\n\t},\n\tshadowMapWidth: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\tthis.shadow.mapSize.width = value;\n\t\t}\n\t},\n\tshadowMapHeight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\tthis.shadow.mapSize.height = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.BufferAttribute.prototype, {\n\tlength: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\treturn this.array.length;\n\t\t}\n\t}\n} );\n\nObject.assign( THREE.BufferGeometry.prototype, {\n\taddIndex: function ( index ) {\n\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\tthis.setIndex( index );\n\t},\n\taddDrawCall: function ( start, count, indexOffset ) {\n\t\tif ( indexOffset !== undefined ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t}\n\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\tthis.addGroup( start, count );\n\t},\n\tclearDrawCalls: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\tthis.clearGroups();\n\t},\n\tcomputeTangents: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t},\n\tcomputeOffsets: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.BufferGeometry.prototype, {\n\tdrawcalls: {\n\t\tget: function () {\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t},\n\toffsets: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.Material.prototype, {\n\twrapAround: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t}\n\t},\n\twrapRGB: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\treturn new THREE.Color();\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\n\tmetal: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\treturn false;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.ShaderMaterial.prototype, {\n\tderivatives: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\treturn this.extensions.derivatives;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\tthis.extensions.derivatives = value;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.EventDispatcher.prototype = Object.assign( Object.create( {\n\n\t// Note: Extra base ensures these properties are not 'assign'ed.\n\n\tconstructor: THREE.EventDispatcher,\n\n\tapply: function ( target ) {\n\n\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\n\t\tObject.assign( target, this );\n\n\t}\n\n} ), THREE.EventDispatcher.prototype );\n\n//\n\nObject.assign( THREE.WebGLRenderer.prototype, {\n\tsupportsFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_float' );\n\t},\n\tsupportsHalfFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t},\n\tsupportsStandardDerivatives: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t},\n\tsupportsCompressedTextureS3TC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t},\n\tsupportsCompressedTexturePVRTC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t},\n\tsupportsBlendMinMax: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t},\n\tsupportsVertexTextures: function () {\n\t\treturn this.capabilities.vertexTextures;\n\t},\n\tsupportsInstancedArrays: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t},\n\tenableScissorTest: function ( boolean ) {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\tthis.setScissorTest( boolean );\n\t},\n\tinitMaterial: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t},\n\taddPrePlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t},\n\taddPostPlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t},\n\tupdateShadowMap: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLRenderer.prototype, {\n\tshadowMapEnabled: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.enabled;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\tthis.shadowMap.enabled = value;\n\t\t}\n\t},\n\tshadowMapType: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\tthis.shadowMap.type = value;\n\t\t}\n\t},\n\tshadowMapCullFace: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.cullFace;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\tthis.shadowMap.cullFace = value;\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLShadowMap.prototype, {\n\tcullFace: {\n\t\tget: function () {\n\t\t\treturn this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;\n\t\t},\n\t\tset: function ( cullFace ) {\n\t\t\tvar value = ( cullFace !== THREE.CullFaceBack );\n\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\tthis.renderReverseSided = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\n\twrapS: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\treturn this.texture.wrapS;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\tthis.texture.wrapS = value;\n\t\t}\n\t},\n\twrapT: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\treturn this.texture.wrapT;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\tthis.texture.wrapT = value;\n\t\t}\n\t},\n\tmagFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\treturn this.texture.magFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\tthis.texture.magFilter = value;\n\t\t}\n\t},\n\tminFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\treturn this.texture.minFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\tthis.texture.minFilter = value;\n\t\t}\n\t},\n\tanisotropy: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\treturn this.texture.anisotropy;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\tthis.texture.anisotropy = value;\n\t\t}\n\t},\n\toffset: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\treturn this.texture.offset;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\tthis.texture.offset = value;\n\t\t}\n\t},\n\trepeat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\treturn this.texture.repeat;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\tthis.texture.repeat = value;\n\t\t}\n\t},\n\tformat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\treturn this.texture.format;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\tthis.texture.format = value;\n\t\t}\n\t},\n\ttype: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\treturn this.texture.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\tthis.texture.type = value;\n\t\t}\n\t},\n\tgenerateMipmaps: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\treturn this.texture.generateMipmaps;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\tthis.texture.generateMipmaps = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.assign( THREE.Audio.prototype, {\n\tload: function ( file ) {\n\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\tvar scope = this;\n\t\tvar audioLoader = new THREE.AudioLoader();\n\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\tscope.setBuffer( buffer );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\tgetData: function ( file ) {\n\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\treturn this.getFrequencyData();\n\t}\n} );\n\n//\n\nTHREE.GeometryUtils = {\n\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\tvar matrix;\n\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\n\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\tmatrix = geometry2.matrix;\n\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t}\n\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t},\n\n\tcenter: function ( geometry ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\treturn geometry.center();\n\n\t}\n\n};\n\nTHREE.ImageUtils = {\n\n\tcrossOrigin: undefined,\n\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\tvar loader = new THREE.TextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\tvar loader = new THREE.CubeTextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTexture: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t},\n\n\tloadCompressedTextureCube: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t}\n\n};\n\n//\n\nTHREE.Projector = function () {\n\n\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\tvector.project( camera );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\tvector.unproject( camera );\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t};\n\n};\n\n//\n\nTHREE.CanvasRenderer = function () {\n\n\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\tthis.clear = function () {};\n\tthis.render = function () {};\n\tthis.setClearColor = function () {};\n\tthis.setSize = function () {};\n\n};\n\n// File:src/extras/CurveUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.CurveUtils = {\n\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t},\n\n\t// Puay Bing, thanks for helping with this derivative!\n\n\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\n\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t3 * t * t * p3;\n\n\t},\n\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t// To check if my formulas are correct\n\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\n\t\treturn h00 + h10 + h01 + h11;\n\n\t},\n\n\t// Catmull-Rom\n\n\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\tvar t2 = t * t;\n\t\tvar t3 = t * t2;\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/extras/SceneUtils.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\tvar group = new THREE.Group();\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t},\n\n\tdetach: function ( child, parent, scene ) {\n\n\t\tchild.applyMatrix( parent.matrixWorld );\n\t\tparent.remove( child );\n\t\tscene.add( child );\n\n\t},\n\n\tattach: function ( child, scene, parent ) {\n\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\tscene.remove( child );\n\t\tparent.add( child );\n\n\t}\n\n};\n\n// File:src/extras/ShapeUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.ShapeUtils = {\n\n\t// calculate area of the contour polygon\n\n\tarea: function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t},\n\n\ttriangulate: ( function () {\n\n\t\t/**\n\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t * See original code and more information here:\n\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t *\n\t\t * ported to actionscript by Zevan Rosser\n\t\t * www.actionsnippet.com\n\t\t *\n\t\t * ported to javascript by Joshua Koo\n\t\t * http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t */\n\n\t\tfunction snip( contour, u, v, w, n, verts ) {\n\n\t\t\tvar p;\n\t\t\tvar ax, ay, bx, by;\n\t\t\tvar cx, cy, px, py;\n\n\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\tay = contour[ verts[ u ] ].y;\n\n\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\tby = contour[ verts[ v ] ].y;\n\n\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\tcy = contour[ verts[ w ] ].y;\n\n\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\n\n\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\tcX = bx - ax;  cY = by - ay;\n\n\t\t\tfor ( p = 0; p < n; p ++ ) {\n\n\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\tpy = contour[ verts[ p ] ].y;\n\n\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\n\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t\t// see if p is inside triangle abc\n\n\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\n\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// takes in an contour array and returns\n\n\t\treturn function triangulate( contour, indices ) {\n\n\t\t\tvar n = contour.length;\n\n\t\t\tif ( n < 3 ) return null;\n\n\t\t\tvar result = [],\n\t\t\t\tverts = [],\n\t\t\t\tvertIndices = [];\n\n\t\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\t\tvar u, v, w;\n\n\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t\t}\n\n\t\t\tvar nv = n;\n\n\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\t\tvar count = 2 * nv;   /* error detection */\n\n\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\n\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\t\tif ( ( count -- ) <= 0 ) {\n\n\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t//return null;\n\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\treturn result;\n\n\t\t\t\t}\n\n\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t\t/* true names of the vertices */\n\n\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\tc = verts[ w ];\n\n\t\t\t\t\t/* output Triangle */\n\n\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnv --;\n\n\t\t\t\t\t/* reset error detection counter */\n\n\t\t\t\t\tcount = 2 * nv;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( indices ) return vertIndices;\n\t\t\treturn result;\n\n\t\t}\n\n\t} )(),\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\n\t\t\t\t// not parallel\n\n\t\t\t\tvar perpSeg2;\n\t\t\t\tif ( limit > 0 ) {\n\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\n\t\t\t\t}\n\n\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\tif ( perpSeg2 === 0 ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\tif ( perpSeg2 === limit ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt2 ];\n\n\t\t\t\t}\n\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\n\t\t\t\t// return real intersection point\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n\t\t\t} else {\n\n\t\t\t\t// parallel or collinear\n\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\n\t\t\t\t// they are collinear or degenerate\n\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t// both segments are points\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\n\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\n\t\t\t\t}\n\t\t\t\t// segment#1  is a single point\n\t\t\t\tif ( seg1Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\t// segment#2  is a single point\n\t\t\t\tif ( seg2Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\treturn [ inSeg2Pt1 ];\n\n\t\t\t\t}\n\n\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\tif ( seg1dx !== 0 ) {\n\n\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg2min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg1min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n\t\t\t// The order of legs is important\n\n\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n\t\t\t\t// angle != 180 deg.\n\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n\t\t\t\tif ( from2toAngle > 0 ) {\n\n\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// angle == 180 deg.\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\treturn\t( from2otherAngle > 0 );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction removeHoles( contour, holes ) {\n\n\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\tvar hole;\n\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\treturn\ttrue;\n\n\t\t\t}\n\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with shape edges\n\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t}\n\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar indepHoles = [];\n\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with hole edges\n\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\tshapePt, holePt,\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\ttmpHole1, tmpHole2;\n\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tindepHoles.push( h );\n\n\t\t\t}\n\n\t\t\tvar minShapeIndex = 0;\n\t\t\tvar counter = indepHoles.length * 2;\n\t\t\twhile ( indepHoles.length > 0 ) {\n\n\t\t\t\tcounter --;\n\t\t\t\tif ( counter < 0 ) {\n\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t// which can be connected without intersections\n\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\tholeIndex\t= - 1;\n\n\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\n\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\n\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\n\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\n\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn shape; \t\t\t/* shape with no holes */\n\n\t\t}\n\n\n\t\tvar i, il, f, face,\n\t\t\tkey, index,\n\t\t\tallPointsMap = {};\n\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\tvar allpoints = contour.concat();\n\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\n\t\t}\n\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\t// prepare all points map\n\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\n\n\t\t\t}\n\n\t\t\tallPointsMap[ key ] = i;\n\n\t\t}\n\n\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\n\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t//console.log( \"triangles\",triangles, triangles.length );\n\n\t\t// check all face vertices against all points map\n\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\tface = triangles[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangles.concat();\n\n\t},\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn THREE.ShapeUtils.area( pts ) < 0;\n\n\t},\n\n\t// Bezier Curves formulas obtained from\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t// Quad Bezier Functions\n\n\tb2: ( function () {\n\n\t\tfunction b2p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * p;\n\n\t\t}\n\n\t\tfunction b2p1( t, p ) {\n\n\t\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t\t}\n\n\t\tfunction b2p2( t, p ) {\n\n\t\t\treturn t * t * p;\n\n\t\t}\n\n\t\treturn function b2( t, p0, p1, p2 ) {\n\n\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\n\t\t};\n\n\t} )(),\n\n\t// Cubic Bezier Functions\n\n\tb3: ( function () {\n\n\t\tfunction b3p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * k * p;\n\n\t\t}\n\n\t\tfunction b3p1( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * k * t * p;\n\n\t\t}\n\n\t\tfunction b3p2( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * t * t * p;\n\n\t\t}\n\n\t\tfunction b3p3( t, p ) {\n\n\t\t\treturn t * t * t * p;\n\n\t\t}\n\n\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\n\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\n\t\t};\n\n\t} )()\n\n};\n\n// File:src/extras/core/Curve.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of Curve methods\n * .getPoint(t), getTangent(t)\n * .getPointAt(u), getTagentAt(u)\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following classes subclasses THREE.Curve:\n *\n * -- 2d classes --\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.CubicBezierCurve\n * THREE.SplineCurve\n * THREE.ArcCurve\n * THREE.EllipseCurve\n *\n * -- 3d classes --\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n * THREE.CubicBezierCurve3\n * THREE.SplineCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nTHREE.Curve = function () {\n\n};\n\nTHREE.Curve.prototype = {\n\n\tconstructor: THREE.Curve,\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint: function ( t ) {\n\n\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\treturn null;\n\n\t},\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t );\n\n\t},\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar d, pts = [];\n\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpts.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn pts;\n\n\t},\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar d, pts = [];\n\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpts.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn pts;\n\n\t},\n\n\t// Get total curve arc length\n\n\tgetLength: function () {\n\n\t\tvar lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t},\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n\t\tif ( this.cacheArcLengths\n\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t&& ! this.needsUpdate ) {\n\n\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tvar cache = [];\n\t\tvar current, last = this.getPoint( 0 );\n\t\tvar p, sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n\t},\n\n\tupdateArcLengths: function() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping: function ( u, distance ) {\n\n\t\tvar arcLengths = this.getLengths();\n\n\t\tvar i = 0, il = arcLengths.length;\n\n\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t//var time = Date.now();\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tvar low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\t//console.log('b' , i, low, high, Date.now()- time);\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\tvar t = i / ( il - 1 );\n\t\t\treturn t;\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tvar lengthBefore = arcLengths[ i ];\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t},\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent: function( t ) {\n\n\t\tvar delta = 0.0001;\n\t\tvar t1 = t - delta;\n\t\tvar t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tvar pt1 = this.getPoint( t1 );\n\t\tvar pt2 = this.getPoint( t2 );\n\n\t\tvar vec = pt2.clone().sub( pt1 );\n\t\treturn vec.normalize();\n\n\t},\n\n\tgetTangentAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t );\n\n\t}\n\n};\n\n// TODO: Transformation for Curves?\n\n/**************************************************************\n *\t3D Curves\n **************************************************************/\n\n// A Factory method for creating new curve subclasses\n\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\tconstructor.prototype.constructor = constructor;\n\tconstructor.prototype.getPoint = getPointFunc;\n\n\treturn constructor;\n\n};\n\n// File:src/extras/core/CurvePath.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nTHREE.CurvePath = function () {\n\n\tthis.curves = [];\n\n\tthis.autoClose = false; // Automatically closes the path\n\n};\n\nTHREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {\n\n\tconstructor: THREE.CurvePath,\n\n\tadd: function ( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t},\n\n\tclosePath: function () {\n\n\t\t// TODO Test\n\t\t// and verify for vector3 (needs to implement equals)\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\n\n\t\t}\n\n\t},\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint: function ( t ) {\n\n\t\tvar d = t * this.getLength();\n\t\tvar curveLengths = this.getCurveLengths();\n\t\tvar i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\tvar u = 1 - diff / curve.getLength();\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t},\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength: function () {\n\n\t\tvar lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t},\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths: function () {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tvar lengths = [], sums = 0;\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t},\n\n\t/**************************************************************\n\t *\tCreate Geometries Helpers\n\t **************************************************************/\n\n\t/// Generate geometry from path points (for Line or Points objects)\n\n\tcreatePointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\t// Generate geometry from equidistant sampling along the path\n\n\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getSpacedPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\tcreateGeometry: function ( points ) {\n\n\t\tvar geometry = new THREE.Geometry();\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/extras/core/Font.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Font = function ( data ) {\n\n\tthis.data = data;\n\n};\n\nObject.assign( THREE.Font.prototype, {\n\n\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\tfunction createPaths( text ) {\n\n\t\t\tvar chars = String( text ).split( '' );\n\t\t\tvar scale = size / data.resolution;\n\t\t\tvar offset = 0;\n\n\t\t\tvar paths = [];\n\n\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\toffset += ret.offset;\n\n\t\t\t\tpaths.push( ret.path );\n\n\t\t\t}\n\n\t\t\treturn paths;\n\n\t\t}\n\n\t\tfunction createPath( c, scale, offset ) {\n\n\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n\t\t\tif ( ! glyph ) return;\n\n\t\t\tvar path = new THREE.Path();\n\n\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\n\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n\t\t\tif ( glyph.o ) {\n\n\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn { offset: glyph.ha * scale, path: path };\n\n\t\t}\n\n\t\t//\n\n\t\tif ( size === undefined ) size = 100;\n\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\tvar data = this.data;\n\n\t\tvar paths = createPaths( text );\n\t\tvar shapes = [];\n\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n// File:src/extras/core/Path.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n *\n **/\n\nTHREE.Path = function ( points ) {\n\n\tTHREE.CurvePath.call( this );\n\n\tthis.actions = [];\n\n\tif ( points ) {\n\n\t\tthis.fromPoints( points );\n\n\t}\n\n};\n\nTHREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {\n\n\tconstructor: THREE.Path,\n\n\t// TODO Clean up PATH API\n\n\t// Create path using straight lines to connect all points\n\t// - vectors: array of Vector2\n\n\tfromPoints: function ( vectors ) {\n\n\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n\t\t}\n\n\t},\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.QuadraticBezierCurve(\n\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.CubicBezierCurve(\n\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\n\n\t},\n\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\tvar args = Array.prototype.slice.call( arguments );\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\n\t\tArray.prototype.push.apply( npts, pts );\n\n\t\tvar curve = new THREE.SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = pts[ pts.length - 1 ];\n\t\targs.push( lastPoint.x );\n\t\targs.push( lastPoint.y );\n\n\t\tthis.actions.push( { action: 'splineThru', args: args } );\n\n\t},\n\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t},\n\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar args = [\n\t\t\taX, aY,\n\t\t\txRadius, yRadius,\n\t\t\taStartAngle, aEndAngle,\n\t\t\taClockwise,\n\t\t\taRotation || 0 // aRotation is optional.\n\t\t];\n\n\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = curve.getPoint( 1 );\n\t\targs.push( lastPoint.x );\n\t\targs.push( lastPoint.y );\n\n\t\tthis.actions.push( { action: 'ellipse', args: args } );\n\n\t},\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 40;\n\n\t\tvar points = [];\n\n\t\tfor ( var i = 0; i < divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tgetPoints: function ( divisions ) {\n\n\t\tdivisions = divisions || 12;\n\n\t\tvar b2 = THREE.ShapeUtils.b2;\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\n\t\tvar points = [];\n\n\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\n\t\t\tlaste, tx, ty;\n\n\t\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\n\n\t\t\tvar item = this.actions[ i ];\n\n\t\t\tvar action = item.action;\n\t\t\tvar args = item.args;\n\n\t\t\tswitch ( action ) {\n\n\t\t\tcase 'moveTo':\n\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'lineTo':\n\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'quadraticCurveTo':\n\n\t\t\t\tcpx  = args[ 2 ];\n\t\t\t\tcpy  = args[ 3 ];\n\n\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\tcpy1 = args[ 1 ];\n\n\t\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / divisions;\n\n\t\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\n\t\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'bezierCurveTo':\n\n\t\t\t\tcpx  = args[ 4 ];\n\t\t\t\tcpy  = args[ 5 ];\n\n\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\tcpy1 = args[ 1 ];\n\n\t\t\t\tcpx2 = args[ 2 ];\n\t\t\t\tcpy2 = args[ 3 ];\n\n\t\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t\t}\n\n\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / divisions;\n\n\t\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'splineThru':\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\n\t\t\t\tvar spts = [ last ];\n\n\t\t\t\tvar n = divisions * args[ 0 ].length;\n\n\t\t\t\tspts = spts.concat( args[ 0 ] );\n\n\t\t\t\tvar spline = new THREE.SplineCurve( spts );\n\n\t\t\t\tfor ( var j = 1; j <= n; j ++ ) {\n\n\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'arc':\n\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\taRadius = args[ 2 ],\n\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\n\t\t\t\t\taClockwise = !! args[ 5 ];\n\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\tvar angle;\n\t\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / tdivisions;\n\n\t\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\n\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\n\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\t//console.log(points);\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ellipse':\n\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\txRadius = args[ 2 ],\n\t\t\t\t\tyRadius = args[ 3 ],\n\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\n\t\t\t\t\taClockwise = !! args[ 6 ],\n\t\t\t\t\taRotation = args[ 7 ];\n\n\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\tvar angle;\n\t\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\t\tvar cos, sin;\n\t\t\t\tif ( aRotation !== 0 ) {\n\n\t\t\t\t\tcos = Math.cos( aRotation );\n\t\t\t\t\tsin = Math.sin( aRotation );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / tdivisions;\n\n\t\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\n\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\n\n\t\t\t\t\tif ( aRotation !== 0 ) {\n\n\t\t\t\t\t\tvar x = tx, y = ty;\n\n\t\t\t\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\n\t\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\t//console.log(points);\n\n\t\t\t\tbreak;\n\n\t\t\t} // end switch\n\n\t\t}\n\n\n\n\t\t// Normalize to remove the closing point by default.\n\t\tvar lastPoint = points[ points.length - 1 ];\n\t\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\n\t\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\n\t\t\tpoints.splice( points.length - 1, 1 );\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\tfunction extractSubpaths( inActions ) {\n\n\t\t\tvar subPaths = [], lastPath = new THREE.Path();\n\n\t\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\n\n\t\t\t\tvar item = inActions[ i ];\n\n\t\t\t\tvar args = item.args;\n\t\t\t\tvar action = item.action;\n\n\t\t\t\tif ( action === 'moveTo' ) {\n\n\t\t\t\t\tif ( lastPath.actions.length !== 0 ) {\n\n\t\t\t\t\t\tsubPaths.push( lastPath );\n\t\t\t\t\t\tlastPath = new THREE.Path();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlastPath[ action ].apply( lastPath, args );\n\n\t\t\t}\n\n\t\t\tif ( lastPath.actions.length !== 0 ) {\n\n\t\t\t\tsubPaths.push( lastPath );\n\n\t\t\t}\n\n\t\t\t// console.log(subPaths);\n\n\t\t\treturn\tsubPaths;\n\n\t\t}\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\tvar tmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\t//console.log(\"shape\", shapes);\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tvar inside = false;\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\n\n\t\tvar subPaths = extractSubpaths( this.actions );\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new THREE.Shape();\n\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tvar betterShapeHoles = [];\n\t\tvar newShapes = [];\n\t\tvar newShapeHoles = [];\n\t\tvar mainIdx = 0;\n\t\tvar tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tvar ambiguous = false;\n\t\t\tvar toChange = [];\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmpHoles;\n\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n// File:src/extras/core/Shape.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nTHREE.Shape = function () {\n\n\tTHREE.Path.apply( this, arguments );\n\n\tthis.holes = [];\n\n};\n\nTHREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {\n\n\tconstructor: THREE.Shape,\n\n\t// Convenience method to return ExtrudeGeometry\n\n\textrude: function ( options ) {\n\n\t\treturn new THREE.ExtrudeGeometry( this, options );\n\n\t},\n\n\t// Convenience method to return ShapeGeometry\n\n\tmakeGeometry: function ( options ) {\n\n\t\treturn new THREE.ShapeGeometry( this, options );\n\n\t},\n\n\tgetPointsHoles: function ( divisions ) {\n\n\t\tvar holesPts = [];\n\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t},\n\n\t// Get points of shape and holes (keypoints based on segments parameter)\n\n\textractAllPoints: function ( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t},\n\n\textractPoints: function ( divisions ) {\n\n\t\treturn this.extractAllPoints( divisions );\n\n\t}\n\n} );\n\n// File:src/extras/curves/LineCurve.js\n\n/**************************************************************\n *\tLine\n **************************************************************/\n\nTHREE.LineCurve = function ( v1, v2 ) {\n\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\n\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\n\tvar point = this.v2.clone().sub( this.v1 );\n\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\n\treturn this.getPoint( u );\n\n};\n\nTHREE.LineCurve.prototype.getTangent = function( t ) {\n\n\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\treturn tangent.normalize();\n\n};\n\n// File:src/extras/curves/QuadraticBezierCurve.js\n\n/**************************************************************\n *\tQuadratic Bezier curve\n **************************************************************/\n\n\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\n\n\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b2 = THREE.ShapeUtils.b2;\n\n\treturn new THREE.Vector2(\n\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t);\n\n};\n\n\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\n\n\treturn new THREE.Vector2(\n\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/CubicBezierCurve.js\n\n/**************************************************************\n *\tCubic Bezier curve\n **************************************************************/\n\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\tthis.v3 = v3;\n\n};\n\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\n\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b3 = THREE.ShapeUtils.b3;\n\n\treturn new THREE.Vector2( \n\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t);\n\n};\n\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\n\n\treturn new THREE.Vector2( \n\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/SplineCurve.js\n\n/**************************************************************\n *\tSpline curve\n **************************************************************/\n\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\n\tthis.points = ( points == undefined ) ? [] : points;\n\n};\n\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\n\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\n\tvar points = this.points;\n\tvar point = ( points.length - 1 ) * t;\n\n\tvar intPoint = Math.floor( point );\n\tvar weight = point - intPoint;\n\n\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\tvar point1 = points[ intPoint ];\n\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\treturn new THREE.Vector2(\n\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t);\n\n};\n\n// File:src/extras/curves/EllipseCurve.js\n\n/**************************************************************\n *\tEllipse curve\n **************************************************************/\n\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\tthis.aX = aX;\n\tthis.aY = aY;\n\n\tthis.xRadius = xRadius;\n\tthis.yRadius = yRadius;\n\n\tthis.aStartAngle = aStartAngle;\n\tthis.aEndAngle = aEndAngle;\n\n\tthis.aClockwise = aClockwise;\n\t\n\tthis.aRotation = aRotation || 0;\n\n};\n\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\n\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\n\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\n\n\tvar angle;\n\n\tif ( this.aClockwise === true ) {\n\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\n\n\t} else {\n\n\t\tangle = this.aStartAngle + t * deltaAngle;\n\n\t}\n\t\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\tif ( this.aRotation !== 0 ) {\n\n\t\tvar cos = Math.cos( this.aRotation );\n\t\tvar sin = Math.sin( this.aRotation );\n\n\t\tvar tx = x, ty = y;\n\n\t\t// Rotate the point about the center of the ellipse.\n\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\n\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\n\n\t}\n\n\treturn new THREE.Vector2( x, y );\n\n};\n\n// File:src/extras/curves/ArcCurve.js\n\n/**************************************************************\n *\tArc curve\n **************************************************************/\n\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n};\n\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\n\n// File:src/extras/curves/LineCurve3.js\n\n/**************************************************************\n *\tLine3D\n **************************************************************/\n\nTHREE.LineCurve3 = THREE.Curve.create(\n\n\tfunction ( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\tvector.multiplyScalar( t );\n\t\tvector.add( this.v1 );\n\n\t\treturn vector;\n\n\t}\n\n);\n\n// File:src/extras/curves/QuadraticBezierCurve3.js\n\n/**************************************************************\n *\tQuadratic Bezier 3D curve\n **************************************************************/\n\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\n\n\t\treturn new THREE.Vector3(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CubicBezierCurve3.js\n\n/**************************************************************\n *\tCubic Bezier 3D curve\n **************************************************************/\n\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\n\t\treturn new THREE.Vector3(\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/SplineCurve3.js\n\n/**************************************************************\n *\tSpline 3D curve\n **************************************************************/\n\n\nTHREE.SplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */ ) {\n\n\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\tthis.points = ( points == undefined ) ? [] : points;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\t\treturn new THREE.Vector3(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CatmullRomCurve3.js\n\n/**\n * @author zz85 https://github.com/zz85\n *\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\nTHREE.CatmullRomCurve3 = ( function() {\n\n\tvar\n\t\ttmp = new THREE.Vector3(),\n\t\tpx = new CubicPoly(),\n\t\tpy = new CubicPoly(),\n\t\tpz = new CubicPoly();\n\n\t/*\n\tBased on an optimized c++ solution in\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t - http://ideone.com/NoEbVM\n\n\tThis CubicPoly class could be used for reusing some variables and calculations,\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\twhich can be placed in CurveUtils.\n\t*/\n\n\tfunction CubicPoly() {\n\n\t}\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\n\t\tthis.c0 = x0;\n\t\tthis.c1 = t0;\n\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t};\n\n\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t// compute tangents when parameterized in [t1,t2]\n\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t// rescale tangents for parametrization in [0,1]\n\t\tt1 *= dt1;\n\t\tt2 *= dt1;\n\n\t\t// initCubicPoly\n\t\tthis.init( x1, x2, t1, t2 );\n\n\t};\n\n\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\n\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t};\n\n\tCubicPoly.prototype.calc = function( t ) {\n\n\t\tvar t2 = t * t;\n\t\tvar t3 = t2 * t;\n\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\n\t};\n\n\t// Subclass Three.js curve\n\treturn THREE.Curve.create(\n\n\t\tfunction ( p /* array of Vector3 */ ) {\n\n\t\t\tthis.points = p || [];\n\t\t\tthis.closed = false;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar points = this.points,\n\t\t\t\tpoint, intPoint, weight, l;\n\n\t\t\tl = points.length;\n\n\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tif ( this.closed ) {\n\n\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\t\tintPoint = l - 2;\n\t\t\t\tweight = 1;\n\n\t\t\t}\n\n\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate first point\n\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\tp0 = tmp;\n\n\t\t\t}\n\n\t\t\tp1 = points[ intPoint % l ];\n\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate last point\n\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\tp3 = tmp;\n\n\t\t\t}\n\n\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t\t// safety check for repeated points\n\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t\t} else if ( this.type === 'catmullrom' ) {\n\n\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n\t\t\t}\n\n\t\t\tvar v = new THREE.Vector3(\n\t\t\t\tpx.calc( weight ),\n\t\t\t\tpy.calc( weight ),\n\t\t\t\tpz.calc( weight )\n\t\t\t);\n\n\t\t\treturn v;\n\n\t\t}\n\n\t);\n\n} )();\n\n// File:src/extras/curves/ClosedSplineCurve3.js\n\n/**************************************************************\n *\tClosed Spline 3D curve\n **************************************************************/\n\n\nTHREE.ClosedSplineCurve3 = function ( points ) {\n\n\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\n\tTHREE.CatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\tthis.closed = true;\n\n};\n\nTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\n\n// File:src/extras/geometries/BoxGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n */\n\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'BoxGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\n\nTHREE.CubeGeometry = THREE.BoxGeometry;\n\n// File:src/extras/geometries/BoxBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'BoxBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tvar scope = this;\n\n\t// segments\n\twidthSegments = Math.floor( widthSegments ) || 1;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\tvar numberOfVertices = 0;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// build each side of the box geometry\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\t// helper functions\n\n\tfunction calculateVertexCount ( w, h, d ) {\n\n\t\tvar vertices = 0;\n\n\t\t// calculate the amount of vertices for each side (plane)\n\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\n\t\treturn vertices;\n\n\t}\n\n\tfunction calculateIndexCount ( w, h, d ) {\n\n\t\tvar index = 0;\n\n\t\t// calculate the amount of squares for each side\n\t\tindex += w * h * 2; // xy\n\t\tindex += w * d * 2; // xz\n\t\tindex += d * h * 2; // zy\n\n\t\treturn index * 6; // two triangles per square => six vertices per square\n\n\t}\n\n\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\tvar segmentWidth\t= width / gridX;\n\t\tvar segmentHeight = height / gridY;\n\n\t\tvar widthHalf = width / 2;\n\t\tvar heightHalf = height / 2;\n\t\tvar depthHalf = depth / 2;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar vertexCounter = 0;\n\t\tvar groupCount = 0;\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = 0;\n\t\t\t\tvector[ v ] = 0;\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t// now apply vector to normal buffer\n\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// uvs\n\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\t\t\t\tvertexCounter += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 1. you need three indices to draw a single face\n\t\t// 2. a single segment consists of two faces\n\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tindexBufferOffset += 6;\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t\t// update total number of vertices\n\t\tnumberOfVertices += vertexCounter;\n\n\t}\n\n};\n\nTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\n\n// File:src/extras/geometries/CircleGeometry.js\n\n/**\n * @author hughes\n */\n\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CircleGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\n\n// File:src/extras/geometries/CircleBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CircleBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tvar vertices = segments + 2;\n\n\tvar positions = new Float32Array( vertices * 3 );\n\tvar normals = new Float32Array( vertices * 3 );\n\tvar uvs = new Float32Array( vertices * 2 );\n\n\t// center data is already zero, but need to set a few extras\n\tnormals[ 2 ] = 1.0;\n\tuvs[ 0 ] = 0.5;\n\tuvs[ 1 ] = 0.5;\n\n\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\n\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\n\t\tnormals[ i + 2 ] = 1; // normal z\n\n\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var i = 1; i <= segments; i ++ ) {\n\n\t\tindices.push( i, i + 1, 0 );\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\n\n// File:src/extras/geometries/CylinderBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CylinderBufferGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tvar scope = this;\n\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\theight = height !== undefined ? height : 100;\n\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\n\topenEnded = openEnded !== undefined ? openEnded : false;\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n\t// used to calculate buffer length\n\n\tvar nbCap = 0;\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\tif ( radiusBottom > 0 ) nbCap ++;\n\n\t}\n\n\tvar vertexCount = calculateVertexCount();\n\tvar indexCount = calculateIndexCount();\n\n\t// buffers\n\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\n\tvar index = 0,\n\t    indexOffset = 0,\n\t    indexArray = [],\n\t    halfHeight = height / 2;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// generate geometry\n\n\tgenerateTorso();\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// helper functions\n\n\tfunction calculateVertexCount() {\n\n\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction calculateIndexCount() {\n\n\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += radialSegments * nbCap * 3;\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction generateTorso() {\n\n\t\tvar x, y;\n\t\tvar normal = new THREE.Vector3();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\t// this will be used to calculate the normal\n\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar indexRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\t// calculate the radius of the current row\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\n\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormal.copy( vertex );\n\n\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\n\n\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\n\n\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\n\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\n\n\t\t\t\t}\n\n\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\t// save index of vertex in respective row\n\t\t\t\tindexRow.push( index );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// now save vertices of the row in our index array\n\t\t\tindexArray.push( indexRow );\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n\tfunction generateCap( top ) {\n\n\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\tvar uv = new THREE.Vector2();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t// save the index of the first center vertex\n\t\tcenterIndexStart = index;\n\n\t\t// first we generate the center vertex data of the cap.\n\t\t// because the geometry needs one set of uvs per face,\n\t\t// we must generate a center vertex per face/segment\n\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = 0.5;\n\t\t\tuv.y = 0.5;\n\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// save the index of the last center vertex\n\t\tcenterIndexEnd = index;\n\n\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\tvar u = x / radialSegments;\n\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * sinTheta;\n\t\t\tvertex.y = halfHeight * sign;\n\t\t\tvertex.z = radius * cosTheta;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar c = centerIndexStart + x;\n\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\tif ( top === true ) {\n\n\t\t\t\t// face top\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t} else {\n\n\t\t\t\t// face bottom\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t}\n\n\t\t\t// update counters\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n};\n\nTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\n\n// File:src/extras/geometries/CylinderGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CylinderGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\n\n// File:src/extras/geometries/ConeBufferGeometry.js\n\n/*\n * @author: abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeBufferGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderBufferGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;\n\n// File:src/extras/geometries/ConeGeometry.js\n\n/**\n * @author abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );\nTHREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;\n\n// File:src/extras/geometries/EdgesGeometry.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tvar geometry2;\n\n\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tgeometry2 = new THREE.Geometry();\n\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry2 = geometry.clone();\n\n\t}\n\n\tgeometry2.mergeVertices();\n\tgeometry2.computeFaceNormals();\n\n\tvar vertices = geometry2.vertices;\n\tvar faces = geometry2.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\tedge.sort( sortFunction );\n\n\t\t\tvar key = edge.toString();\n\n\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t} else {\n\n\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvar coords = [];\n\n\tfor ( var key in hash ) {\n\n\t\tvar h = hash[ key ];\n\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t}\n\n\t}\n\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\n\n};\n\nTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\n\n// File:src/extras/geometries/ExtrudeGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  amount: <int>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n *\n *  uvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\n\tif ( typeof( shapes ) === \"undefined\" ) {\n\n\t\tshapes = [];\n\t\treturn;\n\n\t}\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ExtrudeGeometry';\n\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n\t// can't really use automatic vertex normals\n\t// as then front and back sides get smoothed too\n\t// should do separate smoothing just for sides\n\n\t//this.computeVertexNormals();\n\n\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n};\n\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\n\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tvar sl = shapes.length;\n\n\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\tvar shape = shapes[ s ];\n\t\tthis.addShape( shape, options );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\tvar extrudePath = options.extrudePath;\n\tvar extrudePts, extrudeByPath = false;\n\n\t// Use default WorldUVGenerator if no UV generators are specified.\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\n\tvar splineTube, binormal, normal, position2;\n\tif ( extrudePath ) {\n\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\textrudeByPath = true;\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t// SETUP TNB variables\n\n\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t// TODO1 - have a .isClosed in spline?\n\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\n\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\tbinormal = new THREE.Vector3();\n\t\tnormal = new THREE.Vector3();\n\t\tposition2 = new THREE.Vector3();\n\n\t}\n\n\t// Safeguards if bevels are not enabled\n\n\tif ( ! bevelEnabled ) {\n\n\t\tbevelSegments = 0;\n\t\tbevelThickness = 0;\n\t\tbevelSize = 0;\n\n\t}\n\n\t// Variables initialization\n\n\tvar ahole, h, hl; // looping of holes\n\tvar scope = this;\n\n\tvar shapesOffset = this.vertices.length;\n\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t}\n\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t/* Vertices */\n\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\tvertices = vertices.concat( ahole );\n\n\t}\n\n\n\tfunction scalePt2 ( pt, vec, size ) {\n\n\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t}\n\n\tvar b, bs, t, z,\n\t\tvert, vlen = vertices.length,\n\t\tface, flen = faces.length;\n\n\n\t// Find directions for point movement\n\n\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t//\n\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\n\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t// check for collinear edges\n\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t// not collinear\n\n\t\t\t// length of vectors for normalizing\n\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t// vector from inPt to intersection point\n\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t//  but prevent crazy spikes\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\n\n\t\t\t} else {\n\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// handle special case of collinear edges\n\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( direction_eq ) {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t} else {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t}\n\n\n\tvar contourMovements = [];\n\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\tif ( j === il ) j = 0;\n\t\tif ( k === il ) k = 0;\n\n\t\t//  (j)---(i)---(k)\n\t\t// console.log('i,j,k', i, j , k)\n\n\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t}\n\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\toneHoleMovements = [];\n\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t}\n\n\t\tholesMovements.push( oneHoleMovements );\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t}\n\n\n\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\n\t\t//z = bevelThickness * t;\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\n\t\t//bs = bevelSize * t; // linear\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbs = bevelSize;\n\n\t// Back facing vertices\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\tif ( ! extrudeByPath ) {\n\n\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t} else {\n\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t}\n\n\t}\n\n\t// Add stepped vertices...\n\t// Including front facing vertices\n\n\tvar s;\n\n\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Add bevel segments planes\n\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Faces */\n\n\t// Top and bottom faces\n\n\tbuildLidFaces();\n\n\t// Sides faces\n\n\tbuildSideFaces();\n\n\n\t/////  Internal functions\n\n\tfunction buildLidFaces() {\n\n\t\tif ( bevelEnabled ) {\n\n\t\t\tvar layer = 0; // steps + 1\n\t\t\tvar offset = vlen * layer;\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t}\n\n\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\toffset = vlen * layer;\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t}\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Create faces for the z-sides of the shape\n\n\tfunction buildSideFaces() {\n\n\t\tvar layeroffset = 0;\n\t\tsidewalls( contour, layeroffset );\n\t\tlayeroffset += contour.length;\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t//, true\n\t\t\tlayeroffset += ahole.length;\n\n\t\t}\n\n\t}\n\n\tfunction sidewalls( contour, layeroffset ) {\n\n\t\tvar j, k;\n\t\ti = contour.length;\n\n\t\twhile ( -- i >= 0 ) {\n\n\t\t\tj = i;\n\t\t\tk = i - 1;\n\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\tfunction v( x, y, z ) {\n\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t}\n\n\tfunction f3( a, b, c ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\n\n\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\n\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\t\td += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\n\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\n\n\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\n\t\treturn [\n\t\t\tnew THREE.Vector2( a.x, a.y ),\n\t\t\tnew THREE.Vector2( b.x, b.y ),\n\t\t\tnew THREE.Vector2( c.x, c.y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\t\tvar d = vertices[ indexD ];\n\n\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\n\t\t\t];\n\n\t\t}\n\n\t}\n};\n\n// File:src/extras/geometries/ShapeGeometry.js\n\n/**\n * @author jonobr1 / http://jonobr1.com\n *\n * Creates a one-sided polygonal geometry from a path shape. Similar to\n * ExtrudeGeometry.\n *\n * parameters = {\n *\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n *\n *\tmaterial: <int> // material index for front and back faces\n *\tuvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ShapeGeometry = function ( shapes, options ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ShapeGeometry';\n\n\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\n\n/**\n * Add an array of shapes to THREE.ShapeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\tthis.addShape( shapes[ i ], options );\n\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tif ( options === undefined ) options = {};\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar material = options.material;\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\t//\n\n\tvar i, l, hole;\n\n\tvar shapesOffset = this.vertices.length;\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\thole = holes[ i ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\n\n\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false;\n\n\t}\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t// Vertices\n\n\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\thole = holes[ i ];\n\t\tvertices = vertices.concat( hole );\n\n\t}\n\n\t//\n\n\tvar vert, vlen = vertices.length;\n\tvar face, flen = faces.length;\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = vertices[ i ];\n\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\n\t}\n\n\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\tface = faces[ i ];\n\n\t\tvar a = face[ 0 ] + shapesOffset;\n\t\tvar b = face[ 1 ] + shapesOffset;\n\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\n\t}\n\n};\n\n// File:src/extras/geometries/LatheBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n // points - to create a closed torus, one must use a set of points\n //    like so: [ a, b, c, d, a ], see first is the same as last.\n // segments - the number of circumference segments to create\n // phiStart - the starting radian\n // phiLength - the radian (0 to 2PI) range of the lathed section\n //    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'LatheBufferGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tsegments = Math.floor( segments ) || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || Math.PI * 2;\n\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( segments + 1 ) * points.length;\n\tvar indexCount = segments * points.length * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar index = 0, indexOffset = 0, base;\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\tvar inverseSegments = 1.0 / segments;\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar i, j;\n\n\t// generate vertices and uvs\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar sin = Math.sin( phi );\n\t\tvar cos = Math.cos( phi );\n\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\tvertex.y = points[ j ].y;\n\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / segments;\n\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\tbase = j + i * points.length;\n\n\t\t\t// indices\n\t\t\tvar a = base;\n\t\t\tvar b = base + points.length;\n\t\t\tvar c = base + points.length + 1;\n\t\t\tvar d = base + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// generate normals\n\n\tthis.computeVertexNormals();\n\n\t// if the geometry is closed, we need to average the normals along the seam.\n\t// because the corresponding vertices are identical (but still have different UVs).\n\n\tif( phiLength === Math.PI * 2 ) {\n\n\t\tvar normals = this.attributes.normal.array;\n\t\tvar n1 = new THREE.Vector3();\n\t\tvar n2 = new THREE.Vector3();\n\t\tvar n = new THREE.Vector3();\n\n\t\t// this is the buffer offset for the last line of vertices\n\t\tbase = segments * points.length * 3;\n\n\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t// select the normal of the vertex in the first line\n\t\t\tn1.x = normals[ j + 0 ];\n\t\t\tn1.y = normals[ j + 1 ];\n\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t// select the normal of the vertex in the last line\n\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t// average normals\n\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t// assign the new values to both normals\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t} // next row\n\n\t}\n\n};\n\nTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\n\n// File:src/extras/geometries/LatheGeometry.js\n\n/**\n * @author astrodud / http://astrodud.isgreat.org/\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n */\n\n// points - to create a closed torus, one must use a set of points\n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2PI) range of the lathed section\n//    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'LatheGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\n\n// File:src/extras/geometries/PlaneGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PlaneGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n};\n\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\n\n// File:src/extras/geometries/PlaneBufferGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'PlaneBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tvar width_half = width / 2;\n\tvar height_half = height / 2;\n\n\tvar gridX = Math.floor( widthSegments ) || 1;\n\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\tvar gridX1 = gridX + 1;\n\tvar gridY1 = gridY + 1;\n\n\tvar segment_width = width / gridX;\n\tvar segment_height = height / gridY;\n\n\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\n\tvar offset = 0;\n\tvar offset2 = 0;\n\n\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\tvar y = iy * segment_height - height_half;\n\n\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\tvertices[ offset ] = x;\n\t\t\tvertices[ offset + 1 ] = - y;\n\n\t\t\tnormals[ offset + 2 ] = 1;\n\n\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\n\t\t\toffset += 3;\n\t\t\toffset2 += 2;\n\n\t\t}\n\n\t}\n\n\toffset = 0;\n\n\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\n\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\n\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iy;\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\tindices[ offset ] = a;\n\t\t\tindices[ offset + 1 ] = b;\n\t\t\tindices[ offset + 2 ] = d;\n\n\t\t\tindices[ offset + 3 ] = b;\n\t\t\tindices[ offset + 4 ] = c;\n\t\t\tindices[ offset + 5 ] = d;\n\n\t\t\toffset += 6;\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\n\n// File:src/extras/geometries/RingBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'RingBufferGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tinnerRadius = innerRadius || 20;\n\touterRadius = outerRadius || 50;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// some helper variables\n\tvar index = 0, indexOffset = 0, segment;\n\tvar radius = innerRadius;\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\t// values are generate from the inside of the ring to the outside\n\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex++;\n\n\t\t}\n\n\t\t// increase the radius for next row of vertices\n\t\tradius += radiusStep;\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t// indices\n\t\t\tvar a = segment;\n\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\tvar d = segment + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n};\n\nTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\n\n// File:src/extras/geometries/RingGeometry.js\n\n/**\n * @author Kaleb Murphy\n */\n\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'RingGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\n\n// File:src/extras/geometries/SphereGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'SphereGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n};\n\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\n\n// File:src/extras/geometries/SphereBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n * based on THREE.SphereGeometry\n */\n\nTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'SphereBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tphiStart = phiStart !== undefined ? phiStart : 0;\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar thetaEnd = thetaStart + thetaLength;\n\n\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\n\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\tvar index = 0, vertices = [], normal = new THREE.Vector3();\n\n\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\n\t\tvar verticesRow = [];\n\n\t\tvar v = y / heightSegments;\n\n\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\tvar u = x / widthSegments;\n\n\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tnormal.set( px, py, pz ).normalize();\n\n\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\tverticesRow.push( index );\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\n\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\n\tthis.addAttribute( 'position', positions );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\n\n// File:src/extras/geometries/TextGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float> // how far from text outline is bevel\n * }\n */\n\nTHREE.TextGeometry = function ( text, parameters ) {\n\n\tparameters = parameters || {};\n\n\tvar font = parameters.font;\n\n\tif ( font instanceof THREE.Font === false ) {\n\n\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\treturn new THREE.Geometry();\n\n\t}\n\n\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\n\n\tthis.type = 'TextGeometry';\n\n};\n\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\n\n// File:src/extras/geometries/TorusBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\tarc = arc || Math.PI * 2;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\n\t// helper variables\n\tvar center = new THREE.Vector3();\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / tubularSegments * arc;\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t// vertex\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\n\t\t\t// this vector is used to calculate the normal\n\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\tcenter.y = radius * Math.sin( u );\n\n\t\t\t// normal\n\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\n\t\t\t// uv\n\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\n\t\t\t// update offsets\n\t\t\tvertexBufferOffset += 3;\n\t\t\tuvBufferOffset += 2;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t// face one\n\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t// face two\n\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t// update offset\n\t\t\tindexBufferOffset += 6;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\n\n// File:src/extras/geometries/TorusGeometry.js\n\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n */\n\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n};\n\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\n\n// File:src/extras/geometries/TorusKnotBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * see: http://www.blackpawn.com/texts/pqtorus/\n */\nTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusKnotBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\tp = p || 2;\n\tq = q || 3;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar i, j, index = 0, indexOffset = 0;\n\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\n\tvar P1 = new THREE.Vector3();\n\tvar P2 = new THREE.Vector3();\n\n\tvar B = new THREE.Vector3();\n\tvar T = new THREE.Vector3();\n\tvar N = new THREE.Vector3();\n\n\t// generate vertices, normals and uvs\n\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t// calculate orthonormal basis\n\n\t\tT.subVectors( P2, P1 );\n\t\tN.addVectors( P2, P1 );\n\t\tB.crossVectors( T, N );\n\t\tN.crossVectors( B, T );\n\n\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\tB.normalize();\n\t\tN.normalize();\n\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t// now calculate the final vertex position.\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / tubularSegments;\n\t\t\tuv.y = j / radialSegments;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// this function calculates the current position on the torus curve\n\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = q / p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t}\n\n};\n\nTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\n\n// File:src/extras/geometries/TorusKnotGeometry.js\n\n/**\n * @author oosmoxiecode\n */\n\nTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusKnotGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\n\n// File:src/extras/geometries/TubeGeometry.js\n\n/**\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n * @author jonobr1 / https://github.com/jonobr1\n *\n * Modified from the TorusKnotGeometry by @oosmoxiecode\n *\n * Creates a tube which extrudes along a 3d spline\n *\n * Uses parallel transport frames as described in\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n */\n\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TubeGeometry';\n\n\tthis.parameters = {\n\t\tpath: path,\n\t\tsegments: segments,\n\t\tradius: radius,\n\t\tradialSegments: radialSegments,\n\t\tclosed: closed,\n\t\ttaper: taper\n\t};\n\n\tsegments = segments || 64;\n\tradius = radius || 1;\n\tradialSegments = radialSegments || 8;\n\tclosed = closed || false;\n\ttaper = taper || THREE.TubeGeometry.NoTaper;\n\n\tvar grid = [];\n\n\tvar scope = this,\n\n\t\ttangent,\n\t\tnormal,\n\t\tbinormal,\n\n\t\tnumpoints = segments + 1,\n\n\t\tu, v, r,\n\n\t\tcx, cy,\n\t\tpos, pos2 = new THREE.Vector3(),\n\t\ti, j,\n\t\tip, jp,\n\t\ta, b, c, d,\n\t\tuva, uvb, uvc, uvd;\n\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\n\t\ttangents = frames.tangents,\n\t\tnormals = frames.normals,\n\t\tbinormals = frames.binormals;\n\n\t// proxy internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\t// construct the grid\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tgrid[ i ] = [];\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\tpos = path.getPointAt( u );\n\n\t\ttangent = tangents[ i ];\n\t\tnormal = normals[ i ];\n\t\tbinormal = binormals[ i ];\n\n\t\tr = radius * taper( u );\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tv = j / radialSegments * 2 * Math.PI;\n\n\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = r * Math.sin( v );\n\n\t\t\tpos2.copy( pos );\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\n\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\n\t\t}\n\n\t}\n\n\n\t// construct the mesh\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\n\t\t\tjp = ( j + 1 ) % radialSegments;\n\n\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\tb = grid[ ip ][ j ];\n\t\t\tc = grid[ ip ][ jp ];\n\t\t\td = grid[ i ][ jp ];\n\n\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\n\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\n\nTHREE.TubeGeometry.NoTaper = function ( u ) {\n\n\treturn 1;\n\n};\n\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\n\n\treturn Math.sin( Math.PI * u );\n\n};\n\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\n\n\tvar\tnormal = new THREE.Vector3(),\n\n\t\ttangents = [],\n\t\tnormals = [],\n\t\tbinormals = [],\n\n\t\tvec = new THREE.Vector3(),\n\t\tmat = new THREE.Matrix4(),\n\n\t\tnumpoints = segments + 1,\n\t\ttheta,\n\t\tsmallest,\n\n\t\ttx, ty, tz,\n\t\ti, u;\n\n\n\t// expose internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\t// compute the tangent vectors for each segment on the path\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\ttangents[ i ] = path.getTangentAt( u );\n\t\ttangents[ i ].normalize();\n\n\t}\n\n\tinitialNormal3();\n\n\t/*\n\tfunction initialNormal1(lastBinormal) {\n\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t}\n\n\tfunction initialNormal2() {\n\n\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\tvar t2 = path.getTangentAt( epsilon );\n\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\n\t}\n\t*/\n\n\tfunction initialNormal3() {\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the smallest tangent xyz component\n\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tsmallest = Number.MAX_VALUE;\n\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\tty = Math.abs( tangents[ 0 ].y );\n\t\ttz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= smallest ) {\n\n\t\t\tsmallest = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= smallest ) {\n\n\t\t\tsmallest = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= smallest ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t}\n\n\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\n\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\tvec.normalize();\n\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t}\n\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t}\n\n\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\tif ( closed ) {\n\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\n\t\ttheta /= ( numpoints - 1 );\n\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\n\n\t\t\ttheta = - theta;\n\n\t\t}\n\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\t\t// twist a little...\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/extras/geometries/PolyhedronGeometry.js\n\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PolyhedronGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\tvar that = this;\n\n\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\n\n\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\n\n\t}\n\n\tvar p = this.vertices;\n\n\tvar faces = [];\n\n\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\n\n\t\tvar v1 = p[ indices[ i ] ];\n\t\tvar v2 = p[ indices[ i + 1 ] ];\n\t\tvar v3 = p[ indices[ i + 2 ] ];\n\n\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\n\t}\n\n\tvar centroid = new THREE.Vector3();\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tsubdivide( faces[ i ], detail );\n\n\t}\n\n\n\t// Handle case when face straddles the seam\n\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\n\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\tvar x0 = uvs[ 0 ].x;\n\t\tvar x1 = uvs[ 1 ].x;\n\t\tvar x2 = uvs[ 2 ].x;\n\n\t\tvar max = Math.max( x0, x1, x2 );\n\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\n\n\t\t}\n\n\t}\n\n\n\t// Apply radius\n\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\tthis.vertices[ i ].multiplyScalar( radius );\n\n\t}\n\n\n\t// Merge vertices\n\n\tthis.mergeVertices();\n\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n\n\t// Project vector onto sphere's surface\n\n\tfunction prepare( vector ) {\n\n\t\tvar vertex = vector.normalize().clone();\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\n\t\treturn vertex;\n\n\t}\n\n\n\t// Approximate a curved face with recursively sub-divided triangles.\n\n\tfunction make( v1, v2, v3 ) {\n\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\tthat.faces.push( face );\n\n\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\n\t\tvar azi = azimuth( centroid );\n\n\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t] );\n\n\t}\n\n\n\t// Analytically subdivide a face to the required detail level.\n\n\tfunction subdivide( face, detail ) {\n\n\t\tvar cols = Math.pow( 2, detail );\n\t\tvar a = prepare( that.vertices[ face.a ] );\n\t\tvar b = prepare( that.vertices[ face.b ] );\n\t\tvar c = prepare( that.vertices[ face.c ] );\n\t\tvar v = [];\n\n\t\t// Construct all of the vertices for this subdivision.\n\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\n\n\t\t\tv[ i ] = [];\n\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\n\t\t\tvar rows = cols - i;\n\n\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\n\n\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Construct all of the faces.\n\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ],\n\t\t\t\t\t\tv[ i ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n\n\t// Texture fixing helper. Spheres have some odd behaviours.\n\n\tfunction correctUV( uv, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\t\treturn uv.clone();\n\n\t}\n\n\n};\n\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\n\n// File:src/extras/geometries/DodecahedronGeometry.js\n\n/**\n * @author Abe Pazos / https://hamoid.com\n */\n\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\tvar r = 1 / t;\n\n\tvar vertices = [\n\n\t\t// (±1, ±1, ±1)\n\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t 1,  1, - 1,     1,  1,  1,\n\n\t\t// (0, ±1/φ, ±φ)\n\t\t 0, - r, - t,     0, - r,  t,\n\t\t 0,  r, - t,     0,  r,  t,\n\n\t\t// (±1/φ, ±φ, 0)\n\t\t- r, - t,  0,    - r,  t,  0,\n\t\t r, - t,  0,     r,  t,  0,\n\n\t\t// (±φ, 0, ±1/φ)\n\t\t- t,  0, - r,     t,  0, - r,\n\t\t- t,  0,  r,     t,  0,  r\n\t];\n\n\tvar indices = [\n\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'DodecahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\n\n// File:src/extras/geometries/IcosahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t];\n\n\tvar indices = [\n\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'IcosahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\n\n// File:src/extras/geometries/OctahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.OctahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t];\n\n\tvar indices = [\n\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'OctahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\n\n// File:src/extras/geometries/TetrahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t];\n\n\tvar indices = [\n\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'TetrahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\n\n// File:src/extras/geometries/ParametricGeometry.js\n\n/**\n * @author zz85 / https://github.com/zz85\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n *\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\n *\n */\n\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ParametricGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\tvar verts = this.vertices;\n\tvar faces = this.faces;\n\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\tvar i, j, p;\n\tvar u, v;\n\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tv = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tu = j / slices;\n\n\t\t\tp = func( u, v );\n\t\t\tverts.push( p );\n\n\t\t}\n\n\t}\n\n\tvar a, b, c, d;\n\tvar uva, uvb, uvc, uvd;\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\ta = i * sliceCount + j;\n\t\t\tb = i * sliceCount + j + 1;\n\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\td = ( i + 1 ) * sliceCount + j;\n\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\n\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\t// console.log(this);\n\n\t// magic bullet\n\t// var diff = this.mergeVertices();\n\t// console.log('removed ', diff, ' vertices by merging');\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\n\n// File:src/extras/geometries/WireframeGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeGeometry = function ( geometry ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\tvar vertices = geometry.vertices;\n\t\tvar faces = geometry.faces;\n\t\tvar numEdges = 0;\n\n\t\t// allocate maximal size\n\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\n\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\t// Indexed BufferGeometry\n\n\t\t\tvar indices = geometry.index.array;\n\t\t\tvar vertices = geometry.attributes.position;\n\t\t\tvar groups = geometry.groups;\n\t\t\tvar numEdges = 0;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t}\n\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\tvar start = group.start;\n\t\t\t\tvar count = group.count;\n\n\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\n\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t} else {\n\n\t\t\t// non-indexed BufferGeometry\n\n\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\tvar numEdges = vertices.length / 3;\n\t\t\tvar numTris = numEdges / 3;\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\n\n// File:src/extras/helpers/AxisHelper.js\n\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AxisHelper = function ( size ) {\n\n\tsize = size || 1;\n\n\tvar vertices = new Float32Array( [\n\t\t0, 0, 0,  size, 0, 0,\n\t\t0, 0, 0,  0, size, 0,\n\t\t0, 0, 0,  0, 0, size\n\t] );\n\n\tvar colors = new Float32Array( [\n\t\t1, 0, 0,  1, 0.6, 0,\n\t\t0, 1, 0,  0.6, 1, 0,\n\t\t0, 0, 1,  0, 0.6, 1\n\t] );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\n\n// File:src/extras/helpers/ArrowHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / http://github.com/zz85\n * @author bhouston / http://clara.io\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  color - color in hex value\n *  headLength - Number\n *  headWidth - Number\n */\n\nTHREE.ArrowHelper = ( function () {\n\n\tvar lineGeometry = new THREE.BufferGeometry();\n\tlineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\tvar coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tTHREE.Object3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\n\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\n\n\tvar axis = new THREE.Vector3();\n\tvar radians;\n\n\treturn function setDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tradians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t}\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\tthis.line.updateMatrix();\n\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\tthis.cone.position.y = length;\n\tthis.cone.updateMatrix();\n\n};\n\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\n\n\tthis.line.material.color.copy( color );\n\tthis.cone.material.color.copy( color );\n\n};\n\n// File:src/extras/helpers/BoxHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BoxHelper = function ( object, color ) {\n\t\n\tif ( color === undefined ) color = 0xffff00;\n\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\tvar positions = new Float32Array( 8 * 3 );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ) );\n\n\tif ( object !== undefined ) {\n\n\t\tthis.update( object );\n\n\t}\n\n};\n\nTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\n\nTHREE.BoxHelper.prototype.update = ( function () {\n\n\tvar box = new THREE.Box3();\n\n\treturn function update( object ) {\n\n\t\tif ( object instanceof THREE.Box3 ) {\n\n\t\t\tbox.copy( object );\n\n\t\t} else {\n\n\t\t\tbox.setFromObject( object );\n\n\t\t}\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tvar min = box.min;\n\t\tvar max = box.max;\n\n\t\t/*\n\t\t  5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tvar position = this.geometry.attributes.position;\n\t\tvar array = position.array;\n\n\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t};\n\n} )();\n\n// File:src/extras/helpers/BoundingBoxHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\n// a helper to show the world-axis-aligned bounding box for an object\n\nTHREE.BoundingBoxHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\tthis.object = object;\n\n\tthis.box = new THREE.Box3();\n\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n};\n\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\n\nTHREE.BoundingBoxHelper.prototype.update = function () {\n\n\tthis.box.setFromObject( this.object );\n\n\tthis.box.size( this.scale );\n\n\tthis.box.center( this.position );\n\n};\n\n// File:src/extras/helpers/CameraHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nTHREE.CameraHelper = function ( camera ) {\n\n\tvar geometry = new THREE.Geometry();\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\n\tvar pointMap = {};\n\n\t// colors\n\n\tvar hexFrustum = 0xffaa00;\n\tvar hexCone = 0xff0000;\n\tvar hexUp = 0x00aaff;\n\tvar hexTarget = 0xffffff;\n\tvar hexCross = 0x333333;\n\n\t// near\n\n\taddLine( \"n1\", \"n2\", hexFrustum );\n\taddLine( \"n2\", \"n4\", hexFrustum );\n\taddLine( \"n4\", \"n3\", hexFrustum );\n\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t// far\n\n\taddLine( \"f1\", \"f2\", hexFrustum );\n\taddLine( \"f2\", \"f4\", hexFrustum );\n\taddLine( \"f4\", \"f3\", hexFrustum );\n\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t// sides\n\n\taddLine( \"n1\", \"f1\", hexFrustum );\n\taddLine( \"n2\", \"f2\", hexFrustum );\n\taddLine( \"n3\", \"f3\", hexFrustum );\n\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t// cone\n\n\taddLine( \"p\", \"n1\", hexCone );\n\taddLine( \"p\", \"n2\", hexCone );\n\taddLine( \"p\", \"n3\", hexCone );\n\taddLine( \"p\", \"n4\", hexCone );\n\n\t// up\n\n\taddLine( \"u1\", \"u2\", hexUp );\n\taddLine( \"u2\", \"u3\", hexUp );\n\taddLine( \"u3\", \"u1\", hexUp );\n\n\t// target\n\n\taddLine( \"c\", \"t\", hexTarget );\n\taddLine( \"p\", \"c\", hexCross );\n\n\t// cross\n\n\taddLine( \"cn1\", \"cn2\", hexCross );\n\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\taddLine( \"cf1\", \"cf2\", hexCross );\n\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\tfunction addLine( a, b, hex ) {\n\n\t\taddPoint( a, hex );\n\t\taddPoint( b, hex );\n\n\t}\n\n\tfunction addPoint( id, hex ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\n\n\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\tpointMap[ id ] = [];\n\n\t\t}\n\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t}\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.camera = camera;\n\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\tthis.matrix = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = pointMap;\n\n\tthis.update();\n\n};\n\nTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\n\nTHREE.CameraHelper.prototype.update = function () {\n\n\tvar geometry, pointMap;\n\n\tvar vector = new THREE.Vector3();\n\tvar camera = new THREE.Camera();\n\n\tfunction setPoint( point, x, y, z ) {\n\n\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\tvar points = pointMap[ point ];\n\n\t\tif ( points !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn function update() {\n\n\t\tgeometry = this.geometry;\n\t\tpointMap = this.pointMap;\n\n\t\tvar w = 1, h = 1;\n\n\t\t// we need just camera projection matrix\n\t\t// world matrix must be identity\n\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t// center / target\n\n\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t// near\n\n\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\tsetPoint( \"f4\",   w,   h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\n\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/DirectionalLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.DirectionalLightHelper = function ( light, size ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tif ( size === undefined ) size = 1;\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [\n\t\t- size,   size, 0,\n\t\t  size,   size, 0,\n\t\t  size, - size, 0,\n\t\t- size, - size, 0,\n\t\t- size,   size, 0\n\t], 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.add( new THREE.Line( geometry, material ) );\n\n\tgeometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\tthis.add( new THREE.Line( geometry, material ));\n\n\tthis.update();\n\n};\n\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\n\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\n\n\tvar lightPlane = this.children[ 0 ];\n\tvar targetLine = this.children[ 1 ];\n\n\tlightPlane.geometry.dispose();\n\tlightPlane.material.dispose();\n\ttargetLine.geometry.dispose();\n\ttargetLine.material.dispose();\n\n};\n\nTHREE.DirectionalLightHelper.prototype.update = function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar v3 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\tv3.subVectors( v2, v1 );\n\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\n\t\tlightPlane.lookAt( v3 );\n\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\ttargetLine.lookAt( v3 );\n\t\ttargetLine.scale.z = v3.length();\n\n\t};\n\n}();\n\n// File:src/extras/helpers/EdgesHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @param object THREE.Mesh whose geometry will be used\n * @param hex line color\n * @param thresholdAngle the minimum angle (in degrees),\n * between the face normals of adjacent faces,\n * that is required to render an edge. A value of 10 means\n * an edge is only rendered if the angle is at least 10 degrees.\n */\n\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\n\n// File:src/extras/helpers/FaceNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\t// FaceNormalsHelper only supports THREE.Geometry\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length;\n\n\t} else {\n\n\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\tthis.update();\n\n};\n\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\n\nTHREE.FaceNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tvar vertices = objGeometry.vertices;\n\n\t\tvar faces = objGeometry.faces;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar normal = face.normal;\n\n\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t.divideScalar( 3 )\n\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/GridHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.GridHelper = function ( size, step, color1, color2 ) {\n\n\tcolor1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );\n\tcolor2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );\n\n\tvar vertices = [];\n\tvar colors = [];\n\n\tfor ( var i = - size, j = 0; i <= size; i += step ) {\n\n\t\tvertices.push( - size, 0, i, size, 0, i );\n\t\tvertices.push( i, 0, - size, i, 0, size );\n\n\t\tvar color = i === 0 ? color1 : color2;\n\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\n\t}\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\n\nTHREE.GridHelper.prototype.setColors = function () {\n\n\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n};\n\n// File:src/extras/helpers/HemisphereLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\n\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\tgeometry.rotateX( - Math.PI / 2 );\n\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t}\n\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\n\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\n\tthis.add( this.lightSphere );\n\n\tthis.update();\n\n};\n\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\n\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\n\n\tthis.lightSphere.geometry.dispose();\n\tthis.lightSphere.material.dispose();\n\n};\n\nTHREE.HemisphereLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/PointLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLightHelper = function ( light, sphereSize ) {\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tvar geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.matrix = this.light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\t/*\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tvar d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n};\n\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\n\nTHREE.PointLightHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n\n};\n\nTHREE.PointLightHelper.prototype.update = function () {\n\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t/*\n\tvar d = this.light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.visible = true;\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\t*/\n\n};\n\n// File:src/extras/helpers/SkeletonHelper.js\n\n/**\n * @author Sean Griffin / http://twitter.com/sgrif\n * @author Michael Guerrero / http://realitymeltdown.com\n * @author mrdoob / http://mrdoob.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkeletonHelper = function ( object ) {\n\n\tthis.bones = this.getBoneList( object );\n\n\tvar geometry = new THREE.Geometry();\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dynamic = true;\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.root = object;\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\n\nTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\n\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\n\n\tvar boneList = [];\n\n\tif ( object instanceof THREE.Bone ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n};\n\nTHREE.SkeletonHelper.prototype.update = function () {\n\n\tvar geometry = this.geometry;\n\n\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\n\n\tvar boneMatrix = new THREE.Matrix4();\n\n\tvar j = 0;\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tj += 2;\n\n\t\t}\n\n\t}\n\n\tgeometry.verticesNeedUpdate = true;\n\n\tgeometry.computeBoundingSphere();\n\n};\n\n// File:src/extras/helpers/SpotLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.SpotLightHelper = function ( light ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = [\n\t\t0, 0, 0,   0,   0,   1,\n\t\t0, 0, 0,   1,   0,   1,\n\t\t0, 0, 0, - 1,   0,   1,\n\t\t0, 0, 0,   0,   1,   1,\n\t\t0, 0, 0,   0, - 1,   1\n\t];\n\n\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\tpositions.push(\n\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t);\n\n\t}\n\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.cone = new THREE.LineSegments( geometry, material );\n\tthis.add( this.cone );\n\n\tthis.update();\n\n};\n\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\n\nTHREE.SpotLightHelper.prototype.dispose = function () {\n\n\tthis.cone.geometry.dispose();\n\tthis.cone.material.dispose();\n\n};\n\nTHREE.SpotLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\tvar vector2 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t};\n\n}();\n\n// File:src/extras/helpers/VertexNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length * 3;\n\n\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\n\nTHREE.VertexNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\tvar idx = 0;\n\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/WireframeHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\n\n// File:src/extras/objects/ImmediateRenderObject.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ImmediateRenderObject = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.material = material;\n\tthis.render = function ( renderCallback ) {};\n\n};\n\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\n\n// File:src/extras/objects/MorphBlendMesh.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphBlendMesh = function( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.animationsMap = {};\n\tthis.animationsList = [];\n\n\t// prepare default animation\n\t// (all frames played together in 1 second)\n\n\tvar numFrames = this.geometry.morphTargets.length;\n\n\tvar name = \"__default\";\n\n\tvar startFrame = 0;\n\tvar endFrame = numFrames - 1;\n\n\tvar fps = numFrames / 1;\n\n\tthis.createAnimation( name, startFrame, endFrame, fps );\n\tthis.setAnimationWeight( name, 1 );\n\n};\n\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\n\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\n\tvar animation = {\n\n\t\tstart: start,\n\t\tend: end,\n\n\t\tlength: end - start + 1,\n\n\t\tfps: fps,\n\t\tduration: ( end - start ) / fps,\n\n\t\tlastFrame: 0,\n\t\tcurrentFrame: 0,\n\n\t\tactive: false,\n\n\t\ttime: 0,\n\t\tdirection: 1,\n\t\tweight: 1,\n\n\t\tdirectionBackwards: false,\n\t\tmirroredLoop: false\n\n\t};\n\n\tthis.animationsMap[ name ] = animation;\n\tthis.animationsList.push( animation );\n\n};\n\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\n\tvar pattern = /([a-z]+)_?(\\d+)/i;\n\n\tvar firstAnimation, frameRanges = {};\n\n\tvar geometry = this.geometry;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar chunks = morph.name.match( pattern );\n\n\t\tif ( chunks && chunks.length > 1 ) {\n\n\t\t\tvar name = chunks[ 1 ];\n\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\n\n\t\t\tvar range = frameRanges[ name ];\n\n\t\t\tif ( i < range.start ) range.start = i;\n\t\t\tif ( i > range.end ) range.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\n\t\t}\n\n\t}\n\n\tfor ( var name in frameRanges ) {\n\n\t\tvar range = frameRanges[ name ];\n\t\tthis.createAnimation( name, range.start, range.end, fps );\n\n\t}\n\n\tthis.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = 1;\n\t\tanimation.directionBackwards = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = - 1;\n\t\tanimation.directionBackwards = true;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.fps = fps;\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.duration = duration;\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.weight = weight;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = time;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\n\tvar time = 0;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\ttime = animation.time;\n\n\t}\n\n\treturn time;\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\n\tvar duration = - 1;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tduration = animation.duration;\n\n\t}\n\n\treturn duration;\n\n};\n\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = 0;\n\t\tanimation.active = true;\n\n\t} else {\n\n\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.active = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\n\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\n\t\tvar animation = this.animationsList[ i ];\n\n\t\tif ( ! animation.active ) continue;\n\n\t\tvar frameTime = animation.duration / animation.length;\n\n\t\tanimation.time += animation.direction * delta;\n\n\t\tif ( animation.mirroredLoop ) {\n\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\n\t\t\t\tanimation.direction *= - 1;\n\n\t\t\t\tif ( animation.time > animation.duration ) {\n\n\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\tanimation.directionBackwards = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( animation.time < 0 ) {\n\n\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\tanimation.directionBackwards = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tanimation.time = animation.time % animation.duration;\n\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\n\t\t}\n\n\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\tvar weight = animation.weight;\n\n\t\tif ( keyframe !== animation.currentFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\tanimation.currentFrame = keyframe;\n\n\t\t}\n\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\n\t\tif ( animation.currentFrame !== animation.lastFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\n\t\t} else {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\n\n\t\t}\n\n\t}\n\n};\n\n"],"sourceRoot":"/source/"}
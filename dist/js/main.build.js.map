{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","app/index.js","main.build.js","app/config.js","app/libs/BloomPass.js","app/libs/EffectComposer.js","app/libs/FilmPass.js","app/libs/MaskPass.js","app/libs/OrbitControls.js","app/libs/RenderPass.js","app/libs/ShaderPass.js","app/modules/Stage.js","app/shaders/BadTv.js","app/shaders/ConvolutionShader.js","app/shaders/CopyShader.js","app/shaders/FilmShader.js","app/vendor/TweenMax.min.js","node_modules/three/build/three.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","Stage","stage","init","./config","./modules/Stage","2","config","3","THREE","BloomPass","strength","kernelSize","sigma","resolution","Pass","this","undefined","pars","minFilter","LinearFilter","magFilter","format","RGBAFormat","renderTargetX","WebGLRenderTarget","renderTargetY","CopyShader","console","error","copyShader","copyUniforms","UniformsUtils","clone","uniforms","value","materialCopy","ShaderMaterial","vertexShader","fragmentShader","blending","AdditiveBlending","transparent","ConvolutionShader","convolutionShader","convolutionUniforms","blurX","buildKernel","materialConvolution","defines","KERNEL_SIZE_FLOAT","toFixed","KERNEL_SIZE_INT","needsSwap","camera","OrthographicCamera","scene","Scene","quad","Mesh","PlaneBufferGeometry","add","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","delta","maskActive","context","disable","STENCIL_TEST","material","texture","blurY","enable","clear","Vector2","three","4","EffectComposer","renderTarget","parameters","stencilBuffer","size","getSize","width","height","renderTarget1","renderTarget2","passes","copyPass","ShaderPass","swapBuffers","tmp","addPass","pass","push","setSize","insertPass","index","splice","il","enabled","stencilFunc","NOTEQUAL","EQUAL","MaskPass","ClearMaskPass","reset","dispose","renderToScreen","5","FilmPass","noiseIntensity","scanlinesIntensity","scanlinesCount","grayscale","FilmShader","shader","nIntensity","sIntensity","sCount","6","inverse","state","buffers","color","setMask","depth","setLocked","writeValue","clearValue","stencil","setTest","setOp","REPLACE","setFunc","ALWAYS","setClear","KEEP","7","OrbitControls","object","domElement","getAutoRotationAngle","Math","PI","scope","autoRotateSpeed","getZoomScale","pow","zoomSpeed","onMouseDown","event","preventDefault","button","noRotate","STATE","ROTATE","rotateStart","set","clientX","clientY","noZoom","DOLLY","dollyStart","noPan","PAN","panStart","addEventListener","onMouseMove","onMouseUp","element","document","body","rotateEnd","rotateDelta","subVectors","rotateLeft","x","clientWidth","rotateSpeed","rotateUp","y","clientHeight","copy","dollyEnd","dollyDelta","dollyIn","dollyOut","panEnd","panDelta","pan","update","removeEventListener","NONE","onMouseWheel","wheelDelta","detail","onKeyDown","noKeys","needUpdate","keyCode","keys","UP","keyPanSpeed","BOTTOM","LEFT","RIGHT","touchstart","touches","TOUCH_ROTATE","pageX","pageY","TOUCH_DOLLY","dx","dy","distance","sqrt","TOUCH_PAN","touchmove","stopPropagation","touchend","target","Vector3","center","minDistance","maxDistance","Infinity","autoRotate","minPolarAngle","maxPolarAngle","EPS","phiDelta","thetaDelta","scale","lastPosition","changeEvent","type","angle","panLeft","panOffset","te","matrix","elements","multiplyScalar","panUp","fov","position","offset","sub","targetDistance","tan","top","right","left","bottom","warn","dollyScale","theta","atan2","z","phi","max","min","radius","sin","cos","lookAt","distanceTo","dispatchEvent","EventDispatcher","8","RenderPass","overrideMaterial","clearColor","clearAlpha","oldClearColor","oldClearAlpha","getClearColor","getHex","getClearAlpha","setClearColor","9","textureID","10","WebGLRenderer","alpha","setPixelRatio","window","devicePixelRatio","innerWidth","innerHeight","PerspectiveCamera","controls","getAudio","getParticles","requestAnimationFrame","animate","bind","_onResize","TweenMax","to","querySelector","rotation","yoyo","repeat","ease","Power1","easeOut","renderModel","effectBloom","effectFilm","composer","badTVEffect","BadTVShader","clock","Clock","fogDensity","fogColor","time","uvScale","texture1","TextureLoader","load","texture2","wrapS","wrapT","RepeatWrapping","visualMaterial","getElementById","textContent","visualMesh","TorusGeometry","antialias","appendChild","autoClear","Date","now","lastTime","getDelta","particleSystem","updateVisual","array","Uint8Array","analyser","frequencyBinCount","frequencyArray","Float32Array","frequencyData","barsAnalyser","getByteFrequencyData","getFloatFrequencyData","average","_getAverageVolume","frequencyAverage","barsArray","forEach","bar","style","abs","soundBars","newBars","createElement","AudioContext","createAnalyser","smoothingTimeConstant","fftSize","analyser2","sourceNode","createBufferSource","splitter","createChannelSplitter","connect","destination","request","XMLHttpRequest","open","responseType","songBuffer","onload","decodeAudioData","response","buffer","duration","start","loop","_onError","send","count","particles","Geometry","pMaterial","PointsMaterial","map","opacity","p","pX","random","pY","pZ","particle","velocity","vertices","Points","sortParticles","values","aspect","updateProjectionMatrix","log","../libs/BloomPass.js","../libs/EffectComposer.js","../libs/FilmPass.js","../libs/MaskPass.js","../libs/OrbitControls.js","../libs/RenderPass.js","../libs/ShaderPass.js","../shaders/BadTv.js","../shaders/ConvolutionShader.js","../shaders/CopyShader.js","../shaders/FilmShader.js","../vendor/TweenMax.min.js","11","tDiffuse","distortion","distortion2","speed","rollSpeed","join","12","uImageIncrement","cKernel","gauss","exp","sum","halfWidth","kMaxKernelSize","ceil","Array","13","14","15","global","_gsScope","_gsQueue","_gsDefine","b","c","d","cycle","_cycle","_yoyo","vars","_repeat","_repeatDelay","repeatDelay","_dirty","g","h","_internals","isSelector","j","isArray","k","version","kill","_gc","killTweensOf","killDelayedCallsTo","getTweensOf","lagSmoothing","ticker","invalidate","_uncache","updateTo","ratio","immediateRender","_startTime","_timeline","_time","_enabled","insert","_delay","_initted","_notifyPluginsOfEnabled","_firstPT","_onPluginEvent","_duration","_totalTime","_init","_next","m","totalDuration","_totalDuration","q","_rawPrevTime","_ease","_calcEnd","getRatio","_reversed","autoRemoveChildren","lazy","data","_active","_easeType","_easePower","_onUpdate","_callback","lazyTweens","_lazy","_paused","_startAt","onStart","onRepeat","from","runBackwards","fromTo","startAt","staggerTo","allTo","onComplete","apply","onCompleteScope","arguments","callbackScope","v","w","selector","reverse","delay","staggerFrom","allFrom","staggerFromTo","allFromTo","delayedCall","onCompleteParams","onReverseComplete","onReverseCompleteParams","useFrames","overwrite","isTweening","_first","concat","getAllTweens","_rootTimeline","_rootFramesTimeline","killAll","totalTime","killChildTweensOf","tweenLookup","parentNode","tweens","paused","pauseAll","resumeAll","globalTimeScale","_timeScale","frame","progress","totalProgress","_labels","smoothChildTiming","_sortChildren","onUpdate","indexOf","_swapSelfInParams","align","stagger","lazyRender","globals","pauseCallback","_forcingPlayhead","_hasPause","_parseTimeOrLabel","exportRoot","_remove","addLabel","rawTime","remove","_pauseTime","removeLabel","_last","append","insertMultiple","appendMultiple","addPause","getLabelTime","timeline","isNaN","parseInt","charAt","Number","substr","seek","stop","gotoAndPlay","play","gotoAndStop","pause","_hasPausedChild","_prev","endTime","getChildren","_contains","recent","_recent","shiftChildren","_kill","timeScale","usesFrames","addCallback","removeCallback","removePause","tweenTo","tweenFromTo","_locked","A","B","C","getActive","isActive","getLabelAfter","getLabelsArray","name","getLabelBefore","sort","currentLabel","da","ca","ba","unshift","lengths","segments","plugin","propName","priority","API","_target","_func","_round","_props","_timeRes","timeResolution","orientToBezier","_autoRotate","_overwriteProps","parseFloat","_beziers","curviness","correlate","_segCount","_length","_lengths","_segments","_l1","_li","_s1","_si","_l2","_curSeg","_s2","_prec","_initialRotations","_startRatio","round","bezierThrough","cubicToQuadratic","_autoCSS","quadraticToCubic","_cssRegister","CSSPlugin","_parseToProxy","_setPluginRatio","CSSPropTween","_registerComplexSpecialProp","parser","end","pt","setRatio","_transform","_enableTransforms","_gsTransform","_onInitTween","proxy","_tween","_roundProps","bezier","_super","defaultTransformPerspective","defaultSkewType","defaultSmoothOrigin","suffixMap","fontSize","padding","margin","perspective","lineHeight","toUpperCase","D","E","F","G","H","I","J","K","L","createElementNS","M","N","O","_specialProps","P","navigator","userAgent","Q","exec","RegExp","$1","cssText","test","R","currentStyle","filter","S","T","U","V","toLowerCase","W","defaultView","getComputedStyle","X","getStyle","getPropertyValue","replace","Y","convertToPixels","_gsCache","removeChild","cacheWidths","Z","calculateOffset","$","za","ya","La","skewX","scaleX","scaleY","Ba","rotationX","rotationY","scaleZ","filters","_","oa","difs","firstMPT","aa","offsetWidth","offsetHeight","split","oxp","oyp","oxr","oyr","ox","oy","ea","fa","ga","ha","aqua","lime","silver","black","maroon","teal","blue","navy","white","fuchsia","olive","yellow","orange","gray","purple","green","red","pink","cyan","ia","ja","parseColor","match","ka","la","colorStringFilter","lastIndex","defaultStringFilter","ma","na","parse","xs0","xs1","pa","rxp","pr","qa","ra","parseComplex","appendXtra","xfirst","sa","ta","prefix","formatter","defaultValue","collapsible","multi","clrs","keyword","dflt","ua","va","com","greensock","plugins","registerSpecialProp","useSVGTransformAttr","wa","xa","Aa","Ca","Transform","force3D","defaultForce3D","Da","SVGElement","Ea","setAttributeNS","Fa","documentElement","Ga","chrome","getBoundingClientRect","Ha","Ka","xOrigin","yOrigin","getBBox","Ja","xOffset","yOffset","setAttribute","Ia","getCTM","svg","getAttribute","getTransform","zOrigin","Pa","removeAttribute","Ma","xPercent","yPercent","ieOffsetX","ieOffsetY","Na","set3DTransformRatio","setTransformRatio","tween","skewType","skewY","_lastParsedTransform","display","parseTransform","transform","transformPerspective","directionalRotation","shortRotation","rotationZ","shortRotationX","shortRotationY","transformOrigin","svgOrigin","smoothOrigin","_transformType","backgroundPositionX","backgroundPositionY","clipTop","clipRight","clipBottom","clipLeft","Oa","xn1","zoom","removeProperty","Qa","_gsClassPT","_classNamePT","Ra","nodeType","_vars","autoRound","zIndex","_addLazySet","className","WebkitBackfaceVisibility","_linkCSSP","pop","strictUnits","xs2","xn2","xs3","xn3","xs4","xn4","xs5","Sa","autoAlpha","visibility","Ta","slice","childNodes","cascadeTo","reservedProps","_targets","activate","blob","_onInitAllProps","roundProps","_propLookup","pg","_add","_addTween","finals","useRadians","GreenSockGlobals","_class","register","easeIn","easeInOut","next","prev","gap","_p1","_p2","_p","_p3","taper","points","randomize","clamp","template","asin","find","SlowMo","TweenLite","toString","sc","gsClass","func","check","define","amd","GreenSockAMDPath","_type","_power","_params","easing","linear","Linear","swing","Quad","_listeners","_eventTarget","up","wake","cancelAnimationFrame","getTime","tick","sleep","clearTimeout","setTimeout","fps","useRAF","visibilityState","Ticker","events","reversed","resume","restart","eventCallback","startTime","jquery","_overwrite","defaultOverwrite","_siblings","css","_overwrittenProps","defaultEase","autoSleep","jQuery","querySelectorAll","fp","blobDif","_plugins","onUpdateParams","onUpdateScope","onStartParams","onStartScope","onReverseCompleteScope","onRepeatParams","onRepeatScope","easeParams","autoCSS","onOverwrite","stringFilter","none","all","auto","concurrent","allOnStart","preexisting","true","false","_updateRoot","_gsTweenID","_initProps","_priority","_onDisable","_onEnable","_tempKill","_propName","overwriteProps","initAll","self","16","REVISION","EPSILON","sign","Function","defineProperty","get","TypeError","output","source","nextKey","hasOwnProperty","MOUSE","MIDDLE","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","FrontFaceDirectionCW","FrontFaceDirectionCCW","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","FrontSide","BackSide","DoubleSide","FlatShading","SmoothShading","NoColors","FaceColors","VertexColors","NoBlending","NormalBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","NeverDepth","AlwaysDepth","LessDepth","LessEqualDepth","EqualDepth","GreaterEqualDepth","GreaterDepth","NotEqualDepth","MultiplyOperation","MixOperation","AddOperation","NoToneMapping","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","AlphaFormat","RGBFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","LoopOnce","LoopRepeat","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroCurvatureEnding","ZeroSlopeEnding","WrapAroundEnding","TrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LinearEncoding","sRGBEncoding","GammaEncoding","RGBEEncoding","LogLuvEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","BasicDepthPacking","RGBADepthPacking","Color","setRGB","setHex","setStyle","setScalar","scalar","hex","floor","setHSL","hue2rgb","euclideanModulo","handleAlpha","string","components","ColorKeywords","copyGammaToLinear","gammaFactor","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","getHexString","getHSL","optionalTarget","hue","saturation","hsl","lightness","offsetHSL","addColors","color1","color2","addScalar","multiply","lerp","equals","fromArray","toArray","aliceblue","antiquewhite","aquamarine","azure","beige","bisque","blanchedalmond","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","gainsboro","ghostwhite","gold","goldenrod","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","limegreen","linen","magenta","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","oldlace","olivedrab","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","plum","powderblue","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","thistle","tomato","turquoise","violet","wheat","whitesmoke","yellowgreen","Quaternion","_x","_y","_z","_w","onChangeCallback","quaternion","setFromEuler","euler","Euler","c1","c2","c3","s1","s2","s3","order","setFromAxisAngle","axis","halfAngle","setFromRotationMatrix","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","setFromUnitVectors","v1","vFrom","vTo","dot","crossVectors","normalize","conjugate","lengthSq","multiplyQuaternions","premultiply","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","slerp","qb","cosHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","onChange","callback","qm","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","len","tDir","setX","setY","setComponent","getComponent","addVectors","addScaledVector","subScalar","isFinite","divide","divideScalar","clampScalar","minVal","maxVal","clampLength","roundToZero","negate","lengthManhattan","distanceToSquared","setLength","lerpVectors","v2","fromAttribute","attribute","itemSize","rotateAround","setZ","multiplyVectors","applyEuler","applyQuaternion","applyAxisAngle","applyMatrix3","applyMatrix4","applyProjection","qx","qy","qz","qw","ix","iy","iz","iw","project","Matrix4","multiplyMatrices","projectionMatrix","getInverse","matrixWorld","unproject","transformDirection","cross","ax","ay","az","bx","by","bz","projectOnVector","vector","projectOnPlane","planeNormal","reflect","normal","angleTo","acos","dz","setFromSpherical","sinPhiRadius","setFromMatrixPosition","setFromMatrixColumn","setFromMatrixScale","sx","sy","sz","temp","Vector4","setW","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","epsilon","epsilon2","xx","yy","zz","xy","xz","yz","_order","DefaultOrder","RotationOrders","setFromQuaternion","makeRotationFromQuaternion","setFromVector3","reorder","newOrder","toVector3","optionalResult","Line3","line","result","distanceSq","at","closestPointToPointParameter","startP","startEnd","point","clampToLine","startEnd2","startEnd_startP","closestPointToPoint","Box2","setFromPoints","makeEmpty","expandByPoint","setFromCenterAndSize","halfSize","box","isEmpty","expandByVector","expandByScalar","containsPoint","containsBox","getParameter","intersectsBox","clampPoint","distanceToPoint","clampedPoint","intersect","union","translate","Box3","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","setFromObject","updateMatrixWorld","traverse","node","geometry","BufferGeometry","attributes","positions","intersectsSphere","closestPoint","sphere","intersectsPlane","plane","constant","getBoundingSphere","Sphere","Matrix3","n11","n12","n13","n21","n22","n23","n31","n32","n33","identity","me","setFromMatrix4","applyToVector3Array","applyToBuffer","getX","getY","getZ","setXYZ","determinant","throwOnDegenerate","t11","t12","t13","det","msg","detInv","transpose","flattenToArrayOffset","getNormalMatrix","matrix4","transposeIntoArray","n14","n24","n34","n41","n42","n43","n44","copyPosition","extractBasis","xAxis","yAxis","zAxis","makeBasis","extractRotation","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","x2","y2","z2","wx","wy","wz","eye","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","getPosition","setPosition","t14","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","decompose","invSX","invSY","invSZ","makeFrustum","near","far","makePerspective","ymax","DEG2RAD","ymin","xmin","xmax","makeOrthographic","Ray","origin","direction","ray","recast","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","diff","v0","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","b1","invDet","intersectSphere","tca","d2","radius2","thc","t0","t1","distanceToPlane","denominator","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","optionalCenter","maxRadiusSq","empty","radiusSum","deltaLengthSq","getBoundingBox","Frustum","p0","p1","p2","p3","p4","p5","planes","Plane","frustum","setFromMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","setComponents","intersectsObject","boundingSphere","computeBoundingSphere","intersectsSprite","sprite","negRadius","d1","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","intersectLine","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","referencePoint","normalMatrix","Spherical","other","makeSafe","vec3","RAD2DEG","generateUUID","chars","uuid","rnd","mapLinear","a1","a2","b2","smoothstep","smootherstep","random16","randInt","low","high","randFloat","randFloatSpread","range","degToRad","degrees","radToDeg","radians","isPowerOfTwo","nearestPowerOfTwo","LN2","nextPowerOfTwo","Spline","interpolate","t2","t3","intPoint","weight","w2","w3","pb","pc","pd","v3","initFromArray","getPoint","getControlPointsArray","coords","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","chunks","total","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","Triangle","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","setFromPointsAndIndices","i0","i1","i2","triangle","area","midpoint","edgeList","projectedPoint","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","evaluate","pp","validate_interval","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","settings","DefaultSettings_","getSettings_","copySampleValue_","stride","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","DiscreteInterpolant","LinearInterpolant","offset1","offset0","weight1","weight0","QuaternionLinearInterpolant","autoStart","oldTime","elapsedTime","running","performance","getElapsedTime","newTime","listener","listeners","hasEventListener","listenerArray","Layers","mask","channel","toggle","layers","ascSort","intersectObject","raycaster","intersects","recursive","visible","raycast","children","Raycaster","params","Line","LOD","threshold","Sprite","defineProperties","PointCloud","linePrecision","setFromCamera","intersectObjects","objects","Object3D","onRotationChange","onQuaternionChange","Object3DIdCount","parent","DefaultUp","enumerable","modelViewMatrix","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","castShadow","receiveShadow","frustumCulled","renderOrder","userData","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","q1","rotateX","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","getObjectById","id","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","updateMatrix","force","toJSON","meta","extractFromCache","cache","key","metadata","isRootObject","geometries","materials","textures","images","generator","JSON","stringify","Face3","materialIndex","vertexNormals","vertexColors","BufferAttribute","normalized","dynamic","updateRange","needsUpdate","setDynamic","copyAt","index1","index2","copyArray","copyColorsArray","colors","copyIndicesArray","indices","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","getW","setXY","setXYZW","Int8Attribute","Int8Array","Uint8Attribute","Uint8ClampedAttribute","Uint8ClampedArray","Int16Attribute","Int16Array","Uint16Attribute","Uint16Array","Int32Attribute","Int32Array","Uint32Attribute","Uint32Array","Float32Attribute","Float64Attribute","Float64Array","DynamicBufferAttribute","InstancedBufferAttribute","meshPerAttribute","InterleavedBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","interleavedBuffer","GeometryIdCount","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","verticesNeedUpdate","elementsNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","vertex","face","jl","computeBoundingBox","obj","fromBufferGeometry","addFace","normals","tempNormals","uvs","tempUVs","uvs2","tempUVs2","uv","uv2","groups","group","computeFaceNormals","cb","ab","fl","vA","vB","vC","computeVertexNormals","areaWeighted","vl","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","computeLineDistances","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mesh","mergeVertices","verticesMap","unique","changes","precisionPoints","precision","faceIndicesToRemove","dupIndex","idx","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","getNormalIndex","hash","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","kl","DirectGeometry","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","morphTarget","morphNormal","morphAttributes","drawRange","getIndex","setIndex","addAttribute","addGroup","clearGroups","setDrawRange","updateFromObject","direct","__directGeometry","lineDistance","fromDirectGeometry","TypeArray","pA","pB","pC","normalizeNormals","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","geometry2","array2","MaxIndex","InstancedBufferGeometry","maxInstancedCount","instances","Uniform","onUpdateCallback","AnimationAction","_new","mixer","clip","localRoot","_mixer","_clip","_localRoot","tracks","nTracks","interpolants","interpolantSettings","interpolant","createInterpolant","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","_loopCount","_effectiveTimeScale","_effectiveWeight","repetitions","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","_activateAction","_deactivateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","setLoop","mode","setEffectiveWeight","getEffectiveWeight","fadeIn","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","action","halt","startTimeScale","endTimeScale","_lendControlInterpolant","times","timeScaleInterpolant","getMixer","getClip","getRoot","_root","_update","deltaTime","timeDirection","accuIndex","timeRunning","_updateTimeScale","clipTime","_updateTime","_updateWeight","propertyMixers","accumulate","interpolantValue","loopCount","_setEndings","handle_stop","pingPong","loopDelta","pending","atStart","atEnd","weightNow","weightThen","AnimationClip","resetDuration","trim","optimize","track","json","jsonTracks","frameTime","KeyframeTrack","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","AnimationUtils","getKeyframeOrder","sortedArray","NumberKeyframeTrack","findByName","objectOrClipArray","clipArray","animations","CreateClipsFromMorphTargetSequences","animationToMorphTargets","pattern","parts","animationMorphTargets","clips","parseAnimation","animation","bones","nodeName","addNonemptyTrack","trackType","trackName","animationKeys","propertyName","destTracks","flattenJSON","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationMixer","root","_initMemoryManager","_accuIndex","clipAction","optionalRoot","rootUuid","clipObject","clipUuid","actionsForClip","_actionsByClip","prototypeAction","existingAction","actionByRoot","knownActions","newAction","_Action","_bindAction","_addInactiveAction","stopAllAction","actions","_actions","nActions","_nActiveActions","bindings","_bindings","nBindings","_nActiveBindings","useCount","uncacheClip","actionsByClip","actionsToRemove","cacheIndex","lastInactiveAction","_removeInactiveBindingsForAction","uncacheRoot","_removeInactiveAction","bindingsByRoot","_bindingsByRootAndName","bindingByName","binding","restoreOriginalState","_removeInactiveBinding","uncacheAction","bindingsByName","referenceCount","_addInactiveBinding","path","parsedPath","PropertyMixer","PropertyBinding","ValueTypeName","getValueSize","_lendBinding","saveOriginalState","_lendAction","_takeBackBinding","_takeBackAction","_controlInterpolants","_nActiveControlInterpolants","stats","inUse","controlInterpolants","knownActionsForClip","lastKnownAction","byClipCacheIndex","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","propBinding","rootNode","lastInactiveBinding","remove_empty_map","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","AnimationObjectGroup","var_args","_objects","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindingsIndicesByPath","bindingsPerObject","nObjects","nCachedObjects","indicesByUUID","paths","parsedPaths","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastObject","last","subscribe_","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","arraySlice","isTypedArray","subarray","convertArray","forceClone","BYTES_PER_ELEMENT","ArrayBuffer","isView","DataView","compareTime","nValues","srcOffset","jsonKeys","valuePropertyName","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","getInterpolation","shift","timeOffset","nKeys","valid","prevTime","currTime","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","_getTrackTypeForValueTypeName","typeName","ColorKeyframeTrack","BooleanKeyframeTrack","StringKeyframeTrack","parseTrackName","findNode","getValue","targetArray","setValue","sourceArray","targetObject","objectName","propertyIndex","_getValue_unavailable","_setValue_unavailable","objectIndex","skeleton","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","resolvedProperty","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","unbind","_getValue_unbound","_setValue_unbound","dest","Composite","targetGroup","optionalParsedPath","_targetGroup","firstValidIndex","re","matches","results","searchSkeleton","bone","searchNodeSubtree","childNode","subTreeNode","mixFunction","bufferType","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","currentWeight","mix","originalValueOffset","Audio","onended","onEnded","gain","createGain","getInput","autoplay","playbackRate","isPlaying","hasPlaybackControl","sourceType","getOutput","setNodeSource","audioNode","setBuffer","audioBuffer","currentTime","disconnect","getFilters","setFilters","getFilter","setFilter","setPlaybackRate","getPlaybackRate","getLoop","getVolume","setVolume","AudioAnalyser","audio","getFrequencyData","getAverageFrequency","webkitAudioContext","PositionalAudio","panner","createPanner","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","setMaxDistance","AudioListener","removeFilter","getMasterVolume","setMasterVolume","orientation","setOrientation","Camera","matrixWorldInverse","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","options","WebGLRenderTargetCube","updateCubeMap","generateMipmaps","activeCubeFace","setRenderTarget","view","setViewOffset","fullWidth","fullHeight","offsetX","offsetY","clearViewOffset","cx","cy","zoomW","zoomH","scaleW","scaleH","focus","filmGauge","filmOffset","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","getEffectiveFOV","getFilmWidth","skew","StereoCamera","cameraL","cameraR","eyeRight","eyeLeft","eyeSep","eyeSepOnProjection","Light","intensity","groundColor","decay","penumbra","LightShadow","bias","mapSize","AmbientLight","DirectionalLight","shadow","DirectionalLightShadow","light","HemisphereLight","skyColor","PointLight","power","SpotLight","SpotLightShadow","AudioLoader","manager","DefaultLoadingManager","url","onLoad","onProgress","onError","loader","XHRLoader","setResponseType","Cache","files","file","Loader","onLoadStart","onLoadProgress","onLoadComplete","crossOrigin","extractUrlBase","initMaterials","texturePath","createMaterial","textureLoader","materialLoader","loadTexture","wrap","anisotropy","fullPath","Handlers","setCrossOrigin","MaterialLoader","specular","emissive","shininess","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","emissiveMap","mapEmissiveRepeat","mapEmissiveOffset","mapEmissiveWrap","mapEmissiveAnisotropy","lightMap","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","aoMap","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","bumpMap","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","bumpScale","normalMap","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","normalScale","specularMap","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","metalnessMap","mapMetalnessRepeat","mapMetalnessOffset","mapMetalnessWrap","mapMetalnessAnisotropy","roughnessMap","mapRoughnessRepeat","mapRoughnessOffset","mapRoughnessWrap","mapRoughnessAnisotropy","alphaMap","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","side","setTextures","handlers","regex","cached","overrideMimeType","status","itemEnd","itemError","withCredentials","itemStart","setPath","setWithCredentials","FontLoader","text","substring","font","Font","ImageLoader","image","URL","revokeObjectURL","src","createObjectURL","JSONLoader","setTexturePath","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","parseMorphing","dstVertices","srcVertices","morphColors","parseAnimations","outputAnimations","morphAnimationClips","LoadingManager","isLoading","itemsLoaded","itemsTotal","BufferGeometryLoader","TYPED_ARRAYS","typedArray","drawcalls","offsets","getTexture","roughness","metalness","shading","alphaTest","depthTest","depthWrite","colorWrite","wireframe","wireframeLinewidth","sizeAttenuation","displacementMap","displacementScale","displacementBias","emissiveIntensity","envMap","combine","reflectivity","lightMapIntensity","aoMapIntensity","ObjectLoader","lastIndexOf","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","geometryLoader","bufferGeometryLoader","widthSegments","heightSegments","depthSegments","thetaStart","thetaLength","radiusTop","radiusBottom","radialSegments","openEnded","phiStart","phiLength","innerRadius","outerRadius","thetaSegments","phiSegments","tube","tubularSegments","arc","loadImage","parseConstant","Texture","mapping","getGeometry","getMaterial","SkinnedMesh","Group","levels","level","addLevel","CubeTextureLoader","urls","loaded","CubeTexture","DataTextureLoader","BinaryTextureLoader","_parser","DataTexture","texData","mipmaps","mipmapCount","CompressedTextureLoader","texDatas","CompressedTexture","isCubemap","Material","MaterialIdCount","fog","lights","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","clippingPlanes","clipShadows","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","premultipliedAlpha","overdraw","_needsUpdate","setValues","newValue","currentValue","isRoot","srcPlanes","dstPlanes","LineBasicMaterial","linewidth","linecap","linejoin","LineDashedMaterial","dashSize","gapSize","MeshBasicMaterial","refractionRatio","wireframeLinecap","wireframeLinejoin","skinning","MeshDepthMaterial","depthPacking","MeshLambertMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshStandardMaterial","STANDARD","envMapIntensity","MeshPhysicalMaterial","PHYSICAL","clearCoat","clearCoatRoughness","MultiMaterial","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","RawShaderMaterial","SpriteMaterial","ShadowMaterial","UniformsLib","ShaderChunk","encoding","TextureIdCount","sourceFile","DEFAULT_IMAGE","DEFAULT_MAPPING","premultiplyAlpha","flipY","unpackAlignment","getDataURL","canvas","toDataURL","getContext","drawImage","transformUv","DepthTexture","CanvasTexture","VideoTexture","video","readyState","HAVE_CURRENT_DATA","inverseMatrix","testPoint","rayPointDistanceSq","localThresholdSq","intersectPoint","distanceToRay","localThreshold","LineSegments","precisionSq","vStart","vEnd","interSegment","interRay","step","distSq","faceIndex","nbVertices","drawMode","updateMorphTargets","setDrawMode","morphTargetBase","morphTargetInfluences","morphTargetDictionary","ml","getMorphTargetIndexByName","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","uvA","uvB","uvC","tempA","tempB","tempC","fvA","fvB","fvC","isFaceMaterial","faceMaterial","morphInfluences","tl","influence","targets","uvs_f","Bone","skin","Skeleton","boneInverses","useVertexTexture","identityMatrix","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","pose","offsetMatrix","bindMode","bindMatrix","bindMatrixInverse","gbone","pos","rotq","scl","normalizeSkinWeights","sw","vec","skinWeight","getObjectForDistance","matrixPosition","guessSizeSq","LensFlare","lensFlares","positionScreen","customUpdateCallback","updateLensFlares","flare","vecX","vecY","wantedRotation","background","autoUpdate","Fog","FogExp2","density","merged","uniforms_src","uniforms_dst","parameter_src","common","diffuse","offsetRepeat","flipEnvMap","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","fogNear","fogFar","ambientLightColor","directionalLights","properties","shadowBias","shadowRadius","shadowMapSize","directionalShadowMap","directionalShadowMatrix","spotLights","coneCos","penumbraCos","spotShadowMap","spotShadowMatrix","pointLights","pointShadowMap","pointShadowMatrix","hemisphereLights","ShaderLib","basic","lambert","phong","standard","dashed","totalSize","cube","tCube","tFlip","equirect","tEquirect","distanceRGBA","lightPos","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","glClearColor","_premultipliedAlpha","setDefaultGLState","scissor","_currentScissor","_scissor","viewport","_currentViewport","_viewport","_clearColor","_clearAlpha","resetGLState","_currentProgram","_currentCamera","_currentGeometryProgram","_currentMaterialId","onContextLost","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReference","programInfo","program","programCache","releaseProgram","setupVertexAttributes","startIndex","extension","initAttributes","geometryAttributes","programAttributes","getAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","_gl","FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","getAttributeBuffer","enableAttributeAndDivisor","enableAttribute","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","disableUnusedAttributes","absNumericalSort","painterSortStable","reversePainterSortStable","pushRenderItem","transparentObjects","transparentObjectsLastIndex","opaqueObjects","opaqueObjectsLastIndex","renderItem","_vector3","isObjectViewable","_sphere","isSphereViewable","isSpriteViewable","_frustum","numPlanes","_clipping","_this","negRad","projectObject","sprites","ImmediateRenderObject","sortObjects","_projScreenMatrix","groupMaterial","renderObjects","renderList","setMaterial","setProgram","renderBufferImmediate","renderBufferDirect","initMaterial","materialProperties","getParameters","_lights","getProgramCode","programChange","shaderID","__webglShader","acquireProgram","numSupportedMorphTargets","maxMorphTargets","numSupportedMorphNormals","maxMorphNormals","numClippingPlanes","uniform","lightsHash","ambient","directional","spot","hemi","progUniforms","getUniforms","uniformsList","WebGLUniforms","seqWithValue","seq","dynamicUniforms","splitDynamic","CULL_FACE","setFlipSided","setBlending","setDepthFunc","setDepthTest","setDepthWrite","setColorWrite","setPolygonOffset","_usedTextureUnits","_clippingEnabled","_localClippingEnabled","useCache","setState","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","useProgram","capabilities","logarithmicDepthBuffer","uCamPos","cameraPosition","setOptional","floatVertexTextures","markUniformsLightsNeedsUpdate","refreshUniformsFog","refreshUniformsCommon","refreshUniformsLine","refreshUniformsDash","refreshUniformsPoints","refreshUniformsLambert","refreshUniformsPhong","refreshUniformsPhysical","refreshUniformsStandard","upload","dynUniforms","evalDynamic","uvScaleMap","_canvas","setupShadows","lightShadowsLength","shadows","setupLights","ll","shadowMap","viewMatrix","directionalLength","pointLength","spotLength","hemiLength","lightCache","allocTextureUnit","textureUnit","maxTextures","paramThreeToGL","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","HALF_FLOAT_OES","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","DEPTH_COMPONENT","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","SRC_ALPHA_SATURATE","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","MIN_EXT","MAX_EXT","_context","_alpha","_depth","_stencil","_antialias","_preserveDrawingBuffer","preserveDrawingBuffer","autoClearColor","autoClearDepth","autoClearStencil","localClippingEnabled","gammaInput","gammaOutput","physicallyCorrectLights","toneMapping","toneMappingExposure","toneMappingWhitePoint","_currentFramebuffer","_currentScissorTest","_width","_height","_scissorTest","WebGLClipping","_infoRender","calls","info","memory","programs","getShaderPrecisionFormat","rangeMin","rangeMax","WebGLExtensions","WebGLCapabilities","WebGLState","WebGLProperties","WebGLTextures","WebGLObjects","WebGLPrograms","WebGLLights","bufferRenderer","WebGLBufferRenderer","indexedBufferRenderer","WebGLIndexedBufferRenderer","backgroundCamera","backgroundCamera2","backgroundPlaneMesh","backgroundBoxShader","backgroundBoxMesh","BoxBufferGeometry","WebGLShadowMap","spritePlugin","SpritePlugin","lensFlarePlugin","LensFlarePlugin","getContextAttributes","forceContextLoss","loseContext","getMaxAnisotropy","getPrecision","getPixelRatio","updateStyle","setViewport","setScissor","setScissorTest","boolean","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearDepth","clearStencil","clearTarget","hasPositions","createBuffer","hasNormals","hasUvs","hasColors","bufferData","positionArray","DYNAMIC_DRAW","normalArray","nx","ny","nz","uvArray","colorArray","drawArrays","TRIANGLES","updateBuffers","geometryProgram","activeInfluences","getWireframeAttribute","ELEMENT_ARRAY_BUFFER","dataStart","dataCount","rangeStart","rangeCount","groupStart","groupCount","drawStart","drawEnd","drawCount","setLineWidth","setMode","LINES","TRIANGLE_STRIP","TRIANGLE_FAN","lineWidth","LINE_STRIP","POINTS","renderInstances","forceClear","beginShadows","endShadows","updateRenderTargetMipmap","setFaceCulling","cullFace","frontFaceDirection","setCullFace","setTexture2D","warned","slot","setTexture","setTextureCube","setTextureCubeDynamic","getCurrentRenderTarget","__webglFramebuffer","setupRenderTarget","framebuffer","isCube","renderTargetProperties","scissorTest","bindFramebuffer","FRAMEBUFFER","textureProperties","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE_CUBE_MAP_POSITIVE_X","__webglTexture","activeMipMapLevel","readRenderTargetPixels","restore","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","depthBuffer","depthTexture","drawArraysInstancedANGLE","resetGlobalState","globalState","numGlobalPlanes","projectPlanes","skipTransform","nPlanes","dstArray","flatSize","viewNormalMatrix","i4","renderingShadows","enableLocalClipping","fromCache","nGlobal","lGlobal","clippingState","drawElements","drawElementsInstancedANGLE","gl","getExtension","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getMaxPrecision","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","maxTextureSize","MAX_TEXTURE_SIZE","maxCubemapSize","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_ATTRIBS","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","_maxPrecision","WebGLGeometries","onGeometryDispose","buffergeometry","_bufferGeometry","deleteAttribute","deleteAttributes","property","bufferproperty","__webglBuffer","deleteBuffer","removeAttributeBuffer","updateAttribute","attributeProperties","updateBuffer","usage","STATIC_DRAW","bufferSubData","edges","checkEdge","list","WebGLProgram","getEncodingComponents","getTexelDecodingFunction","functionName","getTexelEncodingFunction","getToneMappingFunction","toneMappingName","generateExtensions","rendererExtensions","envMapCubeUV","flatShading","filterEmptyLine","generateDefines","fetchAttributeLocations","identifiers","getProgramParameter","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","replaceLightNums","numDirLights","numSpotLights","numPointLights","numHemiLights","parseIncludes","include","unrollLoops","snippet","unroll","programIdCount","shadowMapTypeDefine","shadowMapType","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","prefixVertex","prefixFragment","gammaFactorDefine","customExtensions","customDefines","createProgram","supportsVertexTextures","maxBones","doubleSided","flipSided","shadowMapEnabled","useFog","fogExp","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","vertexGlsl","fragmentGlsl","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","programLog","getProgramInfoLog","vertexLog","getShaderInfoLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","deleteShader","cachedUniforms","cachedAttributes","destroy","deleteProgram","usedTimes","allocateBones","nVertexUniforms","nVertexMatrices","getTextureEncodingFromMap","gammaOverrideLinear","shaderIDs","parameterNames","nClipPlanes","currentRenderTarget","envMapMode","pl","addLineNumbers","lines","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","_renderer","getDepthMaterial","isPointLight","lightPositionWorld","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","useSkinning","variantIndex","_MorphingFlag","_SkinningFlag","keyA","keyB","materialsForVariant","_materialCache","cachedMaterial","renderSingleSided","renderReverseSided","shadowCamera","_renderList","_state","_lightShadows","_shadowMapSize","_lookTarget","_lightPositionWorld","_NumberOfMaterialVariants","cubeDirections","cubeUps","cube2DViewPorts","depthMaterialTemplate","distanceShader","distanceUniforms","depthMaterial","distanceMaterial","USE_SHADOWMAP","BLEND","faceCount","vpWidth","vpHeight","shadowMatrix","vpDimensions","createTexture","bindTexture","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texImage2D","WebGLColorBuffer","WebGLDepthBuffer","WebGLStencilBuffer","maxVertexAttributes","newAttributes","enabledAttributes","attributeDivisors","compressedTextureFormats","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentFlipSided","currentCullFace","currentLineWidth","currentPolygonOffsetFactor","currentPolygonOffsetUnits","currentScissorTest","currentTextureSlot","currentBoundTextures","currentScissor","currentViewport","emptyTextures","TEXTURE_2D","TEXTURE_CUBE_MAP","DEPTH_TEST","enableVertexAttribArray","vertexAttribDivisorANGLE","disableVertexAttribArray","getCompressedTextureFormats","formats","COMPRESSED_TEXTURE_FORMATS","blendEquationSeparate","blendFuncSeparate","blendFunc","setStencilTest","stencilTest","setStencilWrite","stencilWrite","setStencilFunc","stencilRef","stencilMask","setStencilOp","stencilFail","stencilZFail","stencilZPass","frontFace","CW","CCW","BACK","FRONT","FRONT_AND_BACK","factor","units","POLYGON_OFFSET_FILL","getScissorTest","SCISSOR_TEST","activeTexture","webglSlot","TEXTURE0","webglType","webglTexture","boundTexture","compressedTexImage2D","locked","currentColorMask","currentColorClear","colorMask","lock","currentDepthMask","currentDepthFunc","currentDepthClear","depthMask","NEVER","LESS","LEQUAL","GEQUAL","GREATER","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","stencilOp","clampToMaxSize","maxSize","makePowerOfTwo","HTMLImageElement","HTMLCanvasElement","textureNeedsPowerOfTwo","filterFallback","onTextureDispose","deallocateTexture","_infoMemory","onRenderTargetDispose","deallocateRenderTarget","__image__webglTextureCube","deleteTexture","__webglInit","deleteFramebuffer","__webglDepthbuffer","deleteRenderbuffer","__version","complete","uploadTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","isCompressed","isDataTexture","cubeImage","isPowerOfTwoImage","glFormat","glType","setTextureParameters","mipmap","generateMipmap","textureType","TEXTURE_WRAP_S","TEXTURE_WRAP_T","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","internalFormat","_isWebGL2","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","setupFrameBufferTexture","attachment","textureTarget","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthTexture","webglDepthTexture","setupDepthRenderbuffer","createRenderbuffer","isTargetPowerOfTwo","createFramebuffer","WebGL2RenderingContext","emptyTexture","emptyCubeTexture","UniformContainer","arrayCacheF32","arrayCacheI32","flatten","nBlocks","blockSize","firstElem","allocTexUnits","setValue1f","uniform1f","addr","setValue1i","uniform1i","setValue2fv","uniform2fv","uniform2f","setValue3fv","uniform3f","uniform3fv","setValue4fv","uniform4fv","uniform4f","setValue2fm","uniformMatrix2fv","setValue3fm","uniformMatrix3fv","setValue4fm","uniformMatrix4fv","setValueT1","unit","setValueT6","setValue2iv","uniform2iv","setValue3iv","uniform3iv","setValue4iv","uniform4iv","getSingularSetter","setValue1fv","uniform1fv","setValue1iv","uniform1iv","setValueV2a","setValueV3a","setValueV4a","setValueM2a","setValueM3a","setValueM4a","setValueT1a","setValueT6a","getPureArraySetter","SingleUniform","activeInfo","PureArrayUniform","StructuredUniform","RePathPart","addUniform","container","uniformObject","parseUniform","pathLength","matchEnd","idIsIndex","subscript","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","flares","vertexBuffer","elementBuffer","tempTexture","occlusionTexture","renderType","occlusionMap","screenPosition","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","validArea","TEXTURE1","copyTexImage2D","uvOffset","fogType","fillStyle","fillRect","spritePosition","spriteRotation","spriteScale","oldFogType","sceneFogType","Face4","LineStrip","LinePieces","MeshFaceMaterial","Particle","ParticleSystem","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","Vertex","isIntersectionBox","isIntersectionSphere","multiplyVector3","multiplyVector3Array","extractPosition","multiplyVector4","rotateAxis","crossVector","rotateByAxis","isIntersectionLine","isIntersectionPlane","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","getChildByName","renderDepth","eulerOrder","useQuaternion","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraNear","shadowCameraFar","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","indexOffset","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","metal","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","shadowMapCullFace","audioLoader","getData","GeometryUtils","geometry1","ImageUtils","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","Projector","projectVector","unprojectVector","pickingRay","CanvasRenderer","CurveUtils","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","SceneUtils","createMultiMaterialObject","detach","attach","ShapeUtils","contour","triangulate","snip","verts","px","py","aX","aY","bX","bY","cX","cY","apx","apy","bpx","bpy","cpx","cpy","cCROSSap","bCROSScp","aCROSSbp","vertIndices","nv","triangulateShape","holes","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","shape","prevShapeIdx","nextShapeIdx","insideAngle","hole","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","sIdx","nextIdx","intersectsHoleEdge","ihIdx","chkHole","hIdx","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","counter","h2","allPointsMap","allpoints","shapeWithoutHoles","triangles","isClockWise","pts","b2p0","b2p1","b2p2","b3","b3p0","b3p1","b3p2","b3p3","Curve","getPointAt","getUtoTmapping","getPoints","divisions","getSpacedPoints","getLengths","cacheArcLengths","current","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","getTangentAt","getPointFunc","CurvePath","curves","autoClose","curve","closePath","startPoint","endPoint","LineCurve","curveLengths","getCurveLengths","lens","cacheLengths","sums","createPointsGeometry","createGeometry","createSpacedPointsGeometry","generateShapes","createPaths","String","ret","createPath","glyph","glyphs","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","Path","outline","_cachedOutline","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","shapes","toShapes","fromPoints","args","lastargs","aCPx","aCPy","QuadraticBezierCurve","aCP1x","aCP1y","aCP2x","aCP2y","CubicBezierCurve","splineThru","npts","SplineCurve","lastPoint","aRadius","aStartAngle","aEndAngle","aClockwise","absarc","absellipse","ellipse","xRadius","yRadius","aRotation","EllipseCurve","item","spts","spline","deltaAngle","tdivisions","isCCW","noHoles","extractSubpaths","inActions","subPaths","lastPath","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","Shape","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sLen","sho","ho","hole_unassigned","s2Idx","froms","tos","tmpHoles","extrude","ExtrudeGeometry","makeGeometry","ShapeGeometry","getPointsHoles","holesPts","extractAllPoints","extractPoints","tangent","point0","point1","point2","point3","ArcCurve","LineCurve3","QuadraticBezierCurve3","CubicBezierCurve3","SplineCurve3","CatmullRomCurve3","CubicPoly","pz","c0","initNonuniformCatmullRom","x3","dt0","dt1","dt2","initCatmullRom","tension","calc","closed","ClosedSplineCurve3","BoxGeometry","CubeGeometry","calculateVertexCount","calculateIndexCount","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","vertexBufferOffset","uvBufferOffset","numberOfVertices","indexBufferOffset","vertexCount","indexCount","CircleGeometry","CircleBufferGeometry","ii","segment","CylinderBufferGeometry","nbCap","generateTorso","tanTheta","indexRow","halfHeight","indexArray","i3","generateCap","centerIndexStart","centerIndexEnd","cosTheta","sinTheta","CylinderGeometry","ConeBufferGeometry","ConeGeometry","EdgesGeometry","thresholdAngle","sortFunction","thresholdDot","edge","vert1","vert2","face1","face2","addShapeList","addShape","scalePt2","getBevelVec","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","bevelEnabled","layer","vlen","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","extrudePts","splineTube","binormal","position2","amount","bevelThickness","bevelSize","curveSegments","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","frames","TubeGeometry","FrenetFrames","shapePoints","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","binormals","indexA","indexB","indexC","indexD","LatheBufferGeometry","base","inverseSegments","n1","n2","LatheGeometry","PlaneGeometry","width_half","height_half","segment_width","segment_height","offset2","RingBufferGeometry","radiusStep","thetaSegmentLevel","RingGeometry","SphereGeometry","SphereBufferGeometry","thetaEnd","verticesRow","v4","TextGeometry","TorusBufferGeometry","TorusKnotBufferGeometry","calculatePositionOnCurve","cu","su","quOverP","cs","P1","P2","TorusKnotGeometry","heightScale","NoTaper","ip","jp","uva","uvb","uvc","uvd","grid","numpoints","pos2","tangents","SinusoidalTaper","initialNormal3","smallest","MAX_VALUE","tz","mat","PolyhedronGeometry","prepare","that","azimuth","inclination","make","centroid","azi","correctUV","subdivide","cols","aj","bj","rows","DodecahedronGeometry","IcosahedronGeometry","OctahedronGeometry","TetrahedronGeometry","ParametricGeometry","slices","stacks","sliceCount","WireframeGeometry","numEdges","ol","numTris","AxisHelper","ArrowHelper","lineGeometry","coneGeometry","headLength","headWidth","cone","setDirection","setColor","BoxHelper","BoundingBoxHelper","CameraHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","setPoint","DirectionalLightHelper","lightPlane","targetLine","EdgesHelper","FaceNormalsHelper","nNormals","objGeometry","GridHelper","setColors","HemisphereLightHelper","sphereSize","lightSphere","PointLightHelper","SkeletonHelper","getBoneList","boneList","matrixWorldInv","boneMatrix","SpotLightHelper","vector2","coneLength","coneWidth","VertexNormalsHelper","objPos","objNorm","WireframeHelper","renderCallback","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","createAnimation","setAnimationWeight","lastFrame","currentFrame","active","directionBackwards","mirroredLoop","autoCreateAnimations","firstAnimation","frameRanges","morph","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","stopAnimation","keyframe"],"mappings":"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","file":"main.build.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\nvar config = require('./config');\r\nvar Stage = require('./modules/Stage');\r\n\r\nvar stage = new Stage();\r\nstage.init();\r\n\r\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\r\n\r\nvar config = require('./config');\r\nvar Stage = require('./modules/Stage');\r\n\r\nvar stage = new Stage();\r\nstage.init();\r\n\r\n\n},{\"./config\":2,\"./modules/Stage\":10}],2:[function(require,module,exports){\n'use strict';\r\n\r\nvar config = {};\r\n\r\nmodule.exports = config;\r\n\n},{}],3:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.BloomPass = function ( strength, kernelSize, sigma, resolution ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tstrength = ( strength !== undefined ) ? strength : 1;\r\n\tkernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;\r\n\tsigma = ( sigma !== undefined ) ? sigma : 4.0;\r\n\tresolution = ( resolution !== undefined ) ? resolution : 256;\r\n\r\n\t// render targets\r\n\r\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\r\n\r\n\tthis.renderTargetX = new THREE.WebGLRenderTarget( resolution, resolution, pars );\r\n\tthis.renderTargetY = new THREE.WebGLRenderTarget( resolution, resolution, pars );\r\n\r\n\t// copy material\r\n\r\n\tif ( THREE.CopyShader === undefined )\r\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.CopyShader\" );\r\n\r\n\tvar copyShader = THREE.CopyShader;\r\n\r\n\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\r\n\r\n\tthis.copyUniforms[ \"opacity\" ].value = strength;\r\n\r\n\tthis.materialCopy = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.copyUniforms,\r\n\t\tvertexShader: copyShader.vertexShader,\r\n\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\tblending: THREE.AdditiveBlending,\r\n\t\ttransparent: true\r\n\r\n\t} );\r\n\r\n\t// convolution material\r\n\r\n\tif ( THREE.ConvolutionShader === undefined )\r\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.ConvolutionShader\" );\r\n\r\n\tvar convolutionShader = THREE.ConvolutionShader;\r\n\r\n\tthis.convolutionUniforms = THREE.UniformsUtils.clone( convolutionShader.uniforms );\r\n\r\n\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurX;\r\n\tthis.convolutionUniforms[ \"cKernel\" ].value = THREE.ConvolutionShader.buildKernel( sigma );\r\n\r\n\tthis.materialConvolution = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.convolutionUniforms,\r\n\t\tvertexShader:  convolutionShader.vertexShader,\r\n\t\tfragmentShader: convolutionShader.fragmentShader,\r\n\t\tdefines: {\r\n\t\t\t\"KERNEL_SIZE_FLOAT\": kernelSize.toFixed( 1 ),\r\n\t\t\t\"KERNEL_SIZE_INT\": kernelSize.toFixed( 0 )\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.BloomPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.BloomPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 1)\r\n\r\n\t\tthis.quad.material = this.materialConvolution;\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurX;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetX, true );\r\n\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 2)\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = this.renderTargetX.texture;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurY;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetY, true );\r\n\r\n\t\t// Render original scene with superimposed blur to texture\r\n\r\n\t\tthis.quad.material = this.materialCopy;\r\n\r\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetY.texture;\r\n\r\n\t\tif ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );\r\n\r\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.BloomPass.blurX = new THREE.Vector2( 0.001953125, 0.0 );\r\nTHREE.BloomPass.blurY = new THREE.Vector2( 0.0, 0.001953125 );\n},{\"three\":16}],4:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.EffectComposer = function ( renderer, renderTarget ) {\r\n\r\n\tthis.renderer = renderer;\r\n\r\n\tif ( renderTarget === undefined ) {\r\n\r\n\t\tvar parameters = {\r\n\t\t\tminFilter: THREE.LinearFilter,\r\n\t\t\tmagFilter: THREE.LinearFilter,\r\n\t\t\tformat: THREE.RGBAFormat,\r\n\t\t\tstencilBuffer: false\r\n\t\t};\r\n\t\tvar size = renderer.getSize();\r\n\t\trenderTarget = new THREE.WebGLRenderTarget( size.width, size.height, parameters );\r\n\r\n\t}\r\n\r\n\tthis.renderTarget1 = renderTarget;\r\n\tthis.renderTarget2 = renderTarget.clone();\r\n\r\n\tthis.writeBuffer = this.renderTarget1;\r\n\tthis.readBuffer = this.renderTarget2;\r\n\r\n\tthis.passes = [];\r\n\r\n\tif ( THREE.CopyShader === undefined )\r\n\t\tconsole.error( \"THREE.EffectComposer relies on THREE.CopyShader\" );\r\n\r\n\tthis.copyPass = new THREE.ShaderPass( THREE.CopyShader );\r\n\r\n};\r\n\r\nObject.assign( THREE.EffectComposer.prototype, {\r\n\r\n\tswapBuffers: function() {\r\n\r\n\t\tvar tmp = this.readBuffer;\r\n\t\tthis.readBuffer = this.writeBuffer;\r\n\t\tthis.writeBuffer = tmp;\r\n\r\n\t},\r\n\r\n\taddPass: function ( pass ) {\r\n\r\n\t\tthis.passes.push( pass );\r\n\r\n\t\tvar size = this.renderer.getSize();\r\n\t\tpass.setSize( size.width, size.height );\r\n\r\n\t},\r\n\r\n\tinsertPass: function ( pass, index ) {\r\n\r\n\t\tthis.passes.splice( index, 0, pass );\r\n\r\n\t},\r\n\r\n\trender: function ( delta ) {\r\n\r\n\t\tvar maskActive = false;\r\n\r\n\t\tvar pass, i, il = this.passes.length;\r\n\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tpass = this.passes[ i ];\r\n\r\n\t\t\tif ( pass.enabled === false ) continue;\r\n\r\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );\r\n\r\n\t\t\tif ( pass.needsSwap ) {\r\n\r\n\t\t\t\tif ( maskActive ) {\r\n\r\n\t\t\t\t\tvar context = this.renderer.context;\r\n\r\n\t\t\t\t\tcontext.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );\r\n\r\n\t\t\t\t\tcontext.stencilFunc( context.EQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.swapBuffers();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( THREE.MaskPass !== undefined ) {\r\n\r\n\t\t\t\tif ( pass instanceof THREE.MaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = true;\r\n\r\n\t\t\t\t} else if ( pass instanceof THREE.ClearMaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\treset: function ( renderTarget ) {\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\tvar size = this.renderer.getSize();\r\n\r\n\t\t\trenderTarget = this.renderTarget1.clone();\r\n\t\t\trenderTarget.setSize( size.width, size.height );\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTarget1.dispose();\r\n\t\tthis.renderTarget2.dispose();\r\n\t\tthis.renderTarget1 = renderTarget;\r\n\t\tthis.renderTarget2 = renderTarget.clone();\r\n\r\n\t\tthis.writeBuffer = this.renderTarget1;\r\n\t\tthis.readBuffer = this.renderTarget2;\r\n\r\n\t},\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tthis.renderTarget1.setSize( width, height );\r\n\t\tthis.renderTarget2.setSize( width, height );\r\n\r\n\t\tfor ( var i = 0; i < this.passes.length; i ++ ) {\r\n\r\n\t\t\tthis.passes[i].setSize( width, height );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\nTHREE.Pass = function () {\r\n\r\n\t// if set to true, the pass is processed by the composer\r\n\tthis.enabled = true;\r\n\r\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\r\n\tthis.needsSwap = true;\r\n\r\n\t// if set to true, the pass clears its buffer before rendering\r\n\tthis.clear = false;\r\n\r\n\t// if set to true, the result of the pass is rendered to screen\r\n\tthis.renderToScreen = false;\r\n\r\n};\r\n\r\nObject.assign( THREE.Pass.prototype, {\r\n\r\n\tsetSize: function( width, height ) {},\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tconsole.error( \"THREE.Pass: .render() must be implemented in derived pass.\" );\r\n\r\n\t}\r\n\r\n} );\n},{\"three\":16}],5:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tif ( THREE.FilmShader === undefined )\r\n\t\tconsole.error( \"THREE.FilmPass relies on THREE.FilmShader\" );\r\n\r\n\tvar shader = THREE.FilmShader;\r\n\r\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\tthis.material = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.uniforms,\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t} );\r\n\r\n\tif ( grayscale !== undefined )\tthis.uniforms.grayscale.value = grayscale;\r\n\tif ( noiseIntensity !== undefined ) this.uniforms.nIntensity.value = noiseIntensity;\r\n\tif ( scanlinesIntensity !== undefined ) this.uniforms.sIntensity.value = scanlinesIntensity;\r\n\tif ( scanlinesCount !== undefined ) this.uniforms.sCount.value = scanlinesCount;\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.FilmPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.FilmPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.uniforms[ \"time\" ].value += delta;\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n},{\"three\":16}],6:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MaskPass = function ( scene, camera ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.clear = true;\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.inverse = false;\r\n\r\n};\r\n\r\nTHREE.MaskPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.MaskPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tvar context = renderer.context;\r\n\t\tvar state = renderer.state;\r\n\r\n\t\t// don't update color or depth\r\n\r\n\t\tstate.buffers.color.setMask( false );\r\n\t\tstate.buffers.depth.setMask( false );\r\n\r\n\t\t// lock buffers\r\n\r\n\t\tstate.buffers.color.setLocked( true );\r\n\t\tstate.buffers.depth.setLocked( true );\r\n\r\n\t\t// set up stencil\r\n\r\n\t\tvar writeValue, clearValue;\r\n\r\n\t\tif ( this.inverse ) {\r\n\r\n\t\t\twriteValue = 0;\r\n\t\t\tclearValue = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\twriteValue = 1;\r\n\t\t\tclearValue = 0;\r\n\r\n\t\t}\r\n\r\n\t\tstate.buffers.stencil.setTest( true );\r\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\r\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\r\n\t\tstate.buffers.stencil.setClear( clearValue );\r\n\r\n\t\t// draw into the stencil buffer\r\n\r\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\r\n\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t// unlock color and depth buffer for subsequent rendering\r\n\r\n\t\tstate.buffers.color.setLocked( false );\r\n\t\tstate.buffers.depth.setLocked( false );\r\n\r\n\t\t// only render where stencil is set to 1\r\n\r\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1\r\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\nTHREE.ClearMaskPass = function () {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n};\r\n\r\nTHREE.ClearMaskPass.prototype = Object.create( THREE.Pass.prototype );\r\n\r\nObject.assign( THREE.ClearMaskPass.prototype, {\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\trenderer.state.buffers.stencil.setTest( false );\r\n\r\n\t}\r\n\r\n} );\n},{\"three\":16}],7:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n/*global THREE, console */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\r\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\r\n// supported.\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\r\n//\r\n// This is a drop-in replacement for (most) TrackballControls used in examples.\r\n// That is, include this js file and wherever you see:\r\n//    \tcontrols = new THREE.TrackballControls( camera );\r\n//      controls.target.z = 150;\r\n// Simple substitute \"OrbitControls\" and the control should work as-is.\r\n\r\nTHREE.OrbitControls = function ( object, domElement ) {\r\n\r\n    this.object = object;\r\n    this.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n    // API\r\n\r\n    // Set to false to disable this control\r\n    this.enabled = true;\r\n\r\n    // \"target\" sets the location of focus, where the control orbits around\r\n    // and where it pans with respect to.\r\n    this.target = new THREE.Vector3();\r\n    // center is old, deprecated; use \"target\" instead\r\n    this.center = this.target;\r\n\r\n    // This option actually enables dollying in and out; left as \"zoom\" for\r\n    // backwards compatibility\r\n    this.noZoom = false;\r\n    this.zoomSpeed = 1.0;\r\n    // Limits to how far you can dolly in and out\r\n    this.minDistance = 0;\r\n    this.maxDistance = Infinity;\r\n\r\n    // Set to true to disable this control\r\n    this.noRotate = false;\r\n    this.rotateSpeed = 1.0;\r\n\r\n    // Set to true to disable this control\r\n    this.noPan = false;\r\n    this.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n    // Set to true to automatically rotate around the target\r\n    this.autoRotate = false;\r\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n    // How far you can orbit vertically, upper and lower limits.\r\n    // Range is 0 to Math.PI radians.\r\n    this.minPolarAngle = 0; // radians\r\n    this.maxPolarAngle = Math.PI; // radians\r\n\r\n    // Set to true to disable use of the keys\r\n    this.noKeys = false;\r\n    // The four arrow keys\r\n    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n    ////////////\r\n    // internals\r\n\r\n    var scope = this;\r\n\r\n    var EPS = 0.000001;\r\n\r\n    var rotateStart = new THREE.Vector2();\r\n    var rotateEnd = new THREE.Vector2();\r\n    var rotateDelta = new THREE.Vector2();\r\n\r\n    var panStart = new THREE.Vector2();\r\n    var panEnd = new THREE.Vector2();\r\n    var panDelta = new THREE.Vector2();\r\n\r\n    var dollyStart = new THREE.Vector2();\r\n    var dollyEnd = new THREE.Vector2();\r\n    var dollyDelta = new THREE.Vector2();\r\n\r\n    var phiDelta = 0;\r\n    var thetaDelta = 0;\r\n    var scale = 1;\r\n    var pan = new THREE.Vector3();\r\n\r\n    var lastPosition = new THREE.Vector3();\r\n\r\n    var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\r\n    var state = STATE.NONE;\r\n\r\n    // events\r\n\r\n    var changeEvent = { type: 'change' };\r\n\r\n\r\n    this.rotateLeft = function ( angle ) {\r\n\r\n        if ( angle === undefined ) {\r\n\r\n            angle = getAutoRotationAngle();\r\n\r\n        }\r\n\r\n        thetaDelta -= angle;\r\n\r\n    };\r\n\r\n    this.rotateUp = function ( angle ) {\r\n\r\n        if ( angle === undefined ) {\r\n\r\n            angle = getAutoRotationAngle();\r\n\r\n        }\r\n\r\n        phiDelta -= angle;\r\n\r\n    };\r\n\r\n    // pass in distance in world space to move left\r\n    this.panLeft = function ( distance ) {\r\n\r\n        var panOffset = new THREE.Vector3();\r\n        var te = this.object.matrix.elements;\r\n        // get X column of matrix\r\n        panOffset.set( te[0], te[1], te[2] );\r\n        panOffset.multiplyScalar(-distance);\r\n\r\n        pan.add( panOffset );\r\n\r\n    };\r\n\r\n    // pass in distance in world space to move up\r\n    this.panUp = function ( distance ) {\r\n\r\n        var panOffset = new THREE.Vector3();\r\n        var te = this.object.matrix.elements;\r\n        // get Y column of matrix\r\n        panOffset.set( te[4], te[5], te[6] );\r\n        panOffset.multiplyScalar(distance);\r\n\r\n        pan.add( panOffset );\r\n    };\r\n\r\n    // main entry point; pass in Vector2 of change desired in pixel space,\r\n    // right and down are positive\r\n    this.pan = function ( delta ) {\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        if ( scope.object.fov !== undefined ) {\r\n\r\n            // perspective\r\n            var position = scope.object.position;\r\n            var offset = position.clone().sub( scope.target );\r\n            var targetDistance = offset.length();\r\n\r\n            // half of the fov is center to top of screen\r\n            targetDistance *= Math.tan( (scope.object.fov/2) * Math.PI / 180.0 );\r\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n            scope.panLeft( 2 * delta.x * targetDistance / element.clientHeight );\r\n            scope.panUp( 2 * delta.y * targetDistance / element.clientHeight );\r\n\r\n        } else if ( scope.object.top !== undefined ) {\r\n\r\n            // orthographic\r\n            scope.panLeft( delta.x * (scope.object.right - scope.object.left) / element.clientWidth );\r\n            scope.panUp( delta.y * (scope.object.top - scope.object.bottom) / element.clientHeight );\r\n\r\n        } else {\r\n\r\n            // camera neither orthographic or perspective - warn user\r\n            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n\r\n        }\r\n\r\n    };\r\n\r\n    this.dollyIn = function ( dollyScale ) {\r\n\r\n        if ( dollyScale === undefined ) {\r\n\r\n            dollyScale = getZoomScale();\r\n\r\n        }\r\n\r\n        scale /= dollyScale;\r\n\r\n    };\r\n\r\n    this.dollyOut = function ( dollyScale ) {\r\n\r\n        if ( dollyScale === undefined ) {\r\n\r\n            dollyScale = getZoomScale();\r\n\r\n        }\r\n\r\n        scale *= dollyScale;\r\n\r\n    };\r\n\r\n    this.update = function () {\r\n\r\n        var position = this.object.position;\r\n        var offset = position.clone().sub( this.target );\r\n\r\n        // angle from z-axis around y-axis\r\n\r\n        var theta = Math.atan2( offset.x, offset.z );\r\n\r\n        // angle from y-axis\r\n\r\n        var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\r\n\r\n        if ( this.autoRotate ) {\r\n\r\n            this.rotateLeft( getAutoRotationAngle() );\r\n\r\n        }\r\n\r\n        theta += thetaDelta;\r\n        phi += phiDelta;\r\n\r\n        // restrict phi to be between desired limits\r\n        phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\r\n\r\n        // restrict phi to be betwee EPS and PI-EPS\r\n        phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\r\n\r\n        var radius = offset.length() * scale;\r\n\r\n        // restrict radius to be between desired limits\r\n        radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\r\n\r\n        // move target to panned location\r\n        this.target.add( pan );\r\n\r\n        offset.x = radius * Math.sin( phi ) * Math.sin( theta );\r\n        offset.y = radius * Math.cos( phi );\r\n        offset.z = radius * Math.sin( phi ) * Math.cos( theta );\r\n\r\n        position.copy( this.target ).add( offset );\r\n\r\n        this.object.lookAt( this.target );\r\n\r\n        thetaDelta = 0;\r\n        phiDelta = 0;\r\n        scale = 1;\r\n        pan.set(0,0,0);\r\n\r\n        if ( lastPosition.distanceTo( this.object.position ) > 0 ) {\r\n\r\n            this.dispatchEvent( changeEvent );\r\n\r\n            lastPosition.copy( this.object.position );\r\n\r\n        }\r\n\r\n    };\r\n\r\n\r\n    function getAutoRotationAngle() {\r\n\r\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n    }\r\n\r\n    function getZoomScale() {\r\n\r\n        return Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n    }\r\n\r\n    function onMouseDown( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n        event.preventDefault();\r\n\r\n        if ( event.button === 0 ) {\r\n            if ( scope.noRotate === true ) { return; }\r\n\r\n            state = STATE.ROTATE;\r\n\r\n            rotateStart.set( event.clientX, event.clientY );\r\n\r\n        } else if ( event.button === 1 ) {\r\n            if ( scope.noZoom === true ) { return; }\r\n\r\n            state = STATE.DOLLY;\r\n\r\n            dollyStart.set( event.clientX, event.clientY );\r\n\r\n        } else if ( event.button === 2 ) {\r\n            if ( scope.noPan === true ) { return; }\r\n\r\n            state = STATE.PAN;\r\n\r\n            panStart.set( event.clientX, event.clientY );\r\n\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.domElement.addEventListener( 'mousemove', onMouseMove, false );\r\n        scope.domElement.addEventListener( 'mouseup', onMouseUp, false );\r\n\r\n    }\r\n\r\n    function onMouseMove( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        if ( state === STATE.ROTATE ) {\r\n\r\n            if ( scope.noRotate === true ) return;\r\n\r\n            rotateEnd.set( event.clientX, event.clientY );\r\n            rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n            // rotating across whole screen goes 360 degrees around\r\n            scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n            scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n            rotateStart.copy( rotateEnd );\r\n\r\n        } else if ( state === STATE.DOLLY ) {\r\n\r\n            if ( scope.noZoom === true ) return;\r\n\r\n            dollyEnd.set( event.clientX, event.clientY );\r\n            dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n            if ( dollyDelta.y > 0 ) {\r\n\r\n                scope.dollyIn();\r\n\r\n            } else {\r\n\r\n                scope.dollyOut();\r\n\r\n            }\r\n\r\n            dollyStart.copy( dollyEnd );\r\n\r\n        } else if ( state === STATE.PAN ) {\r\n\r\n            if ( scope.noPan === true ) return;\r\n\r\n            panEnd.set( event.clientX, event.clientY );\r\n            panDelta.subVectors( panEnd, panStart );\r\n\r\n            scope.pan( panDelta );\r\n\r\n            panStart.copy( panEnd );\r\n\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function onMouseUp( /* event */ ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.domElement.removeEventListener( 'mousemove', onMouseMove, false );\r\n        scope.domElement.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n        state = STATE.NONE;\r\n\r\n    }\r\n\r\n    function onMouseWheel( event ) {\r\n\r\n        if ( scope.enabled === false || scope.noZoom === true ) return;\r\n\r\n        var delta = 0;\r\n\r\n        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\r\n\r\n            delta = event.wheelDelta;\r\n\r\n        } else if ( event.detail ) { // Firefox\r\n\r\n            delta = - event.detail;\r\n\r\n        }\r\n\r\n        if ( delta > 0 ) {\r\n\r\n            scope.dollyOut();\r\n\r\n        } else {\r\n\r\n            scope.dollyIn();\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onKeyDown( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n        if ( scope.noKeys === true ) { return; }\r\n        if ( scope.noPan === true ) { return; }\r\n\r\n        // pan a pixel - I guess for precise positioning?\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        var needUpdate = false;\r\n\r\n        switch ( event.keyCode ) {\r\n\r\n            case scope.keys.UP:\r\n                scope.pan( new THREE.Vector2( 0, scope.keyPanSpeed ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.BOTTOM:\r\n                scope.pan( new THREE.Vector2( 0, -scope.keyPanSpeed ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.LEFT:\r\n                scope.pan( new THREE.Vector2( scope.keyPanSpeed, 0 ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.RIGHT:\r\n                scope.pan( new THREE.Vector2( -scope.keyPanSpeed, 0 ) );\r\n                needUpdate = true;\r\n                break;\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        if ( needUpdate ) {\r\n\r\n            scope.update();\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function touchstart( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1:\t// one-fingered touch: rotate\r\n                if ( scope.noRotate === true ) { return; }\r\n\r\n                state = STATE.TOUCH_ROTATE;\r\n\r\n                rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                break;\r\n\r\n            case 2:\t// two-fingered touch: dolly\r\n                if ( scope.noZoom === true ) { return; }\r\n\r\n                state = STATE.TOUCH_DOLLY;\r\n\r\n                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n                var distance = Math.sqrt( dx * dx + dy * dy );\r\n                dollyStart.set( 0, distance );\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n                if ( scope.noPan === true ) { return; }\r\n\r\n                state = STATE.TOUCH_PAN;\r\n\r\n                panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                break;\r\n\r\n            default:\r\n                state = STATE.NONE;\r\n\r\n        }\r\n    }\r\n\r\n    function touchmove( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1: // one-fingered touch: rotate\r\n                if ( scope.noRotate === true ) { return; }\r\n                if ( state !== STATE.TOUCH_ROTATE ) { return; }\r\n\r\n                rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n                // rotating across whole screen goes 360 degrees around\r\n                scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n                scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n                rotateStart.copy( rotateEnd );\r\n                break;\r\n\r\n            case 2: // two-fingered touch: dolly\r\n                if ( scope.noZoom === true ) { return; }\r\n                if ( state !== STATE.TOUCH_DOLLY ) { return; }\r\n\r\n                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n                var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n                dollyEnd.set( 0, distance );\r\n                dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n                if ( dollyDelta.y > 0 ) {\r\n\r\n                    scope.dollyOut();\r\n\r\n                } else {\r\n\r\n                    scope.dollyIn();\r\n\r\n                }\r\n\r\n                dollyStart.copy( dollyEnd );\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n                if ( scope.noPan === true ) { return; }\r\n                if ( state !== STATE.TOUCH_PAN ) { return; }\r\n\r\n                panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                panDelta.subVectors( panEnd, panStart );\r\n\r\n                scope.pan( panDelta );\r\n\r\n                panStart.copy( panEnd );\r\n                break;\r\n\r\n            default:\r\n                state = STATE.NONE;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function touchend( /* event */ ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        state = STATE.NONE;\r\n    }\r\n\r\n    this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\r\n    this.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n    this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\r\n    this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\r\n\r\n    this.domElement.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n    this.domElement.addEventListener( 'touchstart', touchstart, false );\r\n    this.domElement.addEventListener( 'touchend', touchend, false );\r\n    this.domElement.addEventListener( 'touchmove', touchmove, false );\r\n\r\n};\r\n\r\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n},{\"three\":16}],8:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.overrideMaterial = overrideMaterial;\r\n\r\n\tthis.clearColor = clearColor;\r\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\r\n\r\n\tthis.clear = true;\r\n\tthis.needsSwap = false;\r\n\r\n};\r\n\r\nTHREE.RenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.RenderPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.scene.overrideMaterial = this.overrideMaterial;\r\n\r\n\t\tvar oldClearColor, oldClearAlpha;\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\toldClearColor = renderer.getClearColor().getHex();\r\n\t\t\toldClearAlpha = renderer.getClearAlpha();\r\n\r\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\r\n\r\n\t\t}\r\n\r\n\t\tthis.scene.overrideMaterial = null;\r\n\r\n\t}\r\n\r\n} );\n},{\"three\":16}],9:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ShaderPass = function ( shader, textureID ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.textureID = ( textureID !== undefined ) ? textureID : \"tDiffuse\";\r\n\r\n\tif ( shader instanceof THREE.ShaderMaterial ) {\r\n\r\n\t\tthis.uniforms = shader.uniforms;\r\n\r\n\t\tthis.material = shader;\r\n\r\n\t} else if ( shader ) {\r\n\r\n\t\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\tthis.material = new THREE.ShaderMaterial( {\r\n\r\n\t\t\tdefines: shader.defines || {},\r\n\t\t\tuniforms: this.uniforms,\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.ShaderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.ShaderPass,\r\n\r\n\trender: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( this.uniforms[ this.textureID ] ) {\r\n\r\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\r\n\r\n\t\t}\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n},{\"three\":16}],10:[function(require,module,exports){\n'use strict';\r\n\r\nvar uniforms;\r\n\r\nvar THREE = require('three');\r\nvar TweemMax = require('../vendor/TweenMax.min.js');\r\n\r\nvar OrbitControls = require('../libs/OrbitControls.js');\r\n\r\nvar CopyShader = require('../shaders/CopyShader.js');\r\nvar FilmShader = require('../shaders/FilmShader.js');\r\nvar ConvolutionShader = require('../shaders/ConvolutionShader.js');\r\nvar BadTv = require('../shaders/BadTv.js');\r\n\r\nvar EffectComposer = require('../libs/EffectComposer.js');\r\nvar RenderPass = require('../libs/RenderPass.js');\r\nvar FilmPass = require('../libs/FilmPass.js');\r\nvar BloomPass = require('../libs/BloomPass.js');\r\nvar MaskPass = require('../libs/MaskPass.js');\r\nvar ShaderPass = require('../libs/ShaderPass.js');\r\n\r\nvar Stage = function() {\r\n  \r\n  this.renderer = new THREE.WebGLRenderer({alpha: true});\r\n  this.renderer.setPixelRatio(window.devicePixelRatio);\r\n  this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n\r\n  this.camera = new THREE.PerspectiveCamera(35, ((window.innerWidth / 2) / (window.innerHeight / 2)), 1, 3000);\r\n  this.camera.position.z = 4;\r\n\r\n  this.scene = new THREE.Scene();\r\n\r\n  this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);\r\n  this.controls.autoRotate = true;\r\n\r\n};\r\n\r\nStage.prototype.init = function() {\r\n\r\n  this.getAudio();\r\n  this.getParticles();\r\n\r\n  requestAnimationFrame(this.animate.bind(this));\r\n\r\n  // on resize\r\n  window.addEventListener('resize', this._onResize.bind(this));\r\n\r\n  TweenMax.to(document.querySelector('.bg'), 2000, {\r\n    rotation: -1080,\r\n    yoyo: true,\r\n    repeat: -1,\r\n    ease: Power1.easeOut\r\n  });\r\n\r\n  this.renderModel = new THREE.RenderPass( this.scene, this.camera );\r\n  this.effectBloom = new THREE.BloomPass( 1.25 );\r\n  this.effectFilm = new THREE.FilmPass( 0.35, 0.95, 2048, false );\r\n\r\n  this.effectFilm.renderToScreen = true;\r\n\r\n  this.composer = new THREE.EffectComposer( this.renderer );\r\n\r\n  this.composer.addPass(this.renderModel);\r\n  this.composer.addPass(this.effectBloom);\r\n  this.composer.addPass(this.effectFilm);\r\n\r\n  this.badTVEffect = new THREE.ShaderPass(THREE.BadTVShader);\r\n  this.badTVEffect.uniforms['speed'].value = 10;\r\n  this.badTVEffect.uniforms['rollSpeed'].value = 20;\r\n  this.composer.addPass(this.badTVEffect);\r\n\r\n  this.clock = new THREE.Clock();\r\n\r\n  uniforms = {\r\n\r\n    fogDensity: {value: 0.1},\r\n    fogColor:   {value: new THREE.Vector3(0, 0, 0)},\r\n    time:       {value: 1.0},\r\n    resolution: {value: new THREE.Vector2()},\r\n    uvScale:    {value: new THREE.Vector2( 3.0, 1.0)},\r\n    texture1:   {value: new THREE.TextureLoader().load(\"images/cloud.png\")},\r\n    texture2:   {value: new THREE.TextureLoader().load(\"images/lavatile.jpg\")}\r\n\r\n  };\r\n\r\n  uniforms.texture1.value.wrapS = uniforms.texture1.value.wrapT = THREE.RepeatWrapping;\r\n  uniforms.texture2.value.wrapS = uniforms.texture2.value.wrapT = THREE.RepeatWrapping;\r\n\r\n  var size = 0.65;\r\n\r\n  this.visualMaterial = new THREE.ShaderMaterial( {\r\n\r\n    uniforms: uniforms,\r\n    vertexShader: document.getElementById('vertexShader').textContent,\r\n    fragmentShader: document.getElementById('fragmentShader').textContent\r\n\r\n  } );\r\n\r\n  this.visualMesh = new THREE.Mesh( new THREE.TorusGeometry(size, 0.3, 30, 30), this.visualMaterial);\r\n  this.visualMesh.rotation.x = 0.3;\r\n  this.scene.add(this.visualMesh);\r\n\r\n  this.renderer = new THREE.WebGLRenderer({antialias: true});\r\n  this.renderer.setPixelRatio(window.devicePixelRatio);\r\n  document.body.appendChild(this.renderer.domElement);\r\n  this.renderer.autoClear = false;\r\n\r\n  this._onResize();\r\n};\r\n\r\nStage.prototype.animate = function() {\r\n  requestAnimationFrame(this.animate.bind(this));\r\n  var time = Date.now();\r\n\r\n  this.update(time);\r\n\r\n  this.renderer.render(this.scene, this.camera);\r\n\r\n};\r\n\r\nStage.prototype.update = function(time) {\r\n  var diff = time - this.lastTime;\r\n  this.lastTime = time;\r\n\r\n  if (!this.lastTime) {\r\n    this.lastTime = time;\r\n    \r\n    return;\r\n  }  \r\n\r\n  var delta = 5 * this.clock.getDelta();\r\n\r\n  this.visualMesh.rotation.y += 0.0125 * delta;\r\n  this.visualMesh.rotation.x += 0.05 * delta;\r\n\r\n  this.particleSystem.rotation.y += 0.01 * delta;\r\n  \r\n  this.renderer.clear();\r\n  this.composer.render(0.1);\r\n\r\n  this.controls.update()\r\n\r\n  this.updateVisual();\r\n\r\n};\r\n\r\nStage.prototype.updateVisual = function() {\r\n  var array = new Uint8Array(this.analyser.frequencyBinCount);\r\n  var frequencyArray = new Float32Array(this.analyser.frequencyBinCount);\r\n\r\n  var frequencyData = new Uint8Array(this.barsAnalyser.frequencyBinCount);\r\n  \r\n  this.analyser.getByteFrequencyData(array);\r\n  this.analyser.getFloatFrequencyData(frequencyArray);\r\n  \r\n  var average = this._getAverageVolume(array);\r\n  var frequencyAverage = this._getAverageVolume(frequencyArray);\r\n  var frequencyDataArray = this._getAverageVolume(frequencyData);\r\n\r\n  this.visualMaterial.uniforms['fogDensity'].value = frequencyAverage / 200;\r\n  this.visualMaterial.uniforms['time'].value = average / 50;\r\n\r\n  this.barsArray.forEach(function(bar, index) {\r\n    bar.style.height = Math.abs(frequencyArray[index]) + 'px';\r\n  });\r\n\r\n  this.particleSystem.scale.y = average / 5000;\r\n\r\n};\r\n\r\nStage.prototype.soundBars = function() {\r\n\r\n  this.soundBars = document.querySelector('#soundBars');\r\n\r\n  this.barsArray = [];\r\n\r\n  var barSpacingPercent = this.barsAnalyser.frequencyBinCount / 100;\r\n  \r\n  for (var i = 0; i < this.barsAnalyser.frequencyBinCount; i++) {\r\n\r\n    this.newBars = document.createElement('div');\r\n    this.soundBars.appendChild(this.newBars);\r\n    this.barsArray.push(this.newBars);\r\n\r\n  };\r\n\r\n};\r\n\r\nStage.prototype.getAudio = function() {\r\n  var context = new AudioContext();\r\n  this.analyser = context.createAnalyser();\r\n  this.analyser.smoothingTimeConstant = 0.4;\r\n  this.analyser.fftSize = 1024;\r\n\r\n  this.analyser2 = context.createAnalyser();\r\n  this.analyser2.smoothingTimeConstant = 0.4;\r\n  this.analyser2.fftSize = 1024;\r\n\r\n  this.barsAnalyser = context.createAnalyser();\r\n  this.barsAnalyser.fftSize = 64;\r\n\r\n  var sourceNode = context.createBufferSource();\r\n  var splitter = context.createChannelSplitter();\r\n\r\n  sourceNode.connect(splitter);\r\n\r\n  splitter.connect(this.analyser, 0);\r\n  splitter.connect(this.analyser2, 1);\r\n\r\n  sourceNode.connect(context.destination);\r\n\r\n  var request = new XMLHttpRequest();\r\n  request.open('GET', 'audio/sasha.mp3', true);\r\n  request.responseType = 'arraybuffer';\r\n\r\n  var songBuffer;\r\n  \r\n  request.onload = function() {\r\n    context.decodeAudioData(request.response, function(buffer) {\r\n      songBuffer = buffer;\r\n\r\n      var dur = buffer.duration;\r\n\r\n      sourceNode.buffer = buffer;\r\n      sourceNode.start(0);\r\n      sourceNode.loop = true;\r\n\r\n    }, this._onError);\r\n  }.bind(this);\r\n\r\n  request.send();\r\n\r\n  this.soundBars();\r\n};\r\n\r\nStage.prototype.getParticles = function() {\r\n\r\n  this.count = 600;\r\n  this.particles = new THREE.Geometry();\r\n  var pMaterial = new THREE.PointsMaterial({\r\n    color: 0xf1f1f1,\r\n    size: 1,\r\n    map: new THREE.TextureLoader().load('images/eye.png'),\r\n    transparent: true,\r\n    opacity: 0.85\r\n  });\r\n\r\n  window.material = pMaterial;\r\n\r\n  for (var p = 0; p < this.count; p++) {\r\n\r\n    var pX = Math.random() * 100 - 50;\r\n    var pY = Math.random() * 100 - 50;\r\n    var pZ = Math.random() * 100 - 50;\r\n    this.particle = new THREE.Vector3(pX, pY, pZ);\r\n    this.particle.velocity = new THREE.Vector3(0, -Math.random(), 0);  \r\n\r\n    this.particles.vertices.push(this.particle);\r\n\r\n  }\r\n\r\n  this.particleSystem = new THREE.Points(this.particles, pMaterial);\r\n  this.particleSystem.sortParticles = true;\r\n\r\n  this.scene.add(this.particleSystem);\r\n\r\n\r\n};\r\n\r\nStage.prototype._getAverageVolume = function(array) {\r\n  var values = 0;\r\n  var average;\r\n  var length = array.length;\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    values += array[i];\r\n  }\r\n\r\n  average = values / length;\r\n\r\n  return average;\r\n};\r\n\r\nStage.prototype._onResize = function() {\r\n  this.camera.aspect = window.innerWidth / window.innerHeight;\r\n  this.camera.updateProjectionMatrix();\r\n  \r\n  this.renderer.setSize( window.innerWidth, window.innerHeight );\r\n  \r\n  this.composer.setSize( window.innerWidth, window.innerHeight );\r\n  this.composer.reset();\r\n\r\n  uniforms.resolution.value.x = window.innerWidth;\r\n  uniforms.resolution.value.y = window.innerHeight;\r\n};\r\n\r\nStage.prototype._onError = function(e) {\r\n  console.log(e);\r\n};\r\n\r\nmodule.exports = Stage;\n},{\"../libs/BloomPass.js\":3,\"../libs/EffectComposer.js\":4,\"../libs/FilmPass.js\":5,\"../libs/MaskPass.js\":6,\"../libs/OrbitControls.js\":7,\"../libs/RenderPass.js\":8,\"../libs/ShaderPass.js\":9,\"../shaders/BadTv.js\":11,\"../shaders/ConvolutionShader.js\":12,\"../shaders/CopyShader.js\":13,\"../shaders/FilmShader.js\":14,\"../vendor/TweenMax.min.js\":15,\"three\":16}],11:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author Felix Turner / www.airtight.cc / @felixturner\r\n *\r\n * Bad TV Shader\r\n * Simulates a bad TV via horizontal distortion and vertical roll\r\n * Uses Ashima WebGl Noise: https://github.com/ashima/webgl-noise\r\n *\r\n * time: steadily increasing float passed in\r\n * distortion: amount of thick distortion\r\n * distortion2: amount of fine grain distortion\r\n * speed: distortion vertical travel speed\r\n * rollSpeed: vertical roll speed\r\n *\r\n * The MIT License\r\n *\r\n * Copyright (c) 2014 Felix Turner\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n *\r\n */\r\n\r\nTHREE.BadTVShader = {\r\n  uniforms: {\r\n    \"tDiffuse\":    { type: \"t\", value: null },\r\n    \"time\":        { type: \"f\", value: 0.0 },\r\n    \"distortion\":  { type: \"f\", value: 0.5 },\r\n    \"distortion2\": { type: \"f\", value: 1.5 },\r\n    \"speed\":       { type: \"f\", value: 0.5 },\r\n    \"rollSpeed\":   { type: \"f\", value: 0.0 },\r\n  },\r\n\r\n  vertexShader: [\r\n    \"varying vec2 vUv;\",\r\n    \"void main() {\",\r\n    \"vUv = uv;\",\r\n    \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n    \"}\"\r\n\r\n  ].join(\"\\n\"),\r\n\r\n  fragmentShader: [\r\n\r\n    \"uniform sampler2D tDiffuse;\",\r\n    \"uniform float time;\",\r\n    \"uniform float distortion;\",\r\n    \"uniform float distortion2;\",\r\n    \"uniform float speed;\",\r\n    \"uniform float rollSpeed;\",\r\n    \"varying vec2 vUv;\",\r\n\r\n    // Start Ashima 2D Simplex Noise\r\n\r\n    \"vec3 mod289(vec3 x) {\",\r\n    \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\",\r\n    \"}\",\r\n\r\n    \"vec2 mod289(vec2 x) {\",\r\n    \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\",\r\n    \"}\",\r\n\r\n    \"vec3 permute(vec3 x) {\",\r\n    \"  return mod289(((x*34.0)+1.0)*x);\",\r\n    \"}\",\r\n\r\n    \"float snoise(vec2 v)\",\r\n    \"  {\",\r\n    \"  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\",\r\n    \"                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\",\r\n    \"                     -0.577350269189626,  // -1.0 + 2.0 * C.x\",\r\n    \"                      0.024390243902439); // 1.0 / 41.0\",\r\n    \"  vec2 i  = floor(v + dot(v, C.yy) );\",\r\n    \"  vec2 x0 = v -   i + dot(i, C.xx);\",\r\n\r\n    \"  vec2 i1;\",\r\n    \"  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\",\r\n    \"  vec4 x12 = x0.xyxy + C.xxzz;\",\r\n    \" x12.xy -= i1;\",\r\n\r\n    \"  i = mod289(i); // Avoid truncation effects in permutation\",\r\n    \"  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\",\r\n    \"   + i.x + vec3(0.0, i1.x, 1.0 ));\",\r\n\r\n    \"  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\",\r\n    \"  m = m*m ;\",\r\n    \"  m = m*m ;\",\r\n\r\n    \"  vec3 x = 2.0 * fract(p * C.www) - 1.0;\",\r\n    \"  vec3 h = abs(x) - 0.5;\",\r\n    \"  vec3 ox = floor(x + 0.5);\",\r\n    \"  vec3 a0 = x - ox;\",\r\n\r\n    \"  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\",\r\n\r\n    \"  vec3 g;\",\r\n    \"  g.x  = a0.x  * x0.x  + h.x  * x0.y;\",\r\n    \"  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\",\r\n    \"  return 130.0 * dot(m, g);\",\r\n    \"}\",\r\n\r\n    // End Ashima 2D Simplex Noise\r\n\r\n    \"void main() {\",\r\n\r\n      \"vec2 p = vUv;\",\r\n      \"float ty = time*speed;\",\r\n      \"float yt = p.y - ty;\",\r\n\r\n      //smooth distortion\r\n      \"float offset = snoise(vec2(yt*3.0,0.0))*0.2;\",\r\n      // boost distortion\r\n      \"offset = pow( offset*distortion,3.0)/distortion;\",\r\n      //add fine grain distortion\r\n      \"offset += snoise(vec2(yt*50.0,0.0))*distortion2*0.001;\",\r\n      //combine distortion on X with roll on Y\r\n      \"gl_FragColor = texture2D(tDiffuse,  vec2(fract(p.x + offset),fract(p.y-time*rollSpeed) ));\",\r\n\r\n    \"}\"\r\n\r\n  ].join(\"\\n\")\r\n\r\n};\n},{\"three\":16}],12:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Convolution shader\r\n * ported from o3d sample to WebGL / GLSL\r\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\r\n */\r\n\r\nTHREE.ConvolutionShader = {\r\n\r\n\tdefines: {\r\n\r\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\r\n\t\t\"KERNEL_SIZE_INT\": \"25\",\r\n\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":        { value: null },\r\n\t\t\"uImageIncrement\": { value: new THREE.Vector2( 0.001953125, 0.0 ) },\r\n\t\t\"cKernel\":         { value: [] }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 imageCoord = vUv;\",\r\n\t\t\t\"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\r\n\r\n\t\t\t\"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\r\n\r\n\t\t\t\t\"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\r\n\t\t\t\t\"imageCoord += uImageIncrement;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\"}\"\r\n\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tbuildKernel: function ( sigma ) {\r\n\r\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\r\n\r\n\t\tfunction gauss( x, sigma ) {\r\n\r\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\r\n\r\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\r\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\r\n\r\n\t\tvalues = new Array( kernelSize );\r\n\t\tsum = 0.0;\r\n\t\tfor ( i = 0; i < kernelSize; ++ i ) {\r\n\r\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\r\n\t\t\tsum += values[ i ];\r\n\r\n\t\t}\r\n\r\n\t\t// normalize the kernel\r\n\r\n\t\tfor ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\r\n\r\n\t\treturn values;\r\n\r\n\t}\r\n\r\n};\n},{\"three\":16}],13:[function(require,module,exports){\n'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Full-screen textured quad shader\r\n */\r\n\r\nTHREE.CopyShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"opacity\":  { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float opacity;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\"gl_FragColor = opacity * texel;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n},{\"three\":16}],14:[function(require,module,exports){\n'use strict';\n\nvar THREE = require('three');\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\n\nTHREE.FilmShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { value: null },\n\t\t\"time\":       { value: 0.0 },\n\t\t\"nIntensity\": { value: 0.5 },\n\t\t\"sIntensity\": { value: 0.05 },\n\t\t\"sCount\":     { value: 4096 },\n\t\t\"grayscale\":  { value: 1 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"#include <common>\",\n\t\t\n\t\t// control parameter\n\t\t\"uniform float time;\",\n\n\t\t\"uniform bool grayscale;\",\n\n\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float nIntensity;\",\n\n\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float sIntensity;\",\n\n\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\t\"uniform float sCount;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t// sample the source\n\t\t\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// make some noise\n\t\t\t\"float dx = rand( vUv + time );\",\n\n\t\t\t// add noise\n\t\t\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\",\n\n\t\t\t// get us a sine and cosine\n\t\t\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t\t\t// add scanlines\n\t\t\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t\t\t// interpolate between source and result by intensity\n\t\t\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t\t\t// convert to grayscale if desired\n\t\t\t\"if( grayscale ) {\",\n\n\t\t\t\t\"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor =  vec4( cResult, cTextureScreen.a );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\n},{\"three\":16}],15:[function(require,module,exports){\n(function (global){\n/*!\n * VERSION: 1.18.2\n * DATE: 2015-12-22\n * UPDATES AND DOCS AT: http://greensock.com\n * \n * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin\n *\n * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.\n * This work is subject to the terms at http://greensock.com/standard-license or for\n * Club GreenSock members, the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n **/\nvar _gsScope=\"undefined\"!=typeof module&&module.exports&&\"undefined\"!=typeof global?global:this||window;(_gsScope._gsQueue||(_gsScope._gsQueue=[])).push(function(){\"use strict\";_gsScope._gsDefine(\"TweenMax\",[\"core.Animation\",\"core.SimpleTimeline\",\"TweenLite\"],function(a,b,c){var d=function(a){var b,c=[],d=a.length;for(b=0;b!==d;c.push(a[b++]));return c},e=function(a,b,c){var d,e,f=a.cycle;for(d in f)e=f[d],a[d]=\"function\"==typeof e?e.call(b[c],c):e[c%e.length];delete a.cycle},f=function(a,b,d){c.call(this,a,b,d),this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._dirty=!0,this.render=f.prototype.render},g=1e-10,h=c._internals,i=h.isSelector,j=h.isArray,k=f.prototype=c.to({},.1,{}),l=[];f.version=\"1.18.2\",k.constructor=f,k.kill()._gc=!1,f.killTweensOf=f.killDelayedCallsTo=c.killTweensOf,f.getTweensOf=c.getTweensOf,f.lagSmoothing=c.lagSmoothing,f.ticker=c.ticker,f.render=c.render,k.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),c.prototype.invalidate.call(this)},k.updateTo=function(a,b){var d,e=this.ratio,f=this.vars.immediateRender||a.immediateRender;b&&this._startTime<this._timeline._time&&(this._startTime=this._timeline._time,this._uncache(!1),this._gc?this._enabled(!0,!1):this._timeline.insert(this,this._startTime-this._delay));for(d in a)this.vars[d]=a[d];if(this._initted||f)if(b)this._initted=!1,f&&this.render(0,!0,!0);else if(this._gc&&this._enabled(!0,!1),this._notifyPluginsOfEnabled&&this._firstPT&&c._onPluginEvent(\"_onDisable\",this),this._time/this._duration>.998){var g=this._totalTime;this.render(0,!0,!1),this._initted=!1,this.render(g,!0,!1)}else if(this._initted=!1,this._init(),this._time>0||f)for(var h,i=1/(1-e),j=this._firstPT;j;)h=j.s+j.c,j.c*=i,j.s=h-j.c,j=j._next;return this},k.render=function(a,b,c){this._initted||0===this._duration&&this.vars.repeat&&this.invalidate();var d,e,f,i,j,k,l,m,n=this._dirty?this.totalDuration():this._totalDuration,o=this._time,p=this._totalTime,q=this._cycle,r=this._duration,s=this._rawPrevTime;if(a>=n-1e-7?(this._totalTime=n,this._cycle=this._repeat,this._yoyo&&0!==(1&this._cycle)?(this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0):(this._time=r,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1),this._reversed||(d=!0,e=\"onComplete\",c=c||this._timeline.autoRemoveChildren),0===r&&(this._initted||!this.vars.lazy||c)&&(this._startTime===this._timeline._duration&&(a=0),(0>s||0>=a&&a>=-1e-7||s===g&&\"isPause\"!==this.data)&&s!==a&&(c=!0,s>g&&(e=\"onReverseComplete\")),this._rawPrevTime=m=!b||a||s===a?a:g)):1e-7>a?(this._totalTime=this._time=this._cycle=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==p||0===r&&s>0)&&(e=\"onReverseComplete\",d=this._reversed),0>a&&(this._active=!1,0===r&&(this._initted||!this.vars.lazy||c)&&(s>=0&&(c=!0),this._rawPrevTime=m=!b||a||s===a?a:g)),this._initted||(c=!0)):(this._totalTime=this._time=a,0!==this._repeat&&(i=r+this._repeatDelay,this._cycle=this._totalTime/i>>0,0!==this._cycle&&this._cycle===this._totalTime/i&&this._cycle--,this._time=this._totalTime-this._cycle*i,this._yoyo&&0!==(1&this._cycle)&&(this._time=r-this._time),this._time>r?this._time=r:this._time<0&&(this._time=0)),this._easeType?(j=this._time/r,k=this._easeType,l=this._easePower,(1===k||3===k&&j>=.5)&&(j=1-j),3===k&&(j*=2),1===l?j*=j:2===l?j*=j*j:3===l?j*=j*j*j:4===l&&(j*=j*j*j*j),1===k?this.ratio=1-j:2===k?this.ratio=j:this._time/r<.5?this.ratio=j/2:this.ratio=1-j/2):this.ratio=this._ease.getRatio(this._time/r)),o===this._time&&!c&&q===this._cycle)return void(p!==this._totalTime&&this._onUpdate&&(b||this._callback(\"onUpdate\")));if(!this._initted){if(this._init(),!this._initted||this._gc)return;if(!c&&this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration))return this._time=o,this._totalTime=p,this._rawPrevTime=s,this._cycle=q,h.lazyTweens.push(this),void(this._lazy=[a,b]);this._time&&!d?this.ratio=this._ease.getRatio(this._time/r):d&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._lazy!==!1&&(this._lazy=!1),this._active||!this._paused&&this._time!==o&&a>=0&&(this._active=!0),0===p&&(2===this._initted&&a>0&&this._init(),this._startAt&&(a>=0?this._startAt.render(a,b,c):e||(e=\"_dummyGS\")),this.vars.onStart&&(0!==this._totalTime||0===r)&&(b||this._callback(\"onStart\"))),f=this._firstPT;f;)f.f?f.t[f.p](f.c*this.ratio+f.s):f.t[f.p]=f.c*this.ratio+f.s,f=f._next;this._onUpdate&&(0>a&&this._startAt&&this._startTime&&this._startAt.render(a,b,c),b||(this._totalTime!==p||d)&&this._callback(\"onUpdate\")),this._cycle!==q&&(b||this._gc||this.vars.onRepeat&&this._callback(\"onRepeat\")),e&&(!this._gc||c)&&(0>a&&this._startAt&&!this._onUpdate&&this._startTime&&this._startAt.render(a,b,c),d&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[e]&&this._callback(e),0===r&&this._rawPrevTime===g&&m!==g&&(this._rawPrevTime=0))},f.to=function(a,b,c){return new f(a,b,c)},f.from=function(a,b,c){return c.runBackwards=!0,c.immediateRender=0!=c.immediateRender,new f(a,b,c)},f.fromTo=function(a,b,c,d){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,new f(a,b,d)},f.staggerTo=f.allTo=function(a,b,g,h,k,m,n){h=h||0;var o,p,q,r,s=0,t=[],u=function(){g.onComplete&&g.onComplete.apply(g.onCompleteScope||this,arguments),k.apply(n||g.callbackScope||this,m||l)},v=g.cycle,w=g.startAt&&g.startAt.cycle;for(j(a)||(\"string\"==typeof a&&(a=c.selector(a)||a),i(a)&&(a=d(a))),a=a||[],0>h&&(a=d(a),a.reverse(),h*=-1),o=a.length-1,q=0;o>=q;q++){p={};for(r in g)p[r]=g[r];if(v&&e(p,a,q),w){w=p.startAt={};for(r in g.startAt)w[r]=g.startAt[r];e(p.startAt,a,q)}p.delay=s+(p.delay||0),q===o&&k&&(p.onComplete=u),t[q]=new f(a[q],b,p),s+=h}return t},f.staggerFrom=f.allFrom=function(a,b,c,d,e,g,h){return c.runBackwards=!0,c.immediateRender=0!=c.immediateRender,f.staggerTo(a,b,c,d,e,g,h)},f.staggerFromTo=f.allFromTo=function(a,b,c,d,e,g,h,i){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,f.staggerTo(a,b,d,e,g,h,i)},f.delayedCall=function(a,b,c,d,e){return new f(b,0,{delay:a,onComplete:b,onCompleteParams:c,callbackScope:d,onReverseComplete:b,onReverseCompleteParams:c,immediateRender:!1,useFrames:e,overwrite:0})},f.set=function(a,b){return new f(a,0,b)},f.isTweening=function(a){return c.getTweensOf(a,!0).length>0};var m=function(a,b){for(var d=[],e=0,f=a._first;f;)f instanceof c?d[e++]=f:(b&&(d[e++]=f),d=d.concat(m(f,b)),e=d.length),f=f._next;return d},n=f.getAllTweens=function(b){return m(a._rootTimeline,b).concat(m(a._rootFramesTimeline,b))};f.killAll=function(a,c,d,e){null==c&&(c=!0),null==d&&(d=!0);var f,g,h,i=n(0!=e),j=i.length,k=c&&d&&e;for(h=0;j>h;h++)g=i[h],(k||g instanceof b||(f=g.target===g.vars.onComplete)&&d||c&&!f)&&(a?g.totalTime(g._reversed?0:g.totalDuration()):g._enabled(!1,!1))},f.killChildTweensOf=function(a,b){if(null!=a){var e,g,k,l,m,n=h.tweenLookup;if(\"string\"==typeof a&&(a=c.selector(a)||a),i(a)&&(a=d(a)),j(a))for(l=a.length;--l>-1;)f.killChildTweensOf(a[l],b);else{e=[];for(k in n)for(g=n[k].target.parentNode;g;)g===a&&(e=e.concat(n[k].tweens)),g=g.parentNode;for(m=e.length,l=0;m>l;l++)b&&e[l].totalTime(e[l].totalDuration()),e[l]._enabled(!1,!1)}}};var o=function(a,c,d,e){c=c!==!1,d=d!==!1,e=e!==!1;for(var f,g,h=n(e),i=c&&d&&e,j=h.length;--j>-1;)g=h[j],(i||g instanceof b||(f=g.target===g.vars.onComplete)&&d||c&&!f)&&g.paused(a)};return f.pauseAll=function(a,b,c){o(!0,a,b,c)},f.resumeAll=function(a,b,c){o(!1,a,b,c)},f.globalTimeScale=function(b){var d=a._rootTimeline,e=c.ticker.time;return arguments.length?(b=b||g,d._startTime=e-(e-d._startTime)*d._timeScale/b,d=a._rootFramesTimeline,e=c.ticker.frame,d._startTime=e-(e-d._startTime)*d._timeScale/b,d._timeScale=a._rootTimeline._timeScale=b,b):d._timeScale},k.progress=function(a){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-a:a)+this._cycle*(this._duration+this._repeatDelay),!1):this._time/this.duration()},k.totalProgress=function(a){return arguments.length?this.totalTime(this.totalDuration()*a,!1):this._totalTime/this.totalDuration()},k.time=function(a,b){return arguments.length?(this._dirty&&this.totalDuration(),a>this._duration&&(a=this._duration),this._yoyo&&0!==(1&this._cycle)?a=this._duration-a+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(a+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(a,b)):this._time},k.duration=function(b){return arguments.length?a.prototype.duration.call(this,b):this._duration},k.totalDuration=function(a){return arguments.length?-1===this._repeat?this:this.duration((a-this._repeat*this._repeatDelay)/(this._repeat+1)):(this._dirty&&(this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat,this._dirty=!1),this._totalDuration)},k.repeat=function(a){return arguments.length?(this._repeat=a,this._uncache(!0)):this._repeat},k.repeatDelay=function(a){return arguments.length?(this._repeatDelay=a,this._uncache(!0)):this._repeatDelay},k.yoyo=function(a){return arguments.length?(this._yoyo=a,this):this._yoyo},f},!0),_gsScope._gsDefine(\"TimelineLite\",[\"core.Animation\",\"core.SimpleTimeline\",\"TweenLite\"],function(a,b,c){var d=function(a){b.call(this,a),this._labels={},this.autoRemoveChildren=this.vars.autoRemoveChildren===!0,this.smoothChildTiming=this.vars.smoothChildTiming===!0,this._sortChildren=!0,this._onUpdate=this.vars.onUpdate;var c,d,e=this.vars;for(d in e)c=e[d],i(c)&&-1!==c.join(\"\").indexOf(\"{self}\")&&(e[d]=this._swapSelfInParams(c));i(e.tweens)&&this.add(e.tweens,0,e.align,e.stagger)},e=1e-10,f=c._internals,g=d._internals={},h=f.isSelector,i=f.isArray,j=f.lazyTweens,k=f.lazyRender,l=_gsScope._gsDefine.globals,m=function(a){var b,c={};for(b in a)c[b]=a[b];return c},n=function(a,b,c){var d,e,f=a.cycle;for(d in f)e=f[d],a[d]=\"function\"==typeof e?e.call(b[c],c):e[c%e.length];delete a.cycle},o=g.pauseCallback=function(){},p=function(a){var b,c=[],d=a.length;for(b=0;b!==d;c.push(a[b++]));return c},q=d.prototype=new b;return d.version=\"1.18.2\",q.constructor=d,q.kill()._gc=q._forcingPlayhead=q._hasPause=!1,q.to=function(a,b,d,e){var f=d.repeat&&l.TweenMax||c;return b?this.add(new f(a,b,d),e):this.set(a,d,e)},q.from=function(a,b,d,e){return this.add((d.repeat&&l.TweenMax||c).from(a,b,d),e)},q.fromTo=function(a,b,d,e,f){var g=e.repeat&&l.TweenMax||c;return b?this.add(g.fromTo(a,b,d,e),f):this.set(a,e,f)},q.staggerTo=function(a,b,e,f,g,i,j,k){var l,o,q=new d({onComplete:i,onCompleteParams:j,callbackScope:k,smoothChildTiming:this.smoothChildTiming}),r=e.cycle;for(\"string\"==typeof a&&(a=c.selector(a)||a),a=a||[],h(a)&&(a=p(a)),f=f||0,0>f&&(a=p(a),a.reverse(),f*=-1),o=0;o<a.length;o++)l=m(e),l.startAt&&(l.startAt=m(l.startAt),l.startAt.cycle&&n(l.startAt,a,o)),r&&n(l,a,o),q.to(a[o],b,l,o*f);return this.add(q,g)},q.staggerFrom=function(a,b,c,d,e,f,g,h){return c.immediateRender=0!=c.immediateRender,c.runBackwards=!0,this.staggerTo(a,b,c,d,e,f,g,h)},q.staggerFromTo=function(a,b,c,d,e,f,g,h,i){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,this.staggerTo(a,b,d,e,f,g,h,i)},q.call=function(a,b,d,e){return this.add(c.delayedCall(0,a,b,d),e)},q.set=function(a,b,d){return d=this._parseTimeOrLabel(d,0,!0),null==b.immediateRender&&(b.immediateRender=d===this._time&&!this._paused),this.add(new c(a,0,b),d)},d.exportRoot=function(a,b){a=a||{},null==a.smoothChildTiming&&(a.smoothChildTiming=!0);var e,f,g=new d(a),h=g._timeline;for(null==b&&(b=!0),h._remove(g,!0),g._startTime=0,g._rawPrevTime=g._time=g._totalTime=h._time,e=h._first;e;)f=e._next,b&&e instanceof c&&e.target===e.vars.onComplete||g.add(e,e._startTime-e._delay),e=f;return h.add(g,0),g},q.add=function(e,f,g,h){var j,k,l,m,n,o;if(\"number\"!=typeof f&&(f=this._parseTimeOrLabel(f,0,!0,e)),!(e instanceof a)){if(e instanceof Array||e&&e.push&&i(e)){for(g=g||\"normal\",h=h||0,j=f,k=e.length,l=0;k>l;l++)i(m=e[l])&&(m=new d({tweens:m})),this.add(m,j),\"string\"!=typeof m&&\"function\"!=typeof m&&(\"sequence\"===g?j=m._startTime+m.totalDuration()/m._timeScale:\"start\"===g&&(m._startTime-=m.delay())),j+=h;return this._uncache(!0)}if(\"string\"==typeof e)return this.addLabel(e,f);if(\"function\"!=typeof e)throw\"Cannot add \"+e+\" into the timeline; it is not a tween, timeline, function, or string.\";e=c.delayedCall(0,e)}if(b.prototype.add.call(this,e,f),(this._gc||this._time===this._duration)&&!this._paused&&this._duration<this.duration())for(n=this,o=n.rawTime()>e._startTime;n._timeline;)o&&n._timeline.smoothChildTiming?n.totalTime(n._totalTime,!0):n._gc&&n._enabled(!0,!1),n=n._timeline;return this},q.remove=function(b){if(b instanceof a){this._remove(b,!1);var c=b._timeline=b.vars.useFrames?a._rootFramesTimeline:a._rootTimeline;return b._startTime=(b._paused?b._pauseTime:c._time)-(b._reversed?b.totalDuration()-b._totalTime:b._totalTime)/b._timeScale,this}if(b instanceof Array||b&&b.push&&i(b)){for(var d=b.length;--d>-1;)this.remove(b[d]);return this}return\"string\"==typeof b?this.removeLabel(b):this.kill(null,b)},q._remove=function(a,c){b.prototype._remove.call(this,a,c);var d=this._last;return d?this._time>d._startTime+d._totalDuration/d._timeScale&&(this._time=this.duration(),this._totalTime=this._totalDuration):this._time=this._totalTime=this._duration=this._totalDuration=0,this},q.append=function(a,b){return this.add(a,this._parseTimeOrLabel(null,b,!0,a))},q.insert=q.insertMultiple=function(a,b,c,d){return this.add(a,b||0,c,d)},q.appendMultiple=function(a,b,c,d){return this.add(a,this._parseTimeOrLabel(null,b,!0,a),c,d)},q.addLabel=function(a,b){return this._labels[a]=this._parseTimeOrLabel(b),this},q.addPause=function(a,b,d,e){var f=c.delayedCall(0,o,d,e||this);return f.vars.onComplete=f.vars.onReverseComplete=b,f.data=\"isPause\",this._hasPause=!0,this.add(f,a)},q.removeLabel=function(a){return delete this._labels[a],this},q.getLabelTime=function(a){return null!=this._labels[a]?this._labels[a]:-1},q._parseTimeOrLabel=function(b,c,d,e){var f;if(e instanceof a&&e.timeline===this)this.remove(e);else if(e&&(e instanceof Array||e.push&&i(e)))for(f=e.length;--f>-1;)e[f]instanceof a&&e[f].timeline===this&&this.remove(e[f]);if(\"string\"==typeof c)return this._parseTimeOrLabel(c,d&&\"number\"==typeof b&&null==this._labels[c]?b-this.duration():0,d);if(c=c||0,\"string\"!=typeof b||!isNaN(b)&&null==this._labels[b])null==b&&(b=this.duration());else{if(f=b.indexOf(\"=\"),-1===f)return null==this._labels[b]?d?this._labels[b]=this.duration()+c:c:this._labels[b]+c;c=parseInt(b.charAt(f-1)+\"1\",10)*Number(b.substr(f+1)),b=f>1?this._parseTimeOrLabel(b.substr(0,f-1),0,d):this.duration()}return Number(b)+c},q.seek=function(a,b){return this.totalTime(\"number\"==typeof a?a:this._parseTimeOrLabel(a),b!==!1)},q.stop=function(){return this.paused(!0)},q.gotoAndPlay=function(a,b){return this.play(a,b)},q.gotoAndStop=function(a,b){return this.pause(a,b)},q.render=function(a,b,c){this._gc&&this._enabled(!0,!1);var d,f,g,h,i,l,m,n=this._dirty?this.totalDuration():this._totalDuration,o=this._time,p=this._startTime,q=this._timeScale,r=this._paused;if(a>=n-1e-7)this._totalTime=this._time=n,this._reversed||this._hasPausedChild()||(f=!0,h=\"onComplete\",i=!!this._timeline.autoRemoveChildren,0===this._duration&&(0>=a&&a>=-1e-7||this._rawPrevTime<0||this._rawPrevTime===e)&&this._rawPrevTime!==a&&this._first&&(i=!0,this._rawPrevTime>e&&(h=\"onReverseComplete\"))),this._rawPrevTime=this._duration||!b||a||this._rawPrevTime===a?a:e,a=n+1e-4;else if(1e-7>a)if(this._totalTime=this._time=0,(0!==o||0===this._duration&&this._rawPrevTime!==e&&(this._rawPrevTime>0||0>a&&this._rawPrevTime>=0))&&(h=\"onReverseComplete\",f=this._reversed),0>a)this._active=!1,this._timeline.autoRemoveChildren&&this._reversed?(i=f=!0,h=\"onReverseComplete\"):this._rawPrevTime>=0&&this._first&&(i=!0),this._rawPrevTime=a;else{if(this._rawPrevTime=this._duration||!b||a||this._rawPrevTime===a?a:e,0===a&&f)for(d=this._first;d&&0===d._startTime;)d._duration||(f=!1),d=d._next;a=0,this._initted||(i=!0)}else{if(this._hasPause&&!this._forcingPlayhead&&!b){if(a>=o)for(d=this._first;d&&d._startTime<=a&&!l;)d._duration||\"isPause\"!==d.data||d.ratio||0===d._startTime&&0===this._rawPrevTime||(l=d),d=d._next;else for(d=this._last;d&&d._startTime>=a&&!l;)d._duration||\"isPause\"===d.data&&d._rawPrevTime>0&&(l=d),d=d._prev;l&&(this._time=a=l._startTime,this._totalTime=a+this._cycle*(this._totalDuration+this._repeatDelay))}this._totalTime=this._time=this._rawPrevTime=a}if(this._time!==o&&this._first||c||i||l){if(this._initted||(this._initted=!0),this._active||!this._paused&&this._time!==o&&a>0&&(this._active=!0),0===o&&this.vars.onStart&&0!==this._time&&(b||this._callback(\"onStart\")),m=this._time,m>=o)for(d=this._first;d&&(g=d._next,m===this._time&&(!this._paused||r));)(d._active||d._startTime<=m&&!d._paused&&!d._gc)&&(l===d&&this.pause(),d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)),d=g;else for(d=this._last;d&&(g=d._prev,m===this._time&&(!this._paused||r));){if(d._active||d._startTime<=o&&!d._paused&&!d._gc){if(l===d){for(l=d._prev;l&&l.endTime()>this._time;)l.render(l._reversed?l.totalDuration()-(a-l._startTime)*l._timeScale:(a-l._startTime)*l._timeScale,b,c),l=l._prev;l=null,this.pause()}d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)}d=g}this._onUpdate&&(b||(j.length&&k(),this._callback(\"onUpdate\"))),h&&(this._gc||(p===this._startTime||q!==this._timeScale)&&(0===this._time||n>=this.totalDuration())&&(f&&(j.length&&k(),this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[h]&&this._callback(h)))}},q._hasPausedChild=function(){for(var a=this._first;a;){if(a._paused||a instanceof d&&a._hasPausedChild())return!0;a=a._next}return!1},q.getChildren=function(a,b,d,e){e=e||-9999999999;for(var f=[],g=this._first,h=0;g;)g._startTime<e||(g instanceof c?b!==!1&&(f[h++]=g):(d!==!1&&(f[h++]=g),a!==!1&&(f=f.concat(g.getChildren(!0,b,d)),h=f.length))),g=g._next;return f},q.getTweensOf=function(a,b){var d,e,f=this._gc,g=[],h=0;for(f&&this._enabled(!0,!0),d=c.getTweensOf(a),e=d.length;--e>-1;)(d[e].timeline===this||b&&this._contains(d[e]))&&(g[h++]=d[e]);return f&&this._enabled(!1,!0),g},q.recent=function(){return this._recent},q._contains=function(a){for(var b=a.timeline;b;){if(b===this)return!0;b=b.timeline}return!1},q.shiftChildren=function(a,b,c){c=c||0;for(var d,e=this._first,f=this._labels;e;)e._startTime>=c&&(e._startTime+=a),e=e._next;if(b)for(d in f)f[d]>=c&&(f[d]+=a);return this._uncache(!0)},q._kill=function(a,b){if(!a&&!b)return this._enabled(!1,!1);for(var c=b?this.getTweensOf(b):this.getChildren(!0,!0,!1),d=c.length,e=!1;--d>-1;)c[d]._kill(a,b)&&(e=!0);return e},q.clear=function(a){var b=this.getChildren(!1,!0,!0),c=b.length;for(this._time=this._totalTime=0;--c>-1;)b[c]._enabled(!1,!1);return a!==!1&&(this._labels={}),this._uncache(!0)},q.invalidate=function(){for(var b=this._first;b;)b.invalidate(),b=b._next;return a.prototype.invalidate.call(this)},q._enabled=function(a,c){if(a===this._gc)for(var d=this._first;d;)d._enabled(a,!0),d=d._next;return b.prototype._enabled.call(this,a,c)},q.totalTime=function(b,c,d){this._forcingPlayhead=!0;var e=a.prototype.totalTime.apply(this,arguments);return this._forcingPlayhead=!1,e},q.duration=function(a){return arguments.length?(0!==this.duration()&&0!==a&&this.timeScale(this._duration/a),this):(this._dirty&&this.totalDuration(),this._duration)},q.totalDuration=function(a){if(!arguments.length){if(this._dirty){for(var b,c,d=0,e=this._last,f=999999999999;e;)b=e._prev,e._dirty&&e.totalDuration(),e._startTime>f&&this._sortChildren&&!e._paused?this.add(e,e._startTime-e._delay):f=e._startTime,e._startTime<0&&!e._paused&&(d-=e._startTime,this._timeline.smoothChildTiming&&(this._startTime+=e._startTime/this._timeScale),this.shiftChildren(-e._startTime,!1,-9999999999),f=0),c=e._startTime+e._totalDuration/e._timeScale,c>d&&(d=c),e=b;this._duration=this._totalDuration=d,this._dirty=!1}return this._totalDuration}return a&&this.totalDuration()?this.timeScale(this._totalDuration/a):this},q.paused=function(b){if(!b)for(var c=this._first,d=this._time;c;)c._startTime===d&&\"isPause\"===c.data&&(c._rawPrevTime=0),c=c._next;return a.prototype.paused.apply(this,arguments)},q.usesFrames=function(){for(var b=this._timeline;b._timeline;)b=b._timeline;return b===a._rootFramesTimeline},q.rawTime=function(){return this._paused?this._totalTime:(this._timeline.rawTime()-this._startTime)*this._timeScale},d},!0),_gsScope._gsDefine(\"TimelineMax\",[\"TimelineLite\",\"TweenLite\",\"easing.Ease\"],function(a,b,c){var d=function(b){a.call(this,b),this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._dirty=!0},e=1e-10,f=b._internals,g=f.lazyTweens,h=f.lazyRender,i=new c(null,null,1,0),j=d.prototype=new a;return j.constructor=d,j.kill()._gc=!1,d.version=\"1.18.2\",j.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),a.prototype.invalidate.call(this)},j.addCallback=function(a,c,d,e){return this.add(b.delayedCall(0,a,d,e),c)},j.removeCallback=function(a,b){if(a)if(null==b)this._kill(null,a);else for(var c=this.getTweensOf(a,!1),d=c.length,e=this._parseTimeOrLabel(b);--d>-1;)c[d]._startTime===e&&c[d]._enabled(!1,!1);return this},j.removePause=function(b){return this.removeCallback(a._internals.pauseCallback,b)},j.tweenTo=function(a,c){c=c||{};var d,e,f,g={ease:i,useFrames:this.usesFrames(),immediateRender:!1};for(e in c)g[e]=c[e];return g.time=this._parseTimeOrLabel(a),d=Math.abs(Number(g.time)-this._time)/this._timeScale||.001,f=new b(this,d,g),g.onStart=function(){f.target.paused(!0),f.vars.time!==f.target.time()&&d===f.duration()&&f.duration(Math.abs(f.vars.time-f.target.time())/f.target._timeScale),c.onStart&&f._callback(\"onStart\")},f},j.tweenFromTo=function(a,b,c){c=c||{},a=this._parseTimeOrLabel(a),c.startAt={onComplete:this.seek,onCompleteParams:[a],callbackScope:this},c.immediateRender=c.immediateRender!==!1;var d=this.tweenTo(b,c);return d.duration(Math.abs(d.vars.time-a)/this._timeScale||.001)},j.render=function(a,b,c){this._gc&&this._enabled(!0,!1);var d,f,i,j,k,l,m,n,o=this._dirty?this.totalDuration():this._totalDuration,p=this._duration,q=this._time,r=this._totalTime,s=this._startTime,t=this._timeScale,u=this._rawPrevTime,v=this._paused,w=this._cycle;if(a>=o-1e-7)this._locked||(this._totalTime=o,this._cycle=this._repeat),this._reversed||this._hasPausedChild()||(f=!0,j=\"onComplete\",k=!!this._timeline.autoRemoveChildren,0===this._duration&&(0>=a&&a>=-1e-7||0>u||u===e)&&u!==a&&this._first&&(k=!0,u>e&&(j=\"onReverseComplete\"))),this._rawPrevTime=this._duration||!b||a||this._rawPrevTime===a?a:e,this._yoyo&&0!==(1&this._cycle)?this._time=a=0:(this._time=p,a=p+1e-4);else if(1e-7>a)if(this._locked||(this._totalTime=this._cycle=0),this._time=0,(0!==q||0===p&&u!==e&&(u>0||0>a&&u>=0)&&!this._locked)&&(j=\"onReverseComplete\",f=this._reversed),0>a)this._active=!1,this._timeline.autoRemoveChildren&&this._reversed?(k=f=!0,j=\"onReverseComplete\"):u>=0&&this._first&&(k=!0),this._rawPrevTime=a;else{if(this._rawPrevTime=p||!b||a||this._rawPrevTime===a?a:e,0===a&&f)for(d=this._first;d&&0===d._startTime;)d._duration||(f=!1),d=d._next;a=0,this._initted||(k=!0)}else if(0===p&&0>u&&(k=!0),this._time=this._rawPrevTime=a,this._locked||(this._totalTime=a,0!==this._repeat&&(l=p+this._repeatDelay,this._cycle=this._totalTime/l>>0,0!==this._cycle&&this._cycle===this._totalTime/l&&this._cycle--,this._time=this._totalTime-this._cycle*l,this._yoyo&&0!==(1&this._cycle)&&(this._time=p-this._time),this._time>p?(this._time=p,a=p+1e-4):this._time<0?this._time=a=0:a=this._time)),this._hasPause&&!this._forcingPlayhead&&!b){if(a=this._time,a>=q)for(d=this._first;d&&d._startTime<=a&&!m;)d._duration||\"isPause\"!==d.data||d.ratio||0===d._startTime&&0===this._rawPrevTime||(m=d),d=d._next;else for(d=this._last;d&&d._startTime>=a&&!m;)d._duration||\"isPause\"===d.data&&d._rawPrevTime>0&&(m=d),d=d._prev;m&&(this._time=a=m._startTime,this._totalTime=a+this._cycle*(this._totalDuration+this._repeatDelay))}if(this._cycle!==w&&!this._locked){var x=this._yoyo&&0!==(1&w),y=x===(this._yoyo&&0!==(1&this._cycle)),z=this._totalTime,A=this._cycle,B=this._rawPrevTime,C=this._time;if(this._totalTime=w*p,this._cycle<w?x=!x:this._totalTime+=p,this._time=q,this._rawPrevTime=0===p?u-1e-4:u,this._cycle=w,this._locked=!0,q=x?0:p,this.render(q,b,0===p),b||this._gc||this.vars.onRepeat&&this._callback(\"onRepeat\"),q!==this._time)return;if(y&&(q=x?p+1e-4:-1e-4,this.render(q,!0,!1)),this._locked=!1,this._paused&&!v)return;this._time=C,this._totalTime=z,this._cycle=A,this._rawPrevTime=B}if(!(this._time!==q&&this._first||c||k||m))return void(r!==this._totalTime&&this._onUpdate&&(b||this._callback(\"onUpdate\")));if(this._initted||(this._initted=!0),this._active||!this._paused&&this._totalTime!==r&&a>0&&(this._active=!0),0===r&&this.vars.onStart&&0!==this._totalTime&&(b||this._callback(\"onStart\")),n=this._time,n>=q)for(d=this._first;d&&(i=d._next,n===this._time&&(!this._paused||v));)(d._active||d._startTime<=this._time&&!d._paused&&!d._gc)&&(m===d&&this.pause(),d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)),d=i;else for(d=this._last;d&&(i=d._prev,n===this._time&&(!this._paused||v));){if(d._active||d._startTime<=q&&!d._paused&&!d._gc){if(m===d){for(m=d._prev;m&&m.endTime()>this._time;)m.render(m._reversed?m.totalDuration()-(a-m._startTime)*m._timeScale:(a-m._startTime)*m._timeScale,b,c),m=m._prev;m=null,this.pause()}d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)}d=i}this._onUpdate&&(b||(g.length&&h(),this._callback(\"onUpdate\"))),j&&(this._locked||this._gc||(s===this._startTime||t!==this._timeScale)&&(0===this._time||o>=this.totalDuration())&&(f&&(g.length&&h(),this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[j]&&this._callback(j)))},j.getActive=function(a,b,c){null==a&&(a=!0),null==b&&(b=!0),null==c&&(c=!1);var d,e,f=[],g=this.getChildren(a,b,c),h=0,i=g.length;for(d=0;i>d;d++)e=g[d],e.isActive()&&(f[h++]=e);return f},j.getLabelAfter=function(a){a||0!==a&&(a=this._time);var b,c=this.getLabelsArray(),d=c.length;for(b=0;d>b;b++)if(c[b].time>a)return c[b].name;return null},j.getLabelBefore=function(a){null==a&&(a=this._time);for(var b=this.getLabelsArray(),c=b.length;--c>-1;)if(b[c].time<a)return b[c].name;return null},j.getLabelsArray=function(){var a,b=[],c=0;for(a in this._labels)b[c++]={time:this._labels[a],name:a};return b.sort(function(a,b){return a.time-b.time}),b},j.progress=function(a,b){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-a:a)+this._cycle*(this._duration+this._repeatDelay),b):this._time/this.duration()},j.totalProgress=function(a,b){return arguments.length?this.totalTime(this.totalDuration()*a,b):this._totalTime/this.totalDuration()},j.totalDuration=function(b){return arguments.length?-1!==this._repeat&&b?this.timeScale(this.totalDuration()/b):this:(this._dirty&&(a.prototype.totalDuration.call(this),this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat),this._totalDuration)},j.time=function(a,b){return arguments.length?(this._dirty&&this.totalDuration(),a>this._duration&&(a=this._duration),this._yoyo&&0!==(1&this._cycle)?a=this._duration-a+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(a+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(a,b)):this._time},j.repeat=function(a){return arguments.length?(this._repeat=a,this._uncache(!0)):this._repeat},j.repeatDelay=function(a){return arguments.length?(this._repeatDelay=a,this._uncache(!0)):this._repeatDelay},j.yoyo=function(a){return arguments.length?(this._yoyo=a,this):this._yoyo},j.currentLabel=function(a){return arguments.length?this.seek(a,!0):this.getLabelBefore(this._time+1e-8)},d},!0),function(){var a=180/Math.PI,b=[],c=[],d=[],e={},f=_gsScope._gsDefine.globals,g=function(a,b,c,d){this.a=a,this.b=b,this.c=c,this.d=d,this.da=d-a,this.ca=c-a,this.ba=b-a},h=\",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,\",i=function(a,b,c,d){var e={a:a},f={},g={},h={c:d},i=(a+b)/2,j=(b+c)/2,k=(c+d)/2,l=(i+j)/2,m=(j+k)/2,n=(m-l)/8;return e.b=i+(a-i)/4,f.b=l+n,e.c=f.a=(e.b+f.b)/2,f.c=g.a=(l+m)/2,g.b=m-n,h.b=k+(d-k)/4,g.c=h.a=(g.b+h.b)/2,[e,f,g,h]},j=function(a,e,f,g,h){var j,k,l,m,n,o,p,q,r,s,t,u,v,w=a.length-1,x=0,y=a[0].a;for(j=0;w>j;j++)n=a[x],k=n.a,l=n.d,m=a[x+1].d,h?(t=b[j],u=c[j],v=(u+t)*e*.25/(g?.5:d[j]||.5),o=l-(l-k)*(g?.5*e:0!==t?v/t:0),p=l+(m-l)*(g?.5*e:0!==u?v/u:0),q=l-(o+((p-o)*(3*t/(t+u)+.5)/4||0))):(o=l-(l-k)*e*.5,p=l+(m-l)*e*.5,q=l-(o+p)/2),o+=q,p+=q,n.c=r=o,0!==j?n.b=y:n.b=y=n.a+.6*(n.c-n.a),n.da=l-k,n.ca=r-k,n.ba=y-k,f?(s=i(k,y,r,l),a.splice(x,1,s[0],s[1],s[2],s[3]),x+=4):x++,y=p;n=a[x],n.b=y,n.c=y+.4*(n.d-y),n.da=n.d-n.a,n.ca=n.c-n.a,n.ba=y-n.a,f&&(s=i(n.a,y,n.c,n.d),a.splice(x,1,s[0],s[1],s[2],s[3]))},k=function(a,d,e,f){var h,i,j,k,l,m,n=[];if(f)for(a=[f].concat(a),i=a.length;--i>-1;)\"string\"==typeof(m=a[i][d])&&\"=\"===m.charAt(1)&&(a[i][d]=f[d]+Number(m.charAt(0)+m.substr(2)));if(h=a.length-2,0>h)return n[0]=new g(a[0][d],0,0,a[-1>h?0:1][d]),n;for(i=0;h>i;i++)j=a[i][d],k=a[i+1][d],n[i]=new g(j,0,0,k),e&&(l=a[i+2][d],b[i]=(b[i]||0)+(k-j)*(k-j),c[i]=(c[i]||0)+(l-k)*(l-k));return n[i]=new g(a[i][d],0,0,a[i+1][d]),n},l=function(a,f,g,i,l,m){var n,o,p,q,r,s,t,u,v={},w=[],x=m||a[0];l=\"string\"==typeof l?\",\"+l+\",\":h,null==f&&(f=1);for(o in a[0])w.push(o);if(a.length>1){for(u=a[a.length-1],t=!0,n=w.length;--n>-1;)if(o=w[n],Math.abs(x[o]-u[o])>.05){t=!1;break}t&&(a=a.concat(),m&&a.unshift(m),a.push(a[1]),m=a[a.length-3])}for(b.length=c.length=d.length=0,n=w.length;--n>-1;)o=w[n],e[o]=-1!==l.indexOf(\",\"+o+\",\"),v[o]=k(a,o,e[o],m);for(n=b.length;--n>-1;)b[n]=Math.sqrt(b[n]),c[n]=Math.sqrt(c[n]);if(!i){for(n=w.length;--n>-1;)if(e[o])for(p=v[w[n]],s=p.length-1,q=0;s>q;q++)r=p[q+1].da/c[q]+p[q].da/b[q],d[q]=(d[q]||0)+r*r;for(n=d.length;--n>-1;)d[n]=Math.sqrt(d[n])}for(n=w.length,q=g?4:1;--n>-1;)o=w[n],p=v[o],j(p,f,g,i,e[o]),t&&(p.splice(0,q),p.splice(p.length-q,q));return v},m=function(a,b,c){b=b||\"soft\";var d,e,f,h,i,j,k,l,m,n,o,p={},q=\"cubic\"===b?3:2,r=\"soft\"===b,s=[];if(r&&c&&(a=[c].concat(a)),null==a||a.length<q+1)throw\"invalid Bezier data\";for(m in a[0])s.push(m);for(j=s.length;--j>-1;){for(m=s[j],p[m]=i=[],n=0,l=a.length,k=0;l>k;k++)d=null==c?a[k][m]:\"string\"==typeof(o=a[k][m])&&\"=\"===o.charAt(1)?c[m]+Number(o.charAt(0)+o.substr(2)):Number(o),r&&k>1&&l-1>k&&(i[n++]=(d+i[n-2])/2),i[n++]=d;for(l=n-q+1,n=0,k=0;l>k;k+=q)d=i[k],e=i[k+1],f=i[k+2],h=2===q?0:i[k+3],i[n++]=o=3===q?new g(d,e,f,h):new g(d,(2*e+d)/3,(2*e+f)/3,f);i.length=n}return p},n=function(a,b,c){for(var d,e,f,g,h,i,j,k,l,m,n,o=1/c,p=a.length;--p>-1;)for(m=a[p],f=m.a,g=m.d-f,h=m.c-f,i=m.b-f,d=e=0,k=1;c>=k;k++)j=o*k,l=1-j,d=e-(e=(j*j*g+3*l*(j*h+l*i))*j),n=p*c+k-1,b[n]=(b[n]||0)+d*d},o=function(a,b){b=b>>0||6;var c,d,e,f,g=[],h=[],i=0,j=0,k=b-1,l=[],m=[];for(c in a)n(a[c],g,b);for(e=g.length,d=0;e>d;d++)i+=Math.sqrt(g[d]),f=d%b,m[f]=i,f===k&&(j+=i,f=d/b>>0,l[f]=m,h[f]=j,i=0,m=[]);return{length:j,lengths:h,segments:l}},p=_gsScope._gsDefine.plugin({propName:\"bezier\",priority:-1,version:\"1.3.4\",API:2,global:!0,init:function(a,b,c){this._target=a,b instanceof Array&&(b={values:b}),this._func={},this._round={},this._props=[],this._timeRes=null==b.timeResolution?6:parseInt(b.timeResolution,10);\nvar d,e,f,g,h,i=b.values||[],j={},k=i[0],n=b.autoRotate||c.vars.orientToBezier;this._autoRotate=n?n instanceof Array?n:[[\"x\",\"y\",\"rotation\",n===!0?0:Number(n)||0]]:null;for(d in k)this._props.push(d);for(f=this._props.length;--f>-1;)d=this._props[f],this._overwriteProps.push(d),e=this._func[d]=\"function\"==typeof a[d],j[d]=e?a[d.indexOf(\"set\")||\"function\"!=typeof a[\"get\"+d.substr(3)]?d:\"get\"+d.substr(3)]():parseFloat(a[d]),h||j[d]!==i[0][d]&&(h=j);if(this._beziers=\"cubic\"!==b.type&&\"quadratic\"!==b.type&&\"soft\"!==b.type?l(i,isNaN(b.curviness)?1:b.curviness,!1,\"thruBasic\"===b.type,b.correlate,h):m(i,b.type,j),this._segCount=this._beziers[d].length,this._timeRes){var p=o(this._beziers,this._timeRes);this._length=p.length,this._lengths=p.lengths,this._segments=p.segments,this._l1=this._li=this._s1=this._si=0,this._l2=this._lengths[0],this._curSeg=this._segments[0],this._s2=this._curSeg[0],this._prec=1/this._curSeg.length}if(n=this._autoRotate)for(this._initialRotations=[],n[0]instanceof Array||(this._autoRotate=n=[n]),f=n.length;--f>-1;){for(g=0;3>g;g++)d=n[f][g],this._func[d]=\"function\"==typeof a[d]?a[d.indexOf(\"set\")||\"function\"!=typeof a[\"get\"+d.substr(3)]?d:\"get\"+d.substr(3)]:!1;d=n[f][2],this._initialRotations[f]=this._func[d]?this._func[d].call(this._target):this._target[d]}return this._startRatio=c.vars.runBackwards?1:0,!0},set:function(b){var c,d,e,f,g,h,i,j,k,l,m=this._segCount,n=this._func,o=this._target,p=b!==this._startRatio;if(this._timeRes){if(k=this._lengths,l=this._curSeg,b*=this._length,e=this._li,b>this._l2&&m-1>e){for(j=m-1;j>e&&(this._l2=k[++e])<=b;);this._l1=k[e-1],this._li=e,this._curSeg=l=this._segments[e],this._s2=l[this._s1=this._si=0]}else if(b<this._l1&&e>0){for(;e>0&&(this._l1=k[--e])>=b;);0===e&&b<this._l1?this._l1=0:e++,this._l2=k[e],this._li=e,this._curSeg=l=this._segments[e],this._s1=l[(this._si=l.length-1)-1]||0,this._s2=l[this._si]}if(c=e,b-=this._l1,e=this._si,b>this._s2&&e<l.length-1){for(j=l.length-1;j>e&&(this._s2=l[++e])<=b;);this._s1=l[e-1],this._si=e}else if(b<this._s1&&e>0){for(;e>0&&(this._s1=l[--e])>=b;);0===e&&b<this._s1?this._s1=0:e++,this._s2=l[e],this._si=e}h=(e+(b-this._s1)/(this._s2-this._s1))*this._prec}else c=0>b?0:b>=1?m-1:m*b>>0,h=(b-c*(1/m))*m;for(d=1-h,e=this._props.length;--e>-1;)f=this._props[e],g=this._beziers[f][c],i=(h*h*g.da+3*d*(h*g.ca+d*g.ba))*h+g.a,this._round[f]&&(i=Math.round(i)),n[f]?o[f](i):o[f]=i;if(this._autoRotate){var q,r,s,t,u,v,w,x=this._autoRotate;for(e=x.length;--e>-1;)f=x[e][2],v=x[e][3]||0,w=x[e][4]===!0?1:a,g=this._beziers[x[e][0]],q=this._beziers[x[e][1]],g&&q&&(g=g[c],q=q[c],r=g.a+(g.b-g.a)*h,t=g.b+(g.c-g.b)*h,r+=(t-r)*h,t+=(g.c+(g.d-g.c)*h-t)*h,s=q.a+(q.b-q.a)*h,u=q.b+(q.c-q.b)*h,s+=(u-s)*h,u+=(q.c+(q.d-q.c)*h-u)*h,i=p?Math.atan2(u-s,t-r)*w+v:this._initialRotations[e],n[f]?o[f](i):o[f]=i)}}}),q=p.prototype;p.bezierThrough=l,p.cubicToQuadratic=i,p._autoCSS=!0,p.quadraticToCubic=function(a,b,c){return new g(a,(2*b+a)/3,(2*b+c)/3,c)},p._cssRegister=function(){var a=f.CSSPlugin;if(a){var b=a._internals,c=b._parseToProxy,d=b._setPluginRatio,e=b.CSSPropTween;b._registerComplexSpecialProp(\"bezier\",{parser:function(a,b,f,g,h,i){b instanceof Array&&(b={values:b}),i=new p;var j,k,l,m=b.values,n=m.length-1,o=[],q={};if(0>n)return h;for(j=0;n>=j;j++)l=c(a,m[j],g,h,i,n!==j),o[j]=l.end;for(k in b)q[k]=b[k];return q.values=o,h=new e(a,\"bezier\",0,0,l.pt,2),h.data=l,h.plugin=i,h.setRatio=d,0===q.autoRotate&&(q.autoRotate=!0),!q.autoRotate||q.autoRotate instanceof Array||(j=q.autoRotate===!0?0:Number(q.autoRotate),q.autoRotate=null!=l.end.left?[[\"left\",\"top\",\"rotation\",j,!1]]:null!=l.end.x?[[\"x\",\"y\",\"rotation\",j,!1]]:!1),q.autoRotate&&(g._transform||g._enableTransforms(!1),l.autoRotate=g._target._gsTransform),i._onInitTween(l.proxy,q,g._tween),h}})}},q._roundProps=function(a,b){for(var c=this._overwriteProps,d=c.length;--d>-1;)(a[c[d]]||a.bezier||a.bezierThrough)&&(this._round[c[d]]=b)},q._kill=function(a){var b,c,d=this._props;for(b in this._beziers)if(b in a)for(delete this._beziers[b],delete this._func[b],c=d.length;--c>-1;)d[c]===b&&d.splice(c,1);return this._super._kill.call(this,a)}}(),_gsScope._gsDefine(\"plugins.CSSPlugin\",[\"plugins.TweenPlugin\",\"TweenLite\"],function(a,b){var c,d,e,f,g=function(){a.call(this,\"css\"),this._overwriteProps.length=0,this.setRatio=g.prototype.setRatio},h=_gsScope._gsDefine.globals,i={},j=g.prototype=new a(\"css\");j.constructor=g,g.version=\"1.18.2\",g.API=2,g.defaultTransformPerspective=0,g.defaultSkewType=\"compensated\",g.defaultSmoothOrigin=!0,j=\"px\",g.suffixMap={top:j,right:j,bottom:j,left:j,width:j,height:j,fontSize:j,padding:j,margin:j,perspective:j,lineHeight:\"\"};var k,l,m,n,o,p,q=/(?:\\d|\\-\\d|\\.\\d|\\-\\.\\d)+/g,r=/(?:\\d|\\-\\d|\\.\\d|\\-\\.\\d|\\+=\\d|\\-=\\d|\\+=.\\d|\\-=\\.\\d)+/g,s=/(?:\\+=|\\-=|\\-|\\b)[\\d\\-\\.]+[a-zA-Z0-9]*(?:%|\\b)/gi,t=/(?![+-]?\\d*\\.?\\d+|[+-]|e[+-]\\d+)[^0-9]/g,u=/(?:\\d|\\-|\\+|=|#|\\.)*/g,v=/opacity *= *([^)]*)/i,w=/opacity:([^;]*)/i,x=/alpha\\(opacity *=.+?\\)/i,y=/^(rgb|hsl)/,z=/([A-Z])/g,A=/-([a-z])/gi,B=/(^(?:url\\(\\\"|url\\())|(?:(\\\"\\))$|\\)$)/gi,C=function(a,b){return b.toUpperCase()},D=/(?:Left|Right|Width)/i,E=/(M11|M12|M21|M22)=[\\d\\-\\.e]+/gi,F=/progid\\:DXImageTransform\\.Microsoft\\.Matrix\\(.+?\\)/i,G=/,(?=[^\\)]*(?:\\(|$))/gi,H=Math.PI/180,I=180/Math.PI,J={},K=document,L=function(a){return K.createElementNS?K.createElementNS(\"http://www.w3.org/1999/xhtml\",a):K.createElement(a)},M=L(\"div\"),N=L(\"img\"),O=g._internals={_specialProps:i},P=navigator.userAgent,Q=function(){var a=P.indexOf(\"Android\"),b=L(\"a\");return m=-1!==P.indexOf(\"Safari\")&&-1===P.indexOf(\"Chrome\")&&(-1===a||Number(P.substr(a+8,1))>3),o=m&&Number(P.substr(P.indexOf(\"Version/\")+8,1))<6,n=-1!==P.indexOf(\"Firefox\"),(/MSIE ([0-9]{1,}[\\.0-9]{0,})/.exec(P)||/Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(P))&&(p=parseFloat(RegExp.$1)),b?(b.style.cssText=\"top:1px;opacity:.55;\",/^0.55/.test(b.style.opacity)):!1}(),R=function(a){return v.test(\"string\"==typeof a?a:(a.currentStyle?a.currentStyle.filter:a.style.filter)||\"\")?parseFloat(RegExp.$1)/100:1},S=function(a){window.console&&console.log(a)},T=\"\",U=\"\",V=function(a,b){b=b||M;var c,d,e=b.style;if(void 0!==e[a])return a;for(a=a.charAt(0).toUpperCase()+a.substr(1),c=[\"O\",\"Moz\",\"ms\",\"Ms\",\"Webkit\"],d=5;--d>-1&&void 0===e[c[d]+a];);return d>=0?(U=3===d?\"ms\":c[d],T=\"-\"+U.toLowerCase()+\"-\",U+a):null},W=K.defaultView?K.defaultView.getComputedStyle:function(){},X=g.getStyle=function(a,b,c,d,e){var f;return Q||\"opacity\"!==b?(!d&&a.style[b]?f=a.style[b]:(c=c||W(a))?f=c[b]||c.getPropertyValue(b)||c.getPropertyValue(b.replace(z,\"-$1\").toLowerCase()):a.currentStyle&&(f=a.currentStyle[b]),null==e||f&&\"none\"!==f&&\"auto\"!==f&&\"auto auto\"!==f?f:e):R(a)},Y=O.convertToPixels=function(a,c,d,e,f){if(\"px\"===e||!e)return d;if(\"auto\"===e||!d)return 0;var h,i,j,k=D.test(c),l=a,m=M.style,n=0>d;if(n&&(d=-d),\"%\"===e&&-1!==c.indexOf(\"border\"))h=d/100*(k?a.clientWidth:a.clientHeight);else{if(m.cssText=\"border:0 solid red;position:\"+X(a,\"position\")+\";line-height:0;\",\"%\"!==e&&l.appendChild&&\"v\"!==e.charAt(0)&&\"rem\"!==e)m[k?\"borderLeftWidth\":\"borderTopWidth\"]=d+e;else{if(l=a.parentNode||K.body,i=l._gsCache,j=b.ticker.frame,i&&k&&i.time===j)return i.width*d/100;m[k?\"width\":\"height\"]=d+e}l.appendChild(M),h=parseFloat(M[k?\"offsetWidth\":\"offsetHeight\"]),l.removeChild(M),k&&\"%\"===e&&g.cacheWidths!==!1&&(i=l._gsCache=l._gsCache||{},i.time=j,i.width=h/d*100),0!==h||f||(h=Y(a,c,d,e,!0))}return n?-h:h},Z=O.calculateOffset=function(a,b,c){if(\"absolute\"!==X(a,\"position\",c))return 0;var d=\"left\"===b?\"Left\":\"Top\",e=X(a,\"margin\"+d,c);return a[\"offset\"+d]-(Y(a,b,parseFloat(e),e.replace(u,\"\"))||0)},$=function(a,b){var c,d,e,f={};if(b=b||W(a,null))if(c=b.length)for(;--c>-1;)e=b[c],(-1===e.indexOf(\"-transform\")||za===e)&&(f[e.replace(A,C)]=b.getPropertyValue(e));else for(c in b)(-1===c.indexOf(\"Transform\")||ya===c)&&(f[c]=b[c]);else if(b=a.currentStyle||a.style)for(c in b)\"string\"==typeof c&&void 0===f[c]&&(f[c.replace(A,C)]=b[c]);return Q||(f.opacity=R(a)),d=La(a,b,!1),f.rotation=d.rotation,f.skewX=d.skewX,f.scaleX=d.scaleX,f.scaleY=d.scaleY,f.x=d.x,f.y=d.y,Ba&&(f.z=d.z,f.rotationX=d.rotationX,f.rotationY=d.rotationY,f.scaleZ=d.scaleZ),f.filters&&delete f.filters,f},_=function(a,b,c,d,e){var f,g,h,i={},j=a.style;for(g in c)\"cssText\"!==g&&\"length\"!==g&&isNaN(g)&&(b[g]!==(f=c[g])||e&&e[g])&&-1===g.indexOf(\"Origin\")&&(\"number\"==typeof f||\"string\"==typeof f)&&(i[g]=\"auto\"!==f||\"left\"!==g&&\"top\"!==g?\"\"!==f&&\"auto\"!==f&&\"none\"!==f||\"string\"!=typeof b[g]||\"\"===b[g].replace(t,\"\")?f:0:Z(a,g),void 0!==j[g]&&(h=new oa(j,g,j[g],h)));if(d)for(g in d)\"className\"!==g&&(i[g]=d[g]);return{difs:i,firstMPT:h}},aa={width:[\"Left\",\"Right\"],height:[\"Top\",\"Bottom\"]},ba=[\"marginLeft\",\"marginRight\",\"marginTop\",\"marginBottom\"],ca=function(a,b,c){var d=parseFloat(\"width\"===b?a.offsetWidth:a.offsetHeight),e=aa[b],f=e.length;for(c=c||W(a,null);--f>-1;)d-=parseFloat(X(a,\"padding\"+e[f],c,!0))||0,d-=parseFloat(X(a,\"border\"+e[f]+\"Width\",c,!0))||0;return d},da=function(a,b){if(\"contain\"===a||\"auto\"===a||\"auto auto\"===a)return a+\" \";(null==a||\"\"===a)&&(a=\"0 0\");var c=a.split(\" \"),d=-1!==a.indexOf(\"left\")?\"0%\":-1!==a.indexOf(\"right\")?\"100%\":c[0],e=-1!==a.indexOf(\"top\")?\"0%\":-1!==a.indexOf(\"bottom\")?\"100%\":c[1];return null==e?e=\"center\"===d?\"50%\":\"0\":\"center\"===e&&(e=\"50%\"),(\"center\"===d||isNaN(parseFloat(d))&&-1===(d+\"\").indexOf(\"=\"))&&(d=\"50%\"),a=d+\" \"+e+(c.length>2?\" \"+c[2]:\"\"),b&&(b.oxp=-1!==d.indexOf(\"%\"),b.oyp=-1!==e.indexOf(\"%\"),b.oxr=\"=\"===d.charAt(1),b.oyr=\"=\"===e.charAt(1),b.ox=parseFloat(d.replace(t,\"\")),b.oy=parseFloat(e.replace(t,\"\")),b.v=a),b||a},ea=function(a,b){return\"string\"==typeof a&&\"=\"===a.charAt(1)?parseInt(a.charAt(0)+\"1\",10)*parseFloat(a.substr(2)):parseFloat(a)-parseFloat(b)},fa=function(a,b){return null==a?b:\"string\"==typeof a&&\"=\"===a.charAt(1)?parseInt(a.charAt(0)+\"1\",10)*parseFloat(a.substr(2))+b:parseFloat(a)},ga=function(a,b,c,d){var e,f,g,h,i,j=1e-6;return null==a?h=b:\"number\"==typeof a?h=a:(e=360,f=a.split(\"_\"),i=\"=\"===a.charAt(1),g=(i?parseInt(a.charAt(0)+\"1\",10)*parseFloat(f[0].substr(2)):parseFloat(f[0]))*(-1===a.indexOf(\"rad\")?1:I)-(i?0:b),f.length&&(d&&(d[c]=b+g),-1!==a.indexOf(\"short\")&&(g%=e,g!==g%(e/2)&&(g=0>g?g+e:g-e)),-1!==a.indexOf(\"_cw\")&&0>g?g=(g+9999999999*e)%e-(g/e|0)*e:-1!==a.indexOf(\"ccw\")&&g>0&&(g=(g-9999999999*e)%e-(g/e|0)*e)),h=b+g),j>h&&h>-j&&(h=0),h},ha={aqua:[0,255,255],lime:[0,255,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,255],navy:[0,0,128],white:[255,255,255],fuchsia:[255,0,255],olive:[128,128,0],yellow:[255,255,0],orange:[255,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[255,0,0],pink:[255,192,203],cyan:[0,255,255],transparent:[255,255,255,0]},ia=function(a,b,c){return a=0>a?a+1:a>1?a-1:a,255*(1>6*a?b+(c-b)*a*6:.5>a?c:2>3*a?b+(c-b)*(2/3-a)*6:b)+.5|0},ja=g.parseColor=function(a,b){var c,d,e,f,g,h,i,j,k,l,m;if(a)if(\"number\"==typeof a)c=[a>>16,a>>8&255,255&a];else{if(\",\"===a.charAt(a.length-1)&&(a=a.substr(0,a.length-1)),ha[a])c=ha[a];else if(\"#\"===a.charAt(0))4===a.length&&(d=a.charAt(1),e=a.charAt(2),f=a.charAt(3),a=\"#\"+d+d+e+e+f+f),a=parseInt(a.substr(1),16),c=[a>>16,a>>8&255,255&a];else if(\"hsl\"===a.substr(0,3))if(c=m=a.match(q),b){if(-1!==a.indexOf(\"=\"))return a.match(r)}else g=Number(c[0])%360/360,h=Number(c[1])/100,i=Number(c[2])/100,e=.5>=i?i*(h+1):i+h-i*h,d=2*i-e,c.length>3&&(c[3]=Number(a[3])),c[0]=ia(g+1/3,d,e),c[1]=ia(g,d,e),c[2]=ia(g-1/3,d,e);else c=a.match(q)||ha.transparent;c[0]=Number(c[0]),c[1]=Number(c[1]),c[2]=Number(c[2]),c.length>3&&(c[3]=Number(c[3]))}else c=ha.black;return b&&!m&&(d=c[0]/255,e=c[1]/255,f=c[2]/255,j=Math.max(d,e,f),k=Math.min(d,e,f),i=(j+k)/2,j===k?g=h=0:(l=j-k,h=i>.5?l/(2-j-k):l/(j+k),g=j===d?(e-f)/l+(f>e?6:0):j===e?(f-d)/l+2:(d-e)/l+4,g*=60),c[0]=g+.5|0,c[1]=100*h+.5|0,c[2]=100*i+.5|0),c},ka=function(a,b){var c,d,e,f=a.match(la)||[],g=0,h=f.length?\"\":a;for(c=0;c<f.length;c++)d=f[c],e=a.substr(g,a.indexOf(d,g)-g),g+=e.length+d.length,d=ja(d,b),3===d.length&&d.push(1),h+=e+(b?\"hsla(\"+d[0]+\",\"+d[1]+\"%,\"+d[2]+\"%,\"+d[3]:\"rgba(\"+d.join(\",\"))+\")\";return h},la=\"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3}){1,2}\\\\b\";for(j in ha)la+=\"|\"+j+\"\\\\b\";la=new RegExp(la+\")\",\"gi\"),g.colorStringFilter=function(a){var b,c=a[0]+a[1];la.lastIndex=0,la.test(c)&&(b=-1!==c.indexOf(\"hsl(\")||-1!==c.indexOf(\"hsla(\"),a[0]=ka(a[0],b),a[1]=ka(a[1],b))},b.defaultStringFilter||(b.defaultStringFilter=g.colorStringFilter);var ma=function(a,b,c,d){if(null==a)return function(a){return a};var e,f=b?(a.match(la)||[\"\"])[0]:\"\",g=a.split(f).join(\"\").match(s)||[],h=a.substr(0,a.indexOf(g[0])),i=\")\"===a.charAt(a.length-1)?\")\":\"\",j=-1!==a.indexOf(\" \")?\" \":\",\",k=g.length,l=k>0?g[0].replace(q,\"\"):\"\";return k?e=b?function(a){var b,m,n,o;if(\"number\"==typeof a)a+=l;else if(d&&G.test(a)){for(o=a.replace(G,\"|\").split(\"|\"),n=0;n<o.length;n++)o[n]=e(o[n]);return o.join(\",\")}if(b=(a.match(la)||[f])[0],m=a.split(b).join(\"\").match(s)||[],n=m.length,k>n--)for(;++n<k;)m[n]=c?m[(n-1)/2|0]:g[n];return h+m.join(j)+j+b+i+(-1!==a.indexOf(\"inset\")?\" inset\":\"\")}:function(a){var b,f,m;if(\"number\"==typeof a)a+=l;else if(d&&G.test(a)){for(f=a.replace(G,\"|\").split(\"|\"),m=0;m<f.length;m++)f[m]=e(f[m]);return f.join(\",\")}if(b=a.match(s)||[],m=b.length,k>m--)for(;++m<k;)b[m]=c?b[(m-1)/2|0]:g[m];return h+b.join(j)+i}:function(a){return a}},na=function(a){return a=a.split(\",\"),function(b,c,d,e,f,g,h){var i,j=(c+\"\").split(\" \");for(h={},i=0;4>i;i++)h[a[i]]=j[i]=j[i]||j[(i-1)/2>>0];return e.parse(b,h,f,g)}},oa=(O._setPluginRatio=function(a){this.plugin.setRatio(a);for(var b,c,d,e,f,g=this.data,h=g.proxy,i=g.firstMPT,j=1e-6;i;)b=h[i.v],i.r?b=Math.round(b):j>b&&b>-j&&(b=0),i.t[i.p]=b,i=i._next;if(g.autoRotate&&(g.autoRotate.rotation=h.rotation),1===a||0===a)for(i=g.firstMPT,f=1===a?\"e\":\"b\";i;){if(c=i.t,c.type){if(1===c.type){for(e=c.xs0+c.s+c.xs1,d=1;d<c.l;d++)e+=c[\"xn\"+d]+c[\"xs\"+(d+1)];c[f]=e}}else c[f]=c.s+c.xs0;i=i._next}},function(a,b,c,d,e){this.t=a,this.p=b,this.v=c,this.r=e,d&&(d._prev=this,this._next=d)}),pa=(O._parseToProxy=function(a,b,c,d,e,f){var g,h,i,j,k,l=d,m={},n={},o=c._transform,p=J;for(c._transform=null,J=b,d=k=c.parse(a,b,d,e),J=p,f&&(c._transform=o,l&&(l._prev=null,l._prev&&(l._prev._next=null)));d&&d!==l;){if(d.type<=1&&(h=d.p,n[h]=d.s+d.c,m[h]=d.s,f||(j=new oa(d,\"s\",h,j,d.r),d.c=0),1===d.type))for(g=d.l;--g>0;)i=\"xn\"+g,h=d.p+\"_\"+i,n[h]=d.data[i],m[h]=d[i],f||(j=new oa(d,i,h,j,d.rxp[i]));d=d._next}return{proxy:m,end:n,firstMPT:j,pt:k}},O.CSSPropTween=function(a,b,d,e,g,h,i,j,k,l,m){this.t=a,this.p=b,this.s=d,this.c=e,this.n=i||b,a instanceof pa||f.push(this.n),this.r=j,this.type=h||0,k&&(this.pr=k,c=!0),this.b=void 0===l?d:l,this.e=void 0===m?d+e:m,g&&(this._next=g,g._prev=this)}),qa=function(a,b,c,d,e,f){var g=new pa(a,b,c,d-c,e,-1,f);return g.b=c,g.e=g.xs0=d,g},ra=g.parseComplex=function(a,b,c,d,e,f,g,h,i,j){c=c||f||\"\",g=new pa(a,b,0,0,g,j?2:1,null,!1,h,c,d),d+=\"\";var l,m,n,o,p,s,t,u,v,w,x,y,z,A=c.split(\", \").join(\",\").split(\" \"),B=d.split(\", \").join(\",\").split(\" \"),C=A.length,D=k!==!1;for((-1!==d.indexOf(\",\")||-1!==c.indexOf(\",\"))&&(A=A.join(\" \").replace(G,\", \").split(\" \"),B=B.join(\" \").replace(G,\", \").split(\" \"),C=A.length),C!==B.length&&(A=(f||\"\").split(\" \"),C=A.length),g.plugin=i,g.setRatio=j,la.lastIndex=0,l=0;C>l;l++)if(o=A[l],p=B[l],u=parseFloat(o),u||0===u)g.appendXtra(\"\",u,ea(p,u),p.replace(r,\"\"),D&&-1!==p.indexOf(\"px\"),!0);else if(e&&la.test(o))y=\",\"===p.charAt(p.length-1)?\"),\":\")\",z=-1!==p.indexOf(\"hsl\")&&Q,o=ja(o,z),p=ja(p,z),v=o.length+p.length>6,v&&!Q&&0===p[3]?(g[\"xs\"+g.l]+=g.l?\" transparent\":\"transparent\",g.e=g.e.split(B[l]).join(\"transparent\")):(Q||(v=!1),z?g.appendXtra(v?\"hsla(\":\"hsl(\",o[0],ea(p[0],o[0]),\",\",!1,!0).appendXtra(\"\",o[1],ea(p[1],o[1]),\"%,\",!1).appendXtra(\"\",o[2],ea(p[2],o[2]),v?\"%,\":\"%\"+y,!1):g.appendXtra(v?\"rgba(\":\"rgb(\",o[0],p[0]-o[0],\",\",!0,!0).appendXtra(\"\",o[1],p[1]-o[1],\",\",!0).appendXtra(\"\",o[2],p[2]-o[2],v?\",\":y,!0),v&&(o=o.length<4?1:o[3],g.appendXtra(\"\",o,(p.length<4?1:p[3])-o,y,!1))),la.lastIndex=0;else if(s=o.match(q)){if(t=p.match(r),!t||t.length!==s.length)return g;for(n=0,m=0;m<s.length;m++)x=s[m],w=o.indexOf(x,n),g.appendXtra(o.substr(n,w-n),Number(x),ea(t[m],x),\"\",D&&\"px\"===o.substr(w+x.length,2),0===m),n=w+x.length;g[\"xs\"+g.l]+=o.substr(n)}else g[\"xs\"+g.l]+=g.l?\" \"+p:p;if(-1!==d.indexOf(\"=\")&&g.data){for(y=g.xs0+g.data.s,l=1;l<g.l;l++)y+=g[\"xs\"+l]+g.data[\"xn\"+l];g.e=y+g[\"xs\"+l]}return g.l||(g.type=-1,g.xs0=g.e),g.xfirst||g},sa=9;for(j=pa.prototype,j.l=j.pr=0;--sa>0;)j[\"xn\"+sa]=0,j[\"xs\"+sa]=\"\";j.xs0=\"\",j._next=j._prev=j.xfirst=j.data=j.plugin=j.setRatio=j.rxp=null,j.appendXtra=function(a,b,c,d,e,f){var g=this,h=g.l;return g[\"xs\"+h]+=f&&h?\" \"+a:a||\"\",c||0===h||g.plugin?(g.l++,g.type=g.setRatio?2:1,g[\"xs\"+g.l]=d||\"\",h>0?(g.data[\"xn\"+h]=b+c,g.rxp[\"xn\"+h]=e,g[\"xn\"+h]=b,g.plugin||(g.xfirst=new pa(g,\"xn\"+h,b,c,g.xfirst||g,0,g.n,e,g.pr),g.xfirst.xs0=0),g):(g.data={s:b+c},g.rxp={},g.s=b,g.c=c,g.r=e,g)):(g[\"xs\"+h]+=b+(d||\"\"),g)};var ta=function(a,b){b=b||{},this.p=b.prefix?V(a)||a:a,i[a]=i[this.p]=this,this.format=b.formatter||ma(b.defaultValue,b.color,b.collapsible,b.multi),b.parser&&(this.parse=b.parser),this.clrs=b.color,this.multi=b.multi,this.keyword=b.keyword,this.dflt=b.defaultValue,this.pr=b.priority||0},ua=O._registerComplexSpecialProp=function(a,b,c){\"object\"!=typeof b&&(b={parser:c});var d,e,f=a.split(\",\"),g=b.defaultValue;for(c=c||[g],d=0;d<f.length;d++)b.prefix=0===d&&b.prefix,b.defaultValue=c[d]||g,e=new ta(f[d],b)},va=function(a){if(!i[a]){var b=a.charAt(0).toUpperCase()+a.substr(1)+\"Plugin\";ua(a,{parser:function(a,c,d,e,f,g,j){var k=h.com.greensock.plugins[b];return k?(k._cssRegister(),i[d].parse(a,c,d,e,f,g,j)):(S(\"Error: \"+b+\" js file not loaded.\"),f)}})}};j=ta.prototype,j.parseComplex=function(a,b,c,d,e,f){var g,h,i,j,k,l,m=this.keyword;if(this.multi&&(G.test(c)||G.test(b)?(h=b.replace(G,\"|\").split(\"|\"),i=c.replace(G,\"|\").split(\"|\")):m&&(h=[b],i=[c])),i){for(j=i.length>h.length?i.length:h.length,g=0;j>g;g++)b=h[g]=h[g]||this.dflt,c=i[g]=i[g]||this.dflt,m&&(k=b.indexOf(m),l=c.indexOf(m),k!==l&&(-1===l?h[g]=h[g].split(m).join(\"\"):-1===k&&(h[g]+=\" \"+m)));b=h.join(\", \"),c=i.join(\", \")}return ra(a,this.p,b,c,this.clrs,this.dflt,d,this.pr,e,f)},j.parse=function(a,b,c,d,f,g,h){return this.parseComplex(a.style,this.format(X(a,this.p,e,!1,this.dflt)),this.format(b),f,g)},g.registerSpecialProp=function(a,b,c){ua(a,{parser:function(a,d,e,f,g,h,i){var j=new pa(a,e,0,0,g,2,e,!1,c);return j.plugin=h,j.setRatio=b(a,d,f._tween,e),j},priority:c})},g.useSVGTransformAttr=m||n;var wa,xa=\"scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent\".split(\",\"),ya=V(\"transform\"),za=T+\"transform\",Aa=V(\"transformOrigin\"),Ba=null!==V(\"perspective\"),Ca=O.Transform=function(){this.perspective=parseFloat(g.defaultTransformPerspective)||0,this.force3D=g.defaultForce3D!==!1&&Ba?g.defaultForce3D||\"auto\":!1},Da=window.SVGElement,Ea=function(a,b,c){var d,e=K.createElementNS(\"http://www.w3.org/2000/svg\",a),f=/([a-z])([A-Z])/g;for(d in c)e.setAttributeNS(null,d.replace(f,\"$1-$2\").toLowerCase(),c[d]);return b.appendChild(e),e},Fa=K.documentElement,Ga=function(){var a,b,c,d=p||/Android/i.test(P)&&!window.chrome;return K.createElementNS&&!d&&(a=Ea(\"svg\",Fa),b=Ea(\"rect\",a,{width:100,height:50,x:100}),c=b.getBoundingClientRect().width,b.style[Aa]=\"50% 50%\",b.style[ya]=\"scaleX(0.5)\",d=c===b.getBoundingClientRect().width&&!(n&&Ba),Fa.removeChild(a)),d}(),Ha=function(a,b,c,d,e){var f,h,i,j,k,l,m,n,o,p,q,r,s,t,u=a._gsTransform,v=Ka(a,!0);u&&(s=u.xOrigin,t=u.yOrigin),(!d||(f=d.split(\" \")).length<2)&&(m=a.getBBox(),b=da(b).split(\" \"),f=[(-1!==b[0].indexOf(\"%\")?parseFloat(b[0])/100*m.width:parseFloat(b[0]))+m.x,(-1!==b[1].indexOf(\"%\")?parseFloat(b[1])/100*m.height:parseFloat(b[1]))+m.y]),c.xOrigin=j=parseFloat(f[0]),c.yOrigin=k=parseFloat(f[1]),d&&v!==Ja&&(l=v[0],m=v[1],n=v[2],o=v[3],p=v[4],q=v[5],r=l*o-m*n,h=j*(o/r)+k*(-n/r)+(n*q-o*p)/r,i=j*(-m/r)+k*(l/r)-(l*q-m*p)/r,j=c.xOrigin=f[0]=h,k=c.yOrigin=f[1]=i),u&&(e||e!==!1&&g.defaultSmoothOrigin!==!1?(h=j-s,i=k-t,u.xOffset+=h*v[0]+i*v[2]-h,u.yOffset+=h*v[1]+i*v[3]-i):u.xOffset=u.yOffset=0),a.setAttribute(\"data-svg-origin\",f.join(\" \"))},Ia=function(a){return!!(Da&&\"function\"==typeof a.getBBox&&a.getCTM&&(!a.parentNode||a.parentNode.getBBox&&a.parentNode.getCTM))},Ja=[1,0,0,1,0,0],Ka=function(a,b){var c,d,e,f,g,h=a._gsTransform||new Ca,i=1e5;if(ya?d=X(a,za,null,!0):a.currentStyle&&(d=a.currentStyle.filter.match(E),d=d&&4===d.length?[d[0].substr(4),Number(d[2].substr(4)),Number(d[1].substr(4)),d[3].substr(4),h.x||0,h.y||0].join(\",\"):\"\"),c=!d||\"none\"===d||\"matrix(1, 0, 0, 1, 0, 0)\"===d,(h.svg||a.getBBox&&Ia(a))&&(c&&-1!==(a.style[ya]+\"\").indexOf(\"matrix\")&&(d=a.style[ya],c=0),e=a.getAttribute(\"transform\"),c&&e&&(-1!==e.indexOf(\"matrix\")?(d=e,c=0):-1!==e.indexOf(\"translate\")&&(d=\"matrix(1,0,0,1,\"+e.match(/(?:\\-|\\b)[\\d\\-\\.e]+\\b/gi).join(\",\")+\")\",c=0))),c)return Ja;for(e=(d||\"\").match(/(?:\\-|\\b)[\\d\\-\\.e]+\\b/gi)||[],sa=e.length;--sa>-1;)f=Number(e[sa]),e[sa]=(g=f-(f|=0))?(g*i+(0>g?-.5:.5)|0)/i+f:f;return b&&e.length>6?[e[0],e[1],e[4],e[5],e[12],e[13]]:e},La=O.getTransform=function(a,c,d,f){if(a._gsTransform&&d&&!f)return a._gsTransform;var h,i,j,k,l,m,n=d?a._gsTransform||new Ca:new Ca,o=n.scaleX<0,p=2e-5,q=1e5,r=Ba?parseFloat(X(a,Aa,c,!1,\"0 0 0\").split(\" \")[2])||n.zOrigin||0:0,s=parseFloat(g.defaultTransformPerspective)||0;if(n.svg=!(!a.getBBox||!Ia(a)),n.svg&&(Ha(a,X(a,Aa,e,!1,\"50% 50%\")+\"\",n,a.getAttribute(\"data-svg-origin\")),wa=g.useSVGTransformAttr||Ga),h=Ka(a),h!==Ja){if(16===h.length){var t,u,v,w,x,y=h[0],z=h[1],A=h[2],B=h[3],C=h[4],D=h[5],E=h[6],F=h[7],G=h[8],H=h[9],J=h[10],K=h[12],L=h[13],M=h[14],N=h[11],O=Math.atan2(E,J);n.zOrigin&&(M=-n.zOrigin,K=G*M-h[12],L=H*M-h[13],M=J*M+n.zOrigin-h[14]),n.rotationX=O*I,O&&(w=Math.cos(-O),x=Math.sin(-O),t=C*w+G*x,u=D*w+H*x,v=E*w+J*x,G=C*-x+G*w,H=D*-x+H*w,J=E*-x+J*w,N=F*-x+N*w,C=t,D=u,E=v),O=Math.atan2(-A,J),n.rotationY=O*I,O&&(w=Math.cos(-O),x=Math.sin(-O),t=y*w-G*x,u=z*w-H*x,v=A*w-J*x,H=z*x+H*w,J=A*x+J*w,N=B*x+N*w,y=t,z=u,A=v),O=Math.atan2(z,y),n.rotation=O*I,O&&(w=Math.cos(-O),x=Math.sin(-O),y=y*w+C*x,u=z*w+D*x,D=z*-x+D*w,E=A*-x+E*w,z=u),n.rotationX&&Math.abs(n.rotationX)+Math.abs(n.rotation)>359.9&&(n.rotationX=n.rotation=0,n.rotationY=180-n.rotationY),n.scaleX=(Math.sqrt(y*y+z*z)*q+.5|0)/q,n.scaleY=(Math.sqrt(D*D+H*H)*q+.5|0)/q,n.scaleZ=(Math.sqrt(E*E+J*J)*q+.5|0)/q,n.skewX=0,n.perspective=N?1/(0>N?-N:N):0,n.x=K,n.y=L,n.z=M,n.svg&&(n.x-=n.xOrigin-(n.xOrigin*y-n.yOrigin*C),n.y-=n.yOrigin-(n.yOrigin*z-n.xOrigin*D))}else if((!Ba||f||!h.length||n.x!==h[4]||n.y!==h[5]||!n.rotationX&&!n.rotationY)&&(void 0===n.x||\"none\"!==X(a,\"display\",c))){var P=h.length>=6,Q=P?h[0]:1,R=h[1]||0,S=h[2]||0,T=P?h[3]:1;n.x=h[4]||0,n.y=h[5]||0,j=Math.sqrt(Q*Q+R*R),k=Math.sqrt(T*T+S*S),l=Q||R?Math.atan2(R,Q)*I:n.rotation||0,m=S||T?Math.atan2(S,T)*I+l:n.skewX||0,Math.abs(m)>90&&Math.abs(m)<270&&(o?(j*=-1,m+=0>=l?180:-180,l+=0>=l?180:-180):(k*=-1,m+=0>=m?180:-180)),n.scaleX=j,n.scaleY=k,n.rotation=l,n.skewX=m,Ba&&(n.rotationX=n.rotationY=n.z=0,n.perspective=s,n.scaleZ=1),n.svg&&(n.x-=n.xOrigin-(n.xOrigin*Q+n.yOrigin*S),n.y-=n.yOrigin-(n.xOrigin*R+n.yOrigin*T))}n.zOrigin=r;for(i in n)n[i]<p&&n[i]>-p&&(n[i]=0)}return d&&(a._gsTransform=n,n.svg&&(wa&&a.style[ya]?b.delayedCall(.001,function(){Pa(a.style,ya)}):!wa&&a.getAttribute(\"transform\")&&b.delayedCall(.001,function(){a.removeAttribute(\"transform\")}))),n},Ma=function(a){var b,c,d=this.data,e=-d.rotation*H,f=e+d.skewX*H,g=1e5,h=(Math.cos(e)*d.scaleX*g|0)/g,i=(Math.sin(e)*d.scaleX*g|0)/g,j=(Math.sin(f)*-d.scaleY*g|0)/g,k=(Math.cos(f)*d.scaleY*g|0)/g,l=this.t.style,m=this.t.currentStyle;if(m){c=i,i=-j,j=-c,b=m.filter,l.filter=\"\";var n,o,q=this.t.offsetWidth,r=this.t.offsetHeight,s=\"absolute\"!==m.position,t=\"progid:DXImageTransform.Microsoft.Matrix(M11=\"+h+\", M12=\"+i+\", M21=\"+j+\", M22=\"+k,w=d.x+q*d.xPercent/100,x=d.y+r*d.yPercent/100;if(null!=d.ox&&(n=(d.oxp?q*d.ox*.01:d.ox)-q/2,o=(d.oyp?r*d.oy*.01:d.oy)-r/2,w+=n-(n*h+o*i),x+=o-(n*j+o*k)),s?(n=q/2,o=r/2,t+=\", Dx=\"+(n-(n*h+o*i)+w)+\", Dy=\"+(o-(n*j+o*k)+x)+\")\"):t+=\", sizingMethod='auto expand')\",-1!==b.indexOf(\"DXImageTransform.Microsoft.Matrix(\")?l.filter=b.replace(F,t):l.filter=t+\" \"+b,(0===a||1===a)&&1===h&&0===i&&0===j&&1===k&&(s&&-1===t.indexOf(\"Dx=0, Dy=0\")||v.test(b)&&100!==parseFloat(RegExp.$1)||-1===b.indexOf(b.indexOf(\"Alpha\"))&&l.removeAttribute(\"filter\")),!s){var y,z,A,B=8>p?1:-1;for(n=d.ieOffsetX||0,o=d.ieOffsetY||0,d.ieOffsetX=Math.round((q-((0>h?-h:h)*q+(0>i?-i:i)*r))/2+w),d.ieOffsetY=Math.round((r-((0>k?-k:k)*r+(0>j?-j:j)*q))/2+x),sa=0;4>sa;sa++)z=ba[sa],y=m[z],c=-1!==y.indexOf(\"px\")?parseFloat(y):Y(this.t,z,parseFloat(y),y.replace(u,\"\"))||0,A=c!==d[z]?2>sa?-d.ieOffsetX:-d.ieOffsetY:2>sa?n-d.ieOffsetX:o-d.ieOffsetY,l[z]=(d[z]=Math.round(c-A*(0===sa||2===sa?1:B)))+\"px\"}}},Na=O.set3DTransformRatio=O.setTransformRatio=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u,v,w,x,y,z=this.data,A=this.t.style,B=z.rotation,C=z.rotationX,D=z.rotationY,E=z.scaleX,F=z.scaleY,G=z.scaleZ,I=z.x,J=z.y,K=z.z,L=z.svg,M=z.perspective,N=z.force3D;if(((1===a||0===a)&&\"auto\"===N&&(this.tween._totalTime===this.tween._totalDuration||!this.tween._totalTime)||!N)&&!K&&!M&&!D&&!C&&1===G||wa&&L||!Ba)return void(B||z.skewX||L?(B*=H,x=z.skewX*H,y=1e5,b=Math.cos(B)*E,e=Math.sin(B)*E,c=Math.sin(B-x)*-F,f=Math.cos(B-x)*F,x&&\"simple\"===z.skewType&&(s=Math.tan(x),s=Math.sqrt(1+s*s),c*=s,f*=s,z.skewY&&(b*=s,e*=s)),L&&(I+=z.xOrigin-(z.xOrigin*b+z.yOrigin*c)+z.xOffset,J+=z.yOrigin-(z.xOrigin*e+z.yOrigin*f)+z.yOffset,wa&&(z.xPercent||z.yPercent)&&(p=this.t.getBBox(),I+=.01*z.xPercent*p.width,J+=.01*z.yPercent*p.height),p=1e-6,p>I&&I>-p&&(I=0),p>J&&J>-p&&(J=0)),u=(b*y|0)/y+\",\"+(e*y|0)/y+\",\"+(c*y|0)/y+\",\"+(f*y|0)/y+\",\"+I+\",\"+J+\")\",L&&wa?this.t.setAttribute(\"transform\",\"matrix(\"+u):A[ya]=(z.xPercent||z.yPercent?\"translate(\"+z.xPercent+\"%,\"+z.yPercent+\"%) matrix(\":\"matrix(\")+u):A[ya]=(z.xPercent||z.yPercent?\"translate(\"+z.xPercent+\"%,\"+z.yPercent+\"%) matrix(\":\"matrix(\")+E+\",0,0,\"+F+\",\"+I+\",\"+J+\")\");if(n&&(p=1e-4,p>E&&E>-p&&(E=G=2e-5),p>F&&F>-p&&(F=G=2e-5),!M||z.z||z.rotationX||z.rotationY||(M=0)),B||z.skewX)B*=H,q=b=Math.cos(B),r=e=Math.sin(B),z.skewX&&(B-=z.skewX*H,q=Math.cos(B),r=Math.sin(B),\"simple\"===z.skewType&&(s=Math.tan(z.skewX*H),s=Math.sqrt(1+s*s),q*=s,r*=s,z.skewY&&(b*=s,e*=s))),c=-r,f=q;else{if(!(D||C||1!==G||M||L))return void(A[ya]=(z.xPercent||z.yPercent?\"translate(\"+z.xPercent+\"%,\"+z.yPercent+\"%) translate3d(\":\"translate3d(\")+I+\"px,\"+J+\"px,\"+K+\"px)\"+(1!==E||1!==F?\" scale(\"+E+\",\"+F+\")\":\"\"));b=f=1,c=e=0}j=1,d=g=h=i=k=l=0,m=M?-1/M:0,o=z.zOrigin,p=1e-6,v=\",\",w=\"0\",B=D*H,B&&(q=Math.cos(B),r=Math.sin(B),h=-r,k=m*-r,d=b*r,g=e*r,j=q,m*=q,b*=q,e*=q),B=C*H,B&&(q=Math.cos(B),r=Math.sin(B),s=c*q+d*r,t=f*q+g*r,i=j*r,l=m*r,d=c*-r+d*q,g=f*-r+g*q,j*=q,m*=q,c=s,f=t),1!==G&&(d*=G,g*=G,j*=G,m*=G),1!==F&&(c*=F,f*=F,i*=F,l*=F),1!==E&&(b*=E,e*=E,h*=E,k*=E),(o||L)&&(o&&(I+=d*-o,J+=g*-o,K+=j*-o+o),L&&(I+=z.xOrigin-(z.xOrigin*b+z.yOrigin*c)+z.xOffset,J+=z.yOrigin-(z.xOrigin*e+z.yOrigin*f)+z.yOffset),p>I&&I>-p&&(I=w),p>J&&J>-p&&(J=w),p>K&&K>-p&&(K=0)),u=z.xPercent||z.yPercent?\"translate(\"+z.xPercent+\"%,\"+z.yPercent+\"%) matrix3d(\":\"matrix3d(\",u+=(p>b&&b>-p?w:b)+v+(p>e&&e>-p?w:e)+v+(p>h&&h>-p?w:h),u+=v+(p>k&&k>-p?w:k)+v+(p>c&&c>-p?w:c)+v+(p>f&&f>-p?w:f),C||D||1!==G?(u+=v+(p>i&&i>-p?w:i)+v+(p>l&&l>-p?w:l)+v+(p>d&&d>-p?w:d),u+=v+(p>g&&g>-p?w:g)+v+(p>j&&j>-p?w:j)+v+(p>m&&m>-p?w:m)+v):u+=\",0,0,0,0,1,0,\",u+=I+v+J+v+K+v+(M?1+-K/M:1)+\")\",A[ya]=u};j=Ca.prototype,j.x=j.y=j.z=j.skewX=j.skewY=j.rotation=j.rotationX=j.rotationY=j.zOrigin=j.xPercent=j.yPercent=j.xOffset=j.yOffset=0,j.scaleX=j.scaleY=j.scaleZ=1,ua(\"transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin\",{parser:function(a,b,c,d,f,h,i){if(d._lastParsedTransform===i)return f;d._lastParsedTransform=i;var j,k,l,m,n,o,p,q,r,s,t=a._gsTransform,u=a.style,v=1e-6,w=xa.length,x=i,y={},z=\"transformOrigin\";if(i.display?(m=X(a,\"display\"),u.display=\"block\",j=La(a,e,!0,i.parseTransform),u.display=m):j=La(a,e,!0,i.parseTransform),d._transform=j,\"string\"==typeof x.transform&&ya)m=M.style,m[ya]=x.transform,m.display=\"block\",m.position=\"absolute\",K.body.appendChild(M),k=La(M,null,!1),K.body.removeChild(M),k.perspective||(k.perspective=j.perspective),null!=x.xPercent&&(k.xPercent=fa(x.xPercent,j.xPercent)),null!=x.yPercent&&(k.yPercent=fa(x.yPercent,j.yPercent));else if(\"object\"==typeof x){if(k={scaleX:fa(null!=x.scaleX?x.scaleX:x.scale,j.scaleX),scaleY:fa(null!=x.scaleY?x.scaleY:x.scale,j.scaleY),scaleZ:fa(x.scaleZ,j.scaleZ),x:fa(x.x,j.x),y:fa(x.y,j.y),z:fa(x.z,j.z),xPercent:fa(x.xPercent,j.xPercent),yPercent:fa(x.yPercent,j.yPercent),perspective:fa(x.transformPerspective,j.perspective)},q=x.directionalRotation,null!=q)if(\"object\"==typeof q)for(m in q)x[m]=q[m];else x.rotation=q;\"string\"==typeof x.x&&-1!==x.x.indexOf(\"%\")&&(k.x=0,k.xPercent=fa(x.x,j.xPercent)),\"string\"==typeof x.y&&-1!==x.y.indexOf(\"%\")&&(k.y=0,k.yPercent=fa(x.y,j.yPercent)),k.rotation=ga(\"rotation\"in x?x.rotation:\"shortRotation\"in x?x.shortRotation+\"_short\":\"rotationZ\"in x?x.rotationZ:j.rotation,j.rotation,\"rotation\",y),Ba&&(k.rotationX=ga(\"rotationX\"in x?x.rotationX:\"shortRotationX\"in x?x.shortRotationX+\"_short\":j.rotationX||0,j.rotationX,\"rotationX\",y),k.rotationY=ga(\"rotationY\"in x?x.rotationY:\"shortRotationY\"in x?x.shortRotationY+\"_short\":j.rotationY||0,j.rotationY,\"rotationY\",y)),k.skewX=null==x.skewX?j.skewX:ga(x.skewX,j.skewX),k.skewY=null==x.skewY?j.skewY:ga(x.skewY,j.skewY),(l=k.skewY-j.skewY)&&(k.skewX+=l,k.rotation+=l)}for(Ba&&null!=x.force3D&&(j.force3D=x.force3D,p=!0),j.skewType=x.skewType||j.skewType||g.defaultSkewType,o=j.force3D||j.z||j.rotationX||j.rotationY||k.z||k.rotationX||k.rotationY||k.perspective,o||null==x.scale||(k.scaleZ=1);--w>-1;)c=xa[w],n=k[c]-j[c],(n>v||-v>n||null!=x[c]||null!=J[c])&&(p=!0,f=new pa(j,c,j[c],n,f),c in y&&(f.e=y[c]),f.xs0=0,f.plugin=h,d._overwriteProps.push(f.n));return n=x.transformOrigin,j.svg&&(n||x.svgOrigin)&&(r=j.xOffset,s=j.yOffset,Ha(a,da(n),k,x.svgOrigin,x.smoothOrigin),f=qa(j,\"xOrigin\",(t?j:k).xOrigin,k.xOrigin,f,z),f=qa(j,\"yOrigin\",(t?j:k).yOrigin,k.yOrigin,f,z),(r!==j.xOffset||s!==j.yOffset)&&(f=qa(j,\"xOffset\",t?r:j.xOffset,j.xOffset,f,z),f=qa(j,\"yOffset\",t?s:j.yOffset,j.yOffset,f,z)),n=wa?null:\"0px 0px\"),(n||Ba&&o&&j.zOrigin)&&(ya?(p=!0,c=Aa,n=(n||X(a,c,e,!1,\"50% 50%\"))+\"\",f=new pa(u,c,0,0,f,-1,z),f.b=u[c],f.plugin=h,Ba?(m=j.zOrigin,n=n.split(\" \"),j.zOrigin=(n.length>2&&(0===m||\"0px\"!==n[2])?parseFloat(n[2]):m)||0,f.xs0=f.e=n[0]+\" \"+(n[1]||\"50%\")+\" 0px\",f=new pa(j,\"zOrigin\",0,0,f,-1,f.n),f.b=m,f.xs0=f.e=j.zOrigin):f.xs0=f.e=n):da(n+\"\",j)),p&&(d._transformType=j.svg&&wa||!o&&3!==this._transformType?2:3),f},prefix:!0}),ua(\"boxShadow\",{defaultValue:\"0px 0px 0px 0px #999\",prefix:!0,color:!0,multi:!0,keyword:\"inset\"}),ua(\"borderRadius\",{defaultValue:\"0px\",parser:function(a,b,c,f,g,h){b=this.format(b);var i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y=[\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderBottomRightRadius\",\"borderBottomLeftRadius\"],z=a.style;for(q=parseFloat(a.offsetWidth),r=parseFloat(a.offsetHeight),i=b.split(\" \"),j=0;j<y.length;j++)this.p.indexOf(\"border\")&&(y[j]=V(y[j])),m=l=X(a,y[j],e,!1,\"0px\"),-1!==m.indexOf(\" \")&&(l=m.split(\" \"),m=l[0],l=l[1]),n=k=i[j],o=parseFloat(m),t=m.substr((o+\"\").length),u=\"=\"===n.charAt(1),u?(p=parseInt(n.charAt(0)+\"1\",10),n=n.substr(2),p*=parseFloat(n),s=n.substr((p+\"\").length-(0>p?1:0))||\"\"):(p=parseFloat(n),s=n.substr((p+\"\").length)),\"\"===s&&(s=d[c]||t),s!==t&&(v=Y(a,\"borderLeft\",o,t),w=Y(a,\"borderTop\",o,t),\"%\"===s?(m=v/q*100+\"%\",l=w/r*100+\"%\"):\"em\"===s?(x=Y(a,\"borderLeft\",1,\"em\"),m=v/x+\"em\",l=w/x+\"em\"):(m=v+\"px\",l=w+\"px\"),u&&(n=parseFloat(m)+p+s,k=parseFloat(l)+p+s)),g=ra(z,y[j],m+\" \"+l,n+\" \"+k,!1,\"0px\",g);return g},prefix:!0,formatter:ma(\"0px 0px 0px 0px\",!1,!0)}),ua(\"backgroundPosition\",{\ndefaultValue:\"0 0\",parser:function(a,b,c,d,f,g){var h,i,j,k,l,m,n=\"background-position\",o=e||W(a,null),q=this.format((o?p?o.getPropertyValue(n+\"-x\")+\" \"+o.getPropertyValue(n+\"-y\"):o.getPropertyValue(n):a.currentStyle.backgroundPositionX+\" \"+a.currentStyle.backgroundPositionY)||\"0 0\"),r=this.format(b);if(-1!==q.indexOf(\"%\")!=(-1!==r.indexOf(\"%\"))&&(m=X(a,\"backgroundImage\").replace(B,\"\"),m&&\"none\"!==m)){for(h=q.split(\" \"),i=r.split(\" \"),N.setAttribute(\"src\",m),j=2;--j>-1;)q=h[j],k=-1!==q.indexOf(\"%\"),k!==(-1!==i[j].indexOf(\"%\"))&&(l=0===j?a.offsetWidth-N.width:a.offsetHeight-N.height,h[j]=k?parseFloat(q)/100*l+\"px\":parseFloat(q)/l*100+\"%\");q=h.join(\" \")}return this.parseComplex(a.style,q,r,f,g)},formatter:da}),ua(\"backgroundSize\",{defaultValue:\"0 0\",formatter:da}),ua(\"perspective\",{defaultValue:\"0px\",prefix:!0}),ua(\"perspectiveOrigin\",{defaultValue:\"50% 50%\",prefix:!0}),ua(\"transformStyle\",{prefix:!0}),ua(\"backfaceVisibility\",{prefix:!0}),ua(\"userSelect\",{prefix:!0}),ua(\"margin\",{parser:na(\"marginTop,marginRight,marginBottom,marginLeft\")}),ua(\"padding\",{parser:na(\"paddingTop,paddingRight,paddingBottom,paddingLeft\")}),ua(\"clip\",{defaultValue:\"rect(0px,0px,0px,0px)\",parser:function(a,b,c,d,f,g){var h,i,j;return 9>p?(i=a.currentStyle,j=8>p?\" \":\",\",h=\"rect(\"+i.clipTop+j+i.clipRight+j+i.clipBottom+j+i.clipLeft+\")\",b=this.format(b).split(\",\").join(j)):(h=this.format(X(a,this.p,e,!1,this.dflt)),b=this.format(b)),this.parseComplex(a.style,h,b,f,g)}}),ua(\"textShadow\",{defaultValue:\"0px 0px 0px #999\",color:!0,multi:!0}),ua(\"autoRound,strictUnits\",{parser:function(a,b,c,d,e){return e}}),ua(\"border\",{defaultValue:\"0px solid #000\",parser:function(a,b,c,d,f,g){return this.parseComplex(a.style,this.format(X(a,\"borderTopWidth\",e,!1,\"0px\")+\" \"+X(a,\"borderTopStyle\",e,!1,\"solid\")+\" \"+X(a,\"borderTopColor\",e,!1,\"#000\")),this.format(b),f,g)},color:!0,formatter:function(a){var b=a.split(\" \");return b[0]+\" \"+(b[1]||\"solid\")+\" \"+(a.match(la)||[\"#000\"])[0]}}),ua(\"borderWidth\",{parser:na(\"borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth\")}),ua(\"float,cssFloat,styleFloat\",{parser:function(a,b,c,d,e,f){var g=a.style,h=\"cssFloat\"in g?\"cssFloat\":\"styleFloat\";return new pa(g,h,0,0,e,-1,c,!1,0,g[h],b)}});var Oa=function(a){var b,c=this.t,d=c.filter||X(this.data,\"filter\")||\"\",e=this.s+this.c*a|0;100===e&&(-1===d.indexOf(\"atrix(\")&&-1===d.indexOf(\"radient(\")&&-1===d.indexOf(\"oader(\")?(c.removeAttribute(\"filter\"),b=!X(this.data,\"filter\")):(c.filter=d.replace(x,\"\"),b=!0)),b||(this.xn1&&(c.filter=d=d||\"alpha(opacity=\"+e+\")\"),-1===d.indexOf(\"pacity\")?0===e&&this.xn1||(c.filter=d+\" alpha(opacity=\"+e+\")\"):c.filter=d.replace(v,\"opacity=\"+e))};ua(\"opacity,alpha,autoAlpha\",{defaultValue:\"1\",parser:function(a,b,c,d,f,g){var h=parseFloat(X(a,\"opacity\",e,!1,\"1\")),i=a.style,j=\"autoAlpha\"===c;return\"string\"==typeof b&&\"=\"===b.charAt(1)&&(b=(\"-\"===b.charAt(0)?-1:1)*parseFloat(b.substr(2))+h),j&&1===h&&\"hidden\"===X(a,\"visibility\",e)&&0!==b&&(h=0),Q?f=new pa(i,\"opacity\",h,b-h,f):(f=new pa(i,\"opacity\",100*h,100*(b-h),f),f.xn1=j?1:0,i.zoom=1,f.type=2,f.b=\"alpha(opacity=\"+f.s+\")\",f.e=\"alpha(opacity=\"+(f.s+f.c)+\")\",f.data=a,f.plugin=g,f.setRatio=Oa),j&&(f=new pa(i,\"visibility\",0,0,f,-1,null,!1,0,0!==h?\"inherit\":\"hidden\",0===b?\"hidden\":\"inherit\"),f.xs0=\"inherit\",d._overwriteProps.push(f.n),d._overwriteProps.push(c)),f}});var Pa=function(a,b){b&&(a.removeProperty?((\"ms\"===b.substr(0,2)||\"webkit\"===b.substr(0,6))&&(b=\"-\"+b),a.removeProperty(b.replace(z,\"-$1\").toLowerCase())):a.removeAttribute(b))},Qa=function(a){if(this.t._gsClassPT=this,1===a||0===a){this.t.setAttribute(\"class\",0===a?this.b:this.e);for(var b=this.data,c=this.t.style;b;)b.v?c[b.p]=b.v:Pa(c,b.p),b=b._next;1===a&&this.t._gsClassPT===this&&(this.t._gsClassPT=null)}else this.t.getAttribute(\"class\")!==this.e&&this.t.setAttribute(\"class\",this.e)};ua(\"className\",{parser:function(a,b,d,f,g,h,i){var j,k,l,m,n,o=a.getAttribute(\"class\")||\"\",p=a.style.cssText;if(g=f._classNamePT=new pa(a,d,0,0,g,2),g.setRatio=Qa,g.pr=-11,c=!0,g.b=o,k=$(a,e),l=a._gsClassPT){for(m={},n=l.data;n;)m[n.p]=1,n=n._next;l.setRatio(1)}return a._gsClassPT=g,g.e=\"=\"!==b.charAt(1)?b:o.replace(new RegExp(\"\\\\s*\\\\b\"+b.substr(2)+\"\\\\b\"),\"\")+(\"+\"===b.charAt(0)?\" \"+b.substr(2):\"\"),a.setAttribute(\"class\",g.e),j=_(a,k,$(a),i,m),a.setAttribute(\"class\",o),g.data=j.firstMPT,a.style.cssText=p,g=g.xfirst=f.parse(a,j.difs,g,h)}});var Ra=function(a){if((1===a||0===a)&&this.data._totalTime===this.data._totalDuration&&\"isFromStart\"!==this.data.data){var b,c,d,e,f,g=this.t.style,h=i.transform.parse;if(\"all\"===this.e)g.cssText=\"\",e=!0;else for(b=this.e.split(\" \").join(\"\").split(\",\"),d=b.length;--d>-1;)c=b[d],i[c]&&(i[c].parse===h?e=!0:c=\"transformOrigin\"===c?Aa:i[c].p),Pa(g,c);e&&(Pa(g,ya),f=this.t._gsTransform,f&&(f.svg&&(this.t.removeAttribute(\"data-svg-origin\"),this.t.removeAttribute(\"transform\")),delete this.t._gsTransform))}};for(ua(\"clearProps\",{parser:function(a,b,d,e,f){return f=new pa(a,d,0,0,f,2),f.setRatio=Ra,f.e=b,f.pr=-10,f.data=e._tween,c=!0,f}}),j=\"bezier,throwProps,physicsProps,physics2D\".split(\",\"),sa=j.length;sa--;)va(j[sa]);j=g.prototype,j._firstPT=j._lastParsedTransform=j._transform=null,j._onInitTween=function(a,b,h){if(!a.nodeType)return!1;this._target=a,this._tween=h,this._vars=b,k=b.autoRound,c=!1,d=b.suffixMap||g.suffixMap,e=W(a,\"\"),f=this._overwriteProps;var j,n,p,q,r,s,t,u,v,x=a.style;if(l&&\"\"===x.zIndex&&(j=X(a,\"zIndex\",e),(\"auto\"===j||\"\"===j)&&this._addLazySet(x,\"zIndex\",0)),\"string\"==typeof b&&(q=x.cssText,j=$(a,e),x.cssText=q+\";\"+b,j=_(a,j,$(a)).difs,!Q&&w.test(b)&&(j.opacity=parseFloat(RegExp.$1)),b=j,x.cssText=q),b.className?this._firstPT=n=i.className.parse(a,b.className,\"className\",this,null,null,b):this._firstPT=n=this.parse(a,b,null),this._transformType){for(v=3===this._transformType,ya?m&&(l=!0,\"\"===x.zIndex&&(t=X(a,\"zIndex\",e),(\"auto\"===t||\"\"===t)&&this._addLazySet(x,\"zIndex\",0)),o&&this._addLazySet(x,\"WebkitBackfaceVisibility\",this._vars.WebkitBackfaceVisibility||(v?\"visible\":\"hidden\"))):x.zoom=1,p=n;p&&p._next;)p=p._next;u=new pa(a,\"transform\",0,0,null,2),this._linkCSSP(u,null,p),u.setRatio=ya?Na:Ma,u.data=this._transform||La(a,e,!0),u.tween=h,u.pr=-1,f.pop()}if(c){for(;n;){for(s=n._next,p=q;p&&p.pr>n.pr;)p=p._next;(n._prev=p?p._prev:r)?n._prev._next=n:q=n,(n._next=p)?p._prev=n:r=n,n=s}this._firstPT=q}return!0},j.parse=function(a,b,c,f){var g,h,j,l,m,n,o,p,q,r,s=a.style;for(g in b)n=b[g],h=i[g],h?c=h.parse(a,n,g,this,c,f,b):(m=X(a,g,e)+\"\",q=\"string\"==typeof n,\"color\"===g||\"fill\"===g||\"stroke\"===g||-1!==g.indexOf(\"Color\")||q&&y.test(n)?(q||(n=ja(n),n=(n.length>3?\"rgba(\":\"rgb(\")+n.join(\",\")+\")\"),c=ra(s,g,m,n,!0,\"transparent\",c,0,f)):!q||-1===n.indexOf(\" \")&&-1===n.indexOf(\",\")?(j=parseFloat(m),o=j||0===j?m.substr((j+\"\").length):\"\",(\"\"===m||\"auto\"===m)&&(\"width\"===g||\"height\"===g?(j=ca(a,g,e),o=\"px\"):\"left\"===g||\"top\"===g?(j=Z(a,g,e),o=\"px\"):(j=\"opacity\"!==g?0:1,o=\"\")),r=q&&\"=\"===n.charAt(1),r?(l=parseInt(n.charAt(0)+\"1\",10),n=n.substr(2),l*=parseFloat(n),p=n.replace(u,\"\")):(l=parseFloat(n),p=q?n.replace(u,\"\"):\"\"),\"\"===p&&(p=g in d?d[g]:o),n=l||0===l?(r?l+j:l)+p:b[g],o!==p&&\"\"!==p&&(l||0===l)&&j&&(j=Y(a,g,j,o),\"%\"===p?(j/=Y(a,g,100,\"%\")/100,b.strictUnits!==!0&&(m=j+\"%\")):\"em\"===p||\"rem\"===p||\"vw\"===p||\"vh\"===p?j/=Y(a,g,1,p):\"px\"!==p&&(l=Y(a,g,l,p),p=\"px\"),r&&(l||0===l)&&(n=l+j+p)),r&&(l+=j),!j&&0!==j||!l&&0!==l?void 0!==s[g]&&(n||n+\"\"!=\"NaN\"&&null!=n)?(c=new pa(s,g,l||j||0,0,c,-1,g,!1,0,m,n),c.xs0=\"none\"!==n||\"display\"!==g&&-1===g.indexOf(\"Style\")?n:m):S(\"invalid \"+g+\" tween value: \"+b[g]):(c=new pa(s,g,j,l-j,c,0,g,k!==!1&&(\"px\"===p||\"zIndex\"===g),0,m,n),c.xs0=p)):c=ra(s,g,m,n,!0,null,c,0,f)),f&&c&&!c.plugin&&(c.plugin=f);return c},j.setRatio=function(a){var b,c,d,e=this._firstPT,f=1e-6;if(1!==a||this._tween._time!==this._tween._duration&&0!==this._tween._time)if(a||this._tween._time!==this._tween._duration&&0!==this._tween._time||this._tween._rawPrevTime===-1e-6)for(;e;){if(b=e.c*a+e.s,e.r?b=Math.round(b):f>b&&b>-f&&(b=0),e.type)if(1===e.type)if(d=e.l,2===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2;else if(3===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2+e.xn2+e.xs3;else if(4===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2+e.xn2+e.xs3+e.xn3+e.xs4;else if(5===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2+e.xn2+e.xs3+e.xn3+e.xs4+e.xn4+e.xs5;else{for(c=e.xs0+b+e.xs1,d=1;d<e.l;d++)c+=e[\"xn\"+d]+e[\"xs\"+(d+1)];e.t[e.p]=c}else-1===e.type?e.t[e.p]=e.xs0:e.setRatio&&e.setRatio(a);else e.t[e.p]=b+e.xs0;e=e._next}else for(;e;)2!==e.type?e.t[e.p]=e.b:e.setRatio(a),e=e._next;else for(;e;){if(2!==e.type)if(e.r&&-1!==e.type)if(b=Math.round(e.s+e.c),e.type){if(1===e.type){for(d=e.l,c=e.xs0+b+e.xs1,d=1;d<e.l;d++)c+=e[\"xn\"+d]+e[\"xs\"+(d+1)];e.t[e.p]=c}}else e.t[e.p]=b+e.xs0;else e.t[e.p]=e.e;else e.setRatio(a);e=e._next}},j._enableTransforms=function(a){this._transform=this._transform||La(this._target,e,!0),this._transformType=this._transform.svg&&wa||!a&&3!==this._transformType?2:3};var Sa=function(a){this.t[this.p]=this.e,this.data._linkCSSP(this,this._next,null,!0)};j._addLazySet=function(a,b,c){var d=this._firstPT=new pa(a,b,0,0,this._firstPT,2);d.e=c,d.setRatio=Sa,d.data=this},j._linkCSSP=function(a,b,c,d){return a&&(b&&(b._prev=a),a._next&&(a._next._prev=a._prev),a._prev?a._prev._next=a._next:this._firstPT===a&&(this._firstPT=a._next,d=!0),c?c._next=a:d||null!==this._firstPT||(this._firstPT=a),a._next=b,a._prev=c),a},j._kill=function(b){var c,d,e,f=b;if(b.autoAlpha||b.alpha){f={};for(d in b)f[d]=b[d];f.opacity=1,f.autoAlpha&&(f.visibility=1)}return b.className&&(c=this._classNamePT)&&(e=c.xfirst,e&&e._prev?this._linkCSSP(e._prev,c._next,e._prev._prev):e===this._firstPT&&(this._firstPT=c._next),c._next&&this._linkCSSP(c._next,c._next._next,e._prev),this._classNamePT=null),a.prototype._kill.call(this,f)};var Ta=function(a,b,c){var d,e,f,g;if(a.slice)for(e=a.length;--e>-1;)Ta(a[e],b,c);else for(d=a.childNodes,e=d.length;--e>-1;)f=d[e],g=f.type,f.style&&(b.push($(f)),c&&c.push(f)),1!==g&&9!==g&&11!==g||!f.childNodes.length||Ta(f,b,c)};return g.cascadeTo=function(a,c,d){var e,f,g,h,i=b.to(a,c,d),j=[i],k=[],l=[],m=[],n=b._internals.reservedProps;for(a=i._targets||i.target,Ta(a,k,m),i.render(c,!0,!0),Ta(a,l),i.render(0,!0,!0),i._enabled(!0),e=m.length;--e>-1;)if(f=_(m[e],k[e],l[e]),f.firstMPT){f=f.difs;for(g in d)n[g]&&(f[g]=d[g]);h={};for(g in f)h[g]=k[e][g];j.push(b.fromTo(m[e],c,h,f))}return j},a.activate([g]),g},!0),function(){var a=_gsScope._gsDefine.plugin({propName:\"roundProps\",version:\"1.5\",priority:-1,API:2,init:function(a,b,c){return this._tween=c,!0}}),b=function(a){for(;a;)a.f||a.blob||(a.r=1),a=a._next},c=a.prototype;c._onInitAllProps=function(){for(var a,c,d,e=this._tween,f=e.vars.roundProps.join?e.vars.roundProps:e.vars.roundProps.split(\",\"),g=f.length,h={},i=e._propLookup.roundProps;--g>-1;)h[f[g]]=1;for(g=f.length;--g>-1;)for(a=f[g],c=e._firstPT;c;)d=c._next,c.pg?c.t._roundProps(h,!0):c.n===a&&(2===c.f&&c.t?b(c.t._firstPT):(this._add(c.t,a,c.s,c.c),d&&(d._prev=c._prev),c._prev?c._prev._next=d:e._firstPT===c&&(e._firstPT=d),c._next=c._prev=null,e._propLookup[a]=i)),c=d;return!1},c._add=function(a,b,c,d){this._addTween(a,b,c,c+d,b,!0),this._overwriteProps.push(b)}}(),function(){_gsScope._gsDefine.plugin({propName:\"attr\",API:2,version:\"0.5.0\",init:function(a,b,c){var d;if(\"function\"!=typeof a.setAttribute)return!1;for(d in b)this._addTween(a,\"setAttribute\",a.getAttribute(d)+\"\",b[d]+\"\",d,!1,d),this._overwriteProps.push(d);return!0}})}(),_gsScope._gsDefine.plugin({propName:\"directionalRotation\",version:\"0.2.1\",API:2,init:function(a,b,c){\"object\"!=typeof b&&(b={rotation:b}),this.finals={};var d,e,f,g,h,i,j=b.useRadians===!0?2*Math.PI:360,k=1e-6;for(d in b)\"useRadians\"!==d&&(i=(b[d]+\"\").split(\"_\"),e=i[0],f=parseFloat(\"function\"!=typeof a[d]?a[d]:a[d.indexOf(\"set\")||\"function\"!=typeof a[\"get\"+d.substr(3)]?d:\"get\"+d.substr(3)]()),g=this.finals[d]=\"string\"==typeof e&&\"=\"===e.charAt(1)?f+parseInt(e.charAt(0)+\"1\",10)*Number(e.substr(2)):Number(e)||0,h=g-f,i.length&&(e=i.join(\"_\"),-1!==e.indexOf(\"short\")&&(h%=j,h!==h%(j/2)&&(h=0>h?h+j:h-j)),-1!==e.indexOf(\"_cw\")&&0>h?h=(h+9999999999*j)%j-(h/j|0)*j:-1!==e.indexOf(\"ccw\")&&h>0&&(h=(h-9999999999*j)%j-(h/j|0)*j)),(h>k||-k>h)&&(this._addTween(a,d,f,f+h,d),this._overwriteProps.push(d)));return!0},set:function(a){var b;if(1!==a)this._super.setRatio.call(this,a);else for(b=this._firstPT;b;)b.f?b.t[b.p](this.finals[b.p]):b.t[b.p]=this.finals[b.p],b=b._next}})._autoCSS=!0,_gsScope._gsDefine(\"easing.Back\",[\"easing.Ease\"],function(a){var b,c,d,e=_gsScope.GreenSockGlobals||_gsScope,f=e.com.greensock,g=2*Math.PI,h=Math.PI/2,i=f._class,j=function(b,c){var d=i(\"easing.\"+b,function(){},!0),e=d.prototype=new a;return e.constructor=d,e.getRatio=c,d},k=a.register||function(){},l=function(a,b,c,d,e){var f=i(\"easing.\"+a,{easeOut:new b,easeIn:new c,easeInOut:new d},!0);return k(f,a),f},m=function(a,b,c){this.t=a,this.v=b,c&&(this.next=c,c.prev=this,this.c=c.v-b,this.gap=c.t-a)},n=function(b,c){var d=i(\"easing.\"+b,function(a){this._p1=a||0===a?a:1.70158,this._p2=1.525*this._p1},!0),e=d.prototype=new a;return e.constructor=d,e.getRatio=c,e.config=function(a){return new d(a)},d},o=l(\"Back\",n(\"BackOut\",function(a){return(a-=1)*a*((this._p1+1)*a+this._p1)+1}),n(\"BackIn\",function(a){return a*a*((this._p1+1)*a-this._p1)}),n(\"BackInOut\",function(a){return(a*=2)<1?.5*a*a*((this._p2+1)*a-this._p2):.5*((a-=2)*a*((this._p2+1)*a+this._p2)+2)})),p=i(\"easing.SlowMo\",function(a,b,c){b=b||0===b?b:.7,null==a?a=.7:a>1&&(a=1),this._p=1!==a?b:0,this._p1=(1-a)/2,this._p2=a,this._p3=this._p1+this._p2,this._calcEnd=c===!0},!0),q=p.prototype=new a;return q.constructor=p,q.getRatio=function(a){var b=a+(.5-a)*this._p;return a<this._p1?this._calcEnd?1-(a=1-a/this._p1)*a:b-(a=1-a/this._p1)*a*a*a*b:a>this._p3?this._calcEnd?1-(a=(a-this._p3)/this._p1)*a:b+(a-b)*(a=(a-this._p3)/this._p1)*a*a*a:this._calcEnd?1:b},p.ease=new p(.7,.7),q.config=p.config=function(a,b,c){return new p(a,b,c)},b=i(\"easing.SteppedEase\",function(a){a=a||1,this._p1=1/a,this._p2=a+1},!0),q=b.prototype=new a,q.constructor=b,q.getRatio=function(a){return 0>a?a=0:a>=1&&(a=.999999999),(this._p2*a>>0)*this._p1},q.config=b.config=function(a){return new b(a)},c=i(\"easing.RoughEase\",function(b){b=b||{};for(var c,d,e,f,g,h,i=b.taper||\"none\",j=[],k=0,l=0|(b.points||20),n=l,o=b.randomize!==!1,p=b.clamp===!0,q=b.template instanceof a?b.template:null,r=\"number\"==typeof b.strength?.4*b.strength:.4;--n>-1;)c=o?Math.random():1/l*n,d=q?q.getRatio(c):c,\"none\"===i?e=r:\"out\"===i?(f=1-c,e=f*f*r):\"in\"===i?e=c*c*r:.5>c?(f=2*c,e=f*f*.5*r):(f=2*(1-c),e=f*f*.5*r),o?d+=Math.random()*e-.5*e:n%2?d+=.5*e:d-=.5*e,p&&(d>1?d=1:0>d&&(d=0)),j[k++]={x:c,y:d};for(j.sort(function(a,b){return a.x-b.x}),h=new m(1,1,null),n=l;--n>-1;)g=j[n],h=new m(g.x,g.y,h);this._prev=new m(0,0,0!==h.t?h:h.next)},!0),q=c.prototype=new a,q.constructor=c,q.getRatio=function(a){var b=this._prev;if(a>b.t){for(;b.next&&a>=b.t;)b=b.next;b=b.prev}else for(;b.prev&&a<=b.t;)b=b.prev;return this._prev=b,b.v+(a-b.t)/b.gap*b.c},q.config=function(a){return new c(a)},c.ease=new c,l(\"Bounce\",j(\"BounceOut\",function(a){return 1/2.75>a?7.5625*a*a:2/2.75>a?7.5625*(a-=1.5/2.75)*a+.75:2.5/2.75>a?7.5625*(a-=2.25/2.75)*a+.9375:7.5625*(a-=2.625/2.75)*a+.984375}),j(\"BounceIn\",function(a){return(a=1-a)<1/2.75?1-7.5625*a*a:2/2.75>a?1-(7.5625*(a-=1.5/2.75)*a+.75):2.5/2.75>a?1-(7.5625*(a-=2.25/2.75)*a+.9375):1-(7.5625*(a-=2.625/2.75)*a+.984375)}),j(\"BounceInOut\",function(a){var b=.5>a;return a=b?1-2*a:2*a-1,a=1/2.75>a?7.5625*a*a:2/2.75>a?7.5625*(a-=1.5/2.75)*a+.75:2.5/2.75>a?7.5625*(a-=2.25/2.75)*a+.9375:7.5625*(a-=2.625/2.75)*a+.984375,b?.5*(1-a):.5*a+.5})),l(\"Circ\",j(\"CircOut\",function(a){return Math.sqrt(1-(a-=1)*a)}),j(\"CircIn\",function(a){return-(Math.sqrt(1-a*a)-1)}),j(\"CircInOut\",function(a){return(a*=2)<1?-.5*(Math.sqrt(1-a*a)-1):.5*(Math.sqrt(1-(a-=2)*a)+1)})),d=function(b,c,d){var e=i(\"easing.\"+b,function(a,b){this._p1=a>=1?a:1,this._p2=(b||d)/(1>a?a:1),this._p3=this._p2/g*(Math.asin(1/this._p1)||0),this._p2=g/this._p2},!0),f=e.prototype=new a;return f.constructor=e,f.getRatio=c,f.config=function(a,b){return new e(a,b)},e},l(\"Elastic\",d(\"ElasticOut\",function(a){return this._p1*Math.pow(2,-10*a)*Math.sin((a-this._p3)*this._p2)+1},.3),d(\"ElasticIn\",function(a){return-(this._p1*Math.pow(2,10*(a-=1))*Math.sin((a-this._p3)*this._p2))},.3),d(\"ElasticInOut\",function(a){return(a*=2)<1?-.5*(this._p1*Math.pow(2,10*(a-=1))*Math.sin((a-this._p3)*this._p2)):this._p1*Math.pow(2,-10*(a-=1))*Math.sin((a-this._p3)*this._p2)*.5+1},.45)),l(\"Expo\",j(\"ExpoOut\",function(a){return 1-Math.pow(2,-10*a)}),j(\"ExpoIn\",function(a){return Math.pow(2,10*(a-1))-.001}),j(\"ExpoInOut\",function(a){return(a*=2)<1?.5*Math.pow(2,10*(a-1)):.5*(2-Math.pow(2,-10*(a-1)))})),l(\"Sine\",j(\"SineOut\",function(a){return Math.sin(a*h)}),j(\"SineIn\",function(a){return-Math.cos(a*h)+1}),j(\"SineInOut\",function(a){return-.5*(Math.cos(Math.PI*a)-1)})),i(\"easing.EaseLookup\",{find:function(b){return a.map[b]}},!0),k(e.SlowMo,\"SlowMo\",\"ease,\"),k(c,\"RoughEase\",\"ease,\"),k(b,\"SteppedEase\",\"ease,\"),o},!0)}),_gsScope._gsDefine&&_gsScope._gsQueue.pop()(),function(a,b){\"use strict\";var c=a.GreenSockGlobals=a.GreenSockGlobals||a;if(!c.TweenLite){var d,e,f,g,h,i=function(a){var b,d=a.split(\".\"),e=c;for(b=0;b<d.length;b++)e[d[b]]=e=e[d[b]]||{};return e},j=i(\"com.greensock\"),k=1e-10,l=function(a){var b,c=[],d=a.length;for(b=0;b!==d;c.push(a[b++]));return c},m=function(){},n=function(){var a=Object.prototype.toString,b=a.call([]);return function(c){return null!=c&&(c instanceof Array||\"object\"==typeof c&&!!c.push&&a.call(c)===b)}}(),o={},p=function(d,e,f,g){this.sc=o[d]?o[d].sc:[],o[d]=this,this.gsClass=null,this.func=f;var h=[];this.check=function(j){for(var k,l,m,n,q,r=e.length,s=r;--r>-1;)(k=o[e[r]]||new p(e[r],[])).gsClass?(h[r]=k.gsClass,s--):j&&k.sc.push(this);if(0===s&&f)for(l=(\"com.greensock.\"+d).split(\".\"),m=l.pop(),n=i(l.join(\".\"))[m]=this.gsClass=f.apply(f,h),g&&(c[m]=n,q=\"undefined\"!=typeof module&&module.exports,!q&&\"function\"==typeof define&&define.amd?define((a.GreenSockAMDPath?a.GreenSockAMDPath+\"/\":\"\")+d.split(\".\").pop(),[],function(){return n}):d===b&&q&&(module.exports=n)),r=0;r<this.sc.length;r++)this.sc[r].check()},this.check(!0)},q=a._gsDefine=function(a,b,c,d){return new p(a,b,c,d)},r=j._class=function(a,b,c){return b=b||function(){},q(a,[],function(){return b},c),b};q.globals=c;var s=[0,0,1,1],t=[],u=r(\"easing.Ease\",function(a,b,c,d){this._func=a,this._type=c||0,this._power=d||0,this._params=b?s.concat(b):s},!0),v=u.map={},w=u.register=function(a,b,c,d){for(var e,f,g,h,i=b.split(\",\"),k=i.length,l=(c||\"easeIn,easeOut,easeInOut\").split(\",\");--k>-1;)for(f=i[k],e=d?r(\"easing.\"+f,null,!0):j.easing[f]||{},g=l.length;--g>-1;)h=l[g],v[f+\".\"+h]=v[h+f]=e[h]=a.getRatio?a:a[h]||new a};for(f=u.prototype,f._calcEnd=!1,f.getRatio=function(a){if(this._func)return this._params[0]=a,this._func.apply(null,this._params);var b=this._type,c=this._power,d=1===b?1-a:2===b?a:.5>a?2*a:2*(1-a);return 1===c?d*=d:2===c?d*=d*d:3===c?d*=d*d*d:4===c&&(d*=d*d*d*d),1===b?1-d:2===b?d:.5>a?d/2:1-d/2},d=[\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint,Strong\"],e=d.length;--e>-1;)f=d[e]+\",Power\"+e,w(new u(null,null,1,e),f,\"easeOut\",!0),w(new u(null,null,2,e),f,\"easeIn\"+(0===e?\",easeNone\":\"\")),w(new u(null,null,3,e),f,\"easeInOut\");v.linear=j.easing.Linear.easeIn,v.swing=j.easing.Quad.easeInOut;var x=r(\"events.EventDispatcher\",function(a){this._listeners={},this._eventTarget=a||this});f=x.prototype,f.addEventListener=function(a,b,c,d,e){e=e||0;var f,i,j=this._listeners[a],k=0;for(null==j&&(this._listeners[a]=j=[]),i=j.length;--i>-1;)f=j[i],f.c===b&&f.s===c?j.splice(i,1):0===k&&f.pr<e&&(k=i+1);j.splice(k,0,{c:b,s:c,up:d,pr:e}),this!==g||h||g.wake()},f.removeEventListener=function(a,b){var c,d=this._listeners[a];if(d)for(c=d.length;--c>-1;)if(d[c].c===b)return void d.splice(c,1)},f.dispatchEvent=function(a){var b,c,d,e=this._listeners[a];if(e)for(b=e.length,c=this._eventTarget;--b>-1;)d=e[b],d&&(d.up?d.c.call(d.s||c,{type:a,target:c}):d.c.call(d.s||c))};var y=a.requestAnimationFrame,z=a.cancelAnimationFrame,A=Date.now||function(){return(new Date).getTime()},B=A();for(d=[\"ms\",\"moz\",\"webkit\",\"o\"],e=d.length;--e>-1&&!y;)y=a[d[e]+\"RequestAnimationFrame\"],z=a[d[e]+\"CancelAnimationFrame\"]||a[d[e]+\"CancelRequestAnimationFrame\"];r(\"Ticker\",function(a,b){var c,d,e,f,i,j=this,l=A(),n=b!==!1&&y?\"auto\":!1,o=500,p=33,q=\"tick\",r=function(a){var b,g,h=A()-B;h>o&&(l+=h-p),B+=h,j.time=(B-l)/1e3,b=j.time-i,(!c||b>0||a===!0)&&(j.frame++,i+=b+(b>=f?.004:f-b),g=!0),a!==!0&&(e=d(r)),g&&j.dispatchEvent(q)};x.call(j),j.time=j.frame=0,j.tick=function(){r(!0)},j.lagSmoothing=function(a,b){o=a||1/k,p=Math.min(b,o,0)},j.sleep=function(){null!=e&&(n&&z?z(e):clearTimeout(e),d=m,e=null,j===g&&(h=!1))},j.wake=function(a){null!==e?j.sleep():a?l+=-B+(B=A()):j.frame>10&&(B=A()-o+5),d=0===c?m:n&&y?y:function(a){return setTimeout(a,1e3*(i-j.time)+1|0)},j===g&&(h=!0),r(2)},j.fps=function(a){return arguments.length?(c=a,f=1/(c||60),i=this.time+f,void j.wake()):c},j.useRAF=function(a){return arguments.length?(j.sleep(),n=a,void j.fps(c)):n},j.fps(a),setTimeout(function(){\"auto\"===n&&j.frame<5&&\"hidden\"!==document.visibilityState&&j.useRAF(!1)},1500)}),f=j.Ticker.prototype=new j.events.EventDispatcher,f.constructor=j.Ticker;var C=r(\"core.Animation\",function(a,b){if(this.vars=b=b||{},this._duration=this._totalDuration=a||0,this._delay=Number(b.delay)||0,this._timeScale=1,this._active=b.immediateRender===!0,this.data=b.data,this._reversed=b.reversed===!0,V){h||g.wake();var c=this.vars.useFrames?U:V;c.add(this,c._time),this.vars.paused&&this.paused(!0)}});g=C.ticker=new j.Ticker,f=C.prototype,f._dirty=f._gc=f._initted=f._paused=!1,f._totalTime=f._time=0,f._rawPrevTime=-1,f._next=f._last=f._onUpdate=f._timeline=f.timeline=null,f._paused=!1;var D=function(){h&&A()-B>2e3&&g.wake(),setTimeout(D,2e3)};D(),f.play=function(a,b){return null!=a&&this.seek(a,b),this.reversed(!1).paused(!1)},f.pause=function(a,b){return null!=a&&this.seek(a,b),this.paused(!0)},f.resume=function(a,b){return null!=a&&this.seek(a,b),this.paused(!1)},f.seek=function(a,b){return this.totalTime(Number(a),b!==!1)},f.restart=function(a,b){return this.reversed(!1).paused(!1).totalTime(a?-this._delay:0,b!==!1,!0)},f.reverse=function(a,b){return null!=a&&this.seek(a||this.totalDuration(),b),this.reversed(!0).paused(!1)},f.render=function(a,b,c){},f.invalidate=function(){return this._time=this._totalTime=0,this._initted=this._gc=!1,this._rawPrevTime=-1,(this._gc||!this.timeline)&&this._enabled(!0),this},f.isActive=function(){var a,b=this._timeline,c=this._startTime;return!b||!this._gc&&!this._paused&&b.isActive()&&(a=b.rawTime())>=c&&a<c+this.totalDuration()/this._timeScale},f._enabled=function(a,b){return h||g.wake(),this._gc=!a,this._active=this.isActive(),b!==!0&&(a&&!this.timeline?this._timeline.add(this,this._startTime-this._delay):!a&&this.timeline&&this._timeline._remove(this,!0)),!1},f._kill=function(a,b){return this._enabled(!1,!1)},f.kill=function(a,b){return this._kill(a,b),this},f._uncache=function(a){for(var b=a?this:this.timeline;b;)b._dirty=!0,b=b.timeline;return this},f._swapSelfInParams=function(a){for(var b=a.length,c=a.concat();--b>-1;)\"{self}\"===a[b]&&(c[b]=this);return c},f._callback=function(a){var b=this.vars;b[a].apply(b[a+\"Scope\"]||b.callbackScope||this,b[a+\"Params\"]||t)},f.eventCallback=function(a,b,c,d){if(\"on\"===(a||\"\").substr(0,2)){var e=this.vars;if(1===arguments.length)return e[a];null==b?delete e[a]:(e[a]=b,e[a+\"Params\"]=n(c)&&-1!==c.join(\"\").indexOf(\"{self}\")?this._swapSelfInParams(c):c,e[a+\"Scope\"]=d),\"onUpdate\"===a&&(this._onUpdate=b)}return this},f.delay=function(a){return arguments.length?(this._timeline.smoothChildTiming&&this.startTime(this._startTime+a-this._delay),this._delay=a,this):this._delay},f.duration=function(a){return arguments.length?(this._duration=this._totalDuration=a,this._uncache(!0),this._timeline.smoothChildTiming&&this._time>0&&this._time<this._duration&&0!==a&&this.totalTime(this._totalTime*(a/this._duration),!0),this):(this._dirty=!1,this._duration)},f.totalDuration=function(a){return this._dirty=!1,arguments.length?this.duration(a):this._totalDuration},f.time=function(a,b){return arguments.length?(this._dirty&&this.totalDuration(),this.totalTime(a>this._duration?this._duration:a,b)):this._time},f.totalTime=function(a,b,c){if(h||g.wake(),!arguments.length)return this._totalTime;if(this._timeline){if(0>a&&!c&&(a+=this.totalDuration()),this._timeline.smoothChildTiming){this._dirty&&this.totalDuration();var d=this._totalDuration,e=this._timeline;if(a>d&&!c&&(a=d),this._startTime=(this._paused?this._pauseTime:e._time)-(this._reversed?d-a:a)/this._timeScale,e._dirty||this._uncache(!1),e._timeline)for(;e._timeline;)e._timeline._time!==(e._startTime+e._totalTime)/e._timeScale&&e.totalTime(e._totalTime,!0),e=e._timeline}this._gc&&this._enabled(!0,!1),(this._totalTime!==a||0===this._duration)&&(I.length&&X(),this.render(a,b,!1),I.length&&X())}return this},f.progress=f.totalProgress=function(a,b){var c=this.duration();return arguments.length?this.totalTime(c*a,b):c?this._time/c:this.ratio},f.startTime=function(a){return arguments.length?(a!==this._startTime&&(this._startTime=a,this.timeline&&this.timeline._sortChildren&&this.timeline.add(this,a-this._delay)),this):this._startTime},f.endTime=function(a){return this._startTime+(0!=a?this.totalDuration():this.duration())/this._timeScale},f.timeScale=function(a){if(!arguments.length)return this._timeScale;if(a=a||k,this._timeline&&this._timeline.smoothChildTiming){var b=this._pauseTime,c=b||0===b?b:this._timeline.totalTime();this._startTime=c-(c-this._startTime)*this._timeScale/a}return this._timeScale=a,this._uncache(!1)},f.reversed=function(a){return arguments.length?(a!=this._reversed&&(this._reversed=a,this.totalTime(this._timeline&&!this._timeline.smoothChildTiming?this.totalDuration()-this._totalTime:this._totalTime,!0)),this):this._reversed},f.paused=function(a){if(!arguments.length)return this._paused;var b,c,d=this._timeline;return a!=this._paused&&d&&(h||a||g.wake(),b=d.rawTime(),c=b-this._pauseTime,!a&&d.smoothChildTiming&&(this._startTime+=c,this._uncache(!1)),this._pauseTime=a?b:null,this._paused=a,this._active=this.isActive(),!a&&0!==c&&this._initted&&this.duration()&&(b=d.smoothChildTiming?this._totalTime:(b-this._startTime)/this._timeScale,this.render(b,b===this._totalTime,!0))),this._gc&&!a&&this._enabled(!0,!1),this};var E=r(\"core.SimpleTimeline\",function(a){C.call(this,0,a),this.autoRemoveChildren=this.smoothChildTiming=!0});f=E.prototype=new C,f.constructor=E,f.kill()._gc=!1,f._first=f._last=f._recent=null,f._sortChildren=!1,f.add=f.insert=function(a,b,c,d){var e,f;if(a._startTime=Number(b||0)+a._delay,a._paused&&this!==a._timeline&&(a._pauseTime=a._startTime+(this.rawTime()-a._startTime)/a._timeScale),a.timeline&&a.timeline._remove(a,!0),a.timeline=a._timeline=this,a._gc&&a._enabled(!0,!0),e=this._last,this._sortChildren)for(f=a._startTime;e&&e._startTime>f;)e=e._prev;return e?(a._next=e._next,e._next=a):(a._next=this._first,this._first=a),a._next?a._next._prev=a:this._last=a,a._prev=e,this._recent=a,this._timeline&&this._uncache(!0),this},f._remove=function(a,b){return a.timeline===this&&(b||a._enabled(!1,!0),a._prev?a._prev._next=a._next:this._first===a&&(this._first=a._next),a._next?a._next._prev=a._prev:this._last===a&&(this._last=a._prev),a._next=a._prev=a.timeline=null,a===this._recent&&(this._recent=this._last),this._timeline&&this._uncache(!0)),this},f.render=function(a,b,c){var d,e=this._first;for(this._totalTime=this._time=this._rawPrevTime=a;e;)d=e._next,(e._active||a>=e._startTime&&!e._paused)&&(e._reversed?e.render((e._dirty?e.totalDuration():e._totalDuration)-(a-e._startTime)*e._timeScale,b,c):e.render((a-e._startTime)*e._timeScale,b,c)),e=d},f.rawTime=function(){return h||g.wake(),this._totalTime};var F=r(\"TweenLite\",function(b,c,d){if(C.call(this,c,d),this.render=F.prototype.render,null==b)throw\"Cannot tween a null target.\";this.target=b=\"string\"!=typeof b?b:F.selector(b)||b;var e,f,g,h=b.jquery||b.length&&b!==a&&b[0]&&(b[0]===a||b[0].nodeType&&b[0].style&&!b.nodeType),i=this.vars.overwrite;if(this._overwrite=i=null==i?T[F.defaultOverwrite]:\"number\"==typeof i?i>>0:T[i],(h||b instanceof Array||b.push&&n(b))&&\"number\"!=typeof b[0])for(this._targets=g=l(b),this._propLookup=[],this._siblings=[],e=0;e<g.length;e++)f=g[e],f?\"string\"!=typeof f?f.length&&f!==a&&f[0]&&(f[0]===a||f[0].nodeType&&f[0].style&&!f.nodeType)?(g.splice(e--,1),this._targets=g=g.concat(l(f))):(this._siblings[e]=Y(f,this,!1),1===i&&this._siblings[e].length>1&&$(f,this,null,1,this._siblings[e])):(f=g[e--]=F.selector(f),\"string\"==typeof f&&g.splice(e+1,1)):g.splice(e--,1);else this._propLookup={},this._siblings=Y(b,this,!1),1===i&&this._siblings.length>1&&$(b,this,null,1,this._siblings);(this.vars.immediateRender||0===c&&0===this._delay&&this.vars.immediateRender!==!1)&&(this._time=-k,this.render(-this._delay))},!0),G=function(b){return b&&b.length&&b!==a&&b[0]&&(b[0]===a||b[0].nodeType&&b[0].style&&!b.nodeType)},H=function(a,b){var c,d={};for(c in a)S[c]||c in b&&\"transform\"!==c&&\"x\"!==c&&\"y\"!==c&&\"width\"!==c&&\"height\"!==c&&\"className\"!==c&&\"border\"!==c||!(!P[c]||P[c]&&P[c]._autoCSS)||(d[c]=a[c],delete a[c]);a.css=d};f=F.prototype=new C,f.constructor=F,f.kill()._gc=!1,f.ratio=0,f._firstPT=f._targets=f._overwrittenProps=f._startAt=null,f._notifyPluginsOfEnabled=f._lazy=!1,F.version=\"1.18.2\",F.defaultEase=f._ease=new u(null,null,1,1),F.defaultOverwrite=\"auto\",F.ticker=g,F.autoSleep=120,F.lagSmoothing=function(a,b){g.lagSmoothing(a,b)},F.selector=a.$||a.jQuery||function(b){var c=a.$||a.jQuery;return c?(F.selector=c,c(b)):\"undefined\"==typeof document?b:document.querySelectorAll?document.querySelectorAll(b):document.getElementById(\"#\"===b.charAt(0)?b.substr(1):b)};var I=[],J={},K=/(?:(-|-=|\\+=)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/gi,L=function(a){for(var b,c=this._firstPT,d=1e-6;c;)b=c.blob?a?this.join(\"\"):this.start:c.c*a+c.s,c.r?b=Math.round(b):d>b&&b>-d&&(b=0),c.f?c.fp?c.t[c.p](c.fp,b):c.t[c.p](b):c.t[c.p]=b,c=c._next},M=function(a,b,c,d){var e,f,g,h,i,j,k,l=[a,b],m=0,n=\"\",o=0;for(l.start=a,c&&(c(l),a=l[0],b=l[1]),l.length=0,e=a.match(K)||[],f=b.match(K)||[],d&&(d._next=null,d.blob=1,l._firstPT=d),i=f.length,h=0;i>h;h++)k=f[h],j=b.substr(m,b.indexOf(k,m)-m),n+=j||!h?j:\",\",m+=j.length,o?o=(o+1)%5:\"rgba(\"===j.substr(-5)&&(o=1),k===e[h]||e.length<=h?n+=k:(n&&(l.push(n),n=\"\"),g=parseFloat(e[h]),l.push(g),l._firstPT={_next:l._firstPT,t:l,p:l.length-1,s:g,c:(\"=\"===k.charAt(1)?parseInt(k.charAt(0)+\"1\",10)*parseFloat(k.substr(2)):parseFloat(k)-g)||0,f:0,r:o&&4>o}),m+=k.length;return n+=b.substr(m),n&&l.push(n),l.setRatio=L,l},N=function(a,b,c,d,e,f,g,h){var i,j,k=\"get\"===c?a[b]:c,l=typeof a[b],m=\"string\"==typeof d&&\"=\"===d.charAt(1),n={t:a,p:b,s:k,f:\"function\"===l,pg:0,n:e||b,r:f,pr:0,c:m?parseInt(d.charAt(0)+\"1\",10)*parseFloat(d.substr(2)):parseFloat(d)-k||0};return\"number\"!==l&&(\"function\"===l&&\"get\"===c&&(j=b.indexOf(\"set\")||\"function\"!=typeof a[\"get\"+b.substr(3)]?b:\"get\"+b.substr(3),n.s=k=g?a[j](g):a[j]()),\"string\"==typeof k&&(g||isNaN(k))?(n.fp=g,i=M(k,d,h||F.defaultStringFilter,n),n={t:i,p:\"setRatio\",s:0,c:1,f:2,pg:0,n:e||b,pr:0}):m||(n.s=parseFloat(k),n.c=parseFloat(d)-n.s||0)),n.c?((n._next=this._firstPT)&&(n._next._prev=n),this._firstPT=n,n):void 0},O=F._internals={isArray:n,isSelector:G,lazyTweens:I,blobDif:M},P=F._plugins={},Q=O.tweenLookup={},R=0,S=O.reservedProps={ease:1,delay:1,overwrite:1,onComplete:1,onCompleteParams:1,onCompleteScope:1,useFrames:1,runBackwards:1,startAt:1,onUpdate:1,onUpdateParams:1,onUpdateScope:1,onStart:1,onStartParams:1,onStartScope:1,onReverseComplete:1,onReverseCompleteParams:1,onReverseCompleteScope:1,onRepeat:1,onRepeatParams:1,onRepeatScope:1,easeParams:1,yoyo:1,immediateRender:1,repeat:1,repeatDelay:1,data:1,paused:1,reversed:1,autoCSS:1,lazy:1,onOverwrite:1,callbackScope:1,stringFilter:1},T={none:0,all:1,auto:2,concurrent:3,allOnStart:4,preexisting:5,\"true\":1,\"false\":0},U=C._rootFramesTimeline=new E,V=C._rootTimeline=new E,W=30,X=O.lazyRender=function(){\nvar a,b=I.length;for(J={};--b>-1;)a=I[b],a&&a._lazy!==!1&&(a.render(a._lazy[0],a._lazy[1],!0),a._lazy=!1);I.length=0};V._startTime=g.time,U._startTime=g.frame,V._active=U._active=!0,setTimeout(X,1),C._updateRoot=F.render=function(){var a,b,c;if(I.length&&X(),V.render((g.time-V._startTime)*V._timeScale,!1,!1),U.render((g.frame-U._startTime)*U._timeScale,!1,!1),I.length&&X(),g.frame>=W){W=g.frame+(parseInt(F.autoSleep,10)||120);for(c in Q){for(b=Q[c].tweens,a=b.length;--a>-1;)b[a]._gc&&b.splice(a,1);0===b.length&&delete Q[c]}if(c=V._first,(!c||c._paused)&&F.autoSleep&&!U._first&&1===g._listeners.tick.length){for(;c&&c._paused;)c=c._next;c||g.sleep()}}},g.addEventListener(\"tick\",C._updateRoot);var Y=function(a,b,c){var d,e,f=a._gsTweenID;if(Q[f||(a._gsTweenID=f=\"t\"+R++)]||(Q[f]={target:a,tweens:[]}),b&&(d=Q[f].tweens,d[e=d.length]=b,c))for(;--e>-1;)d[e]===b&&d.splice(e,1);return Q[f].tweens},Z=function(a,b,c,d){var e,f,g=a.vars.onOverwrite;return g&&(e=g(a,b,c,d)),g=F.onOverwrite,g&&(f=g(a,b,c,d)),e!==!1&&f!==!1},$=function(a,b,c,d,e){var f,g,h,i;if(1===d||d>=4){for(i=e.length,f=0;i>f;f++)if((h=e[f])!==b)h._gc||h._kill(null,a,b)&&(g=!0);else if(5===d)break;return g}var j,l=b._startTime+k,m=[],n=0,o=0===b._duration;for(f=e.length;--f>-1;)(h=e[f])===b||h._gc||h._paused||(h._timeline!==b._timeline?(j=j||_(b,0,o),0===_(h,j,o)&&(m[n++]=h)):h._startTime<=l&&h._startTime+h.totalDuration()/h._timeScale>l&&((o||!h._initted)&&l-h._startTime<=2e-10||(m[n++]=h)));for(f=n;--f>-1;)if(h=m[f],2===d&&h._kill(c,a,b)&&(g=!0),2!==d||!h._firstPT&&h._initted){if(2!==d&&!Z(h,b))continue;h._enabled(!1,!1)&&(g=!0)}return g},_=function(a,b,c){for(var d=a._timeline,e=d._timeScale,f=a._startTime;d._timeline;){if(f+=d._startTime,e*=d._timeScale,d._paused)return-100;d=d._timeline}return f/=e,f>b?f-b:c&&f===b||!a._initted&&2*k>f-b?k:(f+=a.totalDuration()/a._timeScale/e)>b+k?0:f-b-k};f._init=function(){var a,b,c,d,e,f=this.vars,g=this._overwrittenProps,h=this._duration,i=!!f.immediateRender,j=f.ease;if(f.startAt){this._startAt&&(this._startAt.render(-1,!0),this._startAt.kill()),e={};for(d in f.startAt)e[d]=f.startAt[d];if(e.overwrite=!1,e.immediateRender=!0,e.lazy=i&&f.lazy!==!1,e.startAt=e.delay=null,this._startAt=F.to(this.target,0,e),i)if(this._time>0)this._startAt=null;else if(0!==h)return}else if(f.runBackwards&&0!==h)if(this._startAt)this._startAt.render(-1,!0),this._startAt.kill(),this._startAt=null;else{0!==this._time&&(i=!1),c={};for(d in f)S[d]&&\"autoCSS\"!==d||(c[d]=f[d]);if(c.overwrite=0,c.data=\"isFromStart\",c.lazy=i&&f.lazy!==!1,c.immediateRender=i,this._startAt=F.to(this.target,0,c),i){if(0===this._time)return}else this._startAt._init(),this._startAt._enabled(!1),this.vars.immediateRender&&(this._startAt=null)}if(this._ease=j=j?j instanceof u?j:\"function\"==typeof j?new u(j,f.easeParams):v[j]||F.defaultEase:F.defaultEase,f.easeParams instanceof Array&&j.config&&(this._ease=j.config.apply(j,f.easeParams)),this._easeType=this._ease._type,this._easePower=this._ease._power,this._firstPT=null,this._targets)for(a=this._targets.length;--a>-1;)this._initProps(this._targets[a],this._propLookup[a]={},this._siblings[a],g?g[a]:null)&&(b=!0);else b=this._initProps(this.target,this._propLookup,this._siblings,g);if(b&&F._onPluginEvent(\"_onInitAllProps\",this),g&&(this._firstPT||\"function\"!=typeof this.target&&this._enabled(!1,!1)),f.runBackwards)for(c=this._firstPT;c;)c.s+=c.c,c.c=-c.c,c=c._next;this._onUpdate=f.onUpdate,this._initted=!0},f._initProps=function(b,c,d,e){var f,g,h,i,j,k;if(null==b)return!1;J[b._gsTweenID]&&X(),this.vars.css||b.style&&b!==a&&b.nodeType&&P.css&&this.vars.autoCSS!==!1&&H(this.vars,b);for(f in this.vars)if(k=this.vars[f],S[f])k&&(k instanceof Array||k.push&&n(k))&&-1!==k.join(\"\").indexOf(\"{self}\")&&(this.vars[f]=k=this._swapSelfInParams(k,this));else if(P[f]&&(i=new P[f])._onInitTween(b,this.vars[f],this)){for(this._firstPT=j={_next:this._firstPT,t:i,p:\"setRatio\",s:0,c:1,f:1,n:f,pg:1,pr:i._priority},g=i._overwriteProps.length;--g>-1;)c[i._overwriteProps[g]]=this._firstPT;(i._priority||i._onInitAllProps)&&(h=!0),(i._onDisable||i._onEnable)&&(this._notifyPluginsOfEnabled=!0),j._next&&(j._next._prev=j)}else c[f]=N.call(this,b,f,\"get\",k,f,0,null,this.vars.stringFilter);return e&&this._kill(e,b)?this._initProps(b,c,d,e):this._overwrite>1&&this._firstPT&&d.length>1&&$(b,this,c,this._overwrite,d)?(this._kill(c,b),this._initProps(b,c,d,e)):(this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration)&&(J[b._gsTweenID]=!0),h)},f.render=function(a,b,c){var d,e,f,g,h=this._time,i=this._duration,j=this._rawPrevTime;if(a>=i-1e-7)this._totalTime=this._time=i,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1,this._reversed||(d=!0,e=\"onComplete\",c=c||this._timeline.autoRemoveChildren),0===i&&(this._initted||!this.vars.lazy||c)&&(this._startTime===this._timeline._duration&&(a=0),(0>j||0>=a&&a>=-1e-7||j===k&&\"isPause\"!==this.data)&&j!==a&&(c=!0,j>k&&(e=\"onReverseComplete\")),this._rawPrevTime=g=!b||a||j===a?a:k);else if(1e-7>a)this._totalTime=this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==h||0===i&&j>0)&&(e=\"onReverseComplete\",d=this._reversed),0>a&&(this._active=!1,0===i&&(this._initted||!this.vars.lazy||c)&&(j>=0&&(j!==k||\"isPause\"!==this.data)&&(c=!0),this._rawPrevTime=g=!b||a||j===a?a:k)),this._initted||(c=!0);else if(this._totalTime=this._time=a,this._easeType){var l=a/i,m=this._easeType,n=this._easePower;(1===m||3===m&&l>=.5)&&(l=1-l),3===m&&(l*=2),1===n?l*=l:2===n?l*=l*l:3===n?l*=l*l*l:4===n&&(l*=l*l*l*l),1===m?this.ratio=1-l:2===m?this.ratio=l:.5>a/i?this.ratio=l/2:this.ratio=1-l/2}else this.ratio=this._ease.getRatio(a/i);if(this._time!==h||c){if(!this._initted){if(this._init(),!this._initted||this._gc)return;if(!c&&this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration))return this._time=this._totalTime=h,this._rawPrevTime=j,I.push(this),void(this._lazy=[a,b]);this._time&&!d?this.ratio=this._ease.getRatio(this._time/i):d&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._lazy!==!1&&(this._lazy=!1),this._active||!this._paused&&this._time!==h&&a>=0&&(this._active=!0),0===h&&(this._startAt&&(a>=0?this._startAt.render(a,b,c):e||(e=\"_dummyGS\")),this.vars.onStart&&(0!==this._time||0===i)&&(b||this._callback(\"onStart\"))),f=this._firstPT;f;)f.f?f.t[f.p](f.c*this.ratio+f.s):f.t[f.p]=f.c*this.ratio+f.s,f=f._next;this._onUpdate&&(0>a&&this._startAt&&a!==-1e-4&&this._startAt.render(a,b,c),b||(this._time!==h||d)&&this._callback(\"onUpdate\")),e&&(!this._gc||c)&&(0>a&&this._startAt&&!this._onUpdate&&a!==-1e-4&&this._startAt.render(a,b,c),d&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[e]&&this._callback(e),0===i&&this._rawPrevTime===k&&g!==k&&(this._rawPrevTime=0))}},f._kill=function(a,b,c){if(\"all\"===a&&(a=null),null==a&&(null==b||b===this.target))return this._lazy=!1,this._enabled(!1,!1);b=\"string\"!=typeof b?b||this._targets||this.target:F.selector(b)||b;var d,e,f,g,h,i,j,k,l,m=c&&this._time&&c._startTime===this._startTime&&this._timeline===c._timeline;if((n(b)||G(b))&&\"number\"!=typeof b[0])for(d=b.length;--d>-1;)this._kill(a,b[d],c)&&(i=!0);else{if(this._targets){for(d=this._targets.length;--d>-1;)if(b===this._targets[d]){h=this._propLookup[d]||{},this._overwrittenProps=this._overwrittenProps||[],e=this._overwrittenProps[d]=a?this._overwrittenProps[d]||{}:\"all\";break}}else{if(b!==this.target)return!1;h=this._propLookup,e=this._overwrittenProps=a?this._overwrittenProps||{}:\"all\"}if(h){if(j=a||h,k=a!==e&&\"all\"!==e&&a!==h&&(\"object\"!=typeof a||!a._tempKill),c&&(F.onOverwrite||this.vars.onOverwrite)){for(f in j)h[f]&&(l||(l=[]),l.push(f));if((l||!a)&&!Z(this,c,b,l))return!1}for(f in j)(g=h[f])&&(m&&(g.f?g.t[g.p](g.s):g.t[g.p]=g.s,i=!0),g.pg&&g.t._kill(j)&&(i=!0),g.pg&&0!==g.t._overwriteProps.length||(g._prev?g._prev._next=g._next:g===this._firstPT&&(this._firstPT=g._next),g._next&&(g._next._prev=g._prev),g._next=g._prev=null),delete h[f]),k&&(e[f]=1);!this._firstPT&&this._initted&&this._enabled(!1,!1)}}return i},f.invalidate=function(){return this._notifyPluginsOfEnabled&&F._onPluginEvent(\"_onDisable\",this),this._firstPT=this._overwrittenProps=this._startAt=this._onUpdate=null,this._notifyPluginsOfEnabled=this._active=this._lazy=!1,this._propLookup=this._targets?{}:[],C.prototype.invalidate.call(this),this.vars.immediateRender&&(this._time=-k,this.render(-this._delay)),this},f._enabled=function(a,b){if(h||g.wake(),a&&this._gc){var c,d=this._targets;if(d)for(c=d.length;--c>-1;)this._siblings[c]=Y(d[c],this,!0);else this._siblings=Y(this.target,this,!0)}return C.prototype._enabled.call(this,a,b),this._notifyPluginsOfEnabled&&this._firstPT?F._onPluginEvent(a?\"_onEnable\":\"_onDisable\",this):!1},F.to=function(a,b,c){return new F(a,b,c)},F.from=function(a,b,c){return c.runBackwards=!0,c.immediateRender=0!=c.immediateRender,new F(a,b,c)},F.fromTo=function(a,b,c,d){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,new F(a,b,d)},F.delayedCall=function(a,b,c,d,e){return new F(b,0,{delay:a,onComplete:b,onCompleteParams:c,callbackScope:d,onReverseComplete:b,onReverseCompleteParams:c,immediateRender:!1,lazy:!1,useFrames:e,overwrite:0})},F.set=function(a,b){return new F(a,0,b)},F.getTweensOf=function(a,b){if(null==a)return[];a=\"string\"!=typeof a?a:F.selector(a)||a;var c,d,e,f;if((n(a)||G(a))&&\"number\"!=typeof a[0]){for(c=a.length,d=[];--c>-1;)d=d.concat(F.getTweensOf(a[c],b));for(c=d.length;--c>-1;)for(f=d[c],e=c;--e>-1;)f===d[e]&&d.splice(c,1)}else for(d=Y(a).concat(),c=d.length;--c>-1;)(d[c]._gc||b&&!d[c].isActive())&&d.splice(c,1);return d},F.killTweensOf=F.killDelayedCallsTo=function(a,b,c){\"object\"==typeof b&&(c=b,b=!1);for(var d=F.getTweensOf(a,b),e=d.length;--e>-1;)d[e]._kill(c,a)};var aa=r(\"plugins.TweenPlugin\",function(a,b){this._overwriteProps=(a||\"\").split(\",\"),this._propName=this._overwriteProps[0],this._priority=b||0,this._super=aa.prototype},!0);if(f=aa.prototype,aa.version=\"1.18.0\",aa.API=2,f._firstPT=null,f._addTween=N,f.setRatio=L,f._kill=function(a){var b,c=this._overwriteProps,d=this._firstPT;if(null!=a[this._propName])this._overwriteProps=[];else for(b=c.length;--b>-1;)null!=a[c[b]]&&c.splice(b,1);for(;d;)null!=a[d.n]&&(d._next&&(d._next._prev=d._prev),d._prev?(d._prev._next=d._next,d._prev=null):this._firstPT===d&&(this._firstPT=d._next)),d=d._next;return!1},f._roundProps=function(a,b){for(var c=this._firstPT;c;)(a[this._propName]||null!=c.n&&a[c.n.split(this._propName+\"_\").join(\"\")])&&(c.r=b),c=c._next},F._onPluginEvent=function(a,b){var c,d,e,f,g,h=b._firstPT;if(\"_onInitAllProps\"===a){for(;h;){for(g=h._next,d=e;d&&d.pr>h.pr;)d=d._next;(h._prev=d?d._prev:f)?h._prev._next=h:e=h,(h._next=d)?d._prev=h:f=h,h=g}h=b._firstPT=e}for(;h;)h.pg&&\"function\"==typeof h.t[a]&&h.t[a]()&&(c=!0),h=h._next;return c},aa.activate=function(a){for(var b=a.length;--b>-1;)a[b].API===aa.API&&(P[(new a[b])._propName]=a[b]);return!0},q.plugin=function(a){if(!(a&&a.propName&&a.init&&a.API))throw\"illegal plugin definition.\";var b,c=a.propName,d=a.priority||0,e=a.overwriteProps,f={init:\"_onInitTween\",set:\"setRatio\",kill:\"_kill\",round:\"_roundProps\",initAll:\"_onInitAllProps\"},g=r(\"plugins.\"+c.charAt(0).toUpperCase()+c.substr(1)+\"Plugin\",function(){aa.call(this,c,d),this._overwriteProps=e||[]},a.global===!0),h=g.prototype=new aa(c);h.constructor=g,g.API=a.API;for(b in f)\"function\"==typeof a[b]&&(h[f[b]]=a[b]);return g.version=a.version,aa.activate([g]),g},d=a._gsQueue){for(e=0;e<d.length;e++)d[e]();for(f in o)o[f].func||a.console.log(\"GSAP encountered missing dependency: com.greensock.\"+f)}h=!1}}(\"undefined\"!=typeof module&&module.exports&&\"undefined\"!=typeof global?global:this||window,\"TweenMax\");\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],16:[function(require,module,exports){\n// File:src/Three.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar THREE = { REVISION: '78' };\n\n//\n\nif ( typeof define === 'function' && define.amd ) {\n\n\tdefine( 'three', THREE );\n\n} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\n\n\tmodule.exports = THREE;\n\n}\n\n// Polyfills\n\nif ( Number.EPSILON === undefined ) {\n\n\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n}\n\n//\n\nif ( Math.sign === undefined ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\tMath.sign = function ( x ) {\n\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t};\n\n}\n\nif ( Function.prototype.name === undefined ) {\n\n\t// Missing in IE9-11.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\tget: function () {\n\n\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\n\t\t}\n\n\t} );\n\n}\n\nif ( Object.assign === undefined ) {\n\n\t// Missing in IE.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t( function () {\n\n\t\tObject.assign = function ( target ) {\n\n\t\t\t'use strict';\n\n\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t}\n\n\t\t\tvar output = Object( target );\n\n\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t};\n\n\t} )();\n\n}\n\n//\n\nObject.assign( THREE, {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\n\n\tMOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },\n\n\t// GL STATE CONSTANTS\n\n\tCullFaceNone: 0,\n\tCullFaceBack: 1,\n\tCullFaceFront: 2,\n\tCullFaceFrontBack: 3,\n\n\tFrontFaceDirectionCW: 0,\n\tFrontFaceDirectionCCW: 1,\n\n\t// SHADOWING TYPES\n\n\tBasicShadowMap: 0,\n\tPCFShadowMap: 1,\n\tPCFSoftShadowMap: 2,\n\n\t// MATERIAL CONSTANTS\n\n\t// side\n\n\tFrontSide: 0,\n\tBackSide: 1,\n\tDoubleSide: 2,\n\n\t// shading\n\n\tFlatShading: 1,\n\tSmoothShading: 2,\n\n\t// colors\n\n\tNoColors: 0,\n\tFaceColors: 1,\n\tVertexColors: 2,\n\n\t// blending modes\n\n\tNoBlending: 0,\n\tNormalBlending: 1,\n\tAdditiveBlending: 2,\n\tSubtractiveBlending: 3,\n\tMultiplyBlending: 4,\n\tCustomBlending: 5,\n\n\t// custom blending equations\n\t// (numbers start from 100 not to clash with other\n\t// mappings to OpenGL constants defined in Texture.js)\n\n\tAddEquation: 100,\n\tSubtractEquation: 101,\n\tReverseSubtractEquation: 102,\n\tMinEquation: 103,\n\tMaxEquation: 104,\n\n\t// custom blending destination factors\n\n\tZeroFactor: 200,\n\tOneFactor: 201,\n\tSrcColorFactor: 202,\n\tOneMinusSrcColorFactor: 203,\n\tSrcAlphaFactor: 204,\n\tOneMinusSrcAlphaFactor: 205,\n\tDstAlphaFactor: 206,\n\tOneMinusDstAlphaFactor: 207,\n\n\t// custom blending source factors\n\n\t//ZeroFactor: 200,\n\t//OneFactor: 201,\n\t//SrcAlphaFactor: 204,\n\t//OneMinusSrcAlphaFactor: 205,\n\t//DstAlphaFactor: 206,\n\t//OneMinusDstAlphaFactor: 207,\n\tDstColorFactor: 208,\n\tOneMinusDstColorFactor: 209,\n\tSrcAlphaSaturateFactor: 210,\n\n\t// depth modes\n\n\tNeverDepth: 0,\n\tAlwaysDepth: 1,\n\tLessDepth: 2,\n\tLessEqualDepth: 3,\n\tEqualDepth: 4,\n\tGreaterEqualDepth: 5,\n\tGreaterDepth: 6,\n\tNotEqualDepth: 7,\n\n\n\t// TEXTURE CONSTANTS\n\n\tMultiplyOperation: 0,\n\tMixOperation: 1,\n\tAddOperation: 2,\n\n\t// Tone Mapping modes\n\n\tNoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)\n\tLinearToneMapping: 1, // only apply exposure.\n\tReinhardToneMapping: 2,\n\tUncharted2ToneMapping: 3, // John Hable\n\tCineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\n\t// Mapping modes\n\n\tUVMapping: 300,\n\n\tCubeReflectionMapping: 301,\n\tCubeRefractionMapping: 302,\n\n\tEquirectangularReflectionMapping: 303,\n\tEquirectangularRefractionMapping: 304,\n\n\tSphericalReflectionMapping: 305,\n\tCubeUVReflectionMapping: 306,\n\tCubeUVRefractionMapping: 307,\n\n\t// Wrapping modes\n\n\tRepeatWrapping: 1000,\n\tClampToEdgeWrapping: 1001,\n\tMirroredRepeatWrapping: 1002,\n\n\t// Filters\n\n\tNearestFilter: 1003,\n\tNearestMipMapNearestFilter: 1004,\n\tNearestMipMapLinearFilter: 1005,\n\tLinearFilter: 1006,\n\tLinearMipMapNearestFilter: 1007,\n\tLinearMipMapLinearFilter: 1008,\n\n\t// Data types\n\n\tUnsignedByteType: 1009,\n\tByteType: 1010,\n\tShortType: 1011,\n\tUnsignedShortType: 1012,\n\tIntType: 1013,\n\tUnsignedIntType: 1014,\n\tFloatType: 1015,\n\tHalfFloatType: 1025,\n\n\t// Pixel types\n\n\t//UnsignedByteType: 1009,\n\tUnsignedShort4444Type: 1016,\n\tUnsignedShort5551Type: 1017,\n\tUnsignedShort565Type: 1018,\n\n\t// Pixel formats\n\n\tAlphaFormat: 1019,\n\tRGBFormat: 1020,\n\tRGBAFormat: 1021,\n\tLuminanceFormat: 1022,\n\tLuminanceAlphaFormat: 1023,\n\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\n\tRGBEFormat: THREE.RGBAFormat, //1024;\n\tDepthFormat: 1026,\n\n\t// DDS / ST3C Compressed texture formats\n\n\tRGB_S3TC_DXT1_Format: 2001,\n\tRGBA_S3TC_DXT1_Format: 2002,\n\tRGBA_S3TC_DXT3_Format: 2003,\n\tRGBA_S3TC_DXT5_Format: 2004,\n\n\t// PVRTC compressed texture formats\n\n\tRGB_PVRTC_4BPPV1_Format: 2100,\n\tRGB_PVRTC_2BPPV1_Format: 2101,\n\tRGBA_PVRTC_4BPPV1_Format: 2102,\n\tRGBA_PVRTC_2BPPV1_Format: 2103,\n\n\t// ETC compressed texture formats\n\n\tRGB_ETC1_Format: 2151,\n\n\t// Loop styles for AnimationAction\n\n\tLoopOnce: 2200,\n\tLoopRepeat: 2201,\n\tLoopPingPong: 2202,\n\n\t// Interpolation\n\n\tInterpolateDiscrete: 2300,\n\tInterpolateLinear: 2301,\n\tInterpolateSmooth: 2302,\n\n\t// Interpolant ending modes\n\n\tZeroCurvatureEnding: 2400,\n\tZeroSlopeEnding: 2401,\n\tWrapAroundEnding: 2402,\n\n\t// Triangle Draw modes\n\n\tTrianglesDrawMode: 0,\n\tTriangleStripDrawMode: 1,\n\tTriangleFanDrawMode: 2,\n\n\t// Texture Encodings\n\n\tLinearEncoding: 3000, // No encoding at all.\n\tsRGBEncoding: 3001,\n\tGammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\n\n\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\n\t// These encodings should not specified as output encodings except in rare situations.\n\tRGBEEncoding: 3002, // AKA Radiance.\n\tLogLuvEncoding: 3003,\n\tRGBM7Encoding: 3004,\n\tRGBM16Encoding: 3005,\n\tRGBDEncoding: 3006, // MaxRange is 256.\n\n\t// Depth packing strategies\n\n\tBasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers\n\tRGBADepthPacking: 3201 // for packing into RGBA buffers.\n\n} );\n\n// File:src/math/Color.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Color = function ( r, g, b ) {\n\n\tif ( g === undefined && b === undefined ) {\n\n\t\t// r is THREE.Color, hex or string\n\t\treturn this.set( r );\n\n\t}\n\n\treturn this.setRGB( r, g, b );\n\n};\n\nTHREE.Color.prototype = {\n\n\tconstructor: THREE.Color,\n\n\tr: 1, g: 1, b: 1,\n\n\tset: function ( value ) {\n\n\t\tif ( value instanceof THREE.Color ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSL: function () {\n\n\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\tif ( t < 0 ) t += 1;\n\t\t\tif ( t > 1 ) t -= 1;\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\treturn p;\n\n\t\t}\n\n\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\th = THREE.Math.euclideanModulo( h, 1 );\n\t\t\ts = THREE.Math.clamp( s, 0, 1 );\n\t\t\tl = THREE.Math.clamp( l, 0, 1 );\n\n\t\t\tif ( s === 0 ) {\n\n\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t} else {\n\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetStyle: function ( style ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar m;\n\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tvar color;\n\t\t\tvar name = m[ 1 ];\n\t\t\tvar components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tvar hex = m[ 1 ];\n\t\t\tvar size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( style && style.length > 0 ) {\n\n\t\t\t// color keywords\n\t\t\tvar hex = THREE.ColorKeywords[ style ];\n\n\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t// red\n\t\t\t\tthis.setHex( hex );\n\n\t\t\t} else {\n\n\t\t\t\t// unknown color\n\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t},\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function () {\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tthis.r = r * r;\n\t\tthis.g = g * g;\n\t\tthis.b = b * b;\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function () {\n\n\t\tthis.r = Math.sqrt( this.r );\n\t\tthis.g = Math.sqrt( this.g );\n\t\tthis.b = Math.sqrt( this.b );\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetHexString: function () {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t},\n\n\tgetHSL: function ( optionalTarget ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tvar max = Math.max( r, g, b );\n\t\tvar min = Math.min( r, g, b );\n\n\t\tvar hue, saturation;\n\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tvar delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\thsl.h = hue;\n\t\thsl.s = saturation;\n\t\thsl.l = lightness;\n\n\t\treturn hsl;\n\n\t},\n\n\tgetStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\toffsetHSL: function ( h, s, l ) {\n\n\t\tvar hsl = this.getHSL();\n\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t},\n\n\taddColors: function ( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n};\n\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n// File:src/math/Quaternion.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Quaternion = function ( x, y, z, w ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Quaternion.prototype = {\n\n\tconstructor: THREE.Quaternion,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget w () {\n\n\t\treturn this._w;\n\n\t},\n\n\tset w ( value ) {\n\n\t\tthis._w = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t},\n\n\tcopy: function ( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( euler, update ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\tvar order = euler.order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromUnitVectors: function () {\n\n\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tvar v1, r;\n\n\t\tvar EPS = 0.000001;\n\n\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\tif ( r < EPS ) {\n\n\t\t\t\tr = 0;\n\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t}\n\n\t\t\tthis._x = v1.x;\n\t\t\tthis._y = v1.y;\n\t\t\tthis._z = v1.z;\n\t\t\tthis._w = r;\n\n\t\t\treturn this.normalize();\n\n\t\t};\n\n\t}(),\n\n\tinverse: function () {\n\n\t\treturn this.conjugate().normalize();\n\n\t},\n\n\tconjugate: function () {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t},\n\n\tpremultiply: function ( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t},\n\n\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tslerp: function ( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\nObject.assign( THREE.Quaternion, {\n\n\tslerp: function( qa, qb, qm, t ) {\n\n\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t},\n\n\tslerpFlat: function(\n\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tvar s = 1 - t,\n\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tvar tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n} );\n\n// File:src/math/Vector2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Vector2 = function ( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n};\n\nTHREE.Vector2.prototype = {\n\n\tconstructor: THREE.Vector2,\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t},\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t},\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t},\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t},\n\n\t//\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector2();\n\t\t\t\tmax = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t},\n\n\tlengthManhattan: function() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tangle: function () {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\treturn angle;\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\trotateAround: function ( center, angle ) {\n\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tvar x = this.x - center.x;\n\t\tvar y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author *kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector3 = function ( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n};\n\nTHREE.Vector3.prototype = {\n\n\tconstructor: THREE.Vector3,\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVectors: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyEuler: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyEuler( euler ) {\n\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyAxisAngle: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\tapplyProjection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 projection matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\n\t\treturn this;\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t},\n\n\tproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function project( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\tunproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function unproject( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\ttransformDirection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector3();\n\t\t\t\tmax = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tcross: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tthis.x = y * v.z - z * v.y;\n\t\tthis.y = z * v.x - x * v.z;\n\t\tthis.z = x * v.y - y * v.x;\n\n\t\treturn this;\n\n\t},\n\n\tcrossVectors: function ( a, b ) {\n\n\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t},\n\n\tprojectOnVector: function ( vector ) {\n\n\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\n\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\n\t},\n\n\tprojectOnPlane: function () {\n\n\t\tvar v1;\n\n\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( v1 );\n\n\t\t};\n\n\t}(),\n\n\treflect: function () {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\tvar v1;\n\n\t\treturn function reflect( normal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t};\n\n\t}(),\n\n\tangleTo: function ( v ) {\n\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t},\n\n\tsetFromSpherical: function( s ) {\n\n\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixPosition: function ( m ) {\n\n\t\treturn this.setFromMatrixColumn( m, 3 );\n\n\t},\n\n\tsetFromMatrixScale: function ( m ) {\n\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\tif ( typeof m === 'number' ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\tvar temp = m\n\t\t\tm = index;\n\t\t\tindex = temp;\n\n\t\t}\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector4.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector4 = function ( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Vector4.prototype = {\n\n\tconstructor: THREE.Vector4,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\tthis.w *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\t this.x = 1;\n\t\t\t this.y = 0;\n\t\t\t this.z = 0;\n\n\t\t} else {\n\n\t\t\t this.x = q.x / s;\n\t\t\t this.y = q.y / s;\n\t\t\t this.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector4();\n\t\t\t\tmax = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\t\tthis.w = attribute.array[ index + 3 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Euler.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Euler = function ( x, y, z, order ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._order = order || THREE.Euler.DefaultOrder;\n\n};\n\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nTHREE.Euler.DefaultOrder = 'XYZ';\n\nTHREE.Euler.prototype = {\n\n\tconstructor: THREE.Euler,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget order () {\n\n\t\treturn this._order;\n\n\t},\n\n\tset order ( value ) {\n\n\t\tthis._order = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order || this._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t},\n\n\tcopy: function ( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\tvar clamp = THREE.Math.clamp;\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._y = 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromQuaternion: function () {\n\n\t\tvar matrix;\n\n\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t};\n\n\t}(),\n\n\tsetFromVector3: function ( v, order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t},\n\n\treorder: function () {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\tvar q = new THREE.Quaternion();\n\n\t\treturn function reorder( newOrder ) {\n\n\t\t\tq.setFromEuler( this );\n\t\t\t\n\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t},\n\n\ttoVector3: function ( optionalResult ) {\n\n\t\tif ( optionalResult ) {\n\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t} else {\n\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\n\n\t\t}\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\n// File:src/math/Line3.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Line3 = function ( start, end ) {\n\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\n\n};\n\nTHREE.Line3.prototype = {\n\n\tconstructor: THREE.Line3,\n\n\tset: function ( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t},\n\n\tdelta: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.end, this.start );\n\n\t},\n\n\tdistanceSq: function () {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t},\n\n\tdistance: function () {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tclosestPointToPointParameter: function () {\n\n\t\tvar startP = new THREE.Vector3();\n\t\tvar startEnd = new THREE.Vector3();\n\n\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\tstartP.subVectors( point, this.start );\n\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\tif ( clampToLine ) {\n\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\n\n\t\t\t}\n\n\t\t\treturn t;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n};\n\n// File:src/math/Box2.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Box2 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\n\n};\n\nTHREE.Box2.prototype = {\n\n\tconstructor: THREE.Box2,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Box3.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Box3 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\n\n};\n\nTHREE.Box3.prototype = {\n\n\tconstructor: THREE.Box3,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromArray: function ( array ) {\n\n\t\tvar minX = + Infinity;\n\t\tvar minY = + Infinity;\n\t\tvar minZ = + Infinity;\n\n\t\tvar maxX = - Infinity;\n\t\tvar maxY = - Infinity;\n\t\tvar maxZ = - Infinity;\n\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tvar x = array[ i ];\n\t\t\tvar y = array[ i + 1 ];\n\t\t\tvar z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function () {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromObject( object ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\n\n\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\n\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\tv1.fromArray( positions, i );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsSphere: ( function () {\n\n\t\tvar closestPoint;\n\n\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\n\n\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t};\n\n\t} )(),\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tvar min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tgetBoundingSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\n\t\t\tresult.center = this.center();\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar points = [\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3()\n\t\t];\n\n\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t// transform of empty box is an empty box.\n\t\t\tif( this.isEmpty() ) return this;\n\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Matrix3.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n * @author tschw\n */\n\nTHREE.Matrix3 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0,\n\t\t0, 1, 0,\n\t\t0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix3.prototype = {\n\n\tconstructor: THREE.Matrix3,\n\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix4: function( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t},\n\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\tif ( matrix instanceof THREE.Matrix4 ) {\n\n\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n\t\t}\n\n\t\tvar me = matrix.elements,\n\t\t\tte = this.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t},\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Matrix4.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Matrix4 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix4.prototype = {\n\n\tconstructor: THREE.Matrix4,\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Matrix4().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tthis.elements.set( m.elements );\n\n\t\treturn this;\n\n\t},\n\n\tcopyPosition: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0,       0,       0,       1\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function () {\n\n\t\tvar v1;\n\n\t\treturn function extractRotation( m ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeRotationFromEuler: function ( euler ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\tte[ 4 ] = xy - wz;\n\t\tte[ 8 ] = xz + wy;\n\n\t\tte[ 1 ] = xy + wz;\n\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\tte[ 9 ] = yz - wx;\n\n\t\tte[ 2 ] = xz - wy;\n\t\tte[ 6 ] = yz + wx;\n\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function () {\n\n\t\tvar x, y, z;\n\n\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\tif ( x === undefined ) {\n\n\t\t\t\tx = new THREE.Vector3();\n\t\t\t\ty = new THREE.Vector3();\n\t\t\t\tz = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\tz.z = 1;\n\n\t\t\t}\n\n\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\tz.z += 0.0001;\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t}\n\n\t\t\ty.crossVectors( z, x );\n\n\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tpremultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyToArray: function ( a, b, r ) {\n\n\t\tvar te = this.elements;\n\n\t\tthis.multiplyMatrices( a, b );\n\n\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetPosition: function () {\n\n\t\tvar v1;\n\n\t\treturn function getPosition() {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t};\n\n\t}(),\n\n\tsetPosition: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 12 ] = v.x;\n\t\tte[ 13 ] = v.y;\n\t\tte[ 14 ] = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements,\n\t\t\tme = m.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t},\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0,  0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s,  c, 0,\n\t\t\t0, 0,  0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts,  c, 0, 0,\n\t\t\t0,  0, 1, 0,\n\t\t\t0,  0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function ( position, quaternion, scale ) {\n\n\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\tthis.scale( scale );\n\t\tthis.setPosition( position );\n\n\t\treturn this;\n\n\t},\n\n\tdecompose: function () {\n\n\t\tvar vector, matrix;\n\n\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tvector = new THREE.Vector3();\n\t\t\t\tmatrix = new THREE.Matrix4();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t// if determine is negative, we need to invert one scale\n\t\t\tvar det = this.determinant();\n\t\t\tif ( det < 0 ) {\n\n\t\t\t\tsx = - sx;\n\n\t\t\t}\n\n\t\t\tposition.x = te[ 12 ];\n\t\t\tposition.y = te[ 13 ];\n\t\t\tposition.z = te[ 14 ];\n\n\t\t\t// scale the rotation part\n\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\tvar invSX = 1 / sx;\n\t\t\tvar invSY = 1 / sy;\n\t\t\tvar invSZ = 1 / sz;\n\n\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\tvar ymin = - ymax;\n\t\tvar xmin = ymin * aspect;\n\t\tvar xmax = ymax * aspect;\n\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = 1.0 / ( right - left );\n\t\tvar h = 1.0 / ( top - bottom );\n\t\tvar p = 1.0 / ( far - near );\n\n\t\tvar x = ( right + left ) * w;\n\t\tvar y = ( top + bottom ) * h;\n\t\tvar z = ( far + near ) * p;\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( matrix ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = matrix.elements;\n\n\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Ray.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Ray = function ( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\n};\n\nTHREE.Ray.prototype = {\n\n\tconstructor: THREE.Ray,\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\tlookAt: function ( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\trecast: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function recast( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.subVectors( point, this.origin );\n\t\tvar directionDistance = result.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn result.copy( this.origin );\n\n\t\t}\n\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t},\n\n\tdistanceSqToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t// point behind the ray\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t}\n\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\treturn v1.distanceToSquared( point );\n\n\t\t};\n\n\t}(),\n\n\tdistanceSqToSegment: function () {\n\n\t\tvar segCenter = new THREE.Vector3();\n\t\tvar segDir = new THREE.Vector3();\n\t\tvar diff = new THREE.Vector3();\n\n\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\tvar c = diff.lengthSq();\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\tif ( det > 0 ) {\n\n\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\n\t\t};\n\n\t}(),\n\n\tintersectSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\tvar tca = v1.dot( this.direction );\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\tvar t0 = tca - thc;\n\n\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\tvar t1 = tca + thc;\n\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t// test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t :  null;\n\n\t},\n\n\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\tvar t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, optionalTarget );\n\n\t},\n\n\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tintersectBox: function ( box, optionalTarget ) {\n\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tvar invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tvar origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t},\n\n\tintersectsBox: ( function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t};\n\n\t} )(),\n\n\tintersectTriangle: function () {\n\n\t\t// Compute the offset origin, edges, and normal.\n\t\tvar diff = new THREE.Vector3();\n\t\tvar edge1 = new THREE.Vector3();\n\t\tvar edge2 = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\n\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\tedge1.subVectors( b, a );\n\t\t\tedge2.subVectors( c, a );\n\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\tvar sign;\n\n\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\tsign = 1;\n\n\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\tsign = - 1;\n\t\t\t\tDdN = - DdN;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tdiff.subVectors( this.origin, a );\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t// b1 < 0, no intersection\n\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t// b2 < 0, no intersection\n\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// b1+b2 > 1, no intersection\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Line intersects triangle, check if ray does.\n\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t// t < 0, no intersection\n\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Ray intersects triangle.\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.sub( this.origin );\n\t\tthis.direction.normalize();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n};\n\n// File:src/math/Sphere.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Sphere = function ( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n};\n\nTHREE.Sphere.prototype = {\n\n\tconstructor: THREE.Sphere,\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function () {\n\n\t\tvar box = new THREE.Box3();\n\n\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\tvar center = this.center;\n\n\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromPoints( points ).center( center );\n\n\t\t\t}\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We use the following equation to compute the signed distance from\n\t\t// the center of the sphere to the plane.\n\t\t//\n\t\t// distance = q * n - d\n\t\t//\n\t\t// If this distance is greater than the radius of the sphere,\n\t\t// then there is no intersection.\n\n\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tresult.sub( this.center ).normalize();\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\tvar box = optionalTarget || new THREE.Box3();\n\n\t\tbox.set( this.center, this.center );\n\t\tbox.expandByScalar( this.radius );\n\n\t\treturn box;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n};\n\n// File:src/math/Frustum.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://clara.io\n */\n\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\n\tthis.planes = [\n\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\n\t];\n\n};\n\nTHREE.Frustum.prototype = {\n\n\tconstructor: THREE.Frustum,\n\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tvar planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( frustum ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix: function ( m ) {\n\n\t\tvar planes = this.planes;\n\t\tvar me = m.elements;\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\tintersectsObject: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsObject( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSprite: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar planes = this.planes;\n\t\tvar center = sphere.center;\n\t\tvar negRadius = - sphere.radius;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsBox: function () {\n\n\t\tvar p1 = new THREE.Vector3(),\n\t\t\tp2 = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\n\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t}(),\n\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n};\n\n// File:src/math/Plane.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Plane = function ( normal, constant ) {\n\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n};\n\nTHREE.Plane.prototype = {\n\n\tconstructor: THREE.Plane,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t},\n\n\torthoPoint: function ( point, optionalTarget ) {\n\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t},\n\n\tintersectLine: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tvar direction = line.delta( v1 );\n\n\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t};\n\n\t}(),\n\n\tintersectsLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t},\n\n\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar m1 = new THREE.Matrix3();\n\n\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t// transform normal based on theory here:\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n};\n\n// File:src/math/Spherical.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The poles (phi) are at the positive and negative y axis.\n * The equator starts at positive z.\n */\n\nTHREE.Spherical = function ( radius, phi, theta ) {\n\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\treturn this;\n\n};\n\nTHREE.Spherical.prototype = {\n\n\tconstructor: THREE.Spherical,\n\n\tset: function ( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( other ) {\n\n\t\tthis.radius.copy( other.radius );\n\t\tthis.phi.copy( other.phi );\n\t\tthis.theta.copy( other.theta );\n\n\t\treturn this;\n\n\t},\n\n\t// restrict phi to be betwee EPS and PI-EPS\n\tmakeSafe: function() {\n\n\t\tvar EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromVector3: function( vec3 ) {\n\n\t\tthis.radius = vec3.length();\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n};\n\n// File:src/math/Math.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Math = {\n\n\tDEG2RAD: Math.PI / 180,\n\tRAD2DEG: 180 / Math.PI,\n\n\tgenerateUUID: function () {\n\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\tvar uuid = new Array( 36 );\n\t\tvar rnd = 0, r;\n\n\t\treturn function generateUUID() {\n\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n\t\t\t\t\tuuid[ i ] = '-';\n\n\t\t\t\t} else if ( i === 14 ) {\n\n\t\t\t\t\tuuid[ i ] = '4';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uuid.join( '' );\n\n\t\t};\n\n\t}(),\n\n\tclamp: function ( value, min, max ) {\n\n\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t},\n\n\t// compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\teuclideanModulo: function ( n, m ) {\n\n\t\treturn ( ( n % m ) + m ) % m;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * ( 3 - 2 * x );\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t},\n\n\trandom16: function () {\n\n\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\treturn Math.random();\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tdegToRad: function ( degrees ) {\n\n\t\treturn degrees * THREE.Math.DEG2RAD;\n\n\t},\n\n\tradToDeg: function ( radians ) {\n\n\t\treturn radians * THREE.Math.RAD2DEG;\n\n\t},\n\n\tisPowerOfTwo: function ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t},\n\n\tnearestPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n\t},\n\n\tnextPowerOfTwo: function ( value ) {\n\n\t\tvalue --;\n\t\tvalue |= value >> 1;\n\t\tvalue |= value >> 2;\n\t\tvalue |= value >> 4;\n\t\tvalue |= value >> 8;\n\t\tvalue |= value >> 16;\n\t\tvalue ++;\n\n\t\treturn value;\n\n\t}\n\n};\n\n// File:src/math/Spline.js\n\n/**\n * Spline from Tween.js, slightly optimized (and trashed)\n * http://sole.github.com/tween.js/examples/05_spline.html\n *\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Spline = function ( points ) {\n\n\tthis.points = points;\n\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tthis.initFromArray = function ( a ) {\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t}\n\n\t};\n\n\tthis.getPoint = function ( k ) {\n\n\t\tpoint = ( this.points.length - 1 ) * k;\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\tpa = this.points[ c[ 0 ] ];\n\t\tpb = this.points[ c[ 1 ] ];\n\t\tpc = this.points[ c[ 2 ] ];\n\t\tpd = this.points[ c[ 3 ] ];\n\n\t\tw2 = weight * weight;\n\t\tw3 = weight * w2;\n\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\treturn v3;\n\n\t};\n\n\tthis.getControlPointsArray = function () {\n\n\t\tvar i, p, l = this.points.length,\n\t\t\tcoords = [];\n\n\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\tp = this.points[ i ];\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t}\n\n\t\treturn coords;\n\n\t};\n\n\t// approximate length by summing linear segments\n\n\tthis.getLength = function ( nSubDivisions ) {\n\n\t\tvar i, index, nSamples, position,\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\toldPosition = new THREE.Vector3(),\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tchunkLengths = [],\n\t\t\ttotalLength = 0;\n\n\t\t// first point has 0 length\n\n\t\tchunkLengths[ 0 ] = 0;\n\n\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\n\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\tindex = i / nSamples;\n\n\t\t\tposition = this.getPoint( index );\n\t\t\ttmpVec.copy( position );\n\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\toldPosition.copy( position );\n\n\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\tintPoint = Math.floor( point );\n\n\t\t\tif ( intPoint !== oldIntPoint ) {\n\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// last point ends with total length\n\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t};\n\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\tvar i, j,\n\t\t\tindex, indexCurrent, indexNext,\n\t\t\trealDistance,\n\t\t\tsampling, position,\n\t\t\tnewpoints = [],\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tsl = this.getLength();\n\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t}\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t}\n\n\t\tthis.points = newpoints;\n\n\t};\n\n\t// Catmull-Rom\n\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/math/Triangle.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Triangle = function ( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\n};\n\nTHREE.Triangle.normal = function () {\n\n\tvar v0 = new THREE.Vector3();\n\n\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.subVectors( c, b );\n\t\tv0.subVectors( a, b );\n\t\tresult.cross( v0 );\n\n\t\tvar resultLengthSq = result.lengthSq();\n\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t}\n\n\t\treturn result.set( 0, 0, 0 );\n\n\t};\n\n}();\n\n// static/instance method to calculate barycentric coordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\nTHREE.Triangle.barycoordFromPoint = function () {\n\n\tvar v0 = new THREE.Vector3();\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\n\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\tv0.subVectors( c, a );\n\t\tv1.subVectors( b, a );\n\t\tv2.subVectors( point, a );\n\n\t\tvar dot00 = v0.dot( v0 );\n\t\tvar dot01 = v0.dot( v1 );\n\t\tvar dot02 = v0.dot( v2 );\n\t\tvar dot11 = v1.dot( v1 );\n\t\tvar dot12 = v1.dot( v2 );\n\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tvar invDenom = 1 / denom;\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn result.set( 1 - u - v, v, u );\n\n\t};\n\n}();\n\nTHREE.Triangle.containsPoint = function () {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function containsPoint( point, a, b, c ) {\n\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t};\n\n}();\n\nTHREE.Triangle.prototype = {\n\n\tconstructor: THREE.Triangle,\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tarea: function () {\n\n\t\tvar v0 = new THREE.Vector3();\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function area() {\n\n\t\t\tv0.subVectors( this.c, this.b );\n\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t};\n\n\t}(),\n\n\tmidpoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tnormal: function ( optionalTarget ) {\n\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tplane: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Plane();\n\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tclosestPointToPoint: function () {\n\n\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\n\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\tif ( plane === undefined ) {\n\n\t\t\t\tplane = new THREE.Plane();\n\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\n\t\t\t\tprojectedPoint = new THREE.Vector3();\n\t\t\t\tclosestPoint = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\tvar minDistance = Infinity;\n\n\t\t\t// project the point onto the plane of the triangle\n\n\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t// check if the projection lies within the triangle\n\n\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t// if so, this is the closest point\n\n\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t} else {\n\n\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\tif( distance < minDistance ) {\n\n\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n};\n\n// File:src/math/Interpolant.js\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n * @author tschw\n */\n\nTHREE.Interpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tthis.parameterPositions = parameterPositions;\n\tthis._cachedIndex = 0;\n\n\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\tthis.sampleValues = sampleValues;\n\tthis.valueSize = sampleSize;\n\n};\n\nTHREE.Interpolant.prototype = {\n\n\tconstructor: THREE.Interpolant,\n\n\tevaluate: function( t ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\ti1 = this._cachedIndex,\n\n\t\t\tt1 = pp[   i1   ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tvar right;\n\n\t\t\t\tlinear_scan: {\n//- See http://jsperf.com/comparison-to-undefined/3\n//- slower code:\n//-\n//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n//- slower code:\n//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t},\n\n\tsettings: null, // optional, subclass-specific settings structure\n\t// Note: The indirection allows central control of many interpolants.\n\n\t// --- Protected interface\n\n\tDefaultSettings_: {},\n\n\tgetSettings_: function() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t},\n\n\tcopySampleValue_: function( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Template methods for derived classes:\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tthrow new Error( \"call to abstract method\" );\n\t\t// implementations shall return this.resultBuffer\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t// empty\n\n\t}\n\n};\n\nObject.assign( THREE.Interpolant.prototype, {\n\n\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_,\n\n\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_\n\n} );\n\n// File:src/math/interpolants/CubicInterpolant.js\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n *\n * @author tschw\n */\n\nTHREE.CubicInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\tthis._weightPrev = -0;\n\tthis._offsetPrev = -0;\n\tthis._weightNext = -0;\n\tthis._offsetNext = -0;\n\n};\n\nTHREE.CubicInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.CubicInterpolant,\n\n\tDefaultSettings_: {\n\n\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\tiPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t},\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/DiscreteInterpolant.js\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n *\n * @author tschw\n */\n\nTHREE.DiscreteInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.DiscreteInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.DiscreteInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n} );\n\n// File:src/math/interpolants/LinearInterpolant.js\n\n/**\n * @author tschw\n */\n\nTHREE.LinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.LinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.LinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/QuaternionLinearInterpolant.js\n\n/**\n * Spherical linear unit quaternion interpolant.\n *\n * @author tschw\n */\n\nTHREE.QuaternionLinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.QuaternionLinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.QuaternionLinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset = i1 * stride,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\n\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/core/Clock.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Clock = function ( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n};\n\nTHREE.Clock.prototype = {\n\n\tconstructor: THREE.Clock,\n\n\tstart: function () {\n\n\t\tthis.startTime = ( performance || Date ).now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.running = true;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\n\t},\n\n\tgetElapsedTime: function () {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t},\n\n\tgetDelta: function () {\n\n\t\tvar diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tvar newTime = ( performance || Date ).now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n};\n\n// File:src/core/EventDispatcher.js\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nTHREE.EventDispatcher = function () {};\n\nObject.assign( THREE.EventDispatcher.prototype, {\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function ( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\tvar array = [], i = 0;\n\t\t\tvar length = listenerArray.length;\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/core/Layers.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Layers = function () {\n\n\tthis.mask = 1;\n\n};\n\nTHREE.Layers.prototype = {\n\n\tconstructor: THREE.Layers,\n\n\tset: function ( channel ) {\n\n\t\tthis.mask = 1 << channel;\n\n\t},\n\n\tenable: function ( channel ) {\n\n\t\tthis.mask |= 1 << channel;\n\n\t},\n\n\ttoggle: function ( channel ) {\n\n\t\tthis.mask ^= 1 << channel;\n\n\t},\n\n\tdisable: function ( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel );\n\n\t},\n\n\ttest: function ( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n};\n\n// File:src/core/Raycaster.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://clara.io/\n * @author stephomi / http://stephaneginier.com/\n */\n\n( function ( THREE ) {\n\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\n\t\tthis.ray = new THREE.Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t};\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tTHREE.Raycaster.prototype = {\n\n\t\tconstructor: THREE.Raycaster,\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t};\n\n}( THREE ) );\n\n// File:src/core/Object3D.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author elephantatwork / www.elephantatwork.ch\n */\n\nTHREE.Object3D = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Object3D';\n\n\tthis.parent = null;\n\tthis.children = [];\n\n\tthis.up = THREE.Object3D.DefaultUp.clone();\n\n\tvar position = new THREE.Vector3();\n\tvar rotation = new THREE.Euler();\n\tvar quaternion = new THREE.Quaternion();\n\tvar scale = new THREE.Vector3( 1, 1, 1 );\n\n\tfunction onRotationChange() {\n\n\t\tquaternion.setFromEuler( rotation, false );\n\n\t}\n\n\tfunction onQuaternionChange() {\n\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t}\n\n\trotation.onChange( onRotationChange );\n\tquaternion.onChange( onQuaternionChange );\n\n\tObject.defineProperties( this, {\n\t\tposition: {\n\t\t\tenumerable: true,\n\t\t\tvalue: position\n\t\t},\n\t\trotation: {\n\t\t\tenumerable: true,\n\t\t\tvalue: rotation\n\t\t},\n\t\tquaternion: {\n\t\t\tenumerable: true,\n\t\t\tvalue: quaternion\n\t\t},\n\t\tscale: {\n\t\t\tenumerable: true,\n\t\t\tvalue: scale\n\t\t},\n\t\tmodelViewMatrix: {\n\t\t\tvalue: new THREE.Matrix4()\n\t\t},\n\t\tnormalMatrix: {\n\t\t\tvalue: new THREE.Matrix3()\n\t\t}\n\t} );\n\n\tthis.matrix = new THREE.Matrix4();\n\tthis.matrixWorld = new THREE.Matrix4();\n\n\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\n\tthis.matrixWorldNeedsUpdate = false;\n\n\tthis.layers = new THREE.Layers();\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\tthis.renderOrder = 0;\n\n\tthis.userData = {};\n\n};\n\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\n\nObject.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t},\n\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t},\n\n\tsetRotationFromEuler: function ( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t},\n\n\tsetRotationFromMatrix: function ( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t},\n\n\trotateOnAxis: function () {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar q1 = new THREE.Quaternion();\n\n\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\ttranslateOnAxis: function () {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function translateX( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function translateY( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function translateZ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function () {\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function worldToLocal( vector ) {\n\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object instanceof THREE.Object3D ) {\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\tthis.children.push( object );\n\n\t\t} else {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t}\n\n\t},\n\n\tgetObjectById: function ( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t},\n\n\tgetObjectByName: function ( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t},\n\n\tgetObjectByProperty: function ( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t},\n\n\tgetWorldQuaternion: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar scale = new THREE.Vector3();\n\n\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Quaternion();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldRotation: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Euler();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t};\n\n\t}(),\n\n\tgetWorldScale: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldDirection: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t};\n\n\t}(),\n\n\traycast: function () {},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseVisible: function ( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseAncestors: function ( callback ) {\n\n\t\tvar parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\t// meta is '' when called from JSON.stringify\n\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\n\t\tvar output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tvar object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\n\t\tobject.matrix = this.matrix.toArray();\n\n\t\t//\n\n\t\tif ( this.geometry !== undefined ) {\n\n\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.geometry = this.geometry.uuid;\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\n\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.material = this.material.uuid;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\t\t\treturn values;\n\n\t\t}\n\n\t},\n\n\tclone: function ( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t},\n\n\tcopy: function ( source, recursive ) {\n\n\t\tif ( recursive === undefined ) recursive = true;\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tvar child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\nTHREE.Object3DIdCount = 0;\n\n// File:src/core/Face3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n};\n\nTHREE.Face3.prototype = {\n\n\tconstructor: THREE.Face3,\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.a = source.a;\n\t\tthis.b = source.b;\n\t\tthis.c = source.c;\n\n\t\tthis.normal.copy( source.normal );\n\t\tthis.color.copy( source.color );\n\n\t\tthis.materialIndex = source.materialIndex;\n\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/BufferAttribute.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.itemSize = itemSize;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\tthis.normalized = normalized === true;\n\n};\n\nTHREE.BufferAttribute.prototype = {\n\n\tconstructor: THREE.BufferAttribute,\n\n\tget count() {\n\n\t\treturn this.array.length / this.itemSize;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyArray: function ( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t},\n\n\tcopyColorsArray: function ( colors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\tvar color = colors[ i ];\n\n\t\t\tif ( color === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\tcolor = new THREE.Color();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = color.r;\n\t\t\tarray[ offset ++ ] = color.g;\n\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyIndicesArray: function ( indices ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tvar index = indices[ i ];\n\n\t\t\tarray[ offset ++ ] = index.a;\n\t\t\tarray[ offset ++ ] = index.b;\n\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector2sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector3sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector4sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize ];\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n//\n\nTHREE.Int8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\n};\n\nTHREE.Int16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\n\n};\n\nTHREE.Uint16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\n\n};\n\nTHREE.Int32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\n\n};\n\nTHREE.Uint32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\n\n};\n\nTHREE.Float32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\n\n};\n\nTHREE.Float64Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\n\n};\n\n\n// Deprecated\n\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\n\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\n\n};\n\n// File:src/core/InstancedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\n\n\tTHREE.BufferAttribute.call( this, array, itemSize );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\n\nTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\n\n\tTHREE.BufferAttribute.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBuffer = function ( array, stride ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.stride = stride;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n};\n\nTHREE.InterleavedBuffer.prototype = {\n\n\tconstructor: THREE.InterleavedBuffer,\n\n\tget length () {\n\n\t\treturn this.array.length;\n\n\t},\n\n\tget count () {\n\n\t\treturn this.array.length / this.stride;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.stride = source.stride;\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n// File:src/core/InstancedInterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\n\n\tTHREE.InterleavedBuffer.call( this, array, stride );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\n\nTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.data = interleavedBuffer;\n\tthis.itemSize = itemSize;\n\tthis.offset = offset;\n\n};\n\n\nTHREE.InterleavedBufferAttribute.prototype = {\n\n\tconstructor: THREE.InterleavedBufferAttribute,\n\n\tget length() {\n\n\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\treturn this.array.length;\n\n\t},\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/Geometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://clara.io\n */\n\nTHREE.Geometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [ [] ];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.elementsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tvar scope = this;\n\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tvar tempNormals = [];\n\t\tvar tempUVs = [];\n\t\tvar tempUVs2 = [];\n\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( indices !== undefined ) {\n\n\t\t\tvar groups = geometry.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tvar center = this.boundingSphere.center;\n\t\tvar radius = this.boundingSphere.radius;\n\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tvar matrix = new THREE.Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\tvertices = new Array( this.vertices.length );\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new THREE.Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t},\n\n\tcomputeLineDistances: function () {\n\n\t\tvar d = 0;\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tif ( i > 0 ) {\n\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\tif ( geometry instanceof THREE.Geometry === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalMatrix,\n\t\tvertexOffset = this.vertices.length,\n\t\tvertices1 = this.vertices,\n\t\tvertices2 = geometry.vertices,\n\t\tfaces1 = this.faces,\n\t\tfaces2 = geometry.faces,\n\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tif ( uv === undefined ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( mesh instanceof THREE.Mesh === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i, il, face;\n\t\tvar indices, j, jl;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\tvar dupIndex = - 1;\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tdupIndex = n;\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tvar faces = this.faces;\n\t\tvar length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tvar newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tvar faces = [];\n\t\tvar normals = [];\n\t\tvar normalsHash = {};\n\t\tvar colors = [];\n\t\tvar colorsHash = {};\n\t\tvar uvs = [];\n\t\tvar uvsHash = {};\n\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tvar hasMaterial = true;\n\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tvar faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.vertices = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\n\t\tvar vertices = source.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\tvar faces = source.faces;\n\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.GeometryIdCount = 0;\n\n// File:src/core/DirectGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'DirectGeometry';\n\n\tthis.indices = [];\n\tthis.vertices = [];\n\tthis.normals = [];\n\tthis.colors = [];\n\tthis.uvs = [];\n\tthis.uvs2 = [];\n\n\tthis.groups = [];\n\n\tthis.morphTargets = {};\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\t// this.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\n\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\n\n\tcomputeFaceNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeGroups: function ( geometry ) {\n\n\t\tvar group;\n\t\tvar groups = [];\n\t\tvar materialIndex;\n\n\t\tvar faces = geometry.faces;\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tvar faces = geometry.faces;\n\t\tvar vertices = geometry.vertices;\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tvar morphTargets = geometry.morphTargets;\n\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\tvar morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tvar morphNormals = geometry.morphNormals;\n\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\tvar morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tvar skinIndices = geometry.skinIndices;\n\t\tvar skinWeights = geometry.skinWeights;\n\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/core/BufferGeometry.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n};\n\nObject.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tthis.index = index;\n\n\t},\n\n\taddAttribute: function ( name, attribute ) {\n\n\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( name === 'index' ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\tthis.setIndex( attribute );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tremoveAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tvar normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tsetFromObject: function ( object ) {\n\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\n\n\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\n\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tupdateFromObject: function ( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\tif ( direct === undefined ) {\n\n\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\tgeometry = direct;\n\n\t\t}\n\n\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.position;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.normal;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.color;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\tvar attribute = this.attributes.uv;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\tvar attribute = this.attributes.lineDistance;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\n\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t},\n\n\tfromDirectGeometry: function ( geometry ) {\n\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tthis.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tvar positions = this.attributes.position.array;\n\n\t\tif ( positions !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromArray( positions );\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar box = new THREE.Box3();\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function computeBoundingSphere() {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes.position;\n\n\t\t\tif ( positions ) {\n\n\t\t\t\tvar array = positions.array;\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tbox.setFromArray( array );\n\t\t\t\tbox.center( center );\n\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tvar index = this.index;\n\t\tvar attributes = this.attributes;\n\t\tvar groups = this.groups;\n\n\t\tif ( attributes.position ) {\n\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar normals = attributes.normal.array;\n\n\t\t\tvar vA, vB, vC,\n\n\t\t\tpA = new THREE.Vector3(),\n\t\t\tpB = new THREE.Vector3(),\n\t\t\tpC = new THREE.Vector3(),\n\n\t\t\tcb = new THREE.Vector3(),\n\t\t\tab = new THREE.Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tvar attribute1 = attributes[ key ];\n\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar normals = this.attributes.normal.array;\n\n\t\tvar x, y, z, n;\n\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\tx = normals[ i ];\n\t\t\ty = normals[ i + 1 ];\n\t\t\tz = normals[ i + 2 ];\n\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\tnormals[ i ] *= n;\n\t\t\tnormals[ i + 1 ] *= n;\n\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t}\n\n\t},\n\n\ttoNonIndexed: function () {\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar geometry2 = new THREE.BufferGeometry();\n\n\t\tvar indices = this.index.array;\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tvar index = 0, index2 = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tdata.data = { attributes: {} };\n\n\t\tvar index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: array\n\t\t\t};\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: attribute.normalized\n\t\t\t};\n\n\t\t}\n\n\t\tvar groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tvar boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.BufferGeometry.MaxIndex = 65535;\n\n// File:src/core/InstancedBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferGeometry = function () {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'InstancedBufferGeometry';\n\tthis.maxInstancedCount = undefined;\n\n};\n\nTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\n\nTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\n\n\tthis.groups.push( {\n\n\t\tstart: start,\n\t\tcount: count,\n\t\tinstances: instances\n\n\t} );\n\n};\n\nTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\n\n\tvar index = source.index;\n\n\tif ( index !== null ) {\n\n\t\tthis.setIndex( index.clone() );\n\n\t}\n\n\tvar attributes = source.attributes;\n\n\tfor ( var name in attributes ) {\n\n\t\tvar attribute = attributes[ name ];\n\t\tthis.addAttribute( name, attribute.clone() );\n\n\t}\n\n\tvar groups = source.groups;\n\n\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tvar group = groups[ i ];\n\t\tthis.addGroup( group.start, group.count, group.instances );\n\n\t}\n\n\treturn this;\n\n};\n\n// File:src/core/Uniform.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Uniform = function ( value ) {\n\n\tif ( typeof value === 'string' ) {\n\n\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\tvalue = arguments[ 1 ];\n\n\t}\n\n\tthis.value = value;\n\n\tthis.dynamic = false;\n\n};\n\nTHREE.Uniform.prototype = {\n\n\tconstructor: THREE.Uniform,\n\n\tonUpdate: function ( callback ) {\n\n\t\tthis.dynamic = true;\n\t\tthis.onUpdateCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/animation/AnimationAction.js\n\n/**\n *\n * Action provided by AnimationMixer for scheduling clip playback on specific\n * objects.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n *\n */\n\nTHREE.AnimationAction = function() {\n\n\tthrow new Error( \"THREE.AnimationAction: \" +\n\t\t\t\"Use mixer.clipAction for construction.\" );\n\n};\n\nTHREE.AnimationAction._new =\n\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\tthis._mixer = mixer;\n\tthis._clip = clip;\n\tthis._localRoot = localRoot || null;\n\n\tvar tracks = clip.tracks,\n\t\tnTracks = tracks.length,\n\t\tinterpolants = new Array( nTracks );\n\n\tvar interpolantSettings = {\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\t};\n\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\tinterpolants[ i ] = interpolant;\n\t\tinterpolant.settings = interpolantSettings;\n\n\t}\n\n\tthis._interpolantSettings = interpolantSettings;\n\n\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t// inside: PropertyMixer (managed by the mixer)\n\tthis._propertyBindings = new Array( nTracks );\n\n\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\tthis._timeScaleInterpolant = null;\n\tthis._weightInterpolant = null;\n\n\tthis.loop = THREE.LoopRepeat;\n\tthis._loopCount = -1;\n\n\t// global mixer time when the action is to be started\n\t// it's set back to 'null' upon start of the action\n\tthis._startTime = null;\n\n\t// scaled local time of the action\n\t// gets clamped or wrapped to 0..clip.duration according to loop\n\tthis.time = 0;\n\n\tthis.timeScale = 1;\n\tthis._effectiveTimeScale = 1;\n\n\tthis.weight = 1;\n\tthis._effectiveWeight = 1;\n\n\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\n\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n};\n\nTHREE.AnimationAction._new.prototype = {\n\n\tconstructor: THREE.AnimationAction._new,\n\n\t// State & Scheduling\n\n\tplay: function() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t},\n\n\tstop: function() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t},\n\n\treset: function() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0;\t\t\t// restart clip\n\t\tthis._loopCount = -1;\t// forget previous loops\n\t\tthis._startTime = null;\t// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t},\n\n\tisRunning: function() {\n\n\t\tvar start = this._startTime;\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t},\n\n\t// return true when play has been called\n\tisScheduled: function() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t},\n\n\tstartAt: function( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t},\n\n\tsetLoop: function( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t},\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight: function( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t},\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight: function() {\n\n\t\treturn this._effectiveWeight;\n\n\t},\n\n\tfadeIn: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t},\n\n\tfadeOut: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t},\n\n\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n\t\tvar mixer = this._mixer;\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif( warp ) {\n\n\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t},\n\n\tstopFading: function() {\n\n\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Time Scale Control\n\n\t// set the weight stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale: function( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale: function() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t},\n\n\tsetDuration: function( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\tsyncWith: function( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\thalt: function( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t},\n\n\twarp: function( startTimeScale, endTimeScale, duration ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t},\n\n\tstopWarping: function() {\n\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Object Accessors\n\n\tgetMixer: function() {\n\n\t\treturn this._mixer;\n\n\t},\n\n\tgetClip: function() {\n\n\t\treturn this._clip;\n\n\t},\n\n\tgetRoot: function() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t},\n\n\t// Interna\n\n\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t// called by the mixer\n\n\t\tvar startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tvar weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tvar interpolants = this._interpolants;\n\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_updateWeight: function( time ) {\n\n\t\tvar weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t},\n\n\t_updateTimeScale: function( time ) {\n\n\t\tvar timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t},\n\n\t_updateTime: function( deltaTime ) {\n\n\t\tvar time = this.time + deltaTime;\n\n\t\tif ( deltaTime === 0 ) return time;\n\n\t\tvar duration = this._clip.duration,\n\n\t\t\tloop = this.loop,\n\t\t\tloopCount = this._loopCount;\n\n\t\tif ( loop === THREE.LoopOnce ) {\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tthis.loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else break handle_stop;\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tvar pingPong = ( loop === THREE.LoopPingPong );\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t// wrap around\n\n\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\tthis.time = time;\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.time = time;\n\t\treturn time;\n\n\t},\n\n\t_setEndings: function( atStart, atEnd, pingPong ) {\n\n\t\tvar settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\n\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationClip.js\n\n/**\n *\n * Reusable set of Tracks that represent an animation.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationClip = function ( name, duration, tracks ) {\n\n\tthis.name = name;\n\tthis.tracks = tracks;\n\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// this means it should figure out its duration by scanning the tracks\n\tif ( this.duration < 0 ) {\n\n\t\tthis.resetDuration();\n\n\t}\n\n\t// maybe only do these on demand, as doing them here could potentially slow down loading\n\t// but leaving these here during development as this ensures a lot of testing of these functions\n\tthis.trim();\n\tthis.optimize();\n\n};\n\nTHREE.AnimationClip.prototype = {\n\n\tconstructor: THREE.AnimationClip,\n\n\tresetDuration: function() {\n\n\t\tvar tracks = this.tracks,\n\t\t\tduration = 0;\n\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tvar track = this.tracks[ i ];\n\n\t\t\tduration = Math.max(\n\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t},\n\n\ttrim: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\toptimize: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.AnimationClip, {\n\n\tparse: function( json ) {\n\n\t\tvar tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\n\n\t},\n\n\n\ttoJSON: function( clip ) {\n\n\t\tvar tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tvar json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks\n\n\t\t};\n\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t},\n\n\n\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tvar times = [];\n\t\t\tvar values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\ti,\n\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\t\tnew THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\ttimes, values\n\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t}\n\n\t\treturn new THREE.AnimationClip( name, -1, tracks );\n\n\t},\n\n\tfindByName: function( objectOrClipArray, name ) {\n\n\t\tvar clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tvar o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\n\t\tvar animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar clips = [];\n\n\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t},\n\n\t// parse the animation.hierarchy format\n\tparseAnimation: function( animation, bones, nodeName ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar addNonemptyTrack = function(\n\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\tTHREE.AnimationUtils.flattenJSON(\n\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar tracks = [];\n\n\t\tvar clipName = animation.name || 'default';\n\t\t// automatic length determination in AnimationClip.\n\t\tvar duration = animation.length || -1;\n\t\tvar fps = animation.fps || 30;\n\n\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets in a way exactly compatible\n\t\t\t// with AnimationHandler.init( animation )\n\t\t\tif ( animationKeys[0].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tvar morphTargetNames = {};\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\n\n\t\treturn clip;\n\n\t}\n\n} );\n\n// File:src/animation/AnimationMixer.js\n\n/**\n *\n * Player for AnimationClips.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.AnimationMixer = function( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n};\n\nObject.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\tprototypeAction = null;\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tvar existingAction =\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tvar newAction = new THREE.\n\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function() {\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tthis._nActiveActions = 0;\n\t\tthis._nActiveBindings = 0;\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tactions[ i ].reset();\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].useCount = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tvar action = actions[ i ];\n\n\t\t\tif ( action.enabled ) {\n\n\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tvar bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function() {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function( clip ) {\n\n\t\tvar actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function( root ) {\n\n\t\tvar rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function( clip, optionalRoot ) {\n\n\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\nTHREE.AnimationMixer._Action = THREE.AnimationAction._new;\n\n// Implementation details:\n\nObject.assign( THREE.AnimationMixer.prototype, {\n\n\t_bindAction: function( action, prototypeAction ) {\n\n\t\tvar root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar track = tracks[ i ],\n\t\t\t\ttrackName = track.name,\n\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new THREE.PropertyMixer(\n\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\n\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for _Action objects\n\n\t_isActiveAction: function( action ) {\n\n\t\tvar index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\n\t\tvar actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function( action ) {\n\n\t\tvar actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tvar clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function( action ) {\n\n\t\tvar bindings = action._propertyBindings;\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tvar binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tbindings = this._bindings;\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tremove_empty_map: {\n\n\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function() {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new THREE.LinearInterpolant(\n\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function( interpolant ) {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\n} );\n\n// File:src/animation/AnimationObjectGroup.js\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n * \t-\tAdd objects you would otherwise pass as 'root' to the\n * \t\tconstructor or the .clipAction method of AnimationMixer.\n *\n * \t-\tInstead pass this object as 'root'.\n *\n * \t-\tYou can also add and remove objects later when the mixer\n * \t\tis running.\n *\n * Note:\n *\n *  \tObjects of this class appear as one object to the mixer,\n *  \tso cache control of the individual objects must be done\n *  \ton the group.\n *\n * Limitation:\n *\n * \t- \tThe animated properties must be compatible among the\n * \t\tall objects in the group.\n *\n *  -\tA single property can either be controlled through a\n *  \ttarget group or directly, but not both.\n *\n * @author tschw\n */\n\nTHREE.AnimationObjectGroup = function( var_args ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// cached objects followed by the active ones\n\tthis._objects = Array.prototype.slice.call( arguments );\n\n\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t// note: read by PropertyBinding.Composite\n\n\tvar indices = {};\n\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t}\n\n\tthis._paths = [];\t\t\t\t\t// inside: string\n\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\tvar scope = this;\n\n\tthis.stats = {\n\n\t\tobjects: {\n\t\t\tget total() { return scope._objects.length; },\n\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t},\n\n\t\tget bindingsPerObject() { return scope._bindings.length; }\n\n\t};\n\n};\n\nTHREE.AnimationObjectGroup.prototype = {\n\n\tconstructor: THREE.AnimationObjectGroup,\n\n\tadd: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\tnew THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tvar knownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject) {\n\n\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\tremove: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// remove & forget\n\tuncache: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_: function( path, parsedPath ) {\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ],\n\t\t\tbindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tvar paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( var i = nCachedObjects,\n\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\n\t\t\tvar object = objects[ i ];\n\n\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t},\n\n\tunsubscribe_: function( path ) {\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationUtils.js\n\n/**\n * @author tschw\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function( array, from, to ) {\n\n\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tvar n = times.length;\n\t\tvar result = new Array( n );\n\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function( values, stride, order ) {\n\n\t\tvar nValues = values.length;\n\t\tvar result = new values.constructor( nValues );\n\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tvar value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/KeyframeTrack.js\n\n/**\n *\n * A timed sequence of keyframes for a specific property.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\n\tif( times === undefined || times.length === 0 ) {\n\n\t\tthrow new Error( \"no keyframes in track named \" + name );\n\n\t}\n\n\tthis.name = name;\n\n\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\n\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\tthis.validate();\n\tthis.optimize();\n\n};\n\nTHREE.KeyframeTrack.prototype = {\n\n\tconstructor: THREE.KeyframeTrack,\n\n\tTimeBufferType: Float32Array,\n\tValueBufferType: Float32Array,\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodDiscrete: function( result ) {\n\n\t\treturn new THREE.DiscreteInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.LinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: function( result ) {\n\n\t\treturn new THREE.CubicInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tsetInterpolation: function( interpolation ) {\n\n\t\tvar factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase THREE.InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( message );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t},\n\n\tgetInterpolation: function() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn THREE.InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn THREE.InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn THREE.InterpolateSmooth;\n\n\t\t}\n\n\t},\n\n\tgetValueSize: function() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t},\n\n\t// move all keyframes either forwards or backwards in time\n\tshift: function( timeOffset ) {\n\n\t\tif( timeOffset !== 0.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale: function( timeScale ) {\n\n\t\tif( timeScale !== 1.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim: function( startTime, endTime ) {\n\n\t\tvar times = this.times,\n\t\t\tnKeys = times.length,\n\t\t\tfrom = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\n\t\t\tvar stride = this.getValueSize();\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = THREE.AnimationUtils.\n\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate: function() {\n\n\t\tvar valid = true;\n\n\t\tvar valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif( nKeys === 0 ) {\n\n\t\t\tconsole.error( \"track is empty\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar prevTime = null;\n\n\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tvar currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize: function() {\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\t\t\tstride = this.getValueSize(),\n\n\t\t\twriteIndex = 1;\n\n\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\n\n\t\t\tvar keep = false;\n\n\t\t\tvar time = times[ i ];\n\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\t\t\tvar offset = i * stride,\n\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.KeyframeTrack, {\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tparse: function( json ) {\n\n\t\tif( json.type === undefined ) {\n\n\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\n\t\t}\n\n\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\tif ( json.times === undefined ) {\n\n\t\t\tvar times = [], values = [];\n\n\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\tjson.times = times;\n\t\t\tjson.values = values;\n\n\t\t}\n\n\t\t// derived classes can define a static parse method\n\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\treturn trackType.parse( json );\n\n\t\t} else {\n\n\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\treturn new trackType(\n\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function( track ) {\n\n\t\tvar trackType = track.constructor;\n\n\t\tvar json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t},\n\n\t_getTrackTypeForValueTypeName: function( typeName ) {\n\n\t\tswitch( typeName.toLowerCase() ) {\n\n\t\t\tcase \"scalar\":\n\t\t\tcase \"double\":\n\t\t\tcase \"float\":\n\t\t\tcase \"number\":\n\t\t\tcase \"integer\":\n\n\t\t\t\treturn THREE.NumberKeyframeTrack;\n\n\t\t\tcase \"vector\":\n\t\t\tcase \"vector2\":\n\t\t\tcase \"vector3\":\n\t\t\tcase \"vector4\":\n\n\t\t\t\treturn THREE.VectorKeyframeTrack;\n\n\t\t\tcase \"color\":\n\n\t\t\t\treturn THREE.ColorKeyframeTrack;\n\n\t\t\tcase \"quaternion\":\n\n\t\t\t\treturn THREE.QuaternionKeyframeTrack;\n\n\t\t\tcase \"bool\":\n\t\t\tcase \"boolean\":\n\n\t\t\t\treturn THREE.BooleanKeyframeTrack;\n\n\t\t\tcase \"string\":\n\n\t\t\t\treturn THREE.StringKeyframeTrack;\n\n\t\t}\n\n\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\n\t}\n\n} );\n\n// File:src/animation/PropertyBinding.js\n\n/**\n *\n * A reference to a real property in the scene graph.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\n\n\tthis.path = path;\n\tthis.parsedPath = parsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis.node = THREE.PropertyBinding.findNode(\n\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\n\tthis.rootNode = rootNode;\n\n};\n\nTHREE.PropertyBinding.prototype = {\n\n\tconstructor: THREE.PropertyBinding,\n\n\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t// prototype version of these methods with one that represents\n\t\t// the bound state. When the property is not found, the methods\n\t\t// become no-ops.\n\n\t},\n\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t},\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind: function() {\n\n\t\tvar targetObject = this.node,\n\t\t\tparsedPath = this.parsedPath,\n\n\t\t\tobjectName = parsedPath.objectName,\n\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = THREE.PropertyBinding.findNode(\n\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n \t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tvar versioning = this.Versioning.None;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tvar bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( nodeProperty.length !== undefined ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t},\n\n\tunbind: function() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n};\n\nObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable: function() {},\n\t_setValue_unavailable: function() {},\n\n\t// initial state of these methods that calls 'bind'\n\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\n\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\n\n\tBindingType: {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t},\n\n\tVersioning: {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t},\n\n\tGetterByBindingType: [\n\n\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t},\n\n\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\tvar source = this.resolvedProperty;\n\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t},\n\n\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t}\n\n\t],\n\n\tSetterByBindingTypeAndVersioning: [\n\n\t\t[\n\t\t\t// Direct\n\n\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// EntireArray\n\n\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// ArrayElement\n\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// HasToFromArray\n\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t]\n\n\t]\n\n} );\n\nTHREE.PropertyBinding.Composite =\n\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\n\tvar parsedPath = optionalParsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis._targetGroup = targetGroup;\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n};\n\nTHREE.PropertyBinding.Composite.prototype = {\n\n\tconstructor: THREE.PropertyBinding.Composite,\n\n\tgetValue: function( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t},\n\n\tsetValue: function( array, offset ) {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t},\n\n\tbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t},\n\n\tunbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\n\n\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\n\n\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\n\n\t} else {\n\n\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\n\n\t}\n\n};\n\nTHREE.PropertyBinding.parseTrackName = function( trackName ) {\n\n\t// matches strings in the form of:\n\t//    nodeName.property\n\t//    nodeName.property[accessor]\n\t//    nodeName.material.property[accessor]\n\t//    uuid.property[accessor]\n\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t//    parentName/nodeName.property\n\t//    parentName/parentName/nodeName.property[index]\n\t//\t  .bone[Armature.DEF_cog].position\n\t// created and tested via https://regex101.com/#javascript\n\n\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\n\tvar matches = re.exec( trackName );\n\n\tif ( ! matches ) {\n\n\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\n\t}\n\n\tif ( matches.index === re.lastIndex ) {\n\n\t\tre.lastIndex++;\n\n\t}\n\n\tvar results = {\n\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\tnodeName: matches[ 3 ], \t// allowed to be null, specified root node.\n\t\tobjectName: matches[ 5 ],\n\t\tobjectIndex: matches[ 7 ],\n\t\tpropertyName: matches[ 9 ],\n\t\tpropertyIndex: matches[ 11 ]\t// allowed to be null, specifies that the whole property is set.\n\t};\n\n\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n\t}\n\n\treturn results;\n\n};\n\nTHREE.PropertyBinding.findNode = function( root, nodeName ) {\n\n\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\treturn root;\n\n\t}\n\n\t// search into skeleton bones.\n\tif ( root.skeleton ) {\n\n\t\tvar searchSkeleton = function( skeleton ) {\n\n\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n\t\t\t\tvar bone = skeleton.bones[ i ];\n\n\t\t\t\tif ( bone.name === nodeName ) {\n\n\t\t\t\t\treturn bone;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar bone = searchSkeleton( root.skeleton );\n\n\t\tif ( bone ) {\n\n\t\t\treturn bone;\n\n\t\t}\n\t}\n\n\t// search into node subtree.\n\tif ( root.children ) {\n\n\t\tvar searchNodeSubtree = function( children ) {\n\n\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\treturn childNode;\n\n\t\t\t\t}\n\n\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\tif ( result ) return result;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\tif ( subTreeNode ) {\n\n\t\t\treturn subTreeNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\n// File:src/animation/PropertyMixer.js\n\n/**\n *\n * Buffered scene graph property that allows weighted accumulation.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tvar bufferType = Float64Array,\n\t\tmixFunction;\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\n\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\n\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\n\t}\n\n\tthis.buffer = new bufferType( valueSize * 4 );\n\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\n\tthis._mixBufferRegion = mixFunction;\n\n\tthis.cumulativeWeight = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n};\n\nTHREE.PropertyMixer.prototype = {\n\n\tconstructor: THREE.PropertyMixer,\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tvar mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function( accuIndex ) {\n\n\t\tvar stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function() {\n\n\t\tvar binding = this.binding;\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * 3;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\tthis.cumulativeWeight = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function() {\n\n\t\tvar originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tvar s = 1 - t;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tvar j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/tracks/BooleanKeyframeTrack.js\n\n/**\n *\n * A Track of Boolean keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values );\n\n};\n\nTHREE.BooleanKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.BooleanKeyframeTrack,\n\n\tValueTypeName: 'bool',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\tInterpolantFactoryMethodSmooth: undefined\n\n\t// Note: Actually this track could have a optimized / compressed\n\t// representation of a single value and a custom interpolant that\n\t// computes \"firstValue ^ isOdd( index )\".\n\n} );\n\n// File:src/animation/tracks/ColorKeyframeTrack.js\n\n/**\n *\n * A Track of keyframe values that represent color.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.ColorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.ColorKeyframeTrack,\n\n\tValueTypeName: 'color'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n\n\t// Note: Very basic implementation and nothing special yet.\n\t// However, this is the place for color space parameterization.\n\n} );\n\n// File:src/animation/tracks/NumberKeyframeTrack.js\n\n/**\n *\n * A Track of numeric keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.NumberKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.NumberKeyframeTrack,\n\n\tValueTypeName: 'number',\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/animation/tracks/QuaternionKeyframeTrack.js\n\n/**\n *\n * A Track of quaternion keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.QuaternionKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.QuaternionKeyframeTrack,\n\n\tValueTypeName: 'quaternion',\n\n\t// ValueBufferType is inherited\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.QuaternionLinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n} );\n\n// File:src/animation/tracks/StringKeyframeTrack.js\n\n/**\n *\n * A Track that interpolates Strings\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.StringKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.StringKeyframeTrack,\n\n\tValueTypeName: 'string',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\n\tInterpolantFactoryMethodSmooth: undefined\n\n} );\n\n// File:src/animation/tracks/VectorKeyframeTrack.js\n\n/**\n *\n * A Track of vectored keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.VectorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.VectorKeyframeTrack,\n\n\tValueTypeName: 'vector'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/audio/Audio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.Audio = function ( listener ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Audio';\n\n\tthis.context = listener.context;\n\tthis.source = this.context.createBufferSource();\n\tthis.source.onended = this.onEnded.bind( this );\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( listener.getInput() );\n\n\tthis.autoplay = false;\n\n\tthis.startTime = 0;\n\tthis.playbackRate = 1;\n\tthis.isPlaying = false;\n\tthis.hasPlaybackControl = true;\n\tthis.sourceType = 'empty';\n\n\tthis.filters = [];\n\n};\n\nTHREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Audio,\n\n\tgetOutput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tsetNodeSource: function ( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t},\n\n\tsetBuffer: function ( audioBuffer ) {\n\n\t\tthis.source.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t},\n\n\tplay: function () {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar source = this.context.createBufferSource();\n\n\t\tsource.buffer = this.source.buffer;\n\t\tsource.loop = this.source.loop;\n\t\tsource.onended = this.source.onended;\n\t\tsource.start( 0, this.startTime );\n\t\tsource.playbackRate.value = this.playbackRate;\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\treturn this.connect();\n\n\t},\n\n\tpause: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = this.context.currentTime;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = 0;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdisconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilters: function () {\n\n\t\treturn this.filters;\n\n\t},\n\n\tsetFilters: function ( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value;\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t},\n\n\tsetFilter: function ( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t},\n\n\tsetPlaybackRate: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetPlaybackRate: function () {\n\n\t\treturn this.playbackRate;\n\n\t},\n\n\tonEnded: function () {\n\n\t\tthis.isPlaying = false;\n\n\t},\n\n\tgetLoop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.source.loop;\n\n\t},\n\n\tsetLoop: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.loop = value;\n\n\t},\n\n\tgetVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\n\tsetVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/audio/AudioAnalyser.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioAnalyser = function ( audio, fftSize ) {\n\n\tthis.analyser = audio.context.createAnalyser();\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\taudio.getOutput().connect( this.analyser );\n\n};\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\n\tgetFrequencyData: function () {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t},\n\n\tgetAverageFrequency: function () {\n\n\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n} );\n\n// File:src/audio/AudioContext.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.defineProperty( THREE, 'AudioContext', {\n\n\tget: ( function () {\n\n\t\tvar context;\n\n\t\treturn function get() {\n\n\t\t\tif ( context === undefined ) {\n\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t\t}\n\n\t\t\treturn context;\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/audio/PositionalAudio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PositionalAudio = function ( listener ) {\n\n\tTHREE.Audio.call( this, listener );\n\n\tthis.panner = this.context.createPanner();\n\tthis.panner.connect( this.gain );\n\n};\n\nTHREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {\n\n\tconstructor: THREE.PositionalAudio,\n\n\tgetOutput: function () {\n\n\t\treturn this.panner;\n\n\t},\n\n\tgetRefDistance: function () {\n\n\t\treturn this.panner.refDistance;\n\n\t},\n\n\tsetRefDistance: function ( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t},\n\n\tgetRolloffFactor: function () {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t},\n\n\tsetRolloffFactor: function ( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t},\n\n\tgetDistanceModel: function () {\n\n\t\treturn this.panner.distanceModel;\n\n\t},\n\n\tsetDistanceModel: function ( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t},\n\n\tgetMaxDistance: function () {\n\n\t\treturn this.panner.maxDistance;\n\n\t},\n\n\tsetMaxDistance: function ( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t};\n\n\t} )()\n\n\n} );\n\n// File:src/audio/AudioListener.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioListener = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'AudioListener';\n\n\tthis.context = THREE.AudioContext;\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( this.context.destination );\n\n\tthis.filter = null;\n\n};\n\nTHREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.AudioListener,\n\n\tgetInput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tremoveFilter: function ( ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.filter;\n\n\t},\n\n\tsetFilter: function ( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t},\n\n\tgetMasterVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\tsetMasterVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar scale = new THREE.Vector3();\n\n\t\tvar orientation = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tvar listener = this.context.listener;\n\t\t\tvar up = this.up;\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/cameras/Camera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.Camera = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Camera';\n\n\tthis.matrixWorldInverse = new THREE.Matrix4();\n\tthis.projectionMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Camera.prototype.constructor = THREE.Camera;\n\nTHREE.Camera.prototype.getWorldDirection = function () {\n\n\tvar quaternion = new THREE.Quaternion();\n\n\treturn function getWorldDirection( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.getWorldQuaternion( quaternion );\n\n\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.lookAt = function () {\n\n\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\tvar m1 = new THREE.Matrix4();\n\n\treturn function lookAt( vector ) {\n\n\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.clone = function () {\n\n\treturn new this.constructor().copy( this );\n\n};\n\nTHREE.Camera.prototype.copy = function ( source ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\treturn this;\n\n};\n\n// File:src/cameras/CubeCamera.js\n\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'CubeCamera';\n\n\tvar fov = 90, aspect = 1;\n\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, - 1, 0 );\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, - 1, 0 );\n\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, - 1 );\n\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, - 1, 0 );\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, - 1, 0 );\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\n\tthis.add( cameraNZ );\n\n\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\n\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderTarget.activeCubeFace = 0;\n\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 1;\n\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 2;\n\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 3;\n\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 4;\n\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderTarget.activeCubeFace = 5;\n\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\trenderer.setRenderTarget( null );\n\n\t};\n\n};\n\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\n\n// File:src/cameras/OrthographicCamera.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author arose / http://github.com/arose\n */\n\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'OrthographicCamera';\n\n\tthis.zoom = 1;\n\tthis.view = null;\n\n\tthis.left = left;\n\tthis.right = right;\n\tthis.top = top;\n\tthis.bottom = bottom;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.OrthographicCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t},\n\n\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tvar cx = ( this.right + this.left ) / 2;\n\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\tvar left = cx - dx;\n\t\tvar right = cx + dx;\n\t\tvar top = cy + dy;\n\t\tvar bottom = cy - dy;\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/PerspectiveCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author tschw\n */\n\nTHREE.PerspectiveCamera = function( fov, aspect, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'PerspectiveCamera';\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.zoom = 1;\n\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\tthis.focus = 10;\n\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.view = null;\n\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.PerspectiveCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength: function ( focalLength ) {\n\n\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength: function () {\n\n\t\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t},\n\n\tgetEffectiveFOV: function () {\n\n\t\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t},\n\n\tgetFilmWidth: function () {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t},\n\n\tgetFilmHeight: function () {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t},\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   var w = 1920;\n\t *   var h = 1080;\n\t *   var fullWidth = w * 3;\n\t *   var fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar near = this.near,\n\t\t\ttop = near * Math.tan(\n\t\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\theight = 2 * top,\n\t\t\twidth = this.aspect * height,\n\t\t\tleft = - 0.5 * width,\n\t\t\tview = this.view;\n\n\t\tif ( view !== null ) {\n\n\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tvar skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/StereoCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.StereoCamera = function () {\n\n\tthis.type = 'StereoCamera';\n\n\tthis.aspect = 1;\n\n\tthis.cameraL = new THREE.PerspectiveCamera();\n\tthis.cameraL.layers.enable( 1 );\n\tthis.cameraL.matrixAutoUpdate = false;\n\n\tthis.cameraR = new THREE.PerspectiveCamera();\n\tthis.cameraR.layers.enable( 2 );\n\tthis.cameraR.matrixAutoUpdate = false;\n\n};\n\nObject.assign( THREE.StereoCamera.prototype, {\n\n\tupdate: ( function () {\n\n\t\tvar focus, fov, aspect, near, far;\n\n\t\tvar eyeRight = new THREE.Matrix4();\n\t\tvar eyeLeft = new THREE.Matrix4();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\tfocus = camera.focus;\n\t\t\t\tfov = camera.fov;\n\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\tnear = camera.near;\n\t\t\t\tfar = camera.far;\n\n\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\tvar eyeSep = 0.064 / 2;\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t// translate xOffset\n\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t// for left eye\n\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t// for right eye\n\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t}\n\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/lights/Light.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Light = function ( color, intensity ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Light';\n\n\tthis.color = new THREE.Color( color );\n\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\tthis.receiveShadow = undefined;\n\n};\n\nTHREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Light,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/lights/LightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LightShadow = function ( camera ) {\n\n\tthis.camera = camera;\n\n\tthis.bias = 0;\n\tthis.radius = 1;\n\n\tthis.mapSize = new THREE.Vector2( 512, 512 );\n\n\tthis.map = null;\n\tthis.matrix = new THREE.Matrix4();\n\n};\n\nObject.assign( THREE.LightShadow.prototype, {\n\n\tcopy: function ( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\n// File:src/lights/AmbientLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AmbientLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'AmbientLight';\n\n\tthis.castShadow = undefined;\n\n};\n\nTHREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.AmbientLight\n\n} );\n\n// File:src/lights/DirectionalLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DirectionalLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'DirectionalLight';\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tthis.shadow = new THREE.DirectionalLightShadow();\n\n};\n\nTHREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.DirectionalLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/DirectionalLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectionalLightShadow = function ( light ) {\n\n\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n};\n\nTHREE.DirectionalLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.DirectionalLightShadow\n\n} );\n\n// File:src/lights/HemisphereLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\n\n\tTHREE.Light.call( this, skyColor, intensity );\n\n\tthis.type = 'HemisphereLight';\n\n\tthis.castShadow = undefined;\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.groundColor = new THREE.Color( groundColor );\n\n};\n\nTHREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.HemisphereLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/PointLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'PointLight';\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n};\n\nTHREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.PointLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'SpotLight';\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * Math.PI;\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / Math.PI;\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.SpotLightShadow();\n\n};\n\nTHREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.SpotLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SpotLightShadow = function () {\n\n\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n};\n\nTHREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.SpotLightShadow,\n\n\tupdate: function ( light ) {\n\n\t\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\n\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\tvar far = light.distance || 500;\n\n\t\tvar camera = this.camera;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/AudioLoader.js\n\n/**\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.AudioLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.AudioLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar context = THREE.AudioContext;\n\n\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t} );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n} );\n\n// File:src/loaders/Cache.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\n// File:src/loaders/Loader.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Loader = function () {\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function () {};\n\tthis.onLoadComplete = function () {};\n\n};\n\nTHREE.Loader.prototype = {\n\n\tconstructor: THREE.Loader,\n\n\tcrossOrigin: undefined,\n\n\textractUrlBase: function ( url ) {\n\n\t\tvar parts = url.split( '/' );\n\n\t\tif ( parts.length === 1 ) return './';\n\n\t\tparts.pop();\n\n\t\treturn parts.join( '/' ) + '/';\n\n\t},\n\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\tvar array = [];\n\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tcreateMaterial: ( function () {\n\n\t\tvar color, textureLoader, materialLoader;\n\n\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\tif ( color === undefined ) color = new THREE.Color();\n\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\n\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\n\n\t\t\t// convert from old material format\n\n\t\t\tvar textures = {};\n\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\n\n\t\t\t\tvar texture;\n\n\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t}\n\n\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t}\n\n\t\t\t\tvar uuid = THREE.Math.generateUUID();\n\n\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\treturn uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar json = {\n\t\t\t\tuuid: THREE.Math.generateUUID(),\n\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t};\n\n\t\t\tfor ( var name in m ) {\n\n\t\t\t\tvar value = m[ name ];\n\n\t\t\t\tswitch ( name ) {\n\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\tjson.blending = THREE[ value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\tjson.side = THREE.BackSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\tjson.side = THREE.DoubleSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\tcase 'opacity':\n\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\tcase 'visible':\n\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\treturn materialLoader.parse( json );\n\n\t\t};\n\n\t} )()\n\n};\n\nTHREE.Loader.Handlers = {\n\n\thandlers: [],\n\n\tadd: function ( regex, loader ) {\n\n\t\tthis.handlers.push( regex, loader );\n\n\t},\n\n\tget: function ( file ) {\n\n\t\tvar handlers = this.handlers;\n\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\tvar regex = handlers[ i ];\n\t\t\tvar loader  = handlers[ i + 1 ];\n\n\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n};\n\n// File:src/loaders/XHRLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.XHRLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.XHRLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\tvar scope = this;\n\n\t\tvar cached = THREE.Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tif ( onLoad ) {\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tonLoad( cached );\n\n\t\t\t\t}, 0 );\n\n\t\t\t}\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tvar request = new XMLHttpRequest();\n\t\trequest.overrideMimeType( 'text/plain' );\n\t\trequest.open( 'GET', url, true );\n\n\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\tvar response = event.target.response;\n\n\t\t\tTHREE.Cache.add( url, response );\n\n\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else {\n\n\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, false );\n\n\t\tif ( onProgress !== undefined ) {\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tonProgress( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}, false );\n\n\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\trequest.send( null );\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn request;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetResponseType: function ( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t},\n\n\tsetWithCredentials: function ( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/FontLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.FontLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.FontLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t}\n\n\t\t\tvar font = scope.parse( json );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\treturn new THREE.Font( json );\n\n\t}\n\n} );\n\n// File:src/loaders/ImageLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.ImageLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\timage.onload = function () {\n\n\t\t\tURL.revokeObjectURL( image.src );\n\t\t\tif ( onLoad ) onLoad( image );\n\n\t\t};\n\n\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\n\t\t\timage.src = url;\n\n\t\t} else {\n\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'blob' );\n\t\t\tloader.load( url, function ( blob ) {\n\n\t\t\t\timage.src = URL.createObjectURL( blob );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn image;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/JSONLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.JSONLoader = function ( manager ) {\n\n\tif ( typeof manager === 'boolean' ) {\n\n\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\tmanager = undefined;\n\n\t}\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\tthis.withCredentials = false;\n\n};\n\nObject.assign( THREE.JSONLoader.prototype, {\n\n\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json = JSON.parse( text );\n\t\t\tvar metadata = json.metadata;\n\n\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\tvar type = metadata.type;\n\n\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tparse: function ( json, texturePath ) {\n\n\t\tvar geometry = new THREE.Geometry(),\n\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\tparseModel( scale );\n\n\t\tparseSkin();\n\t\tparseMorphing( scale );\n\t\tparseAnimations();\n\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeBoundingSphere();\n\n\t\tfunction parseModel( scale ) {\n\n\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t}\n\n\t\t\tvar i, j, fi,\n\n\t\t\toffset, zLength,\n\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\ttype,\n\t\t\tisQuad,\n\t\t\thasMaterial,\n\t\t\thasFaceVertexUv,\n\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\tuvLayer, uv, u, v,\n\n\t\t\tfaces = json.faces,\n\t\t\tvertices = json.vertices,\n\t\t\tnormals = json.normals,\n\t\t\tcolors = json.colors,\n\n\t\t\tnUvLayers = 0;\n\n\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t// disregard empty arrays\n\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = vertices.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\tvertex = new THREE.Vector3();\n\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = faces.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\tfaceA = new THREE.Face3();\n\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\tfaceB = new THREE.Face3();\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\toffset += 4;\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface = new THREE.Face3();\n\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseSkin() {\n\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.bones = json.bones;\n\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseMorphing( scale ) {\n\n\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimations() {\n\n\t\t\tvar outputAnimations = [];\n\n\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\tvar animations = [];\n\n\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\tanimations.push( json.animation );\n\n\t\t\t}\n\n\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t}\n\n\t\t\t// parse implicit morph animations\n\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t}\n\n\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t}\n\n\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\treturn { geometry: geometry };\n\n\t\t} else {\n\n\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/LoadingManager.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n\tthis.onStart = undefined;\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\titemsTotal ++;\n\n\t\tif ( isLoading === false ) {\n\n\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLoading = true;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\titemsLoaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t}\n\n\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\tisLoading = false;\n\n\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\tscope.onLoad();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.itemError = function ( url ) {\n\n\t\tif ( scope.onError !== undefined ) {\n\n\t\t\tscope.onError( url );\n\n\t\t}\n\n\t};\n\n};\n\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\n\n// File:src/loaders/BufferGeometryLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometryLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.BufferGeometryLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar index = json.data.index;\n\n\t\tvar TYPED_ARRAYS = {\n\t\t\t'Int8Array': Int8Array,\n\t\t\t'Uint8Array': Uint8Array,\n\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t'Int16Array': Int16Array,\n\t\t\t'Uint16Array': Uint16Array,\n\t\t\t'Int32Array': Int32Array,\n\t\t\t'Uint32Array': Uint32Array,\n\t\t\t'Float32Array': Float32Array,\n\t\t\t'Float64Array': Float64Array\n\t\t};\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tvar attributes = json.data.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t}\n\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tvar center = new THREE.Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/loaders/MaterialLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MaterialLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.textures = {};\n\n};\n\nObject.assign( THREE.MaterialLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTextures: function ( value ) {\n\n\t\tthis.textures = value;\n\n\t},\n\n\tgetTexture: function ( name ) {\n\n\t\tvar textures = this.textures;\n\n\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t}\n\n\t\treturn textures[ name ];\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar material = new THREE[ json.type ];\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\n\t\t// for PointsMaterial\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\n\n\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\n\t\t\tmaterial.transparent = true;\n\n\t\t}\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tvar normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\n\n\t\tif ( json.envMap !== undefined ) {\n\n\t\t\tmaterial.envMap = this.getTexture( json.envMap );\n\t\t\tmaterial.combine = THREE.MultiplyOperation;\n\n\t\t}\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t// MultiMaterial\n\n\t\tif ( json.materials !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n} );\n\n// File:src/loaders/ObjectLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ObjectLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.texturePath = '';\n\n};\n\nObject.assign( THREE.ObjectLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.texturePath === '' ) {\n\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t}\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tparse: function ( json, onLoad ) {\n\n\t\tvar geometries = this.parseGeometries( json.geometries );\n\n\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\tif ( json.animations ) {\n\n\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t}\n\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t},\n\n\tparseGeometries: function ( json ) {\n\n\t\tvar geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE [ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\tcase 'TetrahedronGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t},\n\n\tparseMaterials: function ( json, textures ) {\n\n\t\tvar materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar loader = new THREE.MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t},\n\n\tparseAnimations: function ( json ) {\n\n\t\tvar animations = [];\n\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t},\n\n\tparseImages: function ( json, onLoad ) {\n\n\t\tvar scope = this;\n\t\tvar images = {};\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tvar manager = new THREE.LoadingManager( onLoad );\n\n\t\t\tvar loader = new THREE.ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar image = json[ i ];\n\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t},\n\n\tparseTextures: function ( json, images ) {\n\n\t\tfunction parseConstant( value ) {\n\n\t\t\tif ( typeof( value ) === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn THREE[ value ];\n\n\t\t}\n\n\t\tvar textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\n\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\t\t\t\tif ( Array.isArray( data.wrap ) ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t},\n\n\tparseObject: function () {\n\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\treturn function parseObject( data, geometries, materials ) {\n\n\t\t\tvar object;\n\n\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometries[ name ];\n\n\t\t\t}\n\n\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn materials[ name ];\n\n\t\t\t}\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'Scene':\n\n\t\t\t\t\tobject = new THREE.Scene();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LOD':\n\n\t\t\t\t\tobject = new THREE.LOD();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Line':\n\n\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointCloud':\n\t\t\t\tcase 'Points':\n\n\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Group':\n\n\t\t\t\t\tobject = new THREE.Group();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t} else {\n\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t}\n\n\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\tvar levels = data.levels;\n\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t};\n\n\t}()\n\n} );\n\n// File:src/loaders/TextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.TextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.TextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.Texture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/CubeTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.CubeTextureLoader.prototype, {\n\n\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.CubeTexture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tvar loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/BinaryTextureLoader.js\n\n/**\n * @author Nikos M. / https://github.com/foo123/\n *\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n */\n\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.BinaryTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new THREE.DataTexture();\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\n\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t}\n\n\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n// File:src/loaders/CompressedTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n */\n\nTHREE.CompressedTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.CompressedTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar images = [];\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/materials/Material.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Material = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Material';\n\n\tthis.fog = true;\n\tthis.lights = true;\n\n\tthis.blending = THREE.NormalBlending;\n\tthis.side = THREE.FrontSide;\n\tthis.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\tthis.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blendSrc = THREE.SrcAlphaFactor;\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\tthis.blendEquation = THREE.AddEquation;\n\tthis.blendSrcAlpha = null;\n\tthis.blendDstAlpha = null;\n\tthis.blendEquationAlpha = null;\n\n\tthis.depthFunc = THREE.LessEqualDepth;\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.clippingPlanes = null;\n\tthis.clipShadows = false;\n\n\tthis.colorWrite = true;\n\n\tthis.precision = null; // override the renderer's default precision for this material\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.alphaTest = 0;\n\tthis.premultipliedAlpha = false;\n\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\tthis.visible = true;\n\n\tthis._needsUpdate = true;\n\n};\n\nTHREE.Material.prototype = {\n\n\tconstructor: THREE.Material,\n\n\tget needsUpdate() {\n\n\t\treturn this._needsUpdate;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.update();\n\t\tthis._needsUpdate = value;\n\n\t},\n\n\tsetValues: function ( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( var key in values ) {\n\n\t\t\tvar newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue instanceof THREE.Color ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar isRoot = meta === undefined;\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\n\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\n\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\tif ( this.bumpMap instanceof THREE.Texture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\t\tif ( this.normalMap instanceof THREE.Texture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\t\tif ( this.displacementMap instanceof THREE.Texture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap instanceof THREE.Texture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t}\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;\n\t\tif ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;\n\t\tif ( this.side !== THREE.FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.shading = source.shading;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.alphaTest = source.alphaTest;\n\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\tthis.overdraw = source.overdraw;\n\n\t\tthis.visible = source.visible;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\tdstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tvar n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\n\t\treturn this;\n\n\t},\n\n\tupdate: function () {\n\n\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nObject.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.MaterialIdCount = 0;\n\n// File:src/materials/LineBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nTHREE.LineBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\n\nTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\tthis.linecap = source.linecap;\n\tthis.linejoin = source.linejoin;\n\n\treturn this;\n\n};\n\n// File:src/materials/LineDashedMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nTHREE.LineDashedMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineDashedMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\n\tthis.scale = 1;\n\tthis.dashSize = 3;\n\tthis.gapSize = 1;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\n\nTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\n\tthis.scale = source.scale;\n\tthis.dashSize = source.dashSize;\n\tthis.gapSize = source.gapSize;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>\n * }\n */\n\nTHREE.MeshBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\n\nTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshDepthMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / https://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshDepthMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshDepthMaterial';\n\n\tthis.depthPacking = THREE.BasicDepthPacking;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.map = null;\n\n\tthis.alphaMap = null;\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\n\nTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.depthPacking = source.depthPacking;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\tthis.map = source.map;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshLambertMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshLambertMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshLambertMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\n\nTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshNormalMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshNormalMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this, parameters );\n\n\tthis.type = 'MeshNormalMaterial';\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\n\nTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhongMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshPhongMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshPhongMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.specular = new THREE.Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\n\nTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.specular.copy( source.specular );\n\tthis.shininess = source.shininess;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshStandardMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshStandardMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.type = 'MeshStandardMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.roughness = 0.5;\n\tthis.metalness = 0.5;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.roughnessMap = null;\n\n\tthis.metalnessMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.envMapIntensity = 1.0;\n\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\n\nTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.color.copy( source.color );\n\tthis.roughness = source.roughness;\n\tthis.metalness = source.metalness;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.roughnessMap = source.roughnessMap;\n\n\tthis.metalnessMap = source.metalnessMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.envMapIntensity = source.envMapIntensity;\n\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhysicalMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  reflectivity: <float>\n * }\n */\n\nTHREE.MeshPhysicalMaterial = function ( parameters ) {\n\n\tTHREE.MeshStandardMaterial.call( this );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.type = 'MeshPhysicalMaterial';\n\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\tthis.clearCoat = 0.0;\n\tthis.clearCoatRoughness = 0.0;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\nTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\n\nTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.reflectivity = source.reflectivity;\n\n\tthis.clearCoat = source.clearCoat;\n\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\treturn this;\n\n};\n\n// File:src/materials/MultiMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MultiMaterial = function ( materials ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.type = 'MultiMaterial';\n\n\tthis.materials = materials instanceof Array ? materials : [];\n\n\tthis.visible = true;\n\n};\n\nTHREE.MultiMaterial.prototype = {\n\n\tconstructor: THREE.MultiMaterial,\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.2,\n\t\t\t\ttype: 'material',\n\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t},\n\t\t\tuuid: this.uuid,\n\t\t\ttype: this.type,\n\t\t\tmaterials: []\n\t\t};\n\n\t\tvar materials = this.materials;\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\tdelete material.metadata;\n\n\t\t\toutput.materials.push( material );\n\n\t\t}\n\n\t\toutput.visible = this.visible;\n\n\t\treturn output;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar material = new this.constructor();\n\n\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t\t}\n\n\t\tmaterial.visible = this.visible;\n\n\t\treturn material;\n\n\t}\n\n};\n\n// File:src/materials/PointsMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nTHREE.PointsMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'PointsMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\n\nTHREE.PointsMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.size = source.size;\n\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShaderMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.ShaderMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'ShaderMaterial';\n\n\tthis.defines = {};\n\tthis.uniforms = {};\n\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\tthis.lights = false; // set to use scene lights\n\tthis.clipping = false; // set to use user-defined clipping planes\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.extensions = {\n\t\tderivatives: false, // set to use derivatives\n\t\tfragDepth: false, // set to use fragment depth values\n\t\tdrawBuffers: false, // set to use draw buffers\n\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t};\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t'color': [ 1, 1, 1 ],\n\t\t'uv': [ 0, 0 ],\n\t\t'uv2': [ 0, 0 ]\n\t};\n\n\tthis.index0AttributeName = undefined;\n\n\tif ( parameters !== undefined ) {\n\n\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n};\n\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\n\nTHREE.ShaderMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.fragmentShader = source.fragmentShader;\n\tthis.vertexShader = source.vertexShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\n\n\tthis.defines = source.defines;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.lights = source.lights;\n\tthis.clipping = source.clipping;\n\n\tthis.skinning = source.skinning;\n\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.extensions = source.extensions;\n\n\treturn this;\n\n};\n\nTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\n\n\tdata.uniforms = this.uniforms;\n\tdata.vertexShader = this.vertexShader;\n\tdata.fragmentShader = this.fragmentShader;\n\n\treturn data;\n\n};\n\n// File:src/materials/RawShaderMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RawShaderMaterial = function ( parameters ) {\n\n\tTHREE.ShaderMaterial.call( this, parameters );\n\n\tthis.type = 'RawShaderMaterial';\n\n};\n\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\n\n// File:src/materials/SpriteMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *\tuvOffset: new THREE.Vector2(),\n *\tuvScale: new THREE.Vector2()\n * }\n */\n\nTHREE.SpriteMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'SpriteMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.map = null;\n\n\tthis.rotation = 0;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\n\nTHREE.SpriteMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.map = source.map;\n\n\tthis.rotation = source.rotation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShadowMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ShadowMaterial = function () {\n\n\tTHREE.ShaderMaterial.call( this, {\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\t\tvertexShader: THREE.ShaderChunk[ 'shadow_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]\n\t} );\n\n\tthis.lights = true;\n\tthis.transparent = true;\n\n\tObject.defineProperties( this, {\n\t\topacity: {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t}\n\t\t}\n\t} );\n\n};\n\nTHREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;\n\n// File:src/textures/Texture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.sourceFile = '';\n\n\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t//\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\n\n\tthis.version = 0;\n\tthis.onUpdate = null;\n\n};\n\nTHREE.Texture.DEFAULT_IMAGE = undefined;\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\n\nTHREE.Texture.prototype = {\n\n\tconstructor: THREE.Texture,\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tfunction getDataURL( image ) {\n\n\t\t\tvar canvas;\n\n\t\t\tif ( image.toDataURL !== undefined ) {\n\n\t\t\t\tcanvas = image;\n\n\t\t\t} else {\n\n\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = image.width;\n\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t} else {\n\n\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tvar image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tmeta.textures[ this.uuid ] = output;\n\n\t\treturn output;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t},\n\n\ttransformUv: function ( uv ) {\n\n\t\tif ( this.mapping !== THREE.UVMapping )  return;\n\n\t\tuv.multiply( this.repeat );\n\t\tuv.add( this.offset );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.TextureIdCount = 0;\n\n// File:src/textures/DepthTexture.js\n\n/**\n * @author Matt DesLauriers / @mattdesl\n */\n\nTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\n\n  this.image = { width: width, height: height };\n\n  this.type = type !== undefined ? type : THREE.UnsignedShortType;\n\n  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n  this.flipY = false;\n  this.generateMipmaps  = false;\n\n};\n\nTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\n\n// File:src/textures/CanvasTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.needsUpdate = true;\n\n};\n\nTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\n\n// File:src/textures/CubeTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\timages = images !== undefined ? images : [];\n\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\n\n\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.flipY = false;\n\n};\n\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\n\nObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\n\n\tget: function () {\n\n\t\treturn this.image;\n\n\t},\n\n\tset: function ( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n} );\n\n// File:src/textures/CompressedTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n\t// no flipping for cube textures\n\t// (also flipping doesn't work for compressed textures )\n\n\tthis.flipY = false;\n\n\t// can't generate mipmaps for compressed textures\n\t// mips must be embedded in DDS files\n\n\tthis.generateMipmaps = false;\n\n};\n\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\n\n// File:src/textures/DataTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { data: data, width: width, height: height };\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n\tthis.flipY = false;\n\tthis.generateMipmaps  = false;\n\n};\n\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\n\n// File:src/textures/VideoTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.generateMipmaps = false;\n\n\tvar scope = this;\n\n\tfunction update() {\n\n\t\trequestAnimationFrame( update );\n\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tscope.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tupdate();\n\n};\n\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\n\n// File:src/objects/Group.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Group = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Group';\n\n};\n\nTHREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Group\n\n} );\n\n// File:src/objects/Points.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Points = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Points';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Points,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar object = this;\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\tvar position = new THREE.Vector3();\n\n\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Line.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Line = function ( geometry, material, mode ) {\n\n\tif ( mode === 1 ) {\n\n\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\treturn new THREE.LineSegments( geometry, material );\n\n\t}\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Line';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Line,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar precision = raycaster.linePrecision;\n\t\t\tvar precisionSq = precision * precision;\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar vStart = new THREE.Vector3();\n\t\t\tvar vEnd = new THREE.Vector3();\n\t\t\tvar interSegment = new THREE.Vector3();\n\t\t\tvar interRay = new THREE.Vector3();\n\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LineSegments.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LineSegments = function ( geometry, material ) {\n\n\tTHREE.Line.call( this, geometry, material );\n\n\tthis.type = 'LineSegments';\n\n};\n\nTHREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {\n\n\tconstructor: THREE.LineSegments\n\n} );\n\n// File:src/objects/Mesh.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */\n\nTHREE.Mesh = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Mesh';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.drawMode = THREE.TrianglesDrawMode;\n\n\tthis.updateMorphTargets();\n\n};\n\nTHREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Mesh,\n\n\tsetDrawMode: function ( value ) {\n\n\t\tthis.drawMode = value;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.drawMode = source.drawMode;\n\n\t\treturn this;\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\n\n\t\t\tthis.morphTargetBase = - 1;\n\t\t\tthis.morphTargetInfluences = [];\n\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tgetMorphTargetIndexByName: function ( name ) {\n\n\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\n\t\t\treturn this.morphTargetDictionary[ name ];\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\n\n\t\treturn 0;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\tvar vA = new THREE.Vector3();\n\t\tvar vB = new THREE.Vector3();\n\t\tvar vC = new THREE.Vector3();\n\n\t\tvar tempA = new THREE.Vector3();\n\t\tvar tempB = new THREE.Vector3();\n\t\tvar tempC = new THREE.Vector3();\n\n\t\tvar uvA = new THREE.Vector2();\n\t\tvar uvB = new THREE.Vector2();\n\t\tvar uvC = new THREE.Vector2();\n\n\t\tvar barycoord = new THREE.Vector3();\n\n\t\tvar intersectionPoint = new THREE.Vector3();\n\t\tvar intersectionPointWorld = new THREE.Vector3();\n\n\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\treturn uv1.clone();\n\n\t\t}\n\n\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\tvar intersect;\n\t\t\tvar material = object.material;\n\n\t\t\tif ( material.side === THREE.BackSide ) {\n\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t} else {\n\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\n\n\t\t\t}\n\n\t\t\tif ( intersect === null ) return null;\n\n\t\t\tintersectionPointWorld.copy( point );\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\treturn {\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\tobject: object\n\t\t\t};\n\n\t\t}\n\n\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\tif ( intersection ) {\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n\t\t\t\t}\n\n\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\n\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t}\n\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar material = this.material;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\tif ( material === undefined ) return;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t// Check boundingBox before continuing\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t}\n\n\t\t\tvar uvs, intersection;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar a, b, c;\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\tuvs = attributes.uv.array;\n\n\t\t\t\t}\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\tc = indices[ i + 2 ];\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\n\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\tc = a + 2;\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\n\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Bone.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.Bone = function ( skin ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Bone';\n\n\tthis.skin = skin;\n\n};\n\nTHREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Bone,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.skin = source.skin;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/objects/Skeleton.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author michael guerrero / http://realitymeltdown.com\n * @author ikerr / http://verold.com\n */\n\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\n\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\tthis.identityMatrix = new THREE.Matrix4();\n\n\t// copy the bone array\n\n\tbones = bones || [];\n\n\tthis.bones = bones.slice( 0 );\n\n\t// create a bone texture or an array of floats\n\n\tif ( this.useVertexTexture ) {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\tsize = Math.max( size, 4 );\n\n\t\tthis.boneTextureWidth = size;\n\t\tthis.boneTextureHeight = size;\n\n\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\n\t} else {\n\n\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n\t}\n\n\t// use the supplied bone inverses or calculate the inverses\n\n\tif ( boneInverses === undefined ) {\n\n\t\tthis.calculateInverses();\n\n\t} else {\n\n\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Skeleton.prototype, {\n\n\tcalculateInverses: function () {\n\n\t\tthis.boneInverses = [];\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tvar inverse = new THREE.Matrix4();\n\n\t\t\tif ( this.bones[ b ] ) {\n\n\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t},\n\n\tpose: function () {\n\n\t\tvar bone;\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdate: ( function () {\n\n\t\tvar offsetMatrix = new THREE.Matrix4();\n\n\t\treturn function update() {\n\n\t\t\t// flatten bone matrices to array\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n\t\t\t}\n\n\t\t\tif ( this.useVertexTexture ) {\n\n\t\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )(),\n\n\tclone: function () {\n\n\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n\t}\n\n} );\n\n// File:src/objects/SkinnedMesh.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.type = 'SkinnedMesh';\n\n\tthis.bindMode = \"attached\";\n\tthis.bindMatrix = new THREE.Matrix4();\n\tthis.bindMatrixInverse = new THREE.Matrix4();\n\n\t// init bones\n\n\t// TODO: remove bone creation as there is no reason (other than\n\t// convenience) for THREE.SkinnedMesh to do this.\n\n\tvar bones = [];\n\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\tvar bone, gbone;\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tbone = new THREE.Bone( this );\n\t\t\tbones.push( bone );\n\n\t\t\tbone.name = gbone.name;\n\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t}\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\n\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\n\t\t\t} else {\n\n\t\t\t\tthis.add( bones[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.normalizeSkinWeights();\n\n\tthis.updateMatrixWorld( true );\n\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n};\n\n\nTHREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\n\n\tconstructor: THREE.SkinnedMesh,\n\n\tbind: function( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t},\n\n\tpose: function () {\n\n\t\tthis.skeleton.pose();\n\n\t},\n\n\tnormalizeSkinWeights: function () {\n\n\t\tif ( this.geometry instanceof THREE.Geometry ) {\n\n\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar vec = new THREE.Vector4();\n\n\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdateMatrixWorld: function( force ) {\n\n\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\n\n\t\tif ( this.bindMode === \"attached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t} else if ( this.bindMode === \"detached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t},\n\n\tclone: function() {\n\n\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LOD.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LOD = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'LOD';\n\n\tObject.defineProperties( this, {\n\t\tlevels: {\n\t\t\tenumerable: true,\n\t\t\tvalue: []\n\t\t}\n\t} );\n\n};\n\n\nTHREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LOD,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\n\n\t\tvar levels = source.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\taddLevel: function ( object, distance ) {\n\n\t\tif ( distance === undefined ) distance = 0;\n\n\t\tdistance = Math.abs( distance );\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\tthis.add( object );\n\n\t},\n\n\tgetObjectForDistance: function ( distance ) {\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn levels[ i - 1 ].object;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t};\n\n\t}() ),\n\n\tupdate: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.levels = [];\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/objects/Sprite.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Sprite = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Sprite';\n\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\n};\n\nTHREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Sprite,\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\n\t\t\tif ( distanceSq > guessSizeSq ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tintersects.push( {\n\n\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\tpoint: this.position,\n\t\t\t\tface: null,\n\t\t\t\tobject: this\n\n\t\t\t} );\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LensFlare.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.lensFlares = [];\n\n\tthis.positionScreen = new THREE.Vector3();\n\tthis.customUpdateCallback = undefined;\n\n\tif ( texture !== undefined ) {\n\n\t\tthis.add( texture, size, distance, blending, color );\n\n\t}\n\n};\n\nTHREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LensFlare,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.positionScreen.copy( source.positionScreen );\n\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\n\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\n\t\tif ( size === undefined ) size = - 1;\n\t\tif ( distance === undefined ) distance = 0;\n\t\tif ( opacity === undefined ) opacity = 1;\n\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\n\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\n\n\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\t\tthis.lensFlares.push( {\n\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\tscale: 1, \t\t// scale\n\t\t\trotation: 0, \t\t// rotation\n\t\t\topacity: opacity,\t// opacity\n\t\t\tcolor: color,\t\t// color\n\t\t\tblending: blending\t// blending\n\t\t} );\n\n\t},\n\n\t/*\n\t * Update lens flares update positions on all flares based on the screen position\n\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t */\n\n\tupdateLensFlares: function () {\n\n\t\tvar f, fl = this.lensFlares.length;\n\t\tvar flare;\n\t\tvar vecX = - this.positionScreen.x * 2;\n\t\tvar vecY = - this.positionScreen.y * 2;\n\n\t\tfor ( f = 0; f < fl; f ++ ) {\n\n\t\t\tflare = this.lensFlares[ f ];\n\n\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/scenes/Scene.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Scene = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Scene';\n\n\tthis.background = null;\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.autoUpdate = true; // checked by the renderer\n\n};\n\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Scene.prototype.constructor = THREE.Scene;\n\nTHREE.Scene.prototype.copy = function ( source, recursive ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\n\n\tif ( source.background !== null ) this.background = source.background.clone();\n\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\tthis.autoUpdate = source.autoUpdate;\n\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\treturn this;\n\n};\n\n// File:src/scenes/Fog.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Fog = function ( color, near, far ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n};\n\nTHREE.Fog.prototype.clone = function () {\n\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\n};\n\n// File:src/scenes/FogExp2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FogExp2 = function ( color, density ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n};\n\nTHREE.FogExp2.prototype.clone = function () {\n\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\n};\n\n// File:src/renderers/shaders/ShaderChunk.js\n\nTHREE.ShaderChunk = {};\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\n\nTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\n\nTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/common.glsl\n\nTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\n\nTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\n\nTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\n\nTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#include <normal_flip>\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#include <normal_flip>\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t\tfloat clearCoat;\\n\t\tfloat clearCoatRoughness;\\n\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\t#ifndef STANDARD\\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\t#ifndef STANDARD\\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\n\nTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\t#ifndef STANDARD\\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\t#else\\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\t#endif\\n\t\t\\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_flip.glsl\n\nTHREE.ShaderChunk[ 'normal_flip' ] = \"#ifdef DOUBLE_SIDED\\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\n\nTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/packing.glsl\n\nTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\n\nTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\n\nTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\n\nTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/UniformsUtils.js\n\n/**\n * Uniform Utilities\n */\n\nTHREE.UniformsUtils = {\n\n\tmerge: function ( uniforms ) {\n\n\t\tvar merged = {};\n\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn merged;\n\n\t},\n\n\tclone: function ( uniforms_src ) {\n\n\t\tvar uniforms_dst = {};\n\n\t\tfor ( var u in uniforms_src ) {\n\n\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uniforms_dst;\n\n\t}\n\n};\n\n// File:src/renderers/shaders/UniformsLib.js\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nTHREE.UniformsLib = {\n\n\tcommon: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\n\t\t\"specularMap\": { value: null },\n\t\t\"alphaMap\": { value: null },\n\n\t\t\"envMap\": { value: null },\n\t\t\"flipEnvMap\": { value: - 1 },\n\t\t\"reflectivity\": { value: 1.0 },\n\t\t\"refractionRatio\": { value: 0.98 }\n\n\t},\n\n\taomap: {\n\n\t\t\"aoMap\": { value: null },\n\t\t\"aoMapIntensity\": { value: 1 }\n\n\t},\n\n\tlightmap: {\n\n\t\t\"lightMap\": { value: null },\n\t\t\"lightMapIntensity\": { value: 1 }\n\n\t},\n\n\temissivemap: {\n\n\t\t\"emissiveMap\": { value: null }\n\n\t},\n\n\tbumpmap: {\n\n\t\t\"bumpMap\": { value: null },\n\t\t\"bumpScale\": { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\t\"normalMap\": { value: null },\n\t\t\"normalScale\": { value: new THREE.Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\t\"displacementMap\": { value: null },\n\t\t\"displacementScale\": { value: 1 },\n\t\t\"displacementBias\": { value: 0 }\n\n\t},\n\n\troughnessmap: {\n\n\t\t\"roughnessMap\": { value: null }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\t\"metalnessMap\": { value: null }\n\n\t},\n\n\tfog: {\n\n\t\t\"fogDensity\": { value: 0.00025 },\n\t\t\"fogNear\": { value: 1 },\n\t\t\"fogFar\": { value: 2000 },\n\t\t\"fogColor\": { value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\t\"ambientLightColor\": { value: [] },\n\n\t\t\"directionalLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"color\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"directionalShadowMap\": { value: [] },\n\t\t\"directionalShadowMatrix\": { value: [] },\n\n\t\t\"spotLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"direction\": {},\n\t\t\t\"distance\": {},\n\t\t\t\"coneCos\": {},\n\t\t\t\"penumbraCos\": {},\n\t\t\t\"decay\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"spotShadowMap\": { value: [] },\n\t\t\"spotShadowMatrix\": { value: [] },\n\n\t\t\"pointLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"decay\": {},\n\t\t\t\"distance\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"pointShadowMap\": { value: [] },\n\t\t\"pointShadowMatrix\": { value: [] },\n\n\t\t\"hemisphereLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"skyColor\": {},\n\t\t\t\"groundColor\": {}\n\t\t} }\n\n\t},\n\n\tpoints: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\t\t\"size\": { value: 1.0 },\n\t\t\"scale\": { value: 1.0 },\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) }\n\n\t}\n\n};\n\n// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\n\nTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\n\nTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\n\nTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\n\nTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\n\nTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\n\nTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\n\nTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\n\nTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\tuniform float clearCoat;\\n\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\n\nTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\n\nTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_frag.glsl\n\nTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_vert.glsl\n\nTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl\n\nTHREE.ShaderChunk[ 'shadow_frag' ] = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl\n\nTHREE.ShaderChunk[ 'shadow_vert' ] = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib.js\n\n/**\n * Webgl Shader Library for three.js\n *\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\n\nTHREE.ShaderLib = {\n\n\t'basic': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\n\n\t},\n\n\t'lambert': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\n\n\t},\n\n\t'phong': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"specular\" : { value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"shininess\": { value: 30 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\n\n\t},\n\n\t'standard': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"roughness\": { value: 0.5 },\n\t\t\t\t\"metalness\": { value: 0 },\n\t\t\t\t\"envMapIntensity\" : { value: 1 }, // temporary\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n\t},\n\n\t'points': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'points' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\n\n\t},\n\n\t'dashed': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\n\t\t\t{\n\t\t\t\t\"scale\"    : { value: 1 },\n\t\t\t\t\"dashSize\" : { value: 1 },\n\t\t\t\t\"totalSize\": { value: 2 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\n\n\t},\n\n\t'depth': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\n\n\t},\n\n\t'normal': {\n\n\t\tuniforms: {\n\n\t\t\t\"opacity\" : { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'cube': {\n\n\t\tuniforms: {\n\t\t\t\"tCube\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'equirect': {\n\n\t\tuniforms: {\n\t\t\t\"tEquirect\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\n\n\t},\n\n\t'distanceRGBA': {\n\n\t\tuniforms: {\n\n\t\t\t\"lightPos\": { value: new THREE.Vector3() }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\n\n\t}\n\n};\n\nTHREE.ShaderLib[ 'physical' ] = {\n\n\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\n\n\t\t{\n\t\t\t\"clearCoat\": { value: 0 },\n\t\t\t\"clearCoatRoughness\": { value: 0 }\n\t\t}\n\n\t] ),\n\n\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n};\n\n// File:src/renderers/WebGLRenderer.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n * @author tschw\n */\n\nTHREE.WebGLRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n\tvar lights = [];\n\n\tvar opaqueObjects = [];\n\tvar opaqueObjectsLastIndex = - 1;\n\tvar transparentObjects = [];\n\tvar transparentObjectsLastIndex = - 1;\n\n\tvar morphInfluences = new Float32Array( 8 );\n\n\tvar sprites = [];\n\tvar lensFlares = [];\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\t// user-defined clipping\n\n\tthis.clippingPlanes = [];\n\tthis.localClippingEnabled = false;\n\n\t// physically based shading\n\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\n\t// physical lights\n\n\tthis.physicallyCorrectLights = false;\n\n\t// tone mapping\n\n\tthis.toneMapping = THREE.LinearToneMapping;\n\tthis.toneMappingExposure = 1.0;\n\tthis.toneMappingWhitePoint = 1.0;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t// internal state cache\n\n\t_currentProgram = null,\n\t_currentRenderTarget = null,\n\t_currentFramebuffer = null,\n\t_currentMaterialId = - 1,\n\t_currentGeometryProgram = '',\n\t_currentCamera = null,\n\n\t_currentScissor = new THREE.Vector4(),\n\t_currentScissorTest = null,\n\n\t_currentViewport = new THREE.Vector4(),\n\n\t//\n\n\t_usedTextureUnits = 0,\n\n\t//\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearAlpha = 0,\n\n\t_width = _canvas.width,\n\t_height = _canvas.height,\n\n\t_pixelRatio = 1,\n\n\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\n\t_scissorTest = false,\n\n\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\n\n\t// frustum\n\n\t_frustum = new THREE.Frustum(),\n\n\t// clipping\n\n\t_clipping = new THREE.WebGLClipping(),\n\t_clippingEnabled = false,\n\t_localClippingEnabled = false,\n\n\t_sphere = new THREE.Sphere(),\n\n\t// camera matrices cache\n\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_vector3 = new THREE.Vector3(),\n\n\t// light arrays cache\n\n\t_lights = {\n\n\t\thash: '',\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tdirectional: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotShadowMap: [],\n\t\tspotShadowMatrix: [],\n\t\tpoint: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: [],\n\n\t\tshadows: []\n\n\t},\n\n\t// info\n\n\t_infoRender = {\n\n\t\tcalls: 0,\n\t\tvertices: 0,\n\t\tfaces: 0,\n\t\tpoints: 0\n\n\t};\n\n\tthis.info = {\n\n\t\trender: _infoRender,\n\t\tmemory: {\n\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\n\t\t},\n\t\tprograms: null\n\n\t};\n\n\n\t// initialize\n\n\tvar _gl;\n\n\ttry {\n\n\t\tvar attributes = {\n\t\t\talpha: _alpha,\n\t\t\tdepth: _depth,\n\t\t\tstencil: _stencil,\n\t\t\tantialias: _antialias,\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t};\n\n\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\tif ( _gl === null ) {\n\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\n\t\t\t} else {\n\n\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t};\n\n\t\t}\n\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t} catch ( error ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\n\t}\n\n\tvar extensions = new THREE.WebGLExtensions( _gl );\n\n\textensions.get( 'WEBGL_depth_texture' );\n\textensions.get( 'OES_texture_float' );\n\textensions.get( 'OES_texture_float_linear' );\n\textensions.get( 'OES_texture_half_float' );\n\textensions.get( 'OES_texture_half_float_linear' );\n\textensions.get( 'OES_standard_derivatives' );\n\textensions.get( 'ANGLE_instanced_arrays' );\n\n\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\n\n\t}\n\n\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\n\n\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\n\tvar properties = new THREE.WebGLProperties();\n\tvar textures = new THREE.WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\n\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\n\tvar lightCache = new THREE.WebGLLights();\n\n\tthis.info.programs = programCache.programs;\n\n\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\n\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t//\n\n\tvar backgroundCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\tvar backgroundCamera2 = new THREE.PerspectiveCamera();\n\tvar backgroundPlaneMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry( 2, 2 ),\n\t\tnew THREE.MeshBasicMaterial( { depthTest: false, depthWrite: false } )\n\t);\n\tvar backgroundBoxShader = THREE.ShaderLib[ 'cube' ];\n\tvar backgroundBoxMesh = new THREE.Mesh(\n\t\tnew THREE.BoxBufferGeometry( 5, 5, 5 ),\n\t\tnew THREE.ShaderMaterial( {\n\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\tside: THREE.BackSide\n\t\t} )\n\t);\n\tobjects.update( backgroundPlaneMesh );\n\tobjects.update( backgroundBoxMesh );\n\n\t//\n\n\tfunction getTargetPixelRatio() {\n\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t}\n\n\tfunction glClearColor( r, g, b, a ) {\n\n\t\tif ( _premultipliedAlpha === true ) {\n\n\t\t\tr *= a; g *= a; b *= a;\n\n\t\t}\n\n\t\tstate.clearColor( r, g, b, a );\n\n\t}\n\n\tfunction setDefaultGLState() {\n\n\t\tstate.init();\n\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t}\n\n\tfunction resetGLState() {\n\n\t\t_currentProgram = null;\n\t\t_currentCamera = null;\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\n\t\tstate.reset();\n\n\t}\n\n\tsetDefaultGLState();\n\n\tthis.context = _gl;\n\tthis.capabilities = capabilities;\n\tthis.extensions = extensions;\n\tthis.properties = properties;\n\tthis.state = state;\n\n\t// shadow map\n\n\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\n\n\tthis.shadowMap = shadowMap;\n\n\n\t// Plugins\n\n\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\n\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _gl.getContextAttributes();\n\n\t};\n\n\tthis.forceContextLoss = function () {\n\n\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\n\t};\n\n\tthis.getMaxAnisotropy = function () {\n\n\t\treturn capabilities.getMaxAnisotropy();\n\n\t};\n\n\tthis.getPrecision = function () {\n\n\t\treturn capabilities.precision;\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value === undefined ) return;\n\n\t\t_pixelRatio = value;\n\n\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\n\t};\n\n\tthis.getSize = function () {\n\n\t\treturn {\n\t\t\twidth: _width,\n\t\t\theight: _height\n\t\t};\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_canvas.width = width * _pixelRatio;\n\t\t_canvas.height = height * _pixelRatio;\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t};\n\n\t// Clearing\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\n\t};\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.set( color );\n\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\n\t};\n\n\tthis.setClearAlpha = function ( alpha ) {\n\n\t\t_clearAlpha = alpha;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\tthis.clear( true, false, false );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\tthis.clear( false, true, false );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\tthis.clear( false, false, true );\n\n\t};\n\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t};\n\n\t// Reset\n\n\tthis.resetGLState = resetGLState;\n\n\tthis.dispose = function() {\n\n\t\ttransparentObjects = [];\n\t\ttransparentObjectsLastIndex = -1;\n\t\topaqueObjects = [];\n\t\topaqueObjectsLastIndex = -1;\n\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n\t};\n\n\t// Events\n\n\tfunction onContextLost( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tresetGLState();\n\t\tsetDefaultGLState();\n\n\t\tproperties.clear();\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tvar material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t}\n\n\t// Buffer deallocation\n\n\tfunction deallocateMaterial( material ) {\n\n\t\treleaseMaterialProgramReference( material );\n\n\t\tproperties.delete( material );\n\n\t}\n\n\n\tfunction releaseMaterialProgramReference( material ) {\n\n\t\tvar programInfo = properties.get( material ).program;\n\n\t\tmaterial.program = undefined;\n\n\t\tif ( programInfo !== undefined ) {\n\n\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t}\n\n\t}\n\n\t// Buffer rendering\n\n\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\tstate.initAttributes();\n\n\t\tvar buffers = properties.get( object );\n\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\n\n\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.normal );\n\n\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.uv );\n\n\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.color );\n\n\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\tsetMaterial( material );\n\n\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\tvar updateBuffers = false;\n\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphTargetInfluences !== undefined ) {\n\n\t\t\tvar activeInfluences = [];\n\n\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\n\t\t\t}\n\n\t\t\tactiveInfluences.sort( absNumericalSort );\n\n\t\t\tif ( activeInfluences.length > 8 ) {\n\n\t\t\t\tactiveInfluences.length = 8;\n\n\t\t\t}\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\n\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\n\t\t\t\t\tvar index = influence[ 1 ];\n\n\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t//\n\n\t\tvar index = geometry.index;\n\t\tvar position = geometry.attributes.position;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tindex = objects.getWireframeAttribute( geometry );\n\n\t\t}\n\n\t\tvar renderer;\n\n\t\tif ( index !== null ) {\n\n\t\t\trenderer = indexedBufferRenderer;\n\t\t\trenderer.setIndex( index );\n\n\t\t} else {\n\n\t\t\trenderer = bufferRenderer;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar dataStart = 0;\n\t\tvar dataCount = Infinity;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdataCount = index.count;\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\tdataCount = position.count;\n\n\t\t}\n\n\t\tvar rangeStart = geometry.drawRange.start;\n\t\tvar rangeCount = geometry.drawRange.count;\n\n\t\tvar groupStart = group !== null ? group.start : 0;\n\t\tvar groupCount = group !== null ? group.count : Infinity;\n\n\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\n\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t//\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\tcase THREE.TrianglesDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleStripDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleFanDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\tif ( object instanceof THREE.LineSegments ) {\n\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Points ) {\n\n\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t}\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t}\n\n\t};\n\n\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\tvar extension;\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\tstate.initAttributes();\n\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( var name in programAttributes ) {\n\n\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\n\t\t\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\t\t\ttype = _gl.FLOAT;\n\n\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\n\n\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\t\t\ttype = _gl.SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\n\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\t\t\ttype = _gl.INT;\n\n\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\t\t\ttype = _gl.BYTE;\n\n\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\n\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t}\n\n\t// Sorting\n\n\tfunction absNumericalSort( a, b ) {\n\n\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\treturn a.material.id - b.material.id;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn a.z - b.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\tfunction reversePainterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar fog = scene.fog;\n\n\t\t// reset caching for this frame\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\t\t_currentCamera = null;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\tlights.length = 0;\n\n\t\topaqueObjectsLastIndex = - 1;\n\t\ttransparentObjectsLastIndex = - 1;\n\n\t\tsprites.length = 0;\n\t\tlensFlares.length = 0;\n\n\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\tprojectObject( scene, camera );\n\n\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\n\t\tif ( _this.sortObjects === true ) {\n\n\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\tsetupShadows( lights );\n\n\t\tshadowMap.render( scene, camera );\n\n\t\tsetupLights( lights, camera );\n\n\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t//\n\n\t\t_infoRender.calls = 0;\n\t\t_infoRender.vertices = 0;\n\t\t_infoRender.faces = 0;\n\t\t_infoRender.points = 0;\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = null;\n\n\t\t}\n\n\t\tthis.setRenderTarget( renderTarget );\n\n\t\t//\n\n\t\tvar background = scene.background;\n\n\t\tif ( background === null ) {\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t} else if ( background instanceof THREE.Color ) {\n\n\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\n\t\t}\n\n\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background instanceof THREE.CubeTexture ) {\n\n\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\n\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n\t\t} else if ( background instanceof THREE.Texture ) {\n\n\t\t\tbackgroundPlaneMesh.material.map = background;\n\n\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\n\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\n\n\t\t} else {\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\t\t\trenderObjects( opaqueObjects, camera, fog );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\trenderObjects( transparentObjects, camera, fog );\n\n\t\t}\n\n\t\t// custom render plugins (post pass)\n\n\t\tspritePlugin.render( scene, camera );\n\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\tif ( renderTarget ) {\n\n\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tstate.setDepthTest( true );\n\t\tstate.setDepthWrite( true );\n\t\tstate.setColorWrite( true );\n\n\t\t// _gl.finish();\n\n\t};\n\n\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\n\t\tvar array, index;\n\n\t\t// allocate the next position in the appropriate array\n\n\t\tif ( material.transparent ) {\n\n\t\t\tarray = transparentObjects;\n\t\t\tindex = ++ transparentObjectsLastIndex;\n\n\t\t} else {\n\n\t\t\tarray = opaqueObjects;\n\t\t\tindex = ++ opaqueObjectsLastIndex;\n\n\t\t}\n\n\t\t// recycle existing render item or grow the array\n\n\t\tvar renderItem = array[ index ];\n\n\t\tif ( renderItem !== undefined ) {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.z = _vector3.z;\n\t\t\trenderItem.group = group;\n\n\t\t} else {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tz: _vector3.z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\t// assert( index === array.length );\n\t\t\tarray.push( renderItem );\n\n\t\t}\n\n\t}\n\n\t// TODO Duplicated code (Frustum)\n\n\tfunction isObjectViewable( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometry.boundingSphere === null )\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSpriteViewable( sprite ) {\n\n\t\t_sphere.center.set( 0, 0, 0 );\n\t\t_sphere.radius = 0.7071067811865476;\n\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSphereViewable( sphere ) {\n\n\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\tif ( numPlanes === 0 ) return true;\n\n\t\tvar planes = _this.clippingPlanes,\n\n\t\t\tcenter = sphere.center,\n\t\t\tnegRad = - sphere.radius,\n\t\t\ti = 0;\n\n\t\tdo {\n\n\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t} while ( ++ i !== numPlanes );\n\n\t\treturn true;\n\n\t}\n\n\tfunction projectObject( object, camera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\tlights.push( object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n\t\t\t\t\tsprites.push( object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\t\tlensFlares.push( object );\n\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\n\n\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar geometry = objects.update( object );\n\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera );\n\n\t\t}\n\n\t}\n\n\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\n\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\tvar object = renderItem.object;\n\t\t\tvar geometry = renderItem.geometry;\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\tvar group = renderItem.group;\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tsetMaterial( material );\n\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initMaterial( material, fog, object ) {\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tvar parameters = programCache.getParameters(\n\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, object );\n\n\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\tvar program = materialProperties.program;\n\t\tvar programChange = true;\n\n\t\tif ( program === undefined ) {\n\n\t\t\t// new material\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t} else if ( program.code !== code ) {\n\n\t\t\t// changed glsl or parameters\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t// same glsl and uniform list\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// only rebuild uniform list\n\t\t\tprogramChange = false;\n\n\t\t}\n\n\t\tif ( programChange ) {\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\n\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\n\t\t\tmaterialProperties.program = program;\n\t\t\tmaterial.program = program;\n\n\t\t}\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\n\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\n\t\t\t\tmaterial.clipping === true ) {\n\n\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t}\n\n\t\tif ( material.lights ) {\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\n\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\n\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\n\t\t}\n\n\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\tuniformsList =\n\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\tmaterialProperties.uniformsList = uniformsList;\n\t\tmaterialProperties.dynamicUniforms =\n\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\n\n\t}\n\n\tfunction setMaterial( material ) {\n\n\t\tif ( material.side !== THREE.DoubleSide )\n\t\t\tstate.enable( _gl.CULL_FACE );\n\t\telse\n\t\t\tstate.disable( _gl.CULL_FACE );\n\n\t\tstate.setFlipSided( material.side === THREE.BackSide );\n\n\t\tif ( material.transparent === true ) {\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\t} else {\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\n\t\t}\n\n\t\tstate.setDepthFunc( material.depthFunc );\n\t\tstate.setDepthTest( material.depthTest );\n\t\tstate.setDepthWrite( material.depthWrite );\n\t\tstate.setColorWrite( material.colorWrite );\n\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t}\n\n\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t_usedTextureUnits = 0;\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tif ( _clippingEnabled ) {\n\n\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\tvar useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t// (#8465, #8379)\n\t\t\t\t_clipping.setState(\n\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\n\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t}\n\n\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\tmaterialProperties.numClippingPlanes !== _clipping.numPlanes ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( materialProperties.lightsHash !== undefined &&\n\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tinitMaterial( material, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tvar refreshProgram = false;\n\t\tvar refreshMaterial = false;\n\t\tvar refreshLights = false;\n\n\t\tvar program = materialProperties.program,\n\t\t\tp_uniforms = program.getUniforms(),\n\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( program.id !== _currentProgram ) {\n\n\t\t\t_gl.useProgram( program.program );\n\t\t\t_currentProgram = program.id;\n\n\t\t\trefreshProgram = true;\n\t\t\trefreshMaterial = true;\n\t\t\trefreshLights = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t}\n\n\n\t\t\tif ( camera !== _currentCamera ) {\n\n\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t}\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material.envMap ) {\n\n\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material.skinning ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\tvar skeleton = object.skeleton;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t// values\n\t\t\t\t//\n\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t// the GL state when required\n\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t}\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t}\n\n\t\t\t// refresh single material specific uniforms\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\n\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\n\n\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\tTHREE.WebGLUniforms.upload(\n\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t}\n\n\n\t\t// common matrices\n\n\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\n\t\t// dynamic uniforms\n\n\t\tvar dynUniforms = materialProperties.dynamicUniforms;\n\n\t\tif ( dynUniforms !== null ) {\n\n\t\t\tTHREE.WebGLUniforms.evalDynamic(\n\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\n\n\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon ( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tuniforms.diffuse.value = material.color;\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tuniforms.map.value = material.map;\n\t\tuniforms.specularMap.value = material.specularMap;\n\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. specular map\n\t\t// 3. normal map\n\t\t// 4. bump map\n\t\t// 5. alpha map\n\t\t// 6. emissive map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.displacementMap ) {\n\n\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t} else if ( material.roughnessMap ) {\n\n\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t} else if ( material.metalnessMap ) {\n\n\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t} else if ( material.emissiveMap ) {\n\n\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tvar offset = uvScaleMap.offset;\n\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t\tuniforms.envMap.value = material.envMap;\n\n\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;\n\n\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t}\n\n\tfunction refreshUniformsLine ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\n\t}\n\n\tfunction refreshUniformsDash ( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\n\n\t\tuniforms.map.value = material.map;\n\n\t\tif ( material.map !== null ) {\n\n\t\t\tvar offset = material.map.offset;\n\t\t\tvar repeat = material.map.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsFog ( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value = fog.color;\n\n\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLambert ( uniforms, material ) {\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong ( uniforms, material ) {\n\n\t\tuniforms.specular.value = material.specular;\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard ( uniforms, material ) {\n\n\t\tuniforms.roughness.value = material.roughness;\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t}\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical ( uniforms, material ) {\n\n\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\trefreshUniformsStandard( uniforms, material );\n\n\t}\n\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\n\n\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\tuniforms.directionalLights.needsUpdate = value;\n\t\tuniforms.pointLights.needsUpdate = value;\n\t\tuniforms.spotLights.needsUpdate = value;\n\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t}\n\n\t// Lighting\n\n\tfunction setupShadows ( lights ) {\n\n\t\tvar lightShadowsLength = 0;\n\n\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tvar light = lights[ i ];\n\n\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.shadows.length = lightShadowsLength;\n\n\t}\n\n\tfunction setupLights ( lights, camera ) {\n\n\t\tvar l, ll, light,\n\t\tr = 0, g = 0, b = 0,\n\t\tcolor,\n\t\tintensity,\n\t\tdistance,\n\t\tshadowMap,\n\n\t\tviewMatrix = camera.matrixWorldInverse,\n\n\t\tdirectionalLength = 0,\n\t\tpointLength = 0,\n\t\tspotLength = 0,\n\t\themiLength = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tcolor = light.color;\n\t\t\tintensity = light.intensity;\n\t\t\tdistance = light.distance;\n\n\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\n\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\n\n\t\t\t\t}\n\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.ambient[ 0 ] = r;\n\t\t_lights.ambient[ 1 ] = g;\n\t\t_lights.ambient[ 2 ] = b;\n\n\t\t_lights.directional.length = directionalLength;\n\t\t_lights.spot.length = spotLength;\n\t\t_lights.point.length = pointLength;\n\t\t_lights.hemi.length = hemiLength;\n\n\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n\t}\n\n\t// GL state setting\n\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\tstate.setCullFace( cullFace );\n\t\tstate.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );\n\n\t};\n\n\t// Textures\n\n\tfunction allocTextureUnit() {\n\n\t\tvar textureUnit = _usedTextureUnits;\n\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t}\n\n\t\t_usedTextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\tthis.allocTextureUnit = allocTextureUnit;\n\n\t// this.setTexture2D = setTexture2D;\n\tthis.setTexture2D = ( function() {\n\n\t\tvar warned = false;\n\n\t\t// backwards compatibility: peel texture.texture\n\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\tif ( texture instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTexture = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTexture( texture, slot ) {\n\n\t\t\tif ( ! warned ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\twarned = true;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTextureCube = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\tif ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t// TODO: unify these code paths\n\t\t\tif ( texture instanceof THREE.CubeTexture ||\n\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t} else {\n\n\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tthis.getCurrentRenderTarget = function() {\n\n\t\treturn _currentRenderTarget;\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t_currentRenderTarget = renderTarget;\n\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t}\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar framebuffer;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\n\t\t\t}\n\n\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t_currentViewport.copy( renderTarget.viewport );\n\n\t\t} else {\n\n\t\t\tframebuffer = null;\n\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n\t\t}\n\n\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\tstate.scissor( _currentScissor );\n\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\tstate.viewport( _currentViewport );\n\n\t\tif ( isCube ) {\n\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t}\n\n\t};\n\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\tif ( framebuffer ) {\n\n\t\t\tvar restore = false;\n\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\trestore = true;\n\n\t\t\t}\n\n\t\t\ttry {\n\n\t\t\t\tvar texture = renderTarget.texture;\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\n\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\n\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\n\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t}\n\n\t\t\t} finally {\n\n\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Map three.js constants to WebGL constants\n\n\tfunction paramThreeToGL ( p ) {\n\n\t\tvar extension;\n\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\n\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\n\n\t\t}\n\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\n\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\n\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n};\n\n// File:src/renderers/WebGLRenderTarget.js\n\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n * @author Marius Kintel / https://github.com/kintel\n */\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\n\tthis.scissorTest = false;\n\n\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\n\n\toptions = options || {};\n\n\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\n\n\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\tthis.depthTexture = null;\n\n};\n\nObject.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {\n\n\tsetSize: function ( width, height ) {\n\n\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.texture = source.texture.clone();\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\tthis.depthTexture = source.depthTexture;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/renderers/WebGLRenderTargetCube.js\n\n/**\n * @author alteredq / http://alteredqualia.com\n */\n\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\tthis.activeMipMapLevel = 0;\n\n};\n\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\n\n// File:src/renderers/webgl/WebGLBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawArrays( mode, start, count );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar position = geometry.attributes.position;\n\n\t\tvar count = 0;\n\n\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tcount = position.data.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t} else {\n\n\t\t\tcount = position.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t}\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t}\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLClipping.js\n\nTHREE.WebGLClipping = function() {\n\n\tvar scope = this,\n\n\t\tglobalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false,\n\n\t\tplane = new THREE.Plane(),\n\t\tviewNormalMatrix = new THREE.Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\n\tthis.init = function( planes, enableLocalClipping, camera ) {\n\n\t\tvar enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function() {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function() {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function( planes, clipShadows, camera, cache, fromCache ) {\n\n\t\tif ( ! localClippingEnabled ||\n\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tcache.clippingState = dstArray;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\tdstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\treturn dstArray;\n\n\t}\n\n};\n\n\n// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tvar type, size;\n\n\tfunction setIndex( index ) {\n\n\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\ttype = _gl.UNSIGNED_INT;\n\t\t\tsize = 4;\n\n\t\t} else {\n\n\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\t\tsize = 2;\n\n\t\t}\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawElements( mode, count, type, start * size );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry, start, count ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t}\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLExtensions.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLExtensions = function ( gl ) {\n\n\tvar extensions = {};\n\n\tthis.get = function ( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tvar extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLCapabilities.js\n\nTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\n\n\tvar maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tthis.getMaxAnisotropy = getMaxAnisotropy;\n\tthis.getMaxPrecision = getMaxPrecision;\n\n\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\n\n\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\tthis.vertexTextures = this.maxVertexTextures > 0;\n\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\n\n\tvar _maxPrecision = getMaxPrecision( this.precision );\n\n\tif ( _maxPrecision !== this.precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\n\t\tthis.precision = _maxPrecision;\n\n\t}\n\n\tif ( this.logarithmicDepthBuffer ) {\n\n\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLGeometries.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLGeometries = function ( gl, properties, info ) {\n\n\tvar geometries = {};\n\n\tfunction get( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\n\t\t\treturn geometries[ geometry.id ];\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tvar buffergeometry;\n\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tbuffergeometry = geometry;\n\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\n\n\t\t\t}\n\n\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t}\n\n\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tvar geometry = event.target;\n\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\tdeleteAttribute( buffergeometry.index );\n\n\t\t}\n\n\t\tdeleteAttributes( buffergeometry.attributes );\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\t// TODO\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe ) {\n\n\t\t\tdeleteAttribute( property.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( geometry );\n\n\t\tvar bufferproperty = properties.get( buffergeometry );\n\n\t\tif ( bufferproperty.wireframe ) {\n\n\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( buffergeometry );\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction deleteAttribute( attribute ) {\n\n\t\tvar buffer = getAttributeBuffer( attribute );\n\n\t\tif ( buffer !== undefined ) {\n\n\t\t\tgl.deleteBuffer( buffer );\n\t\t\tremoveAttributeBuffer( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction deleteAttributes( attributes ) {\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tdeleteAttribute( attributes[ name ] );\n\n\t\t}\n\n\t}\n\n\tfunction removeAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tproperties.delete( attribute.data );\n\n\t\t} else {\n\n\t\t\tproperties.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tthis.get = get;\n\n};\n\n// File:src/renderers/webgl/WebGLLights.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLLights = function () {\n\n\tvar lights = {};\n\n\tthis.get = function ( light ) {\n\n\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\treturn lights[ light.id ];\n\n\t\t}\n\n\t\tvar uniforms;\n\n\t\tswitch ( light.type ) {\n\n\t\t\tcase 'DirectionalLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tconeCos: 0,\n\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tskyColor: new THREE.Color(),\n\t\t\t\t\tgroundColor: new THREE.Color()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tlights[ light.id ] = uniforms;\n\n\t\treturn uniforms;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLObjects.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLObjects = function ( gl, properties, info ) {\n\n\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\n\n\t//\n\n\tfunction update( object ) {\n\n\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n\t\tvar geometry = geometries.get( object );\n\n\t\tif ( object.geometry instanceof THREE.Geometry ) {\n\n\t\t\tgeometry.updateFromObject( object );\n\n\t\t}\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\n\t\tif ( index !== null ) {\n\n\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction updateAttribute( attribute, bufferType ) {\n\n\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\n\n\t\tvar attributeProperties = properties.get( data );\n\n\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\n\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\n\t\t} else if ( attributeProperties.version !== data.version ) {\n\n\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\n\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\tgl.bufferData( bufferType, data.array, usage );\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\n\t\t} else if ( data.updateRange.count === 0 ) {\n\n\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t} else {\n\n\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n\t\t\tdata.updateRange.count = 0; // reset range\n\n\t\t}\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe !== undefined ) {\n\n\t\t\treturn property.wireframe;\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\t\tvar position = attributes.position;\n\n\t\t// console.time( 'wireframe' );\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar edges = {};\n\t\t\tvar array = index.array;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\n\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\n\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar array = attributes.position.array;\n\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tvar a = i + 0;\n\t\t\t\tvar b = i + 1;\n\t\t\t\tvar c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// console.timeEnd( 'wireframe' );\n\n\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\n\n\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\tproperty.wireframe = attribute;\n\n\t\treturn attribute;\n\n\t}\n\n\tfunction checkEdge( edges, a, b ) {\n\n\t\tif ( a > b ) {\n\n\t\t\tvar tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\n\t\t}\n\n\t\tvar list = edges[ a ];\n\n\t\tif ( list === undefined ) {\n\n\t\t\tedges[ a ] = [ b ];\n\t\t\treturn true;\n\n\t\t} else if ( list.indexOf( b ) === -1 ) {\n\n\t\t\tlist.push( b );\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tthis.getAttributeBuffer = getAttributeBuffer;\n\tthis.getWireframeAttribute = getWireframeAttribute;\n\n\tthis.update = update;\n\n};\n\n// File:src/renderers/webgl/WebGLProgram.js\n\nTHREE.WebGLProgram = ( function () {\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase THREE.LinearEncoding:\n\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\tcase THREE.sRGBEncoding:\n\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\tcase THREE.RGBEEncoding:\n\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\tcase THREE.RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\tcase THREE.RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\tcase THREE.RGBDEncoding:\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\tcase THREE.GammaEncoding:\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase THREE.LinearToneMapping:\n\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.ReinhardToneMapping:\n\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.CineonToneMapping:\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = THREE.ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\treturn function WebGLProgram( renderer, code, material, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar extensions = material.extensions;\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeReflectionMapping:\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.CubeUVReflectionMapping:\n\t\t\t\tcase THREE.CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.EquirectangularReflectionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase THREE.MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material instanceof THREE.RawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\n\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\n\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\t}\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function() {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms =\n\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function() {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function() {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLPrograms.js\n\nTHREE.WebGLPrograms = function ( renderer, capabilities ) {\n\n\tvar programs = [];\n\n\tvar shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points'\n\t};\n\n\tvar parameterNames = [\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\n\t];\n\n\n\tfunction allocateBones ( object ) {\n\n\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t//\n\t\t\t//  - leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t}\n\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\tvar encoding;\n\n\t\tif ( ! map ) {\n\n\t\t\tencoding = THREE.LinearEncoding;\n\n\t\t} else if ( map instanceof THREE.Texture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\tencoding = map.texture.encoding;\n\n\t\t}\n\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\tencoding = THREE.GammaEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\n\n\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tvar maxBones = allocateBones( object );\n\t\tvar precision = renderer.getPrecision();\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\n\t\tvar parameters = {\n\n\t\t\tshaderID: shaderID,\n\n\t\t\tprecision: precision,\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\tmap: !! material.map,\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\tenvMap: !! material.envMap,\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\n\t\t\tlightMap: !! material.lightMap,\n\t\t\taoMap: !! material.aoMap,\n\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\tbumpMap: !! material.bumpMap,\n\t\t\tnormalMap: !! material.normalMap,\n\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\tspecularMap: !! material.specularMap,\n\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\tcombine: material.combine,\n\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\n\t\t\tflatShading: material.shading === THREE.FlatShading,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\tskinning: material.skinning,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumClippingPlanes: nClipPlanes,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\tflipSided: material.side === THREE.BackSide,\n\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t};\n\n\t\treturn parameters;\n\n\t};\n\n\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\tvar array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( material.fragmentShader );\n\t\t\tarray.push( material.vertexShader );\n\n\t\t}\n\n\t\tif ( material.defines !== undefined ) {\n\n\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t}\n\n\t\treturn array.join();\n\n\t};\n\n\tthis.acquireProgram = function ( material, parameters, code ) {\n\n\t\tvar program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\tprogram = programInfo;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\tthis.releaseProgram = function( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tvar i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t};\n\n\t// Exposed for resource monitoring & error feedback via renderer.info:\n\tthis.programs = programs;\n\n};\n\n// File:src/renderers/webgl/WebGLProperties.js\n\n/**\n* @author fordacious / fordacious.github.io\n*/\n\nTHREE.WebGLProperties = function () {\n\n\tvar properties = {};\n\n\tthis.get = function ( object ) {\n\n\t\tvar uuid = object.uuid;\n\t\tvar map = properties[ uuid ];\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties[ uuid ] = map;\n\n\t\t}\n\n\t\treturn map;\n\n\t};\n\n\tthis.delete = function ( object ) {\n\n\t\tdelete properties[ object.uuid ];\n\n\t};\n\n\tthis.clear = function () {\n\n\t\tproperties = {};\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLShader.js\n\nTHREE.WebGLShader = ( function () {\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\treturn function WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLShadowMap.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\n\n\tvar _gl = _renderer.context,\n\t_state = _renderer.state,\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_lightShadows = _lights.shadows,\n\n\t_shadowMapSize = new THREE.Vector2(),\n\n\t_lookTarget = new THREE.Vector3(),\n\t_lightPositionWorld = new THREE.Vector3(),\n\n\t_renderList = [],\n\n\t_MorphingFlag = 1,\n\t_SkinningFlag = 2,\n\n\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t_materialCache = {};\n\n\tvar cubeDirections = [\n\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\n\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\n\t];\n\n\tvar cubeUps = [\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\n\t];\n\n\tvar cube2DViewPorts = [\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\n\t];\n\n\t// init\n\n\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\n\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\n\tdepthMaterialTemplate.clipping = true;\n\n\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\n\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\n\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\tdepthMaterial.morphTargets = useMorphing;\n\t\tdepthMaterial.skinning = useSkinning;\n\n\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\n\t\t\tdefines: {\n\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t},\n\t\t\tuniforms: distanceUniforms,\n\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\tmorphTargets: useMorphing,\n\t\t\tskinning: useSkinning,\n\t\t\tclipping: true\n\t\t} );\n\n\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t}\n\n\t//\n\n\tvar scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = THREE.PCFShadowMap;\n\n\tthis.renderReverseSided = true;\n\tthis.renderSingleSided = true;\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( _lightShadows.length === 0 ) return;\n\n\t\t// Set GL state for depth map.\n\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t_state.disable( _gl.BLEND );\n\t\t_state.setDepthTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tvar faceCount, isPointLight;\n\n\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n\t\t\tvar light = _lightShadows[ i ];\n\t\t\tvar shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tif ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tfaceCount = 6;\n\t\t\t\tisPointLight = true;\n\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t// following orientation:\n\t\t\t\t//\n\t\t\t\t//  xzXZ\n\t\t\t\t//   y Y\n\t\t\t\t//\n\t\t\t\t// X - Positive x direction\n\t\t\t\t// x - Negative x direction\n\t\t\t\t// Y - Positive y direction\n\t\t\t\t// y - Negative y direction\n\t\t\t\t// Z - Positive z direction\n\t\t\t\t// z - Negative z direction\n\n\t\t\t\t// positive X\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative X\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Z\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative Z\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Y\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t// negative Y\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t} else {\n\n\t\t\t\tfaceCount = 1;\n\t\t\t\tisPointLight = false;\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\n\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\n\n\t\t\t\tshadow.update( light );\n\n\t\t\t}\n\n\t\t\tvar shadowMap = shadow.map;\n\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t// run a single pass if not\n\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t}\n\n\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\t\t// compute shadow matrix\n\n\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t);\n\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t_renderList.length = 0;\n\n\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\n\t\t\t\t// render shadow map\n\t\t\t\t// render regular objects\n\n\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Restore GL state.\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\n\t\tscope.needsUpdate = false;\n\n\t};\n\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tvar result = null;\n\n\t\tvar materialVariants = _depthMaterials;\n\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\tif ( isPointLight ) {\n\n\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t}\n\n\t\tif ( ! customMaterial ) {\n\n\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\n\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\n\n\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\n\n\t\t\tvar variantIndex = 0;\n\n\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t} else {\n\n\t\t\tresult = customMaterial;\n\n\t\t}\n\n\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t material.clipShadows === true &&\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tvar side = material.side;\n\n\t\tif ( scope.renderSingleSided && side == THREE.DoubleSide ) {\n\n\t\t\tside = THREE.FrontSide;\n\n\t\t}\n\n\t\tif ( scope.renderReverseSided ) {\n\n\t\t\tif ( side === THREE.FrontSide ) side = THREE.BackSide;\n\t\t\telse if ( side === THREE.BackSide ) side = THREE.FrontSide;\n\n\t\t}\n\n\t\tresult.side = side;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction projectObject( object, camera, shadowCamera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\n\n\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t_renderList.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLState.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\n\n\tvar _this = this;\n\n\tthis.buffers = {\n\t\tcolor: new THREE.WebGLColorBuffer( gl, this ),\n\t\tdepth: new THREE.WebGLDepthBuffer( gl, this ),\n\t\tstencil: new THREE.WebGLStencilBuffer( gl, this )\n\t};\n\n\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\tvar capabilities = {};\n\n\tvar compressedTextureFormats = null;\n\n\tvar currentBlending = null;\n\tvar currentBlendEquation = null;\n\tvar currentBlendSrc = null;\n\tvar currentBlendDst = null;\n\tvar currentBlendEquationAlpha = null;\n\tvar currentBlendSrcAlpha = null;\n\tvar currentBlendDstAlpha = null;\n\tvar currentPremultipledAlpha = false;\n\n\tvar currentFlipSided = null;\n\tvar currentCullFace = null;\n\n\tvar currentLineWidth = null;\n\n\tvar currentPolygonOffsetFactor = null;\n\tvar currentPolygonOffsetUnits = null;\n\n\tvar currentScissorTest = null;\n\n\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n\tvar currentTextureSlot = null;\n\tvar currentBoundTextures = {};\n\n\tvar currentScissor = new THREE.Vector4();\n\tvar currentViewport = new THREE.Vector4();\n\n\tfunction createTexture( type, target, count ) {\n\n\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tvar texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tvar emptyTextures = {};\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t//\n\n\tthis.init = function () {\n\n\t\tthis.clearColor( 0, 0, 0, 1 );\n\t\tthis.clearDepth( 1 );\n\t\tthis.clearStencil( 0 );\n\n\t\tthis.enable( gl.DEPTH_TEST );\n\t\tthis.setDepthFunc( THREE.LessEqualDepth );\n\n\t\tthis.setFlipSided( false );\n\t\tthis.setCullFace( THREE.CullFaceBack );\n\t\tthis.enable( gl.CULL_FACE );\n\n\t\tthis.enable( gl.BLEND );\n\t\tthis.setBlending( THREE.NormalBlending );\n\n\t};\n\n\tthis.initAttributes = function () {\n\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttribute = function ( attribute ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t};\n\n\tthis.disableUnusedAttributes = function () {\n\n\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.enable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tcapabilities[ id ] = true;\n\n\t\t}\n\n\t};\n\n\tthis.disable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tcapabilities[ id ] = false;\n\n\t\t}\n\n\t};\n\n\tthis.getCompressedTextureFormats = function () {\n\n\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\tcompressedTextureFormats = [];\n\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn compressedTextureFormats;\n\n\t};\n\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending !== THREE.NoBlending ) {\n\n\t\t\tthis.enable( gl.BLEND );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.BLEND );\n\t\t\tcurrentBlending = blending; // no blending, that is\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\tif ( blending === THREE.AdditiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentBlending = blending;\n\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t}\n\n\t\tif ( blending === THREE.CustomBlending ) {\n\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t}\n\n\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tcurrentBlendEquation = null;\n\t\t\tcurrentBlendSrc = null;\n\t\t\tcurrentBlendDst = null;\n\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.setColorWrite = function ( colorWrite ) {\n\n\t\tthis.buffers.color.setMask( colorWrite );\n\n\t};\n\n\tthis.setDepthTest = function ( depthTest ) {\n\n\t\tthis.buffers.depth.setTest( depthTest );\n\n\t};\n\n\tthis.setDepthWrite = function ( depthWrite ) {\n\n\t\tthis.buffers.depth.setMask( depthWrite );\n\n\t};\n\n\tthis.setDepthFunc = function ( depthFunc ) {\n\n\t\tthis.buffers.depth.setFunc( depthFunc );\n\n\t};\n\n\tthis.setStencilTest = function ( stencilTest ) {\n\n\t\tthis.buffers.stencil.setTest( stencilTest );\n\n\t};\n\n\tthis.setStencilWrite = function ( stencilWrite ) {\n\n\t\tthis.buffers.stencil.setMask( stencilWrite );\n\n\t};\n\n\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tthis.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );\n\n\t};\n\n\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tthis.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );\n\n\t};\n\n\t//\n\n\tthis.setFlipSided = function ( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t};\n\n\tthis.setCullFace = function ( cullFace ) {\n\n\t\tif ( cullFace !== THREE.CullFaceNone ) {\n\n\t\t\tthis.enable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t};\n\n\tthis.setLineWidth = function ( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tgl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t};\n\n\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t};\n\n\tthis.getScissorTest = function () {\n\n\t\treturn currentScissorTest;\n\n\t};\n\n\tthis.setScissorTest = function ( scissorTest ) {\n\n\t\tcurrentScissorTest = scissorTest;\n\n\t\tif ( scissorTest ) {\n\n\t\t\tthis.enable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t};\n\n\t// texture\n\n\tthis.activeTexture = function ( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t};\n\n\tthis.bindTexture = function ( webglType, webglTexture ) {\n\n\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t_this.activeTexture();\n\n\t\t}\n\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t};\n\n\tthis.compressedTexImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\tthis.texImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.clearColor = function ( r, g, b, a ) {\n\n\t\tthis.buffers.color.setClear( r, g, b, a );\n\n\t};\n\n\tthis.clearDepth = function ( depth ) {\n\n\t\tthis.buffers.depth.setClear( depth );\n\n\t};\n\n\tthis.clearStencil = function ( stencil ) {\n\n\t\tthis.buffers.stencil.setClear( stencil );\n\n\t};\n\n\t//\n\n\tthis.scissor = function ( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t};\n\n\tthis.viewport = function ( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tthis.reset = function () {\n\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcapabilities = {};\n\n\t\tcompressedTextureFormats = null;\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentBlending = null;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tthis.buffers.color.reset();\n\t\tthis.buffers.depth.reset();\n\t\tthis.buffers.stencil.reset();\n\n\t};\n\n};\n\nTHREE.WebGLColorBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar color = new THREE.Vector4();\n\tvar currentColorMask = null;\n\tvar currentColorClear = new THREE.Vector4();\n\n\tthis.setMask = function ( colorMask ) {\n\n\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\tcurrentColorMask = colorMask;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( r, g, b, a ) {\n\n\t\tcolor.set( r, g, b, a );\n\n\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\tgl.clearColor( r, g, b, a );\n\t\t\tcurrentColorClear.copy( color );\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentColorMask = null;\n\t\tcurrentColorClear = new THREE.Vector4();\n\n\t};\n\n};\n\nTHREE.WebGLDepthBuffer = function( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentDepthMask = null;\n\tvar currentDepthFunc = null;\n\tvar currentDepthClear = null;\n\n\tthis.setTest = function ( depthTest ) {\n\n\t\tif ( depthTest ) {\n\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function( depthMask ){\n\n\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\tgl.depthMask( depthMask );\n\t\t\tcurrentDepthMask = depthMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( depthFunc ) {\n\n\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\tif ( depthFunc ) {\n\n\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\tcase THREE.NeverDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.AlwaysDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.EqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.NotEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t}\n\n\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( depth ) {\n\n\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\tgl.clearDepth( depth );\n\t\t\tcurrentDepthClear = depth;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentDepthMask = null;\n\t\tcurrentDepthFunc = null;\n\t\tcurrentDepthClear = null;\n\n\t};\n\n};\n\nTHREE.WebGLStencilBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentStencilMask = null;\n\tvar currentStencilFunc = null;\n\tvar currentStencilRef = null;\n\tvar currentStencilFuncMask = null;\n\tvar currentStencilFail  = null;\n\tvar currentStencilZFail = null;\n\tvar currentStencilZPass = null;\n\tvar currentStencilClear = null;\n\n\tthis.setTest = function ( stencilTest ) {\n\n\t\tif ( stencilTest ) {\n\n\t\t\tstate.enable( gl.STENCIL_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.STENCIL_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function ( stencilMask ) {\n\n\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\tgl.stencilMask( stencilMask );\n\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\n\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setOp\t = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t     currentStencilZFail !== stencilZFail ||\n\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\n\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( stencil ) {\n\n\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\tgl.clearStencil( stencil );\n\t\t\tcurrentStencilClear = stencil;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentStencilMask = null;\n\t\tcurrentStencilFunc = null;\n\t\tcurrentStencilRef = null;\n\t\tcurrentStencilFuncMask = null;\n\t\tcurrentStencilFail = null;\n\t\tcurrentStencilZFail = null;\n\t\tcurrentStencilZPass = null;\n\t\tcurrentStencilClear = null;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLTextures.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLTextures = function ( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n\tvar _infoMemory = info.memory;\n\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n\t//\n\n\tfunction clampToMaxSize ( image, maxSize ) {\n\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t// premultiplied alpha.\n\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction isPowerOfTwo( image ) {\n\n\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\n\n\t}\n\n\tfunction makePowerOfTwo( image ) {\n\n\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\n\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\n\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\n\n\t\treturn false;\n\n\t}\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback ( f ) {\n\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\n\t\t\treturn _gl.NEAREST;\n\n\t\t}\n\n\t\treturn _gl.LINEAR;\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tvar texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\t_infoMemory.textures --;\n\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tvar renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t_infoMemory.textures --;\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t// cube texture\n\n\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t} else {\n\n\t\t\t// 2D texture\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\t// remove all webgl properties\n\t\tproperties.delete( texture );\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\tif ( ! renderTarget ) return;\n\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t}\n\n\t\tproperties.delete( renderTarget.texture );\n\t\tproperties.delete( renderTarget );\n\n\t}\n\n\t//\n\n\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tvar image = texture.image;\n\n\t\t\tif ( image === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTextureCube ( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t} else {\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setTextureCubeDynamic ( texture, slot ) {\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t}\n\n\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\n\n\t\tvar extension;\n\n\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension ) {\n\n\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t_infoMemory.textures ++;\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\timage = makePowerOfTwo( image );\n\n\t\t}\n\n\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\tglFormat = paramThreeToGL( texture.format ),\n\t\tglType = paramThreeToGL( texture.type );\n\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\tif ( texture instanceof THREE.DepthTexture ) {\n\n\t\t\t// populate depth texture with dummy data\n\n\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\tif ( texture.type === THREE.FloatType ) {\n\n\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t}\n\n\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t} else if ( texture instanceof THREE.DataTexture ) {\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t}\n\n\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\n\n\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t_infoMemory.textures ++;\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tvar texture = renderTarget.texture;\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\n\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t_gl.generateMipmap( target );\n\t\t\tstate.bindTexture( target, null );\n\n\t\t}\n\n\t}\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n};\n\n// File:src/renderers/webgl/WebGLUniforms.js\n\n/**\n *\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [renderer] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'renderer' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (renderer factorizations):\n *\n * .upload( gl, seq, values, renderer )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n * .splitDynamic( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\n *\n *\n * Methods of the top-level container (renderer factorizations):\n *\n * .setValue( gl, name, value )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .set( gl, obj, prop )\n *\n * \t\tsets uniform from object and property with same name than uniform\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n *\n * @author tschw\n *\n */\n\nTHREE.WebGLUniforms = ( function() { // scope\n\n\tvar emptyTexture = new THREE.Texture();\n\tvar emptyCubeTexture = new THREE.CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tvar UniformContainer = function() {\n\n\t\t\tthis.seq = [];\n\t\t\tthis.map = {};\n\n\t\t},\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\t\tarrayCacheF32 = [],\n\t\tarrayCacheI32 = [],\n\n\t\tuncacheTemporaryArrays = function() {\n\n\t\t\tarrayCacheF32.length = 0;\n\t\t\tarrayCacheI32.length = 0;\n\n\t\t},\n\n\t// Flattening for arrays of vectors and matrices\n\n\t\tflatten = function( array, nBlocks, blockSize ) {\n\n\t\t\tvar firstElem = array[ 0 ];\n\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t// see http://jacksondunstan.com/articles/983\n\n\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\tr = arrayCacheF32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Float32Array( n );\n\t\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tif ( nBlocks !== 0 ) {\n\n\t\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\t\toffset += blockSize;\n\t\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// Texture unit allocation\n\n\t\tallocTexUnits = function( renderer, n ) {\n\n\t\t\tvar r = arrayCacheI32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Int32Array( n );\n\t\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t\t// Single scalar\n\n\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\n\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\n\n\t\t// Single float vector (from flat array or THREE.VectorN)\n\n\t\tsetValue2fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\n\t\t},\n\n\t\tsetValue3fv = function( gl, v ) {\n\n\t\t\tif ( v.x !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\t\telse if ( v.r !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\t\telse\n\t\t\t\tgl.uniform3fv( this.addr, v );\n\n\t\t},\n\n\t\tsetValue4fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t},\n\n\t\t// Single matrix (from flat array or MatrixN)\n\n\t\tsetValue2fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue3fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue4fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\t// Single texture (2D / Cube)\n\n\t\tsetValueT1 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t\t},\n\n\t\tsetValueT6 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t\t},\n\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\n\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\n\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\n\n\t\t// Helper to pick the right setter for the singular case\n\n\t\tgetSingularSetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Array of scalars\n\n\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\n\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\n\n\t\t// Array of vectors (flat or from THREE classes)\n\n\t\tsetValueV2a = function( gl, v ) {\n\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t\t},\n\n\t\tsetValueV3a = function( gl, v ) {\n\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t\t},\n\n\t\tsetValueV4a = function( gl, v ) {\n\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\t// Array of matrices (flat or from THREE clases)\n\n\t\tsetValueM2a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\tsetValueM3a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t\t},\n\n\t\tsetValueM4a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t\t},\n\n\t\t// Array of textures (2D / Cube)\n\n\t\tsetValueT1a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetValueT6a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\t\tgetPureArraySetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t// --- Uniform Classes ---\n\n\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tPureArrayUniform = function( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.size = activeInfo.size;\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tStructuredUniform = function( id ) {\n\n\t\t\tthis.id = id;\n\n\t\t\tUniformContainer.call( this ); // mix-in\n\n\t\t};\n\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\n\t\t// extracts\n\t\t// \t- the identifier (member name or array index)\n\t\t//  - followed by an optional right bracket (found when array index)\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t//\n\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t// in the uniform names.\n\n\t\taddUniform = function( container, uniformObject ) {\n\n\t\t\tcontainer.seq.push( uniformObject );\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t\t},\n\n\t\tparseUniform = function( activeInfo, addr, container ) {\n\n\t\t\tvar path = activeInfo.name,\n\t\t\t\tpathLength = path.length;\n\n\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\tRePathPart.lastIndex = 0;\n\n\t\t\tfor (; ;) {\n\n\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\t\tif ( subscript === undefined ||\n\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\t\tvar map = container.map,\n\t\t\t\t\t\tnext = map[ id ];\n\n\t\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer = next;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t// Root Container\n\n\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\n\n\t\t\tUniformContainer.call( this );\n\n\t\t\tthis.renderer = renderer;\n\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\tpath = info.name,\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\t\tparseUniform( info, addr, this );\n\n\t\t\t}\n\n\t\t};\n\n\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.splitDynamic = function( seq, values ) {\n\n\t\tvar r = null,\n\t\t\tn = seq.length,\n\t\t\tw = 0;\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v && v.dynamic === true ) {\n\n\t\t\t\tif ( r === null ) r = [];\n\t\t\t\tr.push( u );\n\n\t\t\t} else {\n\n\t\t\t\t// in-place compact 'seq', removing the matches\n\t\t\t\tif ( w < i ) seq[ w ] = u;\n\t\t\t\t++ w;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( w < n ) seq.length = w;\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar v = values[ seq[ i ].id ],\n\t\t\t\tf = v.onUpdateCallback;\n\n\t\t\tif ( f !== undefined ) f.call( v, object, camera );\n\n\t\t}\n\n\t};\n\n\treturn WebGLUniforms;\n\n} )();\n\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar shader, program, attributes, uniforms;\n\n\tvar tempTexture, occlusionTexture;\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 1, - 1,  0, 0,\n\t\t\t 1, - 1,  1, 0,\n\t\t\t 1,  1,  1, 1,\n\t\t\t- 1,  1,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\t// buffers\n\n\t\tvertexBuffer     = gl.createBuffer();\n\t\telementBuffer    = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t// textures\n\n\t\ttempTexture      = gl.createTexture();\n\t\tocclusionTexture = gl.createTexture();\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tshader = {\n\n\t\t\tvertexShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\"uniform float rotation;\",\n\n\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\n\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" ),\n\n\t\t\tfragmentShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t// pink square\n\n\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t\t// restore\n\n\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t\t// flare\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" )\n\n\t\t};\n\n\t\tprogram = createProgram( shader );\n\n\t\tattributes = {\n\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t};\n\n\t\tuniforms = {\n\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t};\n\n\t}\n\n\t/*\n\t * Render lens flares\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t *         reads these back and calculates occlusion.\n\t */\n\n\tthis.render = function ( scene, camera, viewport ) {\n\n\t\tif ( flares.length === 0 ) return;\n\n\t\tvar tempPosition = new THREE.Vector3();\n\n\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\thalfViewportHeight = viewport.w * 0.5;\n\n\t\tvar size = 16 / viewport.w,\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\n\t\tvar validArea = new THREE.Box2();\n\n\t\tvalidArea.min.set( 0, 0 );\n\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.vertex );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\t// loop through all lens flares to update their occlusion and positions\n\t\t// setup gl and common used attribs/uniforms\n\n\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\tgl.uniform1i( uniforms.map, 1 );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.setDepthWrite( false );\n\n\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n\t\t\tsize = 16 / viewport.w;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t// calc object screen position\n\n\t\t\tvar flare = flares[ i ];\n\n\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t// setup arrays for gl programs\n\n\t\t\tscreenPosition.copy( tempPosition );\n\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t// screen cull\n\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// render pink quad\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// restore graphics\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// update object positions\n\n\t\t\t\tflare.positionScreen.copy( screenPosition );\n\n\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t}\n\n\t\t\t\t// render flares\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\tstate.enable( gl.BLEND );\n\n\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\n\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\t\tstate.enable( gl.DEPTH_TEST );\n\t\tstate.setDepthWrite( true );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram ( shader ) {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\tgl.compileShader( fragmentShader );\n\t\tgl.compileShader( vertexShader );\n\n\t\tgl.attachShader( program, fragmentShader );\n\t\tgl.attachShader( program, vertexShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n};\n\n// File:src/renderers/webgl/plugins/SpritePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpritePlugin = function ( renderer, sprites ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar program, attributes, uniforms;\n\n\tvar texture;\n\n\t// decompose matrixWorld\n\n\tvar spritePosition = new THREE.Vector3();\n\tvar spriteRotation = new THREE.Quaternion();\n\tvar spriteScale = new THREE.Vector3();\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t- 0.5,   0.5,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\tvertexBuffer  = gl.createBuffer();\n\t\telementBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\tprogram = createProgram();\n\n\t\tattributes = {\n\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t};\n\n\t\tuniforms = {\n\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\n\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\n\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t};\n\n\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tcanvas.width = 8;\n\t\tcanvas.height = 8;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = 'white';\n\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\ttexture = new THREE.Texture( canvas );\n\t\ttexture.needsUpdate = true;\n\n\t}\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( sprites.length === 0 ) return;\n\n\t\t// setup gl\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.position );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.enable( gl.BLEND );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\tvar oldFogType = 0;\n\t\tvar sceneFogType = 0;\n\t\tvar fog = scene.fog;\n\n\t\tif ( fog ) {\n\n\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\toldFogType = 1;\n\t\t\t\tsceneFogType = 1;\n\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\toldFogType = 2;\n\t\t\t\tsceneFogType = 2;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\toldFogType = 0;\n\t\t\tsceneFogType = 0;\n\n\t\t}\n\n\n\t\t// update positions and sort\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\n\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t}\n\n\t\tsprites.sort( painterSortStable );\n\n\t\t// render all sprites\n\n\t\tvar scale = [];\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\t\t\tvar material = sprite.material;\n\n\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\tvar fogType = 0;\n\n\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\tfogType = sceneFogType;\n\n\t\t\t}\n\n\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\toldFogType = fogType;\n\n\t\t\t}\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t}\n\n\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setTexture2D( texture, 0 );\n\n\t\t\t}\n\n\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram () {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform float rotation;',\n\t\t\t'uniform vec2 scale;',\n\t\t\t'uniform vec2 uvOffset;',\n\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t'attribute vec2 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D map;',\n\t\t\t'uniform float opacity;',\n\n\t\t\t'uniform int fogType;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t\t'uniform float fogDensity;',\n\t\t\t'uniform float fogNear;',\n\t\t\t'uniform float fogFar;',\n\t\t\t'uniform float alphaTest;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t'}',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.compileShader( vertexShader );\n\t\tgl.compileShader( fragmentShader );\n\n\t\tgl.attachShader( program, vertexShader );\n\t\tgl.attachShader( program, fragmentShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\t\t\n\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn b.id - a.id;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/Three.Legacy.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.assign( THREE, {\n\tFace4: function ( a, b, c, d, normal, color, materialIndex ) {\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\n\t},\n\tLineStrip: 0,\n\tLinePieces: 1,\n\tMeshFaceMaterial: THREE.MultiMaterial,\n\tPointCloud: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tParticle: THREE.Sprite,\n\tParticleSystem: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tPointCloudMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleBasicMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleSystemMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tVertex: function ( x, y, z ) {\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new THREE.Vector3( x, y, z );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Box2.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t}\n} );\n\nObject.assign( THREE.Box3.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Matrix3.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\treturn vector.applyMatrix3( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t}\n} );\n\nObject.assign( THREE.Matrix4.prototype, {\n\textractPosition: function ( m ) {\n\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\treturn this.copyPosition( m );\n\t},\n\tsetRotationFromQuaternion: function ( q ) {\n\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\treturn this.makeRotationFromQuaternion( q );\n\t},\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\treturn vector.applyProjection( this );\n\t},\n\tmultiplyVector4: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t},\n\trotateAxis: function ( v ) {\n\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\tv.transformDirection( this );\n\t},\n\tcrossVector: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\ttranslate: function ( v ) {\n\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t},\n\trotateX: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t},\n\trotateY: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t},\n\trotateZ: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t},\n\trotateByAxis: function ( axis, angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t}\n} );\n\nObject.assign( THREE.Plane.prototype, {\n\tisIntersectionLine: function ( line ) {\n\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\treturn this.intersectsLine( line );\n\t}\n} );\n\nObject.assign( THREE.Quaternion.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\treturn vector.applyQuaternion( this );\n\t}\n} );\n\nObject.assign( THREE.Ray.prototype, {\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionPlane: function ( plane ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\treturn this.intersectsPlane( plane );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Vector3.prototype, {\n\tsetEulerFromRotationMatrix: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t},\n\tsetEulerFromQuaternion: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t},\n\tgetPositionFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\treturn this.setFromMatrixPosition( m );\n\t},\n\tgetScaleFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\treturn this.setFromMatrixScale( m );\n\t},\n\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\treturn this.setFromMatrixColumn( matrix, index );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Object3D.prototype, {\n\tgetChildByName: function ( name ) {\n\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\treturn this.getObjectByName( name );\n\t},\n\trenderDepth: function ( value ) {\n\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t},\n\ttranslate: function ( distance, axis ) {\n\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\treturn this.translateOnAxis( axis, distance );\n\t}\n} );\n\nObject.defineProperties( THREE.Object3D.prototype, {\n\teulerOrder: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\treturn this.rotation.order;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\tthis.rotation.order = value;\n\t\t}\n\t},\n\tuseQuaternion: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.LOD.prototype, {\n\tobjects: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\treturn this.levels;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\tthis.setFocalLength( focalLength );\n\n};\n\n//\n\nObject.defineProperties( THREE.Light.prototype, {\n\tonlyShadow: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t}\n\t},\n\tshadowCameraFov: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\tthis.shadow.camera.fov = value;\n\t\t}\n\t},\n\tshadowCameraLeft: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\tthis.shadow.camera.left = value;\n\t\t}\n\t},\n\tshadowCameraRight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\tthis.shadow.camera.right = value;\n\t\t}\n\t},\n\tshadowCameraTop: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\tthis.shadow.camera.top = value;\n\t\t}\n\t},\n\tshadowCameraBottom: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\tthis.shadow.camera.bottom = value;\n\t\t}\n\t},\n\tshadowCameraNear: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\tthis.shadow.camera.near = value;\n\t\t}\n\t},\n\tshadowCameraFar: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\tthis.shadow.camera.far = value;\n\t\t}\n\t},\n\tshadowCameraVisible: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t}\n\t},\n\tshadowBias: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\tthis.shadow.bias = value;\n\t\t}\n\t},\n\tshadowDarkness: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t}\n\t},\n\tshadowMapWidth: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\tthis.shadow.mapSize.width = value;\n\t\t}\n\t},\n\tshadowMapHeight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\tthis.shadow.mapSize.height = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.BufferAttribute.prototype, {\n\tlength: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\treturn this.array.length;\n\t\t}\n\t}\n} );\n\nObject.assign( THREE.BufferGeometry.prototype, {\n\taddIndex: function ( index ) {\n\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\tthis.setIndex( index );\n\t},\n\taddDrawCall: function ( start, count, indexOffset ) {\n\t\tif ( indexOffset !== undefined ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t}\n\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\tthis.addGroup( start, count );\n\t},\n\tclearDrawCalls: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\tthis.clearGroups();\n\t},\n\tcomputeTangents: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t},\n\tcomputeOffsets: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.BufferGeometry.prototype, {\n\tdrawcalls: {\n\t\tget: function () {\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t},\n\toffsets: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.Material.prototype, {\n\twrapAround: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t}\n\t},\n\twrapRGB: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\treturn new THREE.Color();\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\n\tmetal: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\treturn false;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.ShaderMaterial.prototype, {\n\tderivatives: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\treturn this.extensions.derivatives;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\tthis.extensions.derivatives = value;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.EventDispatcher.prototype = Object.assign( Object.create( {\n\n\t// Note: Extra base ensures these properties are not 'assign'ed.\n\n\tconstructor: THREE.EventDispatcher,\n\n\tapply: function ( target ) {\n\n\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\n\t\tObject.assign( target, this );\n\n\t}\n\n} ), THREE.EventDispatcher.prototype );\n\n//\n\nObject.assign( THREE.WebGLRenderer.prototype, {\n\tsupportsFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_float' );\n\t},\n\tsupportsHalfFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t},\n\tsupportsStandardDerivatives: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t},\n\tsupportsCompressedTextureS3TC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t},\n\tsupportsCompressedTexturePVRTC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t},\n\tsupportsBlendMinMax: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t},\n\tsupportsVertexTextures: function () {\n\t\treturn this.capabilities.vertexTextures;\n\t},\n\tsupportsInstancedArrays: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t},\n\tenableScissorTest: function ( boolean ) {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\tthis.setScissorTest( boolean );\n\t},\n\tinitMaterial: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t},\n\taddPrePlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t},\n\taddPostPlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t},\n\tupdateShadowMap: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLRenderer.prototype, {\n\tshadowMapEnabled: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.enabled;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\tthis.shadowMap.enabled = value;\n\t\t}\n\t},\n\tshadowMapType: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\tthis.shadowMap.type = value;\n\t\t}\n\t},\n\tshadowMapCullFace: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.cullFace;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\tthis.shadowMap.cullFace = value;\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLShadowMap.prototype, {\n\tcullFace: {\n\t\tget: function () {\n\t\t\treturn this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;\n\t\t},\n\t\tset: function ( cullFace ) {\n\t\t\tvar value = ( cullFace !== THREE.CullFaceBack );\n\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\tthis.renderReverseSided = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\n\twrapS: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\treturn this.texture.wrapS;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\tthis.texture.wrapS = value;\n\t\t}\n\t},\n\twrapT: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\treturn this.texture.wrapT;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\tthis.texture.wrapT = value;\n\t\t}\n\t},\n\tmagFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\treturn this.texture.magFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\tthis.texture.magFilter = value;\n\t\t}\n\t},\n\tminFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\treturn this.texture.minFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\tthis.texture.minFilter = value;\n\t\t}\n\t},\n\tanisotropy: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\treturn this.texture.anisotropy;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\tthis.texture.anisotropy = value;\n\t\t}\n\t},\n\toffset: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\treturn this.texture.offset;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\tthis.texture.offset = value;\n\t\t}\n\t},\n\trepeat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\treturn this.texture.repeat;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\tthis.texture.repeat = value;\n\t\t}\n\t},\n\tformat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\treturn this.texture.format;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\tthis.texture.format = value;\n\t\t}\n\t},\n\ttype: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\treturn this.texture.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\tthis.texture.type = value;\n\t\t}\n\t},\n\tgenerateMipmaps: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\treturn this.texture.generateMipmaps;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\tthis.texture.generateMipmaps = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.assign( THREE.Audio.prototype, {\n\tload: function ( file ) {\n\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\tvar scope = this;\n\t\tvar audioLoader = new THREE.AudioLoader();\n\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\tscope.setBuffer( buffer );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\tgetData: function ( file ) {\n\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\treturn this.getFrequencyData();\n\t}\n} );\n\n//\n\nTHREE.GeometryUtils = {\n\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\tvar matrix;\n\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\n\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\tmatrix = geometry2.matrix;\n\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t}\n\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t},\n\n\tcenter: function ( geometry ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\treturn geometry.center();\n\n\t}\n\n};\n\nTHREE.ImageUtils = {\n\n\tcrossOrigin: undefined,\n\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\tvar loader = new THREE.TextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\tvar loader = new THREE.CubeTextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTexture: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t},\n\n\tloadCompressedTextureCube: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t}\n\n};\n\n//\n\nTHREE.Projector = function () {\n\n\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\tvector.project( camera );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\tvector.unproject( camera );\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t};\n\n};\n\n//\n\nTHREE.CanvasRenderer = function () {\n\n\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\tthis.clear = function () {};\n\tthis.render = function () {};\n\tthis.setClearColor = function () {};\n\tthis.setSize = function () {};\n\n};\n\n// File:src/extras/CurveUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.CurveUtils = {\n\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t},\n\n\t// Puay Bing, thanks for helping with this derivative!\n\n\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\n\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t3 * t * t * p3;\n\n\t},\n\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t// To check if my formulas are correct\n\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\n\t\tvar h01 = - 6 * t * t + 6 * t; \t//  2t3 + 3t2\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\n\n\t\treturn h00 + h10 + h01 + h11;\n\n\t},\n\n\t// Catmull-Rom\n\n\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\tvar t2 = t * t;\n\t\tvar t3 = t * t2;\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/extras/SceneUtils.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\tvar group = new THREE.Group();\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t},\n\n\tdetach: function ( child, parent, scene ) {\n\n\t\tchild.applyMatrix( parent.matrixWorld );\n\t\tparent.remove( child );\n\t\tscene.add( child );\n\n\t},\n\n\tattach: function ( child, scene, parent ) {\n\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\tscene.remove( child );\n\t\tparent.add( child );\n\n\t}\n\n};\n\n// File:src/extras/ShapeUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.ShapeUtils = {\n\n\t// calculate area of the contour polygon\n\n\tarea: function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t},\n\n\ttriangulate: ( function () {\n\n\t\t/**\n\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t * See original code and more information here:\n\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t *\n\t\t * ported to actionscript by Zevan Rosser\n\t\t * www.actionsnippet.com\n\t\t *\n\t\t * ported to javascript by Joshua Koo\n\t\t * http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t */\n\n\t\tfunction snip( contour, u, v, w, n, verts ) {\n\n\t\t\tvar p;\n\t\t\tvar ax, ay, bx, by;\n\t\t\tvar cx, cy, px, py;\n\n\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\tay = contour[ verts[ u ] ].y;\n\n\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\tby = contour[ verts[ v ] ].y;\n\n\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\tcy = contour[ verts[ w ] ].y;\n\n\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\n\n\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\tcX = bx - ax;  cY = by - ay;\n\n\t\t\tfor ( p = 0; p < n; p ++ ) {\n\n\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\tpy = contour[ verts[ p ] ].y;\n\n\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\n\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t\t// see if p is inside triangle abc\n\n\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\n\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// takes in an contour array and returns\n\n\t\treturn function triangulate( contour, indices ) {\n\n\t\t\tvar n = contour.length;\n\n\t\t\tif ( n < 3 ) return null;\n\n\t\t\tvar result = [],\n\t\t\t\tverts = [],\n\t\t\t\tvertIndices = [];\n\n\t\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\t\tvar u, v, w;\n\n\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t\t}\n\n\t\t\tvar nv = n;\n\n\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\t\tvar count = 2 * nv;   /* error detection */\n\n\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\n\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\t\tif ( ( count -- ) <= 0 ) {\n\n\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t//return null;\n\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\treturn result;\n\n\t\t\t\t}\n\n\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t\t/* true names of the vertices */\n\n\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\tc = verts[ w ];\n\n\t\t\t\t\t/* output Triangle */\n\n\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnv --;\n\n\t\t\t\t\t/* reset error detection counter */\n\n\t\t\t\t\tcount = 2 * nv;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( indices ) return vertIndices;\n\t\t\treturn result;\n\n\t\t}\n\n\t} )(),\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\n\t\t\t\t// not parallel\n\n\t\t\t\tvar perpSeg2;\n\t\t\t\tif ( limit > 0 ) {\n\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\n\t\t\t\t}\n\n\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\tif ( perpSeg2 === 0 ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\tif ( perpSeg2 === limit ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt2 ];\n\n\t\t\t\t}\n\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\n\t\t\t\t// return real intersection point\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n\t\t\t} else {\n\n\t\t\t\t// parallel or collinear\n\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\n\t\t\t\t// they are collinear or degenerate\n\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t// both segments are points\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\n\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\n\t\t\t\t}\n\t\t\t\t// segment#1  is a single point\n\t\t\t\tif ( seg1Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\t// segment#2  is a single point\n\t\t\t\tif ( seg2Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\treturn [ inSeg2Pt1 ];\n\n\t\t\t\t}\n\n\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\tif ( seg1dx !== 0 ) {\n\n\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg2min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg1min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n\t\t\t// The order of legs is important\n\n\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n\t\t\t\t// angle != 180 deg.\n\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n\t\t\t\tif ( from2toAngle > 0 ) {\n\n\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// angle == 180 deg.\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\treturn\t( from2otherAngle > 0 );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction removeHoles( contour, holes ) {\n\n\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\tvar hole;\n\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\treturn\ttrue;\n\n\t\t\t}\n\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with shape edges\n\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t}\n\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar indepHoles = [];\n\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with hole edges\n\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\tshapePt, holePt,\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\ttmpHole1, tmpHole2;\n\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tindepHoles.push( h );\n\n\t\t\t}\n\n\t\t\tvar minShapeIndex = 0;\n\t\t\tvar counter = indepHoles.length * 2;\n\t\t\twhile ( indepHoles.length > 0 ) {\n\n\t\t\t\tcounter --;\n\t\t\t\tif ( counter < 0 ) {\n\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t// which can be connected without intersections\n\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\tholeIndex\t= - 1;\n\n\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\n\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\n\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\n\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\n\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn shape; \t\t\t/* shape with no holes */\n\n\t\t}\n\n\n\t\tvar i, il, f, face,\n\t\t\tkey, index,\n\t\t\tallPointsMap = {};\n\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\tvar allpoints = contour.concat();\n\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\n\t\t}\n\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\t// prepare all points map\n\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\n\n\t\t\t}\n\n\t\t\tallPointsMap[ key ] = i;\n\n\t\t}\n\n\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\n\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t//console.log( \"triangles\",triangles, triangles.length );\n\n\t\t// check all face vertices against all points map\n\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\tface = triangles[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangles.concat();\n\n\t},\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn THREE.ShapeUtils.area( pts ) < 0;\n\n\t},\n\n\t// Bezier Curves formulas obtained from\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t// Quad Bezier Functions\n\n\tb2: ( function () {\n\n\t\tfunction b2p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * p;\n\n\t\t}\n\n\t\tfunction b2p1( t, p ) {\n\n\t\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t\t}\n\n\t\tfunction b2p2( t, p ) {\n\n\t\t\treturn t * t * p;\n\n\t\t}\n\n\t\treturn function b2( t, p0, p1, p2 ) {\n\n\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\n\t\t};\n\n\t} )(),\n\n\t// Cubic Bezier Functions\n\n\tb3: ( function () {\n\n\t\tfunction b3p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * k * p;\n\n\t\t}\n\n\t\tfunction b3p1( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * k * t * p;\n\n\t\t}\n\n\t\tfunction b3p2( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * t * t * p;\n\n\t\t}\n\n\t\tfunction b3p3( t, p ) {\n\n\t\t\treturn t * t * t * p;\n\n\t\t}\n\n\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\n\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\n\t\t};\n\n\t} )()\n\n};\n\n// File:src/extras/core/Curve.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of Curve methods\n * .getPoint(t), getTangent(t)\n * .getPointAt(u), getTagentAt(u)\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following classes subclasses THREE.Curve:\n *\n * -- 2d classes --\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.CubicBezierCurve\n * THREE.SplineCurve\n * THREE.ArcCurve\n * THREE.EllipseCurve\n *\n * -- 3d classes --\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n * THREE.CubicBezierCurve3\n * THREE.SplineCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nTHREE.Curve = function () {\n\n};\n\nTHREE.Curve.prototype = {\n\n\tconstructor: THREE.Curve,\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint: function ( t ) {\n\n\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\treturn null;\n\n\t},\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t );\n\n\t},\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar d, pts = [];\n\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpts.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn pts;\n\n\t},\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar d, pts = [];\n\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpts.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn pts;\n\n\t},\n\n\t// Get total curve arc length\n\n\tgetLength: function () {\n\n\t\tvar lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t},\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n\t\tif ( this.cacheArcLengths\n\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t&& ! this.needsUpdate ) {\n\n\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tvar cache = [];\n\t\tvar current, last = this.getPoint( 0 );\n\t\tvar p, sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n\t},\n\n\tupdateArcLengths: function() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping: function ( u, distance ) {\n\n\t\tvar arcLengths = this.getLengths();\n\n\t\tvar i = 0, il = arcLengths.length;\n\n\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t//var time = Date.now();\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tvar low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\t//console.log('b' , i, low, high, Date.now()- time);\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\tvar t = i / ( il - 1 );\n\t\t\treturn t;\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tvar lengthBefore = arcLengths[ i ];\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t},\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent: function( t ) {\n\n\t\tvar delta = 0.0001;\n\t\tvar t1 = t - delta;\n\t\tvar t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tvar pt1 = this.getPoint( t1 );\n\t\tvar pt2 = this.getPoint( t2 );\n\n\t\tvar vec = pt2.clone().sub( pt1 );\n\t\treturn vec.normalize();\n\n\t},\n\n\tgetTangentAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t );\n\n\t}\n\n};\n\n// TODO: Transformation for Curves?\n\n/**************************************************************\n *\t3D Curves\n **************************************************************/\n\n// A Factory method for creating new curve subclasses\n\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\tconstructor.prototype.constructor = constructor;\n\tconstructor.prototype.getPoint = getPointFunc;\n\n\treturn constructor;\n\n};\n\n// File:src/extras/core/CurvePath.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nTHREE.CurvePath = function () {\n\n\tthis.curves = [];\n\n\tthis.autoClose = false; // Automatically closes the path\n\n};\n\nTHREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {\n\n\tconstructor: THREE.CurvePath,\n\n\tadd: function ( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t},\n\n\tclosePath: function () {\n\n\t\t// TODO Test\n\t\t// and verify for vector3 (needs to implement equals)\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\n\n\t\t}\n\n\t},\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint: function ( t ) {\n\n\t\tvar d = t * this.getLength();\n\t\tvar curveLengths = this.getCurveLengths();\n\t\tvar i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\tvar u = 1 - diff / curve.getLength();\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t},\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength: function () {\n\n\t\tvar lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t},\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths: function () {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tvar lengths = [], sums = 0;\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t},\n\n\t/**************************************************************\n\t *\tCreate Geometries Helpers\n\t **************************************************************/\n\n\t/// Generate geometry from path points (for Line or Points objects)\n\n\tcreatePointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\t// Generate geometry from equidistant sampling along the path\n\n\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getSpacedPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\tcreateGeometry: function ( points ) {\n\n\t\tvar geometry = new THREE.Geometry();\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/extras/core/Font.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Font = function ( data ) {\n\n\tthis.data = data;\n\n};\n\nObject.assign( THREE.Font.prototype, {\n\n\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\tfunction createPaths( text ) {\n\n\t\t\tvar chars = String( text ).split( '' );\n\t\t\tvar scale = size / data.resolution;\n\t\t\tvar offset = 0;\n\n\t\t\tvar paths = [];\n\n\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\toffset += ret.offset;\n\n\t\t\t\tpaths.push( ret.path );\n\n\t\t\t}\n\n\t\t\treturn paths;\n\n\t\t}\n\n\t\tfunction createPath( c, scale, offset ) {\n\n\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n\t\t\tif ( ! glyph ) return;\n\n\t\t\tvar path = new THREE.Path();\n\n\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\n\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n\t\t\tif ( glyph.o ) {\n\n\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn { offset: glyph.ha * scale, path: path };\n\n\t\t}\n\n\t\t//\n\n\t\tif ( size === undefined ) size = 100;\n\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\tvar data = this.data;\n\n\t\tvar paths = createPaths( text );\n\t\tvar shapes = [];\n\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n// File:src/extras/core/Path.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n *\n **/\n\nTHREE.Path = function ( points ) {\n\n\tTHREE.CurvePath.call( this );\n\n\tthis.actions = [];\n\n\tif ( points ) {\n\n\t\tthis.fromPoints( points );\n\n\t}\n\n};\n\nTHREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {\n\n\tconstructor: THREE.Path,\n\n\t// TODO Clean up PATH API\n\n\t// Create path using straight lines to connect all points\n\t// - vectors: array of Vector2\n\n\tfromPoints: function ( vectors ) {\n\n\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n\t\t}\n\n\t},\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.QuadraticBezierCurve(\n\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.CubicBezierCurve(\n\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\n\n\t},\n\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\tvar args = Array.prototype.slice.call( arguments );\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\n\t\tArray.prototype.push.apply( npts, pts );\n\n\t\tvar curve = new THREE.SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = pts[ pts.length - 1 ];\n\t\targs.push( lastPoint.x );\n\t\targs.push( lastPoint.y );\n\n\t\tthis.actions.push( { action: 'splineThru', args: args } );\n\n\t},\n\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t},\n\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar args = [\n\t\t\taX, aY,\n\t\t\txRadius, yRadius,\n\t\t\taStartAngle, aEndAngle,\n\t\t\taClockwise,\n\t\t\taRotation || 0 // aRotation is optional.\n\t\t];\n\n\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = curve.getPoint( 1 );\n\t\targs.push( lastPoint.x );\n\t\targs.push( lastPoint.y );\n\n\t\tthis.actions.push( { action: 'ellipse', args: args } );\n\n\t},\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 40;\n\n\t\tvar points = [];\n\n\t\tfor ( var i = 0; i < divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tgetPoints: function ( divisions ) {\n\n\t\tdivisions = divisions || 12;\n\n\t\tvar b2 = THREE.ShapeUtils.b2;\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\n\t\tvar points = [];\n\n\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\n\t\t\tlaste, tx, ty;\n\n\t\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\n\n\t\t\tvar item = this.actions[ i ];\n\n\t\t\tvar action = item.action;\n\t\t\tvar args = item.args;\n\n\t\t\tswitch ( action ) {\n\n\t\t\tcase 'moveTo':\n\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'lineTo':\n\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'quadraticCurveTo':\n\n\t\t\t\tcpx  = args[ 2 ];\n\t\t\t\tcpy  = args[ 3 ];\n\n\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\tcpy1 = args[ 1 ];\n\n\t\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / divisions;\n\n\t\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\n\t\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'bezierCurveTo':\n\n\t\t\t\tcpx  = args[ 4 ];\n\t\t\t\tcpy  = args[ 5 ];\n\n\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\tcpy1 = args[ 1 ];\n\n\t\t\t\tcpx2 = args[ 2 ];\n\t\t\t\tcpy2 = args[ 3 ];\n\n\t\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t\t}\n\n\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / divisions;\n\n\t\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'splineThru':\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\n\t\t\t\tvar spts = [ last ];\n\n\t\t\t\tvar n = divisions * args[ 0 ].length;\n\n\t\t\t\tspts = spts.concat( args[ 0 ] );\n\n\t\t\t\tvar spline = new THREE.SplineCurve( spts );\n\n\t\t\t\tfor ( var j = 1; j <= n; j ++ ) {\n\n\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'arc':\n\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\taRadius = args[ 2 ],\n\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\n\t\t\t\t\taClockwise = !! args[ 5 ];\n\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\tvar angle;\n\t\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / tdivisions;\n\n\t\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\n\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\n\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\t//console.log(points);\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ellipse':\n\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\txRadius = args[ 2 ],\n\t\t\t\t\tyRadius = args[ 3 ],\n\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\n\t\t\t\t\taClockwise = !! args[ 6 ],\n\t\t\t\t\taRotation = args[ 7 ];\n\n\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\tvar angle;\n\t\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\t\tvar cos, sin;\n\t\t\t\tif ( aRotation !== 0 ) {\n\n\t\t\t\t\tcos = Math.cos( aRotation );\n\t\t\t\t\tsin = Math.sin( aRotation );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / tdivisions;\n\n\t\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\n\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\n\n\t\t\t\t\tif ( aRotation !== 0 ) {\n\n\t\t\t\t\t\tvar x = tx, y = ty;\n\n\t\t\t\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\n\t\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\t//console.log(points);\n\n\t\t\t\tbreak;\n\n\t\t\t} // end switch\n\n\t\t}\n\n\n\n\t\t// Normalize to remove the closing point by default.\n\t\tvar lastPoint = points[ points.length - 1 ];\n\t\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\n\t\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\n\t\t\tpoints.splice( points.length - 1, 1 );\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\tfunction extractSubpaths( inActions ) {\n\n\t\t\tvar subPaths = [], lastPath = new THREE.Path();\n\n\t\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\n\n\t\t\t\tvar item = inActions[ i ];\n\n\t\t\t\tvar args = item.args;\n\t\t\t\tvar action = item.action;\n\n\t\t\t\tif ( action === 'moveTo' ) {\n\n\t\t\t\t\tif ( lastPath.actions.length !== 0 ) {\n\n\t\t\t\t\t\tsubPaths.push( lastPath );\n\t\t\t\t\t\tlastPath = new THREE.Path();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlastPath[ action ].apply( lastPath, args );\n\n\t\t\t}\n\n\t\t\tif ( lastPath.actions.length !== 0 ) {\n\n\t\t\t\tsubPaths.push( lastPath );\n\n\t\t\t}\n\n\t\t\t// console.log(subPaths);\n\n\t\t\treturn\tsubPaths;\n\n\t\t}\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\tvar tmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\t//console.log(\"shape\", shapes);\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tvar inside = false;\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\n\n\t\tvar subPaths = extractSubpaths( this.actions );\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new THREE.Shape();\n\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tvar betterShapeHoles = [];\n\t\tvar newShapes = [];\n\t\tvar newShapeHoles = [];\n\t\tvar mainIdx = 0;\n\t\tvar tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tvar ambiguous = false;\n\t\t\tvar toChange = [];\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmpHoles;\n\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n// File:src/extras/core/Shape.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nTHREE.Shape = function () {\n\n\tTHREE.Path.apply( this, arguments );\n\n\tthis.holes = [];\n\n};\n\nTHREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {\n\n\tconstructor: THREE.Shape,\n\n\t// Convenience method to return ExtrudeGeometry\n\n\textrude: function ( options ) {\n\n\t\treturn new THREE.ExtrudeGeometry( this, options );\n\n\t},\n\n\t// Convenience method to return ShapeGeometry\n\n\tmakeGeometry: function ( options ) {\n\n\t\treturn new THREE.ShapeGeometry( this, options );\n\n\t},\n\n\tgetPointsHoles: function ( divisions ) {\n\n\t\tvar holesPts = [];\n\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t},\n\n\t// Get points of shape and holes (keypoints based on segments parameter)\n\n\textractAllPoints: function ( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t},\n\n\textractPoints: function ( divisions ) {\n\n\t\treturn this.extractAllPoints( divisions );\n\n\t}\n\n} );\n\n// File:src/extras/curves/LineCurve.js\n\n/**************************************************************\n *\tLine\n **************************************************************/\n\nTHREE.LineCurve = function ( v1, v2 ) {\n\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\n\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\n\tvar point = this.v2.clone().sub( this.v1 );\n\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\n\treturn this.getPoint( u );\n\n};\n\nTHREE.LineCurve.prototype.getTangent = function( t ) {\n\n\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\treturn tangent.normalize();\n\n};\n\n// File:src/extras/curves/QuadraticBezierCurve.js\n\n/**************************************************************\n *\tQuadratic Bezier curve\n **************************************************************/\n\n\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\n\n\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b2 = THREE.ShapeUtils.b2;\n\n\treturn new THREE.Vector2(\n\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t);\n\n};\n\n\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\n\n\treturn new THREE.Vector2(\n\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/CubicBezierCurve.js\n\n/**************************************************************\n *\tCubic Bezier curve\n **************************************************************/\n\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\tthis.v3 = v3;\n\n};\n\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\n\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b3 = THREE.ShapeUtils.b3;\n\n\treturn new THREE.Vector2( \n\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t);\n\n};\n\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\n\n\treturn new THREE.Vector2( \n\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/SplineCurve.js\n\n/**************************************************************\n *\tSpline curve\n **************************************************************/\n\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\n\tthis.points = ( points == undefined ) ? [] : points;\n\n};\n\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\n\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\n\tvar points = this.points;\n\tvar point = ( points.length - 1 ) * t;\n\n\tvar intPoint = Math.floor( point );\n\tvar weight = point - intPoint;\n\n\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\tvar point1 = points[ intPoint ];\n\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\treturn new THREE.Vector2(\n\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t);\n\n};\n\n// File:src/extras/curves/EllipseCurve.js\n\n/**************************************************************\n *\tEllipse curve\n **************************************************************/\n\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\tthis.aX = aX;\n\tthis.aY = aY;\n\n\tthis.xRadius = xRadius;\n\tthis.yRadius = yRadius;\n\n\tthis.aStartAngle = aStartAngle;\n\tthis.aEndAngle = aEndAngle;\n\n\tthis.aClockwise = aClockwise;\n\t\n\tthis.aRotation = aRotation || 0;\n\n};\n\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\n\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\n\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\n\n\tvar angle;\n\n\tif ( this.aClockwise === true ) {\n\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\n\n\t} else {\n\n\t\tangle = this.aStartAngle + t * deltaAngle;\n\n\t}\n\t\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\tif ( this.aRotation !== 0 ) {\n\n\t\tvar cos = Math.cos( this.aRotation );\n\t\tvar sin = Math.sin( this.aRotation );\n\n\t\tvar tx = x, ty = y;\n\n\t\t// Rotate the point about the center of the ellipse.\n\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\n\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\n\n\t}\n\n\treturn new THREE.Vector2( x, y );\n\n};\n\n// File:src/extras/curves/ArcCurve.js\n\n/**************************************************************\n *\tArc curve\n **************************************************************/\n\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n};\n\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\n\n// File:src/extras/curves/LineCurve3.js\n\n/**************************************************************\n *\tLine3D\n **************************************************************/\n\nTHREE.LineCurve3 = THREE.Curve.create(\n\n\tfunction ( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\tvector.multiplyScalar( t );\n\t\tvector.add( this.v1 );\n\n\t\treturn vector;\n\n\t}\n\n);\n\n// File:src/extras/curves/QuadraticBezierCurve3.js\n\n/**************************************************************\n *\tQuadratic Bezier 3D curve\n **************************************************************/\n\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\n\n\t\treturn new THREE.Vector3(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CubicBezierCurve3.js\n\n/**************************************************************\n *\tCubic Bezier 3D curve\n **************************************************************/\n\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\n\t\treturn new THREE.Vector3(\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/SplineCurve3.js\n\n/**************************************************************\n *\tSpline 3D curve\n **************************************************************/\n\n\nTHREE.SplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */ ) {\n\n\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\tthis.points = ( points == undefined ) ? [] : points;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\t\treturn new THREE.Vector3(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CatmullRomCurve3.js\n\n/**\n * @author zz85 https://github.com/zz85\n *\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\nTHREE.CatmullRomCurve3 = ( function() {\n\n\tvar\n\t\ttmp = new THREE.Vector3(),\n\t\tpx = new CubicPoly(),\n\t\tpy = new CubicPoly(),\n\t\tpz = new CubicPoly();\n\n\t/*\n\tBased on an optimized c++ solution in\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t - http://ideone.com/NoEbVM\n\n\tThis CubicPoly class could be used for reusing some variables and calculations,\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\twhich can be placed in CurveUtils.\n\t*/\n\n\tfunction CubicPoly() {\n\n\t}\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\n\t\tthis.c0 = x0;\n\t\tthis.c1 = t0;\n\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t};\n\n\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t// compute tangents when parameterized in [t1,t2]\n\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t// rescale tangents for parametrization in [0,1]\n\t\tt1 *= dt1;\n\t\tt2 *= dt1;\n\n\t\t// initCubicPoly\n\t\tthis.init( x1, x2, t1, t2 );\n\n\t};\n\n\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\n\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t};\n\n\tCubicPoly.prototype.calc = function( t ) {\n\n\t\tvar t2 = t * t;\n\t\tvar t3 = t2 * t;\n\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\n\t};\n\n\t// Subclass Three.js curve\n\treturn THREE.Curve.create(\n\n\t\tfunction ( p /* array of Vector3 */ ) {\n\n\t\t\tthis.points = p || [];\n\t\t\tthis.closed = false;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar points = this.points,\n\t\t\t\tpoint, intPoint, weight, l;\n\n\t\t\tl = points.length;\n\n\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tif ( this.closed ) {\n\n\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\t\tintPoint = l - 2;\n\t\t\t\tweight = 1;\n\n\t\t\t}\n\n\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate first point\n\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\tp0 = tmp;\n\n\t\t\t}\n\n\t\t\tp1 = points[ intPoint % l ];\n\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate last point\n\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\tp3 = tmp;\n\n\t\t\t}\n\n\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t\t// safety check for repeated points\n\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t\t} else if ( this.type === 'catmullrom' ) {\n\n\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n\t\t\t}\n\n\t\t\tvar v = new THREE.Vector3(\n\t\t\t\tpx.calc( weight ),\n\t\t\t\tpy.calc( weight ),\n\t\t\t\tpz.calc( weight )\n\t\t\t);\n\n\t\t\treturn v;\n\n\t\t}\n\n\t);\n\n} )();\n\n// File:src/extras/curves/ClosedSplineCurve3.js\n\n/**************************************************************\n *\tClosed Spline 3D curve\n **************************************************************/\n\n\nTHREE.ClosedSplineCurve3 = function ( points ) {\n\n\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\n\tTHREE.CatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\tthis.closed = true;\n\n};\n\nTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\n\n// File:src/extras/geometries/BoxGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n */\n\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'BoxGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\n\nTHREE.CubeGeometry = THREE.BoxGeometry;\n\n// File:src/extras/geometries/BoxBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'BoxBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tvar scope = this;\n\n\t// segments\n\twidthSegments = Math.floor( widthSegments ) || 1;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\tvar numberOfVertices = 0;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// build each side of the box geometry\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\t// helper functions\n\n\tfunction calculateVertexCount ( w, h, d ) {\n\n\t\tvar vertices = 0;\n\n\t\t// calculate the amount of vertices for each side (plane)\n\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\n\t\treturn vertices;\n\n\t}\n\n\tfunction calculateIndexCount ( w, h, d ) {\n\n\t\tvar index = 0;\n\n\t\t// calculate the amount of squares for each side\n\t\tindex += w * h * 2; // xy\n\t\tindex += w * d * 2; // xz\n\t\tindex += d * h * 2; // zy\n\n\t\treturn index * 6; // two triangles per square => six vertices per square\n\n\t}\n\n\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\tvar segmentWidth\t= width / gridX;\n\t\tvar segmentHeight = height / gridY;\n\n\t\tvar widthHalf = width / 2;\n\t\tvar heightHalf = height / 2;\n\t\tvar depthHalf = depth / 2;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar vertexCounter = 0;\n\t\tvar groupCount = 0;\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = 0;\n\t\t\t\tvector[ v ] = 0;\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t// now apply vector to normal buffer\n\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// uvs\n\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\t\t\t\tvertexCounter += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 1. you need three indices to draw a single face\n\t\t// 2. a single segment consists of two faces\n\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tindexBufferOffset += 6;\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t\t// update total number of vertices\n\t\tnumberOfVertices += vertexCounter;\n\n\t}\n\n};\n\nTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\n\n// File:src/extras/geometries/CircleGeometry.js\n\n/**\n * @author hughes\n */\n\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CircleGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\n\n// File:src/extras/geometries/CircleBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CircleBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tvar vertices = segments + 2;\n\n\tvar positions = new Float32Array( vertices * 3 );\n\tvar normals = new Float32Array( vertices * 3 );\n\tvar uvs = new Float32Array( vertices * 2 );\n\n\t// center data is already zero, but need to set a few extras\n\tnormals[ 2 ] = 1.0;\n\tuvs[ 0 ] = 0.5;\n\tuvs[ 1 ] = 0.5;\n\n\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\n\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\n\t\tnormals[ i + 2 ] = 1; // normal z\n\n\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var i = 1; i <= segments; i ++ ) {\n\n\t\tindices.push( i, i + 1, 0 );\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\n\n// File:src/extras/geometries/CylinderBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CylinderBufferGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tvar scope = this;\n\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\theight = height !== undefined ? height : 100;\n\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\n\topenEnded = openEnded !== undefined ? openEnded : false;\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n\t// used to calculate buffer length\n\n\tvar nbCap = 0;\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\tif ( radiusBottom > 0 ) nbCap ++;\n\n\t}\n\n\tvar vertexCount = calculateVertexCount();\n\tvar indexCount = calculateIndexCount();\n\n\t// buffers\n\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\n\tvar index = 0,\n\t    indexOffset = 0,\n\t    indexArray = [],\n\t    halfHeight = height / 2;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// generate geometry\n\n\tgenerateTorso();\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// helper functions\n\n\tfunction calculateVertexCount() {\n\n\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction calculateIndexCount() {\n\n\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += radialSegments * nbCap * 3;\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction generateTorso() {\n\n\t\tvar x, y;\n\t\tvar normal = new THREE.Vector3();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\t// this will be used to calculate the normal\n\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar indexRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\t// calculate the radius of the current row\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\n\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormal.copy( vertex );\n\n\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\n\n\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\n\n\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\n\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\n\n\t\t\t\t}\n\n\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\t// save index of vertex in respective row\n\t\t\t\tindexRow.push( index );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// now save vertices of the row in our index array\n\t\t\tindexArray.push( indexRow );\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n\tfunction generateCap( top ) {\n\n\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\tvar uv = new THREE.Vector2();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t// save the index of the first center vertex\n\t\tcenterIndexStart = index;\n\n\t\t// first we generate the center vertex data of the cap.\n\t\t// because the geometry needs one set of uvs per face,\n\t\t// we must generate a center vertex per face/segment\n\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = 0.5;\n\t\t\tuv.y = 0.5;\n\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// save the index of the last center vertex\n\t\tcenterIndexEnd = index;\n\n\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\tvar u = x / radialSegments;\n\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * sinTheta;\n\t\t\tvertex.y = halfHeight * sign;\n\t\t\tvertex.z = radius * cosTheta;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar c = centerIndexStart + x;\n\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\tif ( top === true ) {\n\n\t\t\t\t// face top\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t} else {\n\n\t\t\t\t// face bottom\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t}\n\n\t\t\t// update counters\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n};\n\nTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\n\n// File:src/extras/geometries/CylinderGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CylinderGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\n\n// File:src/extras/geometries/ConeBufferGeometry.js\n\n/*\n * @author: abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeBufferGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderBufferGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;\n\n// File:src/extras/geometries/ConeGeometry.js\n\n/**\n * @author abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );\nTHREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;\n\n// File:src/extras/geometries/EdgesGeometry.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tvar geometry2;\n\n\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tgeometry2 = new THREE.Geometry();\n\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry2 = geometry.clone();\n\n\t}\n\n\tgeometry2.mergeVertices();\n\tgeometry2.computeFaceNormals();\n\n\tvar vertices = geometry2.vertices;\n\tvar faces = geometry2.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\tedge.sort( sortFunction );\n\n\t\t\tvar key = edge.toString();\n\n\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t} else {\n\n\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvar coords = [];\n\n\tfor ( var key in hash ) {\n\n\t\tvar h = hash[ key ];\n\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t}\n\n\t}\n\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\n\n};\n\nTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\n\n// File:src/extras/geometries/ExtrudeGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  amount: <int>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n *\n *  uvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\n\tif ( typeof( shapes ) === \"undefined\" ) {\n\n\t\tshapes = [];\n\t\treturn;\n\n\t}\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ExtrudeGeometry';\n\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n\t// can't really use automatic vertex normals\n\t// as then front and back sides get smoothed too\n\t// should do separate smoothing just for sides\n\n\t//this.computeVertexNormals();\n\n\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n};\n\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\n\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tvar sl = shapes.length;\n\n\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\tvar shape = shapes[ s ];\n\t\tthis.addShape( shape, options );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\tvar extrudePath = options.extrudePath;\n\tvar extrudePts, extrudeByPath = false;\n\n\t// Use default WorldUVGenerator if no UV generators are specified.\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\n\tvar splineTube, binormal, normal, position2;\n\tif ( extrudePath ) {\n\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\textrudeByPath = true;\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t// SETUP TNB variables\n\n\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t// TODO1 - have a .isClosed in spline?\n\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\n\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\tbinormal = new THREE.Vector3();\n\t\tnormal = new THREE.Vector3();\n\t\tposition2 = new THREE.Vector3();\n\n\t}\n\n\t// Safeguards if bevels are not enabled\n\n\tif ( ! bevelEnabled ) {\n\n\t\tbevelSegments = 0;\n\t\tbevelThickness = 0;\n\t\tbevelSize = 0;\n\n\t}\n\n\t// Variables initialization\n\n\tvar ahole, h, hl; // looping of holes\n\tvar scope = this;\n\n\tvar shapesOffset = this.vertices.length;\n\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t}\n\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t/* Vertices */\n\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\tvertices = vertices.concat( ahole );\n\n\t}\n\n\n\tfunction scalePt2 ( pt, vec, size ) {\n\n\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t}\n\n\tvar b, bs, t, z,\n\t\tvert, vlen = vertices.length,\n\t\tface, flen = faces.length;\n\n\n\t// Find directions for point movement\n\n\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t//\n\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\n\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t// check for collinear edges\n\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t// not collinear\n\n\t\t\t// length of vectors for normalizing\n\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t// vector from inPt to intersection point\n\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t//  but prevent crazy spikes\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\n\n\t\t\t} else {\n\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// handle special case of collinear edges\n\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( direction_eq ) {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t} else {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t}\n\n\n\tvar contourMovements = [];\n\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\tif ( j === il ) j = 0;\n\t\tif ( k === il ) k = 0;\n\n\t\t//  (j)---(i)---(k)\n\t\t// console.log('i,j,k', i, j , k)\n\n\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t}\n\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\toneHoleMovements = [];\n\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t}\n\n\t\tholesMovements.push( oneHoleMovements );\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t}\n\n\n\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\n\t\t//z = bevelThickness * t;\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\n\t\t//bs = bevelSize * t; // linear\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbs = bevelSize;\n\n\t// Back facing vertices\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\tif ( ! extrudeByPath ) {\n\n\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t} else {\n\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t}\n\n\t}\n\n\t// Add stepped vertices...\n\t// Including front facing vertices\n\n\tvar s;\n\n\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Add bevel segments planes\n\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Faces */\n\n\t// Top and bottom faces\n\n\tbuildLidFaces();\n\n\t// Sides faces\n\n\tbuildSideFaces();\n\n\n\t/////  Internal functions\n\n\tfunction buildLidFaces() {\n\n\t\tif ( bevelEnabled ) {\n\n\t\t\tvar layer = 0; // steps + 1\n\t\t\tvar offset = vlen * layer;\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t}\n\n\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\toffset = vlen * layer;\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t}\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Create faces for the z-sides of the shape\n\n\tfunction buildSideFaces() {\n\n\t\tvar layeroffset = 0;\n\t\tsidewalls( contour, layeroffset );\n\t\tlayeroffset += contour.length;\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t//, true\n\t\t\tlayeroffset += ahole.length;\n\n\t\t}\n\n\t}\n\n\tfunction sidewalls( contour, layeroffset ) {\n\n\t\tvar j, k;\n\t\ti = contour.length;\n\n\t\twhile ( -- i >= 0 ) {\n\n\t\t\tj = i;\n\t\t\tk = i - 1;\n\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\tfunction v( x, y, z ) {\n\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t}\n\n\tfunction f3( a, b, c ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\n\n\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\n\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\t\td += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\n\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\n\n\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\n\t\treturn [\n\t\t\tnew THREE.Vector2( a.x, a.y ),\n\t\t\tnew THREE.Vector2( b.x, b.y ),\n\t\t\tnew THREE.Vector2( c.x, c.y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\t\tvar d = vertices[ indexD ];\n\n\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\n\t\t\t];\n\n\t\t}\n\n\t}\n};\n\n// File:src/extras/geometries/ShapeGeometry.js\n\n/**\n * @author jonobr1 / http://jonobr1.com\n *\n * Creates a one-sided polygonal geometry from a path shape. Similar to\n * ExtrudeGeometry.\n *\n * parameters = {\n *\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n *\n *\tmaterial: <int> // material index for front and back faces\n *\tuvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ShapeGeometry = function ( shapes, options ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ShapeGeometry';\n\n\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\n\n/**\n * Add an array of shapes to THREE.ShapeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\tthis.addShape( shapes[ i ], options );\n\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tif ( options === undefined ) options = {};\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar material = options.material;\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\t//\n\n\tvar i, l, hole;\n\n\tvar shapesOffset = this.vertices.length;\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\thole = holes[ i ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\n\n\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false;\n\n\t}\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t// Vertices\n\n\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\thole = holes[ i ];\n\t\tvertices = vertices.concat( hole );\n\n\t}\n\n\t//\n\n\tvar vert, vlen = vertices.length;\n\tvar face, flen = faces.length;\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = vertices[ i ];\n\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\n\t}\n\n\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\tface = faces[ i ];\n\n\t\tvar a = face[ 0 ] + shapesOffset;\n\t\tvar b = face[ 1 ] + shapesOffset;\n\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\n\t}\n\n};\n\n// File:src/extras/geometries/LatheBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n // points - to create a closed torus, one must use a set of points\n //    like so: [ a, b, c, d, a ], see first is the same as last.\n // segments - the number of circumference segments to create\n // phiStart - the starting radian\n // phiLength - the radian (0 to 2PI) range of the lathed section\n //    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'LatheBufferGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tsegments = Math.floor( segments ) || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || Math.PI * 2;\n\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( segments + 1 ) * points.length;\n\tvar indexCount = segments * points.length * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar index = 0, indexOffset = 0, base;\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\tvar inverseSegments = 1.0 / segments;\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar i, j;\n\n\t// generate vertices and uvs\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar sin = Math.sin( phi );\n\t\tvar cos = Math.cos( phi );\n\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\tvertex.y = points[ j ].y;\n\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / segments;\n\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\tbase = j + i * points.length;\n\n\t\t\t// indices\n\t\t\tvar a = base;\n\t\t\tvar b = base + points.length;\n\t\t\tvar c = base + points.length + 1;\n\t\t\tvar d = base + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// generate normals\n\n\tthis.computeVertexNormals();\n\n\t// if the geometry is closed, we need to average the normals along the seam.\n\t// because the corresponding vertices are identical (but still have different UVs).\n\n\tif( phiLength === Math.PI * 2 ) {\n\n\t\tvar normals = this.attributes.normal.array;\n\t\tvar n1 = new THREE.Vector3();\n\t\tvar n2 = new THREE.Vector3();\n\t\tvar n = new THREE.Vector3();\n\n\t\t// this is the buffer offset for the last line of vertices\n\t\tbase = segments * points.length * 3;\n\n\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t// select the normal of the vertex in the first line\n\t\t\tn1.x = normals[ j + 0 ];\n\t\t\tn1.y = normals[ j + 1 ];\n\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t// select the normal of the vertex in the last line\n\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t// average normals\n\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t// assign the new values to both normals\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t} // next row\n\n\t}\n\n};\n\nTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\n\n// File:src/extras/geometries/LatheGeometry.js\n\n/**\n * @author astrodud / http://astrodud.isgreat.org/\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n */\n\n// points - to create a closed torus, one must use a set of points\n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2PI) range of the lathed section\n//    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'LatheGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\n\n// File:src/extras/geometries/PlaneGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PlaneGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n};\n\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\n\n// File:src/extras/geometries/PlaneBufferGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'PlaneBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tvar width_half = width / 2;\n\tvar height_half = height / 2;\n\n\tvar gridX = Math.floor( widthSegments ) || 1;\n\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\tvar gridX1 = gridX + 1;\n\tvar gridY1 = gridY + 1;\n\n\tvar segment_width = width / gridX;\n\tvar segment_height = height / gridY;\n\n\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\n\tvar offset = 0;\n\tvar offset2 = 0;\n\n\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\tvar y = iy * segment_height - height_half;\n\n\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\tvertices[ offset ] = x;\n\t\t\tvertices[ offset + 1 ] = - y;\n\n\t\t\tnormals[ offset + 2 ] = 1;\n\n\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\n\t\t\toffset += 3;\n\t\t\toffset2 += 2;\n\n\t\t}\n\n\t}\n\n\toffset = 0;\n\n\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\n\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\n\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iy;\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\tindices[ offset ] = a;\n\t\t\tindices[ offset + 1 ] = b;\n\t\t\tindices[ offset + 2 ] = d;\n\n\t\t\tindices[ offset + 3 ] = b;\n\t\t\tindices[ offset + 4 ] = c;\n\t\t\tindices[ offset + 5 ] = d;\n\n\t\t\toffset += 6;\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\n\n// File:src/extras/geometries/RingBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'RingBufferGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tinnerRadius = innerRadius || 20;\n\touterRadius = outerRadius || 50;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// some helper variables\n\tvar index = 0, indexOffset = 0, segment;\n\tvar radius = innerRadius;\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\t// values are generate from the inside of the ring to the outside\n\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex++;\n\n\t\t}\n\n\t\t// increase the radius for next row of vertices\n\t\tradius += radiusStep;\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t// indices\n\t\t\tvar a = segment;\n\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\tvar d = segment + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n};\n\nTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\n\n// File:src/extras/geometries/RingGeometry.js\n\n/**\n * @author Kaleb Murphy\n */\n\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'RingGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\n\n// File:src/extras/geometries/SphereGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'SphereGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n};\n\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\n\n// File:src/extras/geometries/SphereBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n * based on THREE.SphereGeometry\n */\n\nTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'SphereBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tphiStart = phiStart !== undefined ? phiStart : 0;\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar thetaEnd = thetaStart + thetaLength;\n\n\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\n\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\tvar index = 0, vertices = [], normal = new THREE.Vector3();\n\n\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\n\t\tvar verticesRow = [];\n\n\t\tvar v = y / heightSegments;\n\n\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\tvar u = x / widthSegments;\n\n\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tnormal.set( px, py, pz ).normalize();\n\n\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\tverticesRow.push( index );\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\n\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\n\tthis.addAttribute( 'position', positions );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\n\n// File:src/extras/geometries/TextGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float> // how far from text outline is bevel\n * }\n */\n\nTHREE.TextGeometry = function ( text, parameters ) {\n\n\tparameters = parameters || {};\n\n\tvar font = parameters.font;\n\n\tif ( font instanceof THREE.Font === false ) {\n\n\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\treturn new THREE.Geometry();\n\n\t}\n\n\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\n\n\tthis.type = 'TextGeometry';\n\n};\n\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\n\n// File:src/extras/geometries/TorusBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\tarc = arc || Math.PI * 2;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\n\t// helper variables\n\tvar center = new THREE.Vector3();\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / tubularSegments * arc;\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t// vertex\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\n\t\t\t// this vector is used to calculate the normal\n\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\tcenter.y = radius * Math.sin( u );\n\n\t\t\t// normal\n\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\n\t\t\t// uv\n\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\n\t\t\t// update offsets\n\t\t\tvertexBufferOffset += 3;\n\t\t\tuvBufferOffset += 2;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t// face one\n\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t// face two\n\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t// update offset\n\t\t\tindexBufferOffset += 6;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\n\n// File:src/extras/geometries/TorusGeometry.js\n\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n */\n\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n};\n\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\n\n// File:src/extras/geometries/TorusKnotBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * see: http://www.blackpawn.com/texts/pqtorus/\n */\nTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusKnotBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\tp = p || 2;\n\tq = q || 3;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar i, j, index = 0, indexOffset = 0;\n\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\n\tvar P1 = new THREE.Vector3();\n\tvar P2 = new THREE.Vector3();\n\n\tvar B = new THREE.Vector3();\n\tvar T = new THREE.Vector3();\n\tvar N = new THREE.Vector3();\n\n\t// generate vertices, normals and uvs\n\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t// calculate orthonormal basis\n\n\t\tT.subVectors( P2, P1 );\n\t\tN.addVectors( P2, P1 );\n\t\tB.crossVectors( T, N );\n\t\tN.crossVectors( B, T );\n\n\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\tB.normalize();\n\t\tN.normalize();\n\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t// now calculate the final vertex position.\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / tubularSegments;\n\t\t\tuv.y = j / radialSegments;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// this function calculates the current position on the torus curve\n\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = q / p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t}\n\n};\n\nTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\n\n// File:src/extras/geometries/TorusKnotGeometry.js\n\n/**\n * @author oosmoxiecode\n */\n\nTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusKnotGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\n\n// File:src/extras/geometries/TubeGeometry.js\n\n/**\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n * @author jonobr1 / https://github.com/jonobr1\n *\n * Modified from the TorusKnotGeometry by @oosmoxiecode\n *\n * Creates a tube which extrudes along a 3d spline\n *\n * Uses parallel transport frames as described in\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n */\n\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TubeGeometry';\n\n\tthis.parameters = {\n\t\tpath: path,\n\t\tsegments: segments,\n\t\tradius: radius,\n\t\tradialSegments: radialSegments,\n\t\tclosed: closed,\n\t\ttaper: taper\n\t};\n\n\tsegments = segments || 64;\n\tradius = radius || 1;\n\tradialSegments = radialSegments || 8;\n\tclosed = closed || false;\n\ttaper = taper || THREE.TubeGeometry.NoTaper;\n\n\tvar grid = [];\n\n\tvar scope = this,\n\n\t\ttangent,\n\t\tnormal,\n\t\tbinormal,\n\n\t\tnumpoints = segments + 1,\n\n\t\tu, v, r,\n\n\t\tcx, cy,\n\t\tpos, pos2 = new THREE.Vector3(),\n\t\ti, j,\n\t\tip, jp,\n\t\ta, b, c, d,\n\t\tuva, uvb, uvc, uvd;\n\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\n\t\ttangents = frames.tangents,\n\t\tnormals = frames.normals,\n\t\tbinormals = frames.binormals;\n\n\t// proxy internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\t// construct the grid\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tgrid[ i ] = [];\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\tpos = path.getPointAt( u );\n\n\t\ttangent = tangents[ i ];\n\t\tnormal = normals[ i ];\n\t\tbinormal = binormals[ i ];\n\n\t\tr = radius * taper( u );\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tv = j / radialSegments * 2 * Math.PI;\n\n\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = r * Math.sin( v );\n\n\t\t\tpos2.copy( pos );\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\n\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\n\t\t}\n\n\t}\n\n\n\t// construct the mesh\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\n\t\t\tjp = ( j + 1 ) % radialSegments;\n\n\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\tb = grid[ ip ][ j ];\n\t\t\tc = grid[ ip ][ jp ];\n\t\t\td = grid[ i ][ jp ];\n\n\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\n\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\n\nTHREE.TubeGeometry.NoTaper = function ( u ) {\n\n\treturn 1;\n\n};\n\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\n\n\treturn Math.sin( Math.PI * u );\n\n};\n\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\n\n\tvar\tnormal = new THREE.Vector3(),\n\n\t\ttangents = [],\n\t\tnormals = [],\n\t\tbinormals = [],\n\n\t\tvec = new THREE.Vector3(),\n\t\tmat = new THREE.Matrix4(),\n\n\t\tnumpoints = segments + 1,\n\t\ttheta,\n\t\tsmallest,\n\n\t\ttx, ty, tz,\n\t\ti, u;\n\n\n\t// expose internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\t// compute the tangent vectors for each segment on the path\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\ttangents[ i ] = path.getTangentAt( u );\n\t\ttangents[ i ].normalize();\n\n\t}\n\n\tinitialNormal3();\n\n\t/*\n\tfunction initialNormal1(lastBinormal) {\n\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t}\n\n\tfunction initialNormal2() {\n\n\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\tvar t2 = path.getTangentAt( epsilon );\n\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\n\t}\n\t*/\n\n\tfunction initialNormal3() {\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the smallest tangent xyz component\n\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tsmallest = Number.MAX_VALUE;\n\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\tty = Math.abs( tangents[ 0 ].y );\n\t\ttz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= smallest ) {\n\n\t\t\tsmallest = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= smallest ) {\n\n\t\t\tsmallest = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= smallest ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t}\n\n\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\n\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\tvec.normalize();\n\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t}\n\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t}\n\n\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\tif ( closed ) {\n\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\n\t\ttheta /= ( numpoints - 1 );\n\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\n\n\t\t\ttheta = - theta;\n\n\t\t}\n\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\t\t// twist a little...\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/extras/geometries/PolyhedronGeometry.js\n\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PolyhedronGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\tvar that = this;\n\n\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\n\n\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\n\n\t}\n\n\tvar p = this.vertices;\n\n\tvar faces = [];\n\n\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\n\n\t\tvar v1 = p[ indices[ i ] ];\n\t\tvar v2 = p[ indices[ i + 1 ] ];\n\t\tvar v3 = p[ indices[ i + 2 ] ];\n\n\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\n\t}\n\n\tvar centroid = new THREE.Vector3();\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tsubdivide( faces[ i ], detail );\n\n\t}\n\n\n\t// Handle case when face straddles the seam\n\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\n\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\tvar x0 = uvs[ 0 ].x;\n\t\tvar x1 = uvs[ 1 ].x;\n\t\tvar x2 = uvs[ 2 ].x;\n\n\t\tvar max = Math.max( x0, x1, x2 );\n\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\n\n\t\t}\n\n\t}\n\n\n\t// Apply radius\n\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\tthis.vertices[ i ].multiplyScalar( radius );\n\n\t}\n\n\n\t// Merge vertices\n\n\tthis.mergeVertices();\n\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n\n\t// Project vector onto sphere's surface\n\n\tfunction prepare( vector ) {\n\n\t\tvar vertex = vector.normalize().clone();\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\n\t\treturn vertex;\n\n\t}\n\n\n\t// Approximate a curved face with recursively sub-divided triangles.\n\n\tfunction make( v1, v2, v3 ) {\n\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\tthat.faces.push( face );\n\n\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\n\t\tvar azi = azimuth( centroid );\n\n\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t] );\n\n\t}\n\n\n\t// Analytically subdivide a face to the required detail level.\n\n\tfunction subdivide( face, detail ) {\n\n\t\tvar cols = Math.pow( 2, detail );\n\t\tvar a = prepare( that.vertices[ face.a ] );\n\t\tvar b = prepare( that.vertices[ face.b ] );\n\t\tvar c = prepare( that.vertices[ face.c ] );\n\t\tvar v = [];\n\n\t\t// Construct all of the vertices for this subdivision.\n\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\n\n\t\t\tv[ i ] = [];\n\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\n\t\t\tvar rows = cols - i;\n\n\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\n\n\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Construct all of the faces.\n\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ],\n\t\t\t\t\t\tv[ i ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n\n\t// Texture fixing helper. Spheres have some odd behaviours.\n\n\tfunction correctUV( uv, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\t\treturn uv.clone();\n\n\t}\n\n\n};\n\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\n\n// File:src/extras/geometries/DodecahedronGeometry.js\n\n/**\n * @author Abe Pazos / https://hamoid.com\n */\n\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\tvar r = 1 / t;\n\n\tvar vertices = [\n\n\t\t// (1, 1, 1)\n\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t 1,  1, - 1,     1,  1,  1,\n\n\t\t// (0, 1/, )\n\t\t 0, - r, - t,     0, - r,  t,\n\t\t 0,  r, - t,     0,  r,  t,\n\n\t\t// (1/, , 0)\n\t\t- r, - t,  0,    - r,  t,  0,\n\t\t r, - t,  0,     r,  t,  0,\n\n\t\t// (, 0, 1/)\n\t\t- t,  0, - r,     t,  0, - r,\n\t\t- t,  0,  r,     t,  0,  r\n\t];\n\n\tvar indices = [\n\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'DodecahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\n\n// File:src/extras/geometries/IcosahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t];\n\n\tvar indices = [\n\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'IcosahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\n\n// File:src/extras/geometries/OctahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.OctahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t];\n\n\tvar indices = [\n\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'OctahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\n\n// File:src/extras/geometries/TetrahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t];\n\n\tvar indices = [\n\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'TetrahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\n\n// File:src/extras/geometries/ParametricGeometry.js\n\n/**\n * @author zz85 / https://github.com/zz85\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n *\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\n *\n */\n\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ParametricGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\tvar verts = this.vertices;\n\tvar faces = this.faces;\n\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\tvar i, j, p;\n\tvar u, v;\n\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tv = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tu = j / slices;\n\n\t\t\tp = func( u, v );\n\t\t\tverts.push( p );\n\n\t\t}\n\n\t}\n\n\tvar a, b, c, d;\n\tvar uva, uvb, uvc, uvd;\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\ta = i * sliceCount + j;\n\t\t\tb = i * sliceCount + j + 1;\n\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\td = ( i + 1 ) * sliceCount + j;\n\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\n\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\t// console.log(this);\n\n\t// magic bullet\n\t// var diff = this.mergeVertices();\n\t// console.log('removed ', diff, ' vertices by merging');\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\n\n// File:src/extras/geometries/WireframeGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeGeometry = function ( geometry ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\tvar vertices = geometry.vertices;\n\t\tvar faces = geometry.faces;\n\t\tvar numEdges = 0;\n\n\t\t// allocate maximal size\n\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\n\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\t// Indexed BufferGeometry\n\n\t\t\tvar indices = geometry.index.array;\n\t\t\tvar vertices = geometry.attributes.position;\n\t\t\tvar groups = geometry.groups;\n\t\t\tvar numEdges = 0;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t}\n\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\tvar start = group.start;\n\t\t\t\tvar count = group.count;\n\n\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\n\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t} else {\n\n\t\t\t// non-indexed BufferGeometry\n\n\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\tvar numEdges = vertices.length / 3;\n\t\t\tvar numTris = numEdges / 3;\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\n\n// File:src/extras/helpers/AxisHelper.js\n\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AxisHelper = function ( size ) {\n\n\tsize = size || 1;\n\n\tvar vertices = new Float32Array( [\n\t\t0, 0, 0,  size, 0, 0,\n\t\t0, 0, 0,  0, size, 0,\n\t\t0, 0, 0,  0, 0, size\n\t] );\n\n\tvar colors = new Float32Array( [\n\t\t1, 0, 0,  1, 0.6, 0,\n\t\t0, 1, 0,  0.6, 1, 0,\n\t\t0, 0, 1,  0, 0.6, 1\n\t] );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\n\n// File:src/extras/helpers/ArrowHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / http://github.com/zz85\n * @author bhouston / http://clara.io\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  color - color in hex value\n *  headLength - Number\n *  headWidth - Number\n */\n\nTHREE.ArrowHelper = ( function () {\n\n\tvar lineGeometry = new THREE.BufferGeometry();\n\tlineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\tvar coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tTHREE.Object3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\n\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\n\n\tvar axis = new THREE.Vector3();\n\tvar radians;\n\n\treturn function setDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tradians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t}\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\tthis.line.updateMatrix();\n\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\tthis.cone.position.y = length;\n\tthis.cone.updateMatrix();\n\n};\n\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\n\n\tthis.line.material.color.copy( color );\n\tthis.cone.material.color.copy( color );\n\n};\n\n// File:src/extras/helpers/BoxHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BoxHelper = function ( object, color ) {\n\t\n\tif ( color === undefined ) color = 0xffff00;\n\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\tvar positions = new Float32Array( 8 * 3 );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ) );\n\n\tif ( object !== undefined ) {\n\n\t\tthis.update( object );\n\n\t}\n\n};\n\nTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\n\nTHREE.BoxHelper.prototype.update = ( function () {\n\n\tvar box = new THREE.Box3();\n\n\treturn function update( object ) {\n\n\t\tif ( object instanceof THREE.Box3 ) {\n\n\t\t\tbox.copy( object );\n\n\t\t} else {\n\n\t\t\tbox.setFromObject( object );\n\n\t\t}\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tvar min = box.min;\n\t\tvar max = box.max;\n\n\t\t/*\n\t\t  5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tvar position = this.geometry.attributes.position;\n\t\tvar array = position.array;\n\n\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t};\n\n} )();\n\n// File:src/extras/helpers/BoundingBoxHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\n// a helper to show the world-axis-aligned bounding box for an object\n\nTHREE.BoundingBoxHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\tthis.object = object;\n\n\tthis.box = new THREE.Box3();\n\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n};\n\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\n\nTHREE.BoundingBoxHelper.prototype.update = function () {\n\n\tthis.box.setFromObject( this.object );\n\n\tthis.box.size( this.scale );\n\n\tthis.box.center( this.position );\n\n};\n\n// File:src/extras/helpers/CameraHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nTHREE.CameraHelper = function ( camera ) {\n\n\tvar geometry = new THREE.Geometry();\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\n\tvar pointMap = {};\n\n\t// colors\n\n\tvar hexFrustum = 0xffaa00;\n\tvar hexCone = 0xff0000;\n\tvar hexUp = 0x00aaff;\n\tvar hexTarget = 0xffffff;\n\tvar hexCross = 0x333333;\n\n\t// near\n\n\taddLine( \"n1\", \"n2\", hexFrustum );\n\taddLine( \"n2\", \"n4\", hexFrustum );\n\taddLine( \"n4\", \"n3\", hexFrustum );\n\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t// far\n\n\taddLine( \"f1\", \"f2\", hexFrustum );\n\taddLine( \"f2\", \"f4\", hexFrustum );\n\taddLine( \"f4\", \"f3\", hexFrustum );\n\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t// sides\n\n\taddLine( \"n1\", \"f1\", hexFrustum );\n\taddLine( \"n2\", \"f2\", hexFrustum );\n\taddLine( \"n3\", \"f3\", hexFrustum );\n\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t// cone\n\n\taddLine( \"p\", \"n1\", hexCone );\n\taddLine( \"p\", \"n2\", hexCone );\n\taddLine( \"p\", \"n3\", hexCone );\n\taddLine( \"p\", \"n4\", hexCone );\n\n\t// up\n\n\taddLine( \"u1\", \"u2\", hexUp );\n\taddLine( \"u2\", \"u3\", hexUp );\n\taddLine( \"u3\", \"u1\", hexUp );\n\n\t// target\n\n\taddLine( \"c\", \"t\", hexTarget );\n\taddLine( \"p\", \"c\", hexCross );\n\n\t// cross\n\n\taddLine( \"cn1\", \"cn2\", hexCross );\n\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\taddLine( \"cf1\", \"cf2\", hexCross );\n\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\tfunction addLine( a, b, hex ) {\n\n\t\taddPoint( a, hex );\n\t\taddPoint( b, hex );\n\n\t}\n\n\tfunction addPoint( id, hex ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\n\n\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\tpointMap[ id ] = [];\n\n\t\t}\n\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t}\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.camera = camera;\n\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\tthis.matrix = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = pointMap;\n\n\tthis.update();\n\n};\n\nTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\n\nTHREE.CameraHelper.prototype.update = function () {\n\n\tvar geometry, pointMap;\n\n\tvar vector = new THREE.Vector3();\n\tvar camera = new THREE.Camera();\n\n\tfunction setPoint( point, x, y, z ) {\n\n\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\tvar points = pointMap[ point ];\n\n\t\tif ( points !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn function update() {\n\n\t\tgeometry = this.geometry;\n\t\tpointMap = this.pointMap;\n\n\t\tvar w = 1, h = 1;\n\n\t\t// we need just camera projection matrix\n\t\t// world matrix must be identity\n\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t// center / target\n\n\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t// near\n\n\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\tsetPoint( \"f4\",   w,   h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\n\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/DirectionalLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.DirectionalLightHelper = function ( light, size ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tif ( size === undefined ) size = 1;\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [\n\t\t- size,   size, 0,\n\t\t  size,   size, 0,\n\t\t  size, - size, 0,\n\t\t- size, - size, 0,\n\t\t- size,   size, 0\n\t], 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.add( new THREE.Line( geometry, material ) );\n\n\tgeometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\tthis.add( new THREE.Line( geometry, material ));\n\n\tthis.update();\n\n};\n\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\n\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\n\n\tvar lightPlane = this.children[ 0 ];\n\tvar targetLine = this.children[ 1 ];\n\n\tlightPlane.geometry.dispose();\n\tlightPlane.material.dispose();\n\ttargetLine.geometry.dispose();\n\ttargetLine.material.dispose();\n\n};\n\nTHREE.DirectionalLightHelper.prototype.update = function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar v3 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\tv3.subVectors( v2, v1 );\n\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\n\t\tlightPlane.lookAt( v3 );\n\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\ttargetLine.lookAt( v3 );\n\t\ttargetLine.scale.z = v3.length();\n\n\t};\n\n}();\n\n// File:src/extras/helpers/EdgesHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @param object THREE.Mesh whose geometry will be used\n * @param hex line color\n * @param thresholdAngle the minimum angle (in degrees),\n * between the face normals of adjacent faces,\n * that is required to render an edge. A value of 10 means\n * an edge is only rendered if the angle is at least 10 degrees.\n */\n\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\n\n// File:src/extras/helpers/FaceNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\t// FaceNormalsHelper only supports THREE.Geometry\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length;\n\n\t} else {\n\n\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\tthis.update();\n\n};\n\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\n\nTHREE.FaceNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tvar vertices = objGeometry.vertices;\n\n\t\tvar faces = objGeometry.faces;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar normal = face.normal;\n\n\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t.divideScalar( 3 )\n\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/GridHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.GridHelper = function ( size, step, color1, color2 ) {\n\n\tcolor1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );\n\tcolor2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );\n\n\tvar vertices = [];\n\tvar colors = [];\n\n\tfor ( var i = - size, j = 0; i <= size; i += step ) {\n\n\t\tvertices.push( - size, 0, i, size, 0, i );\n\t\tvertices.push( i, 0, - size, i, 0, size );\n\n\t\tvar color = i === 0 ? color1 : color2;\n\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\n\t}\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\n\nTHREE.GridHelper.prototype.setColors = function () {\n\n\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n};\n\n// File:src/extras/helpers/HemisphereLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\n\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\tgeometry.rotateX( - Math.PI / 2 );\n\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t}\n\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\n\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\n\tthis.add( this.lightSphere );\n\n\tthis.update();\n\n};\n\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\n\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\n\n\tthis.lightSphere.geometry.dispose();\n\tthis.lightSphere.material.dispose();\n\n};\n\nTHREE.HemisphereLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/PointLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLightHelper = function ( light, sphereSize ) {\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tvar geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.matrix = this.light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\t/*\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tvar d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n};\n\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\n\nTHREE.PointLightHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n\n};\n\nTHREE.PointLightHelper.prototype.update = function () {\n\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t/*\n\tvar d = this.light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.visible = true;\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\t*/\n\n};\n\n// File:src/extras/helpers/SkeletonHelper.js\n\n/**\n * @author Sean Griffin / http://twitter.com/sgrif\n * @author Michael Guerrero / http://realitymeltdown.com\n * @author mrdoob / http://mrdoob.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkeletonHelper = function ( object ) {\n\n\tthis.bones = this.getBoneList( object );\n\n\tvar geometry = new THREE.Geometry();\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dynamic = true;\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.root = object;\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\n\nTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\n\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\n\n\tvar boneList = [];\n\n\tif ( object instanceof THREE.Bone ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n};\n\nTHREE.SkeletonHelper.prototype.update = function () {\n\n\tvar geometry = this.geometry;\n\n\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\n\n\tvar boneMatrix = new THREE.Matrix4();\n\n\tvar j = 0;\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tj += 2;\n\n\t\t}\n\n\t}\n\n\tgeometry.verticesNeedUpdate = true;\n\n\tgeometry.computeBoundingSphere();\n\n};\n\n// File:src/extras/helpers/SpotLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.SpotLightHelper = function ( light ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = [\n\t\t0, 0, 0,   0,   0,   1,\n\t\t0, 0, 0,   1,   0,   1,\n\t\t0, 0, 0, - 1,   0,   1,\n\t\t0, 0, 0,   0,   1,   1,\n\t\t0, 0, 0,   0, - 1,   1\n\t];\n\n\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\tpositions.push(\n\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t);\n\n\t}\n\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.cone = new THREE.LineSegments( geometry, material );\n\tthis.add( this.cone );\n\n\tthis.update();\n\n};\n\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\n\nTHREE.SpotLightHelper.prototype.dispose = function () {\n\n\tthis.cone.geometry.dispose();\n\tthis.cone.material.dispose();\n\n};\n\nTHREE.SpotLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\tvar vector2 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t};\n\n}();\n\n// File:src/extras/helpers/VertexNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length * 3;\n\n\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\n\nTHREE.VertexNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\tvar idx = 0;\n\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/WireframeHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\n\n// File:src/extras/objects/ImmediateRenderObject.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ImmediateRenderObject = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.material = material;\n\tthis.render = function ( renderCallback ) {};\n\n};\n\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\n\n// File:src/extras/objects/MorphBlendMesh.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphBlendMesh = function( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.animationsMap = {};\n\tthis.animationsList = [];\n\n\t// prepare default animation\n\t// (all frames played together in 1 second)\n\n\tvar numFrames = this.geometry.morphTargets.length;\n\n\tvar name = \"__default\";\n\n\tvar startFrame = 0;\n\tvar endFrame = numFrames - 1;\n\n\tvar fps = numFrames / 1;\n\n\tthis.createAnimation( name, startFrame, endFrame, fps );\n\tthis.setAnimationWeight( name, 1 );\n\n};\n\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\n\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\n\tvar animation = {\n\n\t\tstart: start,\n\t\tend: end,\n\n\t\tlength: end - start + 1,\n\n\t\tfps: fps,\n\t\tduration: ( end - start ) / fps,\n\n\t\tlastFrame: 0,\n\t\tcurrentFrame: 0,\n\n\t\tactive: false,\n\n\t\ttime: 0,\n\t\tdirection: 1,\n\t\tweight: 1,\n\n\t\tdirectionBackwards: false,\n\t\tmirroredLoop: false\n\n\t};\n\n\tthis.animationsMap[ name ] = animation;\n\tthis.animationsList.push( animation );\n\n};\n\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\n\tvar pattern = /([a-z]+)_?(\\d+)/i;\n\n\tvar firstAnimation, frameRanges = {};\n\n\tvar geometry = this.geometry;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar chunks = morph.name.match( pattern );\n\n\t\tif ( chunks && chunks.length > 1 ) {\n\n\t\t\tvar name = chunks[ 1 ];\n\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\n\n\t\t\tvar range = frameRanges[ name ];\n\n\t\t\tif ( i < range.start ) range.start = i;\n\t\t\tif ( i > range.end ) range.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\n\t\t}\n\n\t}\n\n\tfor ( var name in frameRanges ) {\n\n\t\tvar range = frameRanges[ name ];\n\t\tthis.createAnimation( name, range.start, range.end, fps );\n\n\t}\n\n\tthis.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = 1;\n\t\tanimation.directionBackwards = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = - 1;\n\t\tanimation.directionBackwards = true;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.fps = fps;\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.duration = duration;\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.weight = weight;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = time;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\n\tvar time = 0;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\ttime = animation.time;\n\n\t}\n\n\treturn time;\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\n\tvar duration = - 1;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tduration = animation.duration;\n\n\t}\n\n\treturn duration;\n\n};\n\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = 0;\n\t\tanimation.active = true;\n\n\t} else {\n\n\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.active = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\n\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\n\t\tvar animation = this.animationsList[ i ];\n\n\t\tif ( ! animation.active ) continue;\n\n\t\tvar frameTime = animation.duration / animation.length;\n\n\t\tanimation.time += animation.direction * delta;\n\n\t\tif ( animation.mirroredLoop ) {\n\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\n\t\t\t\tanimation.direction *= - 1;\n\n\t\t\t\tif ( animation.time > animation.duration ) {\n\n\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\tanimation.directionBackwards = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( animation.time < 0 ) {\n\n\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\tanimation.directionBackwards = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tanimation.time = animation.time % animation.duration;\n\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\n\t\t}\n\n\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\tvar weight = animation.weight;\n\n\t\tif ( keyframe !== animation.currentFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\tanimation.currentFrame = keyframe;\n\n\t\t}\n\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\n\t\tif ( animation.currentFrame !== animation.lastFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\n\t\t} else {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\n\n\t\t}\n\n\t}\n\n};\n\n\n},{}]},{},[1])\n\n","'use strict';\r\n\r\nvar config = {};\r\n\r\nmodule.exports = config;\r\n","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.BloomPass = function ( strength, kernelSize, sigma, resolution ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tstrength = ( strength !== undefined ) ? strength : 1;\r\n\tkernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;\r\n\tsigma = ( sigma !== undefined ) ? sigma : 4.0;\r\n\tresolution = ( resolution !== undefined ) ? resolution : 256;\r\n\r\n\t// render targets\r\n\r\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\r\n\r\n\tthis.renderTargetX = new THREE.WebGLRenderTarget( resolution, resolution, pars );\r\n\tthis.renderTargetY = new THREE.WebGLRenderTarget( resolution, resolution, pars );\r\n\r\n\t// copy material\r\n\r\n\tif ( THREE.CopyShader === undefined )\r\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.CopyShader\" );\r\n\r\n\tvar copyShader = THREE.CopyShader;\r\n\r\n\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\r\n\r\n\tthis.copyUniforms[ \"opacity\" ].value = strength;\r\n\r\n\tthis.materialCopy = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.copyUniforms,\r\n\t\tvertexShader: copyShader.vertexShader,\r\n\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\tblending: THREE.AdditiveBlending,\r\n\t\ttransparent: true\r\n\r\n\t} );\r\n\r\n\t// convolution material\r\n\r\n\tif ( THREE.ConvolutionShader === undefined )\r\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.ConvolutionShader\" );\r\n\r\n\tvar convolutionShader = THREE.ConvolutionShader;\r\n\r\n\tthis.convolutionUniforms = THREE.UniformsUtils.clone( convolutionShader.uniforms );\r\n\r\n\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurX;\r\n\tthis.convolutionUniforms[ \"cKernel\" ].value = THREE.ConvolutionShader.buildKernel( sigma );\r\n\r\n\tthis.materialConvolution = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.convolutionUniforms,\r\n\t\tvertexShader:  convolutionShader.vertexShader,\r\n\t\tfragmentShader: convolutionShader.fragmentShader,\r\n\t\tdefines: {\r\n\t\t\t\"KERNEL_SIZE_FLOAT\": kernelSize.toFixed( 1 ),\r\n\t\t\t\"KERNEL_SIZE_INT\": kernelSize.toFixed( 0 )\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.BloomPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.BloomPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 1)\r\n\r\n\t\tthis.quad.material = this.materialConvolution;\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurX;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetX, true );\r\n\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 2)\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = this.renderTargetX.texture;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurY;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetY, true );\r\n\r\n\t\t// Render original scene with superimposed blur to texture\r\n\r\n\t\tthis.quad.material = this.materialCopy;\r\n\r\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetY.texture;\r\n\r\n\t\tif ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );\r\n\r\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.BloomPass.blurX = new THREE.Vector2( 0.001953125, 0.0 );\r\nTHREE.BloomPass.blurY = new THREE.Vector2( 0.0, 0.001953125 );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.EffectComposer = function ( renderer, renderTarget ) {\r\n\r\n\tthis.renderer = renderer;\r\n\r\n\tif ( renderTarget === undefined ) {\r\n\r\n\t\tvar parameters = {\r\n\t\t\tminFilter: THREE.LinearFilter,\r\n\t\t\tmagFilter: THREE.LinearFilter,\r\n\t\t\tformat: THREE.RGBAFormat,\r\n\t\t\tstencilBuffer: false\r\n\t\t};\r\n\t\tvar size = renderer.getSize();\r\n\t\trenderTarget = new THREE.WebGLRenderTarget( size.width, size.height, parameters );\r\n\r\n\t}\r\n\r\n\tthis.renderTarget1 = renderTarget;\r\n\tthis.renderTarget2 = renderTarget.clone();\r\n\r\n\tthis.writeBuffer = this.renderTarget1;\r\n\tthis.readBuffer = this.renderTarget2;\r\n\r\n\tthis.passes = [];\r\n\r\n\tif ( THREE.CopyShader === undefined )\r\n\t\tconsole.error( \"THREE.EffectComposer relies on THREE.CopyShader\" );\r\n\r\n\tthis.copyPass = new THREE.ShaderPass( THREE.CopyShader );\r\n\r\n};\r\n\r\nObject.assign( THREE.EffectComposer.prototype, {\r\n\r\n\tswapBuffers: function() {\r\n\r\n\t\tvar tmp = this.readBuffer;\r\n\t\tthis.readBuffer = this.writeBuffer;\r\n\t\tthis.writeBuffer = tmp;\r\n\r\n\t},\r\n\r\n\taddPass: function ( pass ) {\r\n\r\n\t\tthis.passes.push( pass );\r\n\r\n\t\tvar size = this.renderer.getSize();\r\n\t\tpass.setSize( size.width, size.height );\r\n\r\n\t},\r\n\r\n\tinsertPass: function ( pass, index ) {\r\n\r\n\t\tthis.passes.splice( index, 0, pass );\r\n\r\n\t},\r\n\r\n\trender: function ( delta ) {\r\n\r\n\t\tvar maskActive = false;\r\n\r\n\t\tvar pass, i, il = this.passes.length;\r\n\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tpass = this.passes[ i ];\r\n\r\n\t\t\tif ( pass.enabled === false ) continue;\r\n\r\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );\r\n\r\n\t\t\tif ( pass.needsSwap ) {\r\n\r\n\t\t\t\tif ( maskActive ) {\r\n\r\n\t\t\t\t\tvar context = this.renderer.context;\r\n\r\n\t\t\t\t\tcontext.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );\r\n\r\n\t\t\t\t\tcontext.stencilFunc( context.EQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.swapBuffers();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( THREE.MaskPass !== undefined ) {\r\n\r\n\t\t\t\tif ( pass instanceof THREE.MaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = true;\r\n\r\n\t\t\t\t} else if ( pass instanceof THREE.ClearMaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\treset: function ( renderTarget ) {\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\tvar size = this.renderer.getSize();\r\n\r\n\t\t\trenderTarget = this.renderTarget1.clone();\r\n\t\t\trenderTarget.setSize( size.width, size.height );\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTarget1.dispose();\r\n\t\tthis.renderTarget2.dispose();\r\n\t\tthis.renderTarget1 = renderTarget;\r\n\t\tthis.renderTarget2 = renderTarget.clone();\r\n\r\n\t\tthis.writeBuffer = this.renderTarget1;\r\n\t\tthis.readBuffer = this.renderTarget2;\r\n\r\n\t},\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tthis.renderTarget1.setSize( width, height );\r\n\t\tthis.renderTarget2.setSize( width, height );\r\n\r\n\t\tfor ( var i = 0; i < this.passes.length; i ++ ) {\r\n\r\n\t\t\tthis.passes[i].setSize( width, height );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\nTHREE.Pass = function () {\r\n\r\n\t// if set to true, the pass is processed by the composer\r\n\tthis.enabled = true;\r\n\r\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\r\n\tthis.needsSwap = true;\r\n\r\n\t// if set to true, the pass clears its buffer before rendering\r\n\tthis.clear = false;\r\n\r\n\t// if set to true, the result of the pass is rendered to screen\r\n\tthis.renderToScreen = false;\r\n\r\n};\r\n\r\nObject.assign( THREE.Pass.prototype, {\r\n\r\n\tsetSize: function( width, height ) {},\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tconsole.error( \"THREE.Pass: .render() must be implemented in derived pass.\" );\r\n\r\n\t}\r\n\r\n} );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tif ( THREE.FilmShader === undefined )\r\n\t\tconsole.error( \"THREE.FilmPass relies on THREE.FilmShader\" );\r\n\r\n\tvar shader = THREE.FilmShader;\r\n\r\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\tthis.material = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.uniforms,\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t} );\r\n\r\n\tif ( grayscale !== undefined )\tthis.uniforms.grayscale.value = grayscale;\r\n\tif ( noiseIntensity !== undefined ) this.uniforms.nIntensity.value = noiseIntensity;\r\n\tif ( scanlinesIntensity !== undefined ) this.uniforms.sIntensity.value = scanlinesIntensity;\r\n\tif ( scanlinesCount !== undefined ) this.uniforms.sCount.value = scanlinesCount;\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.FilmPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.FilmPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.uniforms[ \"time\" ].value += delta;\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MaskPass = function ( scene, camera ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.clear = true;\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.inverse = false;\r\n\r\n};\r\n\r\nTHREE.MaskPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.MaskPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tvar context = renderer.context;\r\n\t\tvar state = renderer.state;\r\n\r\n\t\t// don't update color or depth\r\n\r\n\t\tstate.buffers.color.setMask( false );\r\n\t\tstate.buffers.depth.setMask( false );\r\n\r\n\t\t// lock buffers\r\n\r\n\t\tstate.buffers.color.setLocked( true );\r\n\t\tstate.buffers.depth.setLocked( true );\r\n\r\n\t\t// set up stencil\r\n\r\n\t\tvar writeValue, clearValue;\r\n\r\n\t\tif ( this.inverse ) {\r\n\r\n\t\t\twriteValue = 0;\r\n\t\t\tclearValue = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\twriteValue = 1;\r\n\t\t\tclearValue = 0;\r\n\r\n\t\t}\r\n\r\n\t\tstate.buffers.stencil.setTest( true );\r\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\r\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\r\n\t\tstate.buffers.stencil.setClear( clearValue );\r\n\r\n\t\t// draw into the stencil buffer\r\n\r\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\r\n\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t// unlock color and depth buffer for subsequent rendering\r\n\r\n\t\tstate.buffers.color.setLocked( false );\r\n\t\tstate.buffers.depth.setLocked( false );\r\n\r\n\t\t// only render where stencil is set to 1\r\n\r\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1\r\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\nTHREE.ClearMaskPass = function () {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n};\r\n\r\nTHREE.ClearMaskPass.prototype = Object.create( THREE.Pass.prototype );\r\n\r\nObject.assign( THREE.ClearMaskPass.prototype, {\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\trenderer.state.buffers.stencil.setTest( false );\r\n\r\n\t}\r\n\r\n} );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n/*global THREE, console */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\r\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\r\n// supported.\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\r\n//\r\n// This is a drop-in replacement for (most) TrackballControls used in examples.\r\n// That is, include this js file and wherever you see:\r\n//    \tcontrols = new THREE.TrackballControls( camera );\r\n//      controls.target.z = 150;\r\n// Simple substitute \"OrbitControls\" and the control should work as-is.\r\n\r\nTHREE.OrbitControls = function ( object, domElement ) {\r\n\r\n    this.object = object;\r\n    this.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n    // API\r\n\r\n    // Set to false to disable this control\r\n    this.enabled = true;\r\n\r\n    // \"target\" sets the location of focus, where the control orbits around\r\n    // and where it pans with respect to.\r\n    this.target = new THREE.Vector3();\r\n    // center is old, deprecated; use \"target\" instead\r\n    this.center = this.target;\r\n\r\n    // This option actually enables dollying in and out; left as \"zoom\" for\r\n    // backwards compatibility\r\n    this.noZoom = false;\r\n    this.zoomSpeed = 1.0;\r\n    // Limits to how far you can dolly in and out\r\n    this.minDistance = 0;\r\n    this.maxDistance = Infinity;\r\n\r\n    // Set to true to disable this control\r\n    this.noRotate = false;\r\n    this.rotateSpeed = 1.0;\r\n\r\n    // Set to true to disable this control\r\n    this.noPan = false;\r\n    this.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n    // Set to true to automatically rotate around the target\r\n    this.autoRotate = false;\r\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n    // How far you can orbit vertically, upper and lower limits.\r\n    // Range is 0 to Math.PI radians.\r\n    this.minPolarAngle = 0; // radians\r\n    this.maxPolarAngle = Math.PI; // radians\r\n\r\n    // Set to true to disable use of the keys\r\n    this.noKeys = false;\r\n    // The four arrow keys\r\n    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n    ////////////\r\n    // internals\r\n\r\n    var scope = this;\r\n\r\n    var EPS = 0.000001;\r\n\r\n    var rotateStart = new THREE.Vector2();\r\n    var rotateEnd = new THREE.Vector2();\r\n    var rotateDelta = new THREE.Vector2();\r\n\r\n    var panStart = new THREE.Vector2();\r\n    var panEnd = new THREE.Vector2();\r\n    var panDelta = new THREE.Vector2();\r\n\r\n    var dollyStart = new THREE.Vector2();\r\n    var dollyEnd = new THREE.Vector2();\r\n    var dollyDelta = new THREE.Vector2();\r\n\r\n    var phiDelta = 0;\r\n    var thetaDelta = 0;\r\n    var scale = 1;\r\n    var pan = new THREE.Vector3();\r\n\r\n    var lastPosition = new THREE.Vector3();\r\n\r\n    var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\r\n    var state = STATE.NONE;\r\n\r\n    // events\r\n\r\n    var changeEvent = { type: 'change' };\r\n\r\n\r\n    this.rotateLeft = function ( angle ) {\r\n\r\n        if ( angle === undefined ) {\r\n\r\n            angle = getAutoRotationAngle();\r\n\r\n        }\r\n\r\n        thetaDelta -= angle;\r\n\r\n    };\r\n\r\n    this.rotateUp = function ( angle ) {\r\n\r\n        if ( angle === undefined ) {\r\n\r\n            angle = getAutoRotationAngle();\r\n\r\n        }\r\n\r\n        phiDelta -= angle;\r\n\r\n    };\r\n\r\n    // pass in distance in world space to move left\r\n    this.panLeft = function ( distance ) {\r\n\r\n        var panOffset = new THREE.Vector3();\r\n        var te = this.object.matrix.elements;\r\n        // get X column of matrix\r\n        panOffset.set( te[0], te[1], te[2] );\r\n        panOffset.multiplyScalar(-distance);\r\n\r\n        pan.add( panOffset );\r\n\r\n    };\r\n\r\n    // pass in distance in world space to move up\r\n    this.panUp = function ( distance ) {\r\n\r\n        var panOffset = new THREE.Vector3();\r\n        var te = this.object.matrix.elements;\r\n        // get Y column of matrix\r\n        panOffset.set( te[4], te[5], te[6] );\r\n        panOffset.multiplyScalar(distance);\r\n\r\n        pan.add( panOffset );\r\n    };\r\n\r\n    // main entry point; pass in Vector2 of change desired in pixel space,\r\n    // right and down are positive\r\n    this.pan = function ( delta ) {\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        if ( scope.object.fov !== undefined ) {\r\n\r\n            // perspective\r\n            var position = scope.object.position;\r\n            var offset = position.clone().sub( scope.target );\r\n            var targetDistance = offset.length();\r\n\r\n            // half of the fov is center to top of screen\r\n            targetDistance *= Math.tan( (scope.object.fov/2) * Math.PI / 180.0 );\r\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n            scope.panLeft( 2 * delta.x * targetDistance / element.clientHeight );\r\n            scope.panUp( 2 * delta.y * targetDistance / element.clientHeight );\r\n\r\n        } else if ( scope.object.top !== undefined ) {\r\n\r\n            // orthographic\r\n            scope.panLeft( delta.x * (scope.object.right - scope.object.left) / element.clientWidth );\r\n            scope.panUp( delta.y * (scope.object.top - scope.object.bottom) / element.clientHeight );\r\n\r\n        } else {\r\n\r\n            // camera neither orthographic or perspective - warn user\r\n            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n\r\n        }\r\n\r\n    };\r\n\r\n    this.dollyIn = function ( dollyScale ) {\r\n\r\n        if ( dollyScale === undefined ) {\r\n\r\n            dollyScale = getZoomScale();\r\n\r\n        }\r\n\r\n        scale /= dollyScale;\r\n\r\n    };\r\n\r\n    this.dollyOut = function ( dollyScale ) {\r\n\r\n        if ( dollyScale === undefined ) {\r\n\r\n            dollyScale = getZoomScale();\r\n\r\n        }\r\n\r\n        scale *= dollyScale;\r\n\r\n    };\r\n\r\n    this.update = function () {\r\n\r\n        var position = this.object.position;\r\n        var offset = position.clone().sub( this.target );\r\n\r\n        // angle from z-axis around y-axis\r\n\r\n        var theta = Math.atan2( offset.x, offset.z );\r\n\r\n        // angle from y-axis\r\n\r\n        var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\r\n\r\n        if ( this.autoRotate ) {\r\n\r\n            this.rotateLeft( getAutoRotationAngle() );\r\n\r\n        }\r\n\r\n        theta += thetaDelta;\r\n        phi += phiDelta;\r\n\r\n        // restrict phi to be between desired limits\r\n        phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\r\n\r\n        // restrict phi to be betwee EPS and PI-EPS\r\n        phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\r\n\r\n        var radius = offset.length() * scale;\r\n\r\n        // restrict radius to be between desired limits\r\n        radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\r\n\r\n        // move target to panned location\r\n        this.target.add( pan );\r\n\r\n        offset.x = radius * Math.sin( phi ) * Math.sin( theta );\r\n        offset.y = radius * Math.cos( phi );\r\n        offset.z = radius * Math.sin( phi ) * Math.cos( theta );\r\n\r\n        position.copy( this.target ).add( offset );\r\n\r\n        this.object.lookAt( this.target );\r\n\r\n        thetaDelta = 0;\r\n        phiDelta = 0;\r\n        scale = 1;\r\n        pan.set(0,0,0);\r\n\r\n        if ( lastPosition.distanceTo( this.object.position ) > 0 ) {\r\n\r\n            this.dispatchEvent( changeEvent );\r\n\r\n            lastPosition.copy( this.object.position );\r\n\r\n        }\r\n\r\n    };\r\n\r\n\r\n    function getAutoRotationAngle() {\r\n\r\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n    }\r\n\r\n    function getZoomScale() {\r\n\r\n        return Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n    }\r\n\r\n    function onMouseDown( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n        event.preventDefault();\r\n\r\n        if ( event.button === 0 ) {\r\n            if ( scope.noRotate === true ) { return; }\r\n\r\n            state = STATE.ROTATE;\r\n\r\n            rotateStart.set( event.clientX, event.clientY );\r\n\r\n        } else if ( event.button === 1 ) {\r\n            if ( scope.noZoom === true ) { return; }\r\n\r\n            state = STATE.DOLLY;\r\n\r\n            dollyStart.set( event.clientX, event.clientY );\r\n\r\n        } else if ( event.button === 2 ) {\r\n            if ( scope.noPan === true ) { return; }\r\n\r\n            state = STATE.PAN;\r\n\r\n            panStart.set( event.clientX, event.clientY );\r\n\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.domElement.addEventListener( 'mousemove', onMouseMove, false );\r\n        scope.domElement.addEventListener( 'mouseup', onMouseUp, false );\r\n\r\n    }\r\n\r\n    function onMouseMove( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        if ( state === STATE.ROTATE ) {\r\n\r\n            if ( scope.noRotate === true ) return;\r\n\r\n            rotateEnd.set( event.clientX, event.clientY );\r\n            rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n            // rotating across whole screen goes 360 degrees around\r\n            scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n            scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n            rotateStart.copy( rotateEnd );\r\n\r\n        } else if ( state === STATE.DOLLY ) {\r\n\r\n            if ( scope.noZoom === true ) return;\r\n\r\n            dollyEnd.set( event.clientX, event.clientY );\r\n            dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n            if ( dollyDelta.y > 0 ) {\r\n\r\n                scope.dollyIn();\r\n\r\n            } else {\r\n\r\n                scope.dollyOut();\r\n\r\n            }\r\n\r\n            dollyStart.copy( dollyEnd );\r\n\r\n        } else if ( state === STATE.PAN ) {\r\n\r\n            if ( scope.noPan === true ) return;\r\n\r\n            panEnd.set( event.clientX, event.clientY );\r\n            panDelta.subVectors( panEnd, panStart );\r\n\r\n            scope.pan( panDelta );\r\n\r\n            panStart.copy( panEnd );\r\n\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function onMouseUp( /* event */ ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        scope.domElement.removeEventListener( 'mousemove', onMouseMove, false );\r\n        scope.domElement.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n        state = STATE.NONE;\r\n\r\n    }\r\n\r\n    function onMouseWheel( event ) {\r\n\r\n        if ( scope.enabled === false || scope.noZoom === true ) return;\r\n\r\n        var delta = 0;\r\n\r\n        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\r\n\r\n            delta = event.wheelDelta;\r\n\r\n        } else if ( event.detail ) { // Firefox\r\n\r\n            delta = - event.detail;\r\n\r\n        }\r\n\r\n        if ( delta > 0 ) {\r\n\r\n            scope.dollyOut();\r\n\r\n        } else {\r\n\r\n            scope.dollyIn();\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onKeyDown( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n        if ( scope.noKeys === true ) { return; }\r\n        if ( scope.noPan === true ) { return; }\r\n\r\n        // pan a pixel - I guess for precise positioning?\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        var needUpdate = false;\r\n\r\n        switch ( event.keyCode ) {\r\n\r\n            case scope.keys.UP:\r\n                scope.pan( new THREE.Vector2( 0, scope.keyPanSpeed ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.BOTTOM:\r\n                scope.pan( new THREE.Vector2( 0, -scope.keyPanSpeed ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.LEFT:\r\n                scope.pan( new THREE.Vector2( scope.keyPanSpeed, 0 ) );\r\n                needUpdate = true;\r\n                break;\r\n            case scope.keys.RIGHT:\r\n                scope.pan( new THREE.Vector2( -scope.keyPanSpeed, 0 ) );\r\n                needUpdate = true;\r\n                break;\r\n        }\r\n\r\n        // Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n        if ( needUpdate ) {\r\n\r\n            scope.update();\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function touchstart( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1:\t// one-fingered touch: rotate\r\n                if ( scope.noRotate === true ) { return; }\r\n\r\n                state = STATE.TOUCH_ROTATE;\r\n\r\n                rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                break;\r\n\r\n            case 2:\t// two-fingered touch: dolly\r\n                if ( scope.noZoom === true ) { return; }\r\n\r\n                state = STATE.TOUCH_DOLLY;\r\n\r\n                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n                var distance = Math.sqrt( dx * dx + dy * dy );\r\n                dollyStart.set( 0, distance );\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n                if ( scope.noPan === true ) { return; }\r\n\r\n                state = STATE.TOUCH_PAN;\r\n\r\n                panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                break;\r\n\r\n            default:\r\n                state = STATE.NONE;\r\n\r\n        }\r\n    }\r\n\r\n    function touchmove( event ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1: // one-fingered touch: rotate\r\n                if ( scope.noRotate === true ) { return; }\r\n                if ( state !== STATE.TOUCH_ROTATE ) { return; }\r\n\r\n                rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n                // rotating across whole screen goes 360 degrees around\r\n                scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n                scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n                rotateStart.copy( rotateEnd );\r\n                break;\r\n\r\n            case 2: // two-fingered touch: dolly\r\n                if ( scope.noZoom === true ) { return; }\r\n                if ( state !== STATE.TOUCH_DOLLY ) { return; }\r\n\r\n                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n                var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n                dollyEnd.set( 0, distance );\r\n                dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n                if ( dollyDelta.y > 0 ) {\r\n\r\n                    scope.dollyOut();\r\n\r\n                } else {\r\n\r\n                    scope.dollyIn();\r\n\r\n                }\r\n\r\n                dollyStart.copy( dollyEnd );\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n                if ( scope.noPan === true ) { return; }\r\n                if ( state !== STATE.TOUCH_PAN ) { return; }\r\n\r\n                panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n                panDelta.subVectors( panEnd, panStart );\r\n\r\n                scope.pan( panDelta );\r\n\r\n                panStart.copy( panEnd );\r\n                break;\r\n\r\n            default:\r\n                state = STATE.NONE;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function touchend( /* event */ ) {\r\n\r\n        if ( scope.enabled === false ) { return; }\r\n\r\n        state = STATE.NONE;\r\n    }\r\n\r\n    this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\r\n    this.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n    this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\r\n    this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\r\n\r\n    this.domElement.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n    this.domElement.addEventListener( 'touchstart', touchstart, false );\r\n    this.domElement.addEventListener( 'touchend', touchend, false );\r\n    this.domElement.addEventListener( 'touchmove', touchmove, false );\r\n\r\n};\r\n\r\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.overrideMaterial = overrideMaterial;\r\n\r\n\tthis.clearColor = clearColor;\r\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\r\n\r\n\tthis.clear = true;\r\n\tthis.needsSwap = false;\r\n\r\n};\r\n\r\nTHREE.RenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.RenderPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.scene.overrideMaterial = this.overrideMaterial;\r\n\r\n\t\tvar oldClearColor, oldClearAlpha;\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\toldClearColor = renderer.getClearColor().getHex();\r\n\t\t\toldClearAlpha = renderer.getClearAlpha();\r\n\r\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\r\n\r\n\t\t}\r\n\r\n\t\tthis.scene.overrideMaterial = null;\r\n\r\n\t}\r\n\r\n} );","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ShaderPass = function ( shader, textureID ) {\r\n\r\n\tTHREE.Pass.call( this );\r\n\r\n\tthis.textureID = ( textureID !== undefined ) ? textureID : \"tDiffuse\";\r\n\r\n\tif ( shader instanceof THREE.ShaderMaterial ) {\r\n\r\n\t\tthis.uniforms = shader.uniforms;\r\n\r\n\t\tthis.material = shader;\r\n\r\n\t} else if ( shader ) {\r\n\r\n\t\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\tthis.material = new THREE.ShaderMaterial( {\r\n\r\n\t\t\tdefines: shader.defines || {},\r\n\t\t\tuniforms: this.uniforms,\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene = new THREE.Scene();\r\n\r\n\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTHREE.ShaderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\r\n\r\n\tconstructor: THREE.ShaderPass,\r\n\r\n\trender: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( this.uniforms[ this.textureID ] ) {\r\n\r\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\r\n\r\n\t\t}\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );","'use strict';\r\n\r\nvar uniforms;\r\n\r\nvar THREE = require('three');\r\nvar TweemMax = require('../vendor/TweenMax.min.js');\r\n\r\nvar OrbitControls = require('../libs/OrbitControls.js');\r\n\r\nvar CopyShader = require('../shaders/CopyShader.js');\r\nvar FilmShader = require('../shaders/FilmShader.js');\r\nvar ConvolutionShader = require('../shaders/ConvolutionShader.js');\r\nvar BadTv = require('../shaders/BadTv.js');\r\n\r\nvar EffectComposer = require('../libs/EffectComposer.js');\r\nvar RenderPass = require('../libs/RenderPass.js');\r\nvar FilmPass = require('../libs/FilmPass.js');\r\nvar BloomPass = require('../libs/BloomPass.js');\r\nvar MaskPass = require('../libs/MaskPass.js');\r\nvar ShaderPass = require('../libs/ShaderPass.js');\r\n\r\nvar Stage = function() {\r\n  \r\n  this.renderer = new THREE.WebGLRenderer({alpha: true});\r\n  this.renderer.setPixelRatio(window.devicePixelRatio);\r\n  this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n\r\n  this.camera = new THREE.PerspectiveCamera(35, ((window.innerWidth / 2) / (window.innerHeight / 2)), 1, 3000);\r\n  this.camera.position.z = 4;\r\n\r\n  this.scene = new THREE.Scene();\r\n\r\n  this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);\r\n  this.controls.autoRotate = true;\r\n\r\n};\r\n\r\nStage.prototype.init = function() {\r\n\r\n  this.getAudio();\r\n  this.getParticles();\r\n\r\n  requestAnimationFrame(this.animate.bind(this));\r\n\r\n  // on resize\r\n  window.addEventListener('resize', this._onResize.bind(this));\r\n\r\n  TweenMax.to(document.querySelector('.bg'), 2000, {\r\n    rotation: -1080,\r\n    yoyo: true,\r\n    repeat: -1,\r\n    ease: Power1.easeOut\r\n  });\r\n\r\n  this.renderModel = new THREE.RenderPass( this.scene, this.camera );\r\n  this.effectBloom = new THREE.BloomPass( 1.25 );\r\n  this.effectFilm = new THREE.FilmPass( 0.35, 0.95, 2048, false );\r\n\r\n  this.effectFilm.renderToScreen = true;\r\n\r\n  this.composer = new THREE.EffectComposer( this.renderer );\r\n\r\n  this.composer.addPass(this.renderModel);\r\n  this.composer.addPass(this.effectBloom);\r\n  this.composer.addPass(this.effectFilm);\r\n\r\n  this.badTVEffect = new THREE.ShaderPass(THREE.BadTVShader);\r\n  this.badTVEffect.uniforms['speed'].value = 10;\r\n  this.badTVEffect.uniforms['rollSpeed'].value = 20;\r\n  this.composer.addPass(this.badTVEffect);\r\n\r\n  this.clock = new THREE.Clock();\r\n\r\n  uniforms = {\r\n\r\n    fogDensity: {value: 0.1},\r\n    fogColor:   {value: new THREE.Vector3(0, 0, 0)},\r\n    time:       {value: 1.0},\r\n    resolution: {value: new THREE.Vector2()},\r\n    uvScale:    {value: new THREE.Vector2( 3.0, 1.0)},\r\n    texture1:   {value: new THREE.TextureLoader().load(\"images/cloud.png\")},\r\n    texture2:   {value: new THREE.TextureLoader().load(\"images/lavatile.jpg\")}\r\n\r\n  };\r\n\r\n  uniforms.texture1.value.wrapS = uniforms.texture1.value.wrapT = THREE.RepeatWrapping;\r\n  uniforms.texture2.value.wrapS = uniforms.texture2.value.wrapT = THREE.RepeatWrapping;\r\n\r\n  var size = 0.65;\r\n\r\n  this.visualMaterial = new THREE.ShaderMaterial( {\r\n\r\n    uniforms: uniforms,\r\n    vertexShader: document.getElementById('vertexShader').textContent,\r\n    fragmentShader: document.getElementById('fragmentShader').textContent\r\n\r\n  } );\r\n\r\n  this.visualMesh = new THREE.Mesh( new THREE.TorusGeometry(size, 0.3, 30, 30), this.visualMaterial);\r\n  this.visualMesh.rotation.x = 0.3;\r\n  this.scene.add(this.visualMesh);\r\n\r\n  this.renderer = new THREE.WebGLRenderer({antialias: true});\r\n  this.renderer.setPixelRatio(window.devicePixelRatio);\r\n  document.body.appendChild(this.renderer.domElement);\r\n  this.renderer.autoClear = false;\r\n\r\n  this._onResize();\r\n};\r\n\r\nStage.prototype.animate = function() {\r\n  requestAnimationFrame(this.animate.bind(this));\r\n  var time = Date.now();\r\n\r\n  this.update(time);\r\n\r\n  this.renderer.render(this.scene, this.camera);\r\n\r\n};\r\n\r\nStage.prototype.update = function(time) {\r\n  var diff = time - this.lastTime;\r\n  this.lastTime = time;\r\n\r\n  if (!this.lastTime) {\r\n    this.lastTime = time;\r\n    \r\n    return;\r\n  }  \r\n\r\n  var delta = 5 * this.clock.getDelta();\r\n\r\n  this.visualMesh.rotation.y += 0.0125 * delta;\r\n  this.visualMesh.rotation.x += 0.05 * delta;\r\n\r\n  this.particleSystem.rotation.y += 0.01 * delta;\r\n  \r\n  this.renderer.clear();\r\n  this.composer.render(0.1);\r\n\r\n  this.controls.update()\r\n\r\n  this.updateVisual();\r\n\r\n};\r\n\r\nStage.prototype.updateVisual = function() {\r\n  var array = new Uint8Array(this.analyser.frequencyBinCount);\r\n  var frequencyArray = new Float32Array(this.analyser.frequencyBinCount);\r\n\r\n  var frequencyData = new Uint8Array(this.barsAnalyser.frequencyBinCount);\r\n  \r\n  this.analyser.getByteFrequencyData(array);\r\n  this.analyser.getFloatFrequencyData(frequencyArray);\r\n  \r\n  var average = this._getAverageVolume(array);\r\n  var frequencyAverage = this._getAverageVolume(frequencyArray);\r\n  var frequencyDataArray = this._getAverageVolume(frequencyData);\r\n\r\n  this.visualMaterial.uniforms['fogDensity'].value = frequencyAverage / 200;\r\n  this.visualMaterial.uniforms['time'].value = average / 50;\r\n\r\n  this.barsArray.forEach(function(bar, index) {\r\n    bar.style.height = Math.abs(frequencyArray[index]) + 'px';\r\n  });\r\n\r\n  this.particleSystem.scale.y = average / 5000;\r\n\r\n};\r\n\r\nStage.prototype.soundBars = function() {\r\n\r\n  this.soundBars = document.querySelector('#soundBars');\r\n\r\n  this.barsArray = [];\r\n\r\n  var barSpacingPercent = this.barsAnalyser.frequencyBinCount / 100;\r\n  \r\n  for (var i = 0; i < this.barsAnalyser.frequencyBinCount; i++) {\r\n\r\n    this.newBars = document.createElement('div');\r\n    this.soundBars.appendChild(this.newBars);\r\n    this.barsArray.push(this.newBars);\r\n\r\n  };\r\n\r\n};\r\n\r\nStage.prototype.getAudio = function() {\r\n  var context = new AudioContext();\r\n  this.analyser = context.createAnalyser();\r\n  this.analyser.smoothingTimeConstant = 0.4;\r\n  this.analyser.fftSize = 1024;\r\n\r\n  this.analyser2 = context.createAnalyser();\r\n  this.analyser2.smoothingTimeConstant = 0.4;\r\n  this.analyser2.fftSize = 1024;\r\n\r\n  this.barsAnalyser = context.createAnalyser();\r\n  this.barsAnalyser.fftSize = 64;\r\n\r\n  var sourceNode = context.createBufferSource();\r\n  var splitter = context.createChannelSplitter();\r\n\r\n  sourceNode.connect(splitter);\r\n\r\n  splitter.connect(this.analyser, 0);\r\n  splitter.connect(this.analyser2, 1);\r\n\r\n  sourceNode.connect(context.destination);\r\n\r\n  var request = new XMLHttpRequest();\r\n  request.open('GET', 'audio/sasha.mp3', true);\r\n  request.responseType = 'arraybuffer';\r\n\r\n  var songBuffer;\r\n  \r\n  request.onload = function() {\r\n    context.decodeAudioData(request.response, function(buffer) {\r\n      songBuffer = buffer;\r\n\r\n      var dur = buffer.duration;\r\n\r\n      sourceNode.buffer = buffer;\r\n      sourceNode.start(0);\r\n      sourceNode.loop = true;\r\n\r\n    }, this._onError);\r\n  }.bind(this);\r\n\r\n  request.send();\r\n\r\n  this.soundBars();\r\n};\r\n\r\nStage.prototype.getParticles = function() {\r\n\r\n  this.count = 600;\r\n  this.particles = new THREE.Geometry();\r\n  var pMaterial = new THREE.PointsMaterial({\r\n    color: 0xf1f1f1,\r\n    size: 1,\r\n    map: new THREE.TextureLoader().load('images/eye.png'),\r\n    transparent: true,\r\n    opacity: 0.85\r\n  });\r\n\r\n  window.material = pMaterial;\r\n\r\n  for (var p = 0; p < this.count; p++) {\r\n\r\n    var pX = Math.random() * 100 - 50;\r\n    var pY = Math.random() * 100 - 50;\r\n    var pZ = Math.random() * 100 - 50;\r\n    this.particle = new THREE.Vector3(pX, pY, pZ);\r\n    this.particle.velocity = new THREE.Vector3(0, -Math.random(), 0);  \r\n\r\n    this.particles.vertices.push(this.particle);\r\n\r\n  }\r\n\r\n  this.particleSystem = new THREE.Points(this.particles, pMaterial);\r\n  this.particleSystem.sortParticles = true;\r\n\r\n  this.scene.add(this.particleSystem);\r\n\r\n\r\n};\r\n\r\nStage.prototype._getAverageVolume = function(array) {\r\n  var values = 0;\r\n  var average;\r\n  var length = array.length;\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    values += array[i];\r\n  }\r\n\r\n  average = values / length;\r\n\r\n  return average;\r\n};\r\n\r\nStage.prototype._onResize = function() {\r\n  this.camera.aspect = window.innerWidth / window.innerHeight;\r\n  this.camera.updateProjectionMatrix();\r\n  \r\n  this.renderer.setSize( window.innerWidth, window.innerHeight );\r\n  \r\n  this.composer.setSize( window.innerWidth, window.innerHeight );\r\n  this.composer.reset();\r\n\r\n  uniforms.resolution.value.x = window.innerWidth;\r\n  uniforms.resolution.value.y = window.innerHeight;\r\n};\r\n\r\nStage.prototype._onError = function(e) {\r\n  console.log(e);\r\n};\r\n\r\nmodule.exports = Stage;","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author Felix Turner / www.airtight.cc / @felixturner\r\n *\r\n * Bad TV Shader\r\n * Simulates a bad TV via horizontal distortion and vertical roll\r\n * Uses Ashima WebGl Noise: https://github.com/ashima/webgl-noise\r\n *\r\n * time: steadily increasing float passed in\r\n * distortion: amount of thick distortion\r\n * distortion2: amount of fine grain distortion\r\n * speed: distortion vertical travel speed\r\n * rollSpeed: vertical roll speed\r\n *\r\n * The MIT License\r\n *\r\n * Copyright (c) 2014 Felix Turner\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n *\r\n */\r\n\r\nTHREE.BadTVShader = {\r\n  uniforms: {\r\n    \"tDiffuse\":    { type: \"t\", value: null },\r\n    \"time\":        { type: \"f\", value: 0.0 },\r\n    \"distortion\":  { type: \"f\", value: 0.5 },\r\n    \"distortion2\": { type: \"f\", value: 1.5 },\r\n    \"speed\":       { type: \"f\", value: 0.5 },\r\n    \"rollSpeed\":   { type: \"f\", value: 0.0 },\r\n  },\r\n\r\n  vertexShader: [\r\n    \"varying vec2 vUv;\",\r\n    \"void main() {\",\r\n    \"vUv = uv;\",\r\n    \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n    \"}\"\r\n\r\n  ].join(\"\\n\"),\r\n\r\n  fragmentShader: [\r\n\r\n    \"uniform sampler2D tDiffuse;\",\r\n    \"uniform float time;\",\r\n    \"uniform float distortion;\",\r\n    \"uniform float distortion2;\",\r\n    \"uniform float speed;\",\r\n    \"uniform float rollSpeed;\",\r\n    \"varying vec2 vUv;\",\r\n\r\n    // Start Ashima 2D Simplex Noise\r\n\r\n    \"vec3 mod289(vec3 x) {\",\r\n    \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\",\r\n    \"}\",\r\n\r\n    \"vec2 mod289(vec2 x) {\",\r\n    \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\",\r\n    \"}\",\r\n\r\n    \"vec3 permute(vec3 x) {\",\r\n    \"  return mod289(((x*34.0)+1.0)*x);\",\r\n    \"}\",\r\n\r\n    \"float snoise(vec2 v)\",\r\n    \"  {\",\r\n    \"  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\",\r\n    \"                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\",\r\n    \"                     -0.577350269189626,  // -1.0 + 2.0 * C.x\",\r\n    \"                      0.024390243902439); // 1.0 / 41.0\",\r\n    \"  vec2 i  = floor(v + dot(v, C.yy) );\",\r\n    \"  vec2 x0 = v -   i + dot(i, C.xx);\",\r\n\r\n    \"  vec2 i1;\",\r\n    \"  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\",\r\n    \"  vec4 x12 = x0.xyxy + C.xxzz;\",\r\n    \" x12.xy -= i1;\",\r\n\r\n    \"  i = mod289(i); // Avoid truncation effects in permutation\",\r\n    \"  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\",\r\n    \"   + i.x + vec3(0.0, i1.x, 1.0 ));\",\r\n\r\n    \"  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\",\r\n    \"  m = m*m ;\",\r\n    \"  m = m*m ;\",\r\n\r\n    \"  vec3 x = 2.0 * fract(p * C.www) - 1.0;\",\r\n    \"  vec3 h = abs(x) - 0.5;\",\r\n    \"  vec3 ox = floor(x + 0.5);\",\r\n    \"  vec3 a0 = x - ox;\",\r\n\r\n    \"  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\",\r\n\r\n    \"  vec3 g;\",\r\n    \"  g.x  = a0.x  * x0.x  + h.x  * x0.y;\",\r\n    \"  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\",\r\n    \"  return 130.0 * dot(m, g);\",\r\n    \"}\",\r\n\r\n    // End Ashima 2D Simplex Noise\r\n\r\n    \"void main() {\",\r\n\r\n      \"vec2 p = vUv;\",\r\n      \"float ty = time*speed;\",\r\n      \"float yt = p.y - ty;\",\r\n\r\n      //smooth distortion\r\n      \"float offset = snoise(vec2(yt*3.0,0.0))*0.2;\",\r\n      // boost distortion\r\n      \"offset = pow( offset*distortion,3.0)/distortion;\",\r\n      //add fine grain distortion\r\n      \"offset += snoise(vec2(yt*50.0,0.0))*distortion2*0.001;\",\r\n      //combine distortion on X with roll on Y\r\n      \"gl_FragColor = texture2D(tDiffuse,  vec2(fract(p.x + offset),fract(p.y-time*rollSpeed) ));\",\r\n\r\n    \"}\"\r\n\r\n  ].join(\"\\n\")\r\n\r\n};","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Convolution shader\r\n * ported from o3d sample to WebGL / GLSL\r\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\r\n */\r\n\r\nTHREE.ConvolutionShader = {\r\n\r\n\tdefines: {\r\n\r\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\r\n\t\t\"KERNEL_SIZE_INT\": \"25\",\r\n\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":        { value: null },\r\n\t\t\"uImageIncrement\": { value: new THREE.Vector2( 0.001953125, 0.0 ) },\r\n\t\t\"cKernel\":         { value: [] }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 imageCoord = vUv;\",\r\n\t\t\t\"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\r\n\r\n\t\t\t\"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\r\n\r\n\t\t\t\t\"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\r\n\t\t\t\t\"imageCoord += uImageIncrement;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\"}\"\r\n\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tbuildKernel: function ( sigma ) {\r\n\r\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\r\n\r\n\t\tfunction gauss( x, sigma ) {\r\n\r\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\r\n\r\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\r\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\r\n\r\n\t\tvalues = new Array( kernelSize );\r\n\t\tsum = 0.0;\r\n\t\tfor ( i = 0; i < kernelSize; ++ i ) {\r\n\r\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\r\n\t\t\tsum += values[ i ];\r\n\r\n\t\t}\r\n\r\n\t\t// normalize the kernel\r\n\r\n\t\tfor ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\r\n\r\n\t\treturn values;\r\n\r\n\t}\r\n\r\n};","'use strict';\r\n\r\nvar THREE = require('three');\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Full-screen textured quad shader\r\n */\r\n\r\nTHREE.CopyShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"opacity\":  { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float opacity;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\"gl_FragColor = opacity * texel;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};","'use strict';\n\nvar THREE = require('three');\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\n\nTHREE.FilmShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { value: null },\n\t\t\"time\":       { value: 0.0 },\n\t\t\"nIntensity\": { value: 0.5 },\n\t\t\"sIntensity\": { value: 0.05 },\n\t\t\"sCount\":     { value: 4096 },\n\t\t\"grayscale\":  { value: 1 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"#include <common>\",\n\t\t\n\t\t// control parameter\n\t\t\"uniform float time;\",\n\n\t\t\"uniform bool grayscale;\",\n\n\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float nIntensity;\",\n\n\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float sIntensity;\",\n\n\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\t\"uniform float sCount;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t// sample the source\n\t\t\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// make some noise\n\t\t\t\"float dx = rand( vUv + time );\",\n\n\t\t\t// add noise\n\t\t\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\",\n\n\t\t\t// get us a sine and cosine\n\t\t\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t\t\t// add scanlines\n\t\t\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t\t\t// interpolate between source and result by intensity\n\t\t\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t\t\t// convert to grayscale if desired\n\t\t\t\"if( grayscale ) {\",\n\n\t\t\t\t\"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor =  vec4( cResult, cTextureScreen.a );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n","(function (global){\n/*!\n * VERSION: 1.18.2\n * DATE: 2015-12-22\n * UPDATES AND DOCS AT: http://greensock.com\n * \n * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin\n *\n * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.\n * This work is subject to the terms at http://greensock.com/standard-license or for\n * Club GreenSock members, the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n **/\nvar _gsScope=\"undefined\"!=typeof module&&module.exports&&\"undefined\"!=typeof global?global:this||window;(_gsScope._gsQueue||(_gsScope._gsQueue=[])).push(function(){\"use strict\";_gsScope._gsDefine(\"TweenMax\",[\"core.Animation\",\"core.SimpleTimeline\",\"TweenLite\"],function(a,b,c){var d=function(a){var b,c=[],d=a.length;for(b=0;b!==d;c.push(a[b++]));return c},e=function(a,b,c){var d,e,f=a.cycle;for(d in f)e=f[d],a[d]=\"function\"==typeof e?e.call(b[c],c):e[c%e.length];delete a.cycle},f=function(a,b,d){c.call(this,a,b,d),this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._dirty=!0,this.render=f.prototype.render},g=1e-10,h=c._internals,i=h.isSelector,j=h.isArray,k=f.prototype=c.to({},.1,{}),l=[];f.version=\"1.18.2\",k.constructor=f,k.kill()._gc=!1,f.killTweensOf=f.killDelayedCallsTo=c.killTweensOf,f.getTweensOf=c.getTweensOf,f.lagSmoothing=c.lagSmoothing,f.ticker=c.ticker,f.render=c.render,k.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),c.prototype.invalidate.call(this)},k.updateTo=function(a,b){var d,e=this.ratio,f=this.vars.immediateRender||a.immediateRender;b&&this._startTime<this._timeline._time&&(this._startTime=this._timeline._time,this._uncache(!1),this._gc?this._enabled(!0,!1):this._timeline.insert(this,this._startTime-this._delay));for(d in a)this.vars[d]=a[d];if(this._initted||f)if(b)this._initted=!1,f&&this.render(0,!0,!0);else if(this._gc&&this._enabled(!0,!1),this._notifyPluginsOfEnabled&&this._firstPT&&c._onPluginEvent(\"_onDisable\",this),this._time/this._duration>.998){var g=this._totalTime;this.render(0,!0,!1),this._initted=!1,this.render(g,!0,!1)}else if(this._initted=!1,this._init(),this._time>0||f)for(var h,i=1/(1-e),j=this._firstPT;j;)h=j.s+j.c,j.c*=i,j.s=h-j.c,j=j._next;return this},k.render=function(a,b,c){this._initted||0===this._duration&&this.vars.repeat&&this.invalidate();var d,e,f,i,j,k,l,m,n=this._dirty?this.totalDuration():this._totalDuration,o=this._time,p=this._totalTime,q=this._cycle,r=this._duration,s=this._rawPrevTime;if(a>=n-1e-7?(this._totalTime=n,this._cycle=this._repeat,this._yoyo&&0!==(1&this._cycle)?(this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0):(this._time=r,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1),this._reversed||(d=!0,e=\"onComplete\",c=c||this._timeline.autoRemoveChildren),0===r&&(this._initted||!this.vars.lazy||c)&&(this._startTime===this._timeline._duration&&(a=0),(0>s||0>=a&&a>=-1e-7||s===g&&\"isPause\"!==this.data)&&s!==a&&(c=!0,s>g&&(e=\"onReverseComplete\")),this._rawPrevTime=m=!b||a||s===a?a:g)):1e-7>a?(this._totalTime=this._time=this._cycle=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==p||0===r&&s>0)&&(e=\"onReverseComplete\",d=this._reversed),0>a&&(this._active=!1,0===r&&(this._initted||!this.vars.lazy||c)&&(s>=0&&(c=!0),this._rawPrevTime=m=!b||a||s===a?a:g)),this._initted||(c=!0)):(this._totalTime=this._time=a,0!==this._repeat&&(i=r+this._repeatDelay,this._cycle=this._totalTime/i>>0,0!==this._cycle&&this._cycle===this._totalTime/i&&this._cycle--,this._time=this._totalTime-this._cycle*i,this._yoyo&&0!==(1&this._cycle)&&(this._time=r-this._time),this._time>r?this._time=r:this._time<0&&(this._time=0)),this._easeType?(j=this._time/r,k=this._easeType,l=this._easePower,(1===k||3===k&&j>=.5)&&(j=1-j),3===k&&(j*=2),1===l?j*=j:2===l?j*=j*j:3===l?j*=j*j*j:4===l&&(j*=j*j*j*j),1===k?this.ratio=1-j:2===k?this.ratio=j:this._time/r<.5?this.ratio=j/2:this.ratio=1-j/2):this.ratio=this._ease.getRatio(this._time/r)),o===this._time&&!c&&q===this._cycle)return void(p!==this._totalTime&&this._onUpdate&&(b||this._callback(\"onUpdate\")));if(!this._initted){if(this._init(),!this._initted||this._gc)return;if(!c&&this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration))return this._time=o,this._totalTime=p,this._rawPrevTime=s,this._cycle=q,h.lazyTweens.push(this),void(this._lazy=[a,b]);this._time&&!d?this.ratio=this._ease.getRatio(this._time/r):d&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._lazy!==!1&&(this._lazy=!1),this._active||!this._paused&&this._time!==o&&a>=0&&(this._active=!0),0===p&&(2===this._initted&&a>0&&this._init(),this._startAt&&(a>=0?this._startAt.render(a,b,c):e||(e=\"_dummyGS\")),this.vars.onStart&&(0!==this._totalTime||0===r)&&(b||this._callback(\"onStart\"))),f=this._firstPT;f;)f.f?f.t[f.p](f.c*this.ratio+f.s):f.t[f.p]=f.c*this.ratio+f.s,f=f._next;this._onUpdate&&(0>a&&this._startAt&&this._startTime&&this._startAt.render(a,b,c),b||(this._totalTime!==p||d)&&this._callback(\"onUpdate\")),this._cycle!==q&&(b||this._gc||this.vars.onRepeat&&this._callback(\"onRepeat\")),e&&(!this._gc||c)&&(0>a&&this._startAt&&!this._onUpdate&&this._startTime&&this._startAt.render(a,b,c),d&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[e]&&this._callback(e),0===r&&this._rawPrevTime===g&&m!==g&&(this._rawPrevTime=0))},f.to=function(a,b,c){return new f(a,b,c)},f.from=function(a,b,c){return c.runBackwards=!0,c.immediateRender=0!=c.immediateRender,new f(a,b,c)},f.fromTo=function(a,b,c,d){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,new f(a,b,d)},f.staggerTo=f.allTo=function(a,b,g,h,k,m,n){h=h||0;var o,p,q,r,s=0,t=[],u=function(){g.onComplete&&g.onComplete.apply(g.onCompleteScope||this,arguments),k.apply(n||g.callbackScope||this,m||l)},v=g.cycle,w=g.startAt&&g.startAt.cycle;for(j(a)||(\"string\"==typeof a&&(a=c.selector(a)||a),i(a)&&(a=d(a))),a=a||[],0>h&&(a=d(a),a.reverse(),h*=-1),o=a.length-1,q=0;o>=q;q++){p={};for(r in g)p[r]=g[r];if(v&&e(p,a,q),w){w=p.startAt={};for(r in g.startAt)w[r]=g.startAt[r];e(p.startAt,a,q)}p.delay=s+(p.delay||0),q===o&&k&&(p.onComplete=u),t[q]=new f(a[q],b,p),s+=h}return t},f.staggerFrom=f.allFrom=function(a,b,c,d,e,g,h){return c.runBackwards=!0,c.immediateRender=0!=c.immediateRender,f.staggerTo(a,b,c,d,e,g,h)},f.staggerFromTo=f.allFromTo=function(a,b,c,d,e,g,h,i){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,f.staggerTo(a,b,d,e,g,h,i)},f.delayedCall=function(a,b,c,d,e){return new f(b,0,{delay:a,onComplete:b,onCompleteParams:c,callbackScope:d,onReverseComplete:b,onReverseCompleteParams:c,immediateRender:!1,useFrames:e,overwrite:0})},f.set=function(a,b){return new f(a,0,b)},f.isTweening=function(a){return c.getTweensOf(a,!0).length>0};var m=function(a,b){for(var d=[],e=0,f=a._first;f;)f instanceof c?d[e++]=f:(b&&(d[e++]=f),d=d.concat(m(f,b)),e=d.length),f=f._next;return d},n=f.getAllTweens=function(b){return m(a._rootTimeline,b).concat(m(a._rootFramesTimeline,b))};f.killAll=function(a,c,d,e){null==c&&(c=!0),null==d&&(d=!0);var f,g,h,i=n(0!=e),j=i.length,k=c&&d&&e;for(h=0;j>h;h++)g=i[h],(k||g instanceof b||(f=g.target===g.vars.onComplete)&&d||c&&!f)&&(a?g.totalTime(g._reversed?0:g.totalDuration()):g._enabled(!1,!1))},f.killChildTweensOf=function(a,b){if(null!=a){var e,g,k,l,m,n=h.tweenLookup;if(\"string\"==typeof a&&(a=c.selector(a)||a),i(a)&&(a=d(a)),j(a))for(l=a.length;--l>-1;)f.killChildTweensOf(a[l],b);else{e=[];for(k in n)for(g=n[k].target.parentNode;g;)g===a&&(e=e.concat(n[k].tweens)),g=g.parentNode;for(m=e.length,l=0;m>l;l++)b&&e[l].totalTime(e[l].totalDuration()),e[l]._enabled(!1,!1)}}};var o=function(a,c,d,e){c=c!==!1,d=d!==!1,e=e!==!1;for(var f,g,h=n(e),i=c&&d&&e,j=h.length;--j>-1;)g=h[j],(i||g instanceof b||(f=g.target===g.vars.onComplete)&&d||c&&!f)&&g.paused(a)};return f.pauseAll=function(a,b,c){o(!0,a,b,c)},f.resumeAll=function(a,b,c){o(!1,a,b,c)},f.globalTimeScale=function(b){var d=a._rootTimeline,e=c.ticker.time;return arguments.length?(b=b||g,d._startTime=e-(e-d._startTime)*d._timeScale/b,d=a._rootFramesTimeline,e=c.ticker.frame,d._startTime=e-(e-d._startTime)*d._timeScale/b,d._timeScale=a._rootTimeline._timeScale=b,b):d._timeScale},k.progress=function(a){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-a:a)+this._cycle*(this._duration+this._repeatDelay),!1):this._time/this.duration()},k.totalProgress=function(a){return arguments.length?this.totalTime(this.totalDuration()*a,!1):this._totalTime/this.totalDuration()},k.time=function(a,b){return arguments.length?(this._dirty&&this.totalDuration(),a>this._duration&&(a=this._duration),this._yoyo&&0!==(1&this._cycle)?a=this._duration-a+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(a+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(a,b)):this._time},k.duration=function(b){return arguments.length?a.prototype.duration.call(this,b):this._duration},k.totalDuration=function(a){return arguments.length?-1===this._repeat?this:this.duration((a-this._repeat*this._repeatDelay)/(this._repeat+1)):(this._dirty&&(this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat,this._dirty=!1),this._totalDuration)},k.repeat=function(a){return arguments.length?(this._repeat=a,this._uncache(!0)):this._repeat},k.repeatDelay=function(a){return arguments.length?(this._repeatDelay=a,this._uncache(!0)):this._repeatDelay},k.yoyo=function(a){return arguments.length?(this._yoyo=a,this):this._yoyo},f},!0),_gsScope._gsDefine(\"TimelineLite\",[\"core.Animation\",\"core.SimpleTimeline\",\"TweenLite\"],function(a,b,c){var d=function(a){b.call(this,a),this._labels={},this.autoRemoveChildren=this.vars.autoRemoveChildren===!0,this.smoothChildTiming=this.vars.smoothChildTiming===!0,this._sortChildren=!0,this._onUpdate=this.vars.onUpdate;var c,d,e=this.vars;for(d in e)c=e[d],i(c)&&-1!==c.join(\"\").indexOf(\"{self}\")&&(e[d]=this._swapSelfInParams(c));i(e.tweens)&&this.add(e.tweens,0,e.align,e.stagger)},e=1e-10,f=c._internals,g=d._internals={},h=f.isSelector,i=f.isArray,j=f.lazyTweens,k=f.lazyRender,l=_gsScope._gsDefine.globals,m=function(a){var b,c={};for(b in a)c[b]=a[b];return c},n=function(a,b,c){var d,e,f=a.cycle;for(d in f)e=f[d],a[d]=\"function\"==typeof e?e.call(b[c],c):e[c%e.length];delete a.cycle},o=g.pauseCallback=function(){},p=function(a){var b,c=[],d=a.length;for(b=0;b!==d;c.push(a[b++]));return c},q=d.prototype=new b;return d.version=\"1.18.2\",q.constructor=d,q.kill()._gc=q._forcingPlayhead=q._hasPause=!1,q.to=function(a,b,d,e){var f=d.repeat&&l.TweenMax||c;return b?this.add(new f(a,b,d),e):this.set(a,d,e)},q.from=function(a,b,d,e){return this.add((d.repeat&&l.TweenMax||c).from(a,b,d),e)},q.fromTo=function(a,b,d,e,f){var g=e.repeat&&l.TweenMax||c;return b?this.add(g.fromTo(a,b,d,e),f):this.set(a,e,f)},q.staggerTo=function(a,b,e,f,g,i,j,k){var l,o,q=new d({onComplete:i,onCompleteParams:j,callbackScope:k,smoothChildTiming:this.smoothChildTiming}),r=e.cycle;for(\"string\"==typeof a&&(a=c.selector(a)||a),a=a||[],h(a)&&(a=p(a)),f=f||0,0>f&&(a=p(a),a.reverse(),f*=-1),o=0;o<a.length;o++)l=m(e),l.startAt&&(l.startAt=m(l.startAt),l.startAt.cycle&&n(l.startAt,a,o)),r&&n(l,a,o),q.to(a[o],b,l,o*f);return this.add(q,g)},q.staggerFrom=function(a,b,c,d,e,f,g,h){return c.immediateRender=0!=c.immediateRender,c.runBackwards=!0,this.staggerTo(a,b,c,d,e,f,g,h)},q.staggerFromTo=function(a,b,c,d,e,f,g,h,i){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,this.staggerTo(a,b,d,e,f,g,h,i)},q.call=function(a,b,d,e){return this.add(c.delayedCall(0,a,b,d),e)},q.set=function(a,b,d){return d=this._parseTimeOrLabel(d,0,!0),null==b.immediateRender&&(b.immediateRender=d===this._time&&!this._paused),this.add(new c(a,0,b),d)},d.exportRoot=function(a,b){a=a||{},null==a.smoothChildTiming&&(a.smoothChildTiming=!0);var e,f,g=new d(a),h=g._timeline;for(null==b&&(b=!0),h._remove(g,!0),g._startTime=0,g._rawPrevTime=g._time=g._totalTime=h._time,e=h._first;e;)f=e._next,b&&e instanceof c&&e.target===e.vars.onComplete||g.add(e,e._startTime-e._delay),e=f;return h.add(g,0),g},q.add=function(e,f,g,h){var j,k,l,m,n,o;if(\"number\"!=typeof f&&(f=this._parseTimeOrLabel(f,0,!0,e)),!(e instanceof a)){if(e instanceof Array||e&&e.push&&i(e)){for(g=g||\"normal\",h=h||0,j=f,k=e.length,l=0;k>l;l++)i(m=e[l])&&(m=new d({tweens:m})),this.add(m,j),\"string\"!=typeof m&&\"function\"!=typeof m&&(\"sequence\"===g?j=m._startTime+m.totalDuration()/m._timeScale:\"start\"===g&&(m._startTime-=m.delay())),j+=h;return this._uncache(!0)}if(\"string\"==typeof e)return this.addLabel(e,f);if(\"function\"!=typeof e)throw\"Cannot add \"+e+\" into the timeline; it is not a tween, timeline, function, or string.\";e=c.delayedCall(0,e)}if(b.prototype.add.call(this,e,f),(this._gc||this._time===this._duration)&&!this._paused&&this._duration<this.duration())for(n=this,o=n.rawTime()>e._startTime;n._timeline;)o&&n._timeline.smoothChildTiming?n.totalTime(n._totalTime,!0):n._gc&&n._enabled(!0,!1),n=n._timeline;return this},q.remove=function(b){if(b instanceof a){this._remove(b,!1);var c=b._timeline=b.vars.useFrames?a._rootFramesTimeline:a._rootTimeline;return b._startTime=(b._paused?b._pauseTime:c._time)-(b._reversed?b.totalDuration()-b._totalTime:b._totalTime)/b._timeScale,this}if(b instanceof Array||b&&b.push&&i(b)){for(var d=b.length;--d>-1;)this.remove(b[d]);return this}return\"string\"==typeof b?this.removeLabel(b):this.kill(null,b)},q._remove=function(a,c){b.prototype._remove.call(this,a,c);var d=this._last;return d?this._time>d._startTime+d._totalDuration/d._timeScale&&(this._time=this.duration(),this._totalTime=this._totalDuration):this._time=this._totalTime=this._duration=this._totalDuration=0,this},q.append=function(a,b){return this.add(a,this._parseTimeOrLabel(null,b,!0,a))},q.insert=q.insertMultiple=function(a,b,c,d){return this.add(a,b||0,c,d)},q.appendMultiple=function(a,b,c,d){return this.add(a,this._parseTimeOrLabel(null,b,!0,a),c,d)},q.addLabel=function(a,b){return this._labels[a]=this._parseTimeOrLabel(b),this},q.addPause=function(a,b,d,e){var f=c.delayedCall(0,o,d,e||this);return f.vars.onComplete=f.vars.onReverseComplete=b,f.data=\"isPause\",this._hasPause=!0,this.add(f,a)},q.removeLabel=function(a){return delete this._labels[a],this},q.getLabelTime=function(a){return null!=this._labels[a]?this._labels[a]:-1},q._parseTimeOrLabel=function(b,c,d,e){var f;if(e instanceof a&&e.timeline===this)this.remove(e);else if(e&&(e instanceof Array||e.push&&i(e)))for(f=e.length;--f>-1;)e[f]instanceof a&&e[f].timeline===this&&this.remove(e[f]);if(\"string\"==typeof c)return this._parseTimeOrLabel(c,d&&\"number\"==typeof b&&null==this._labels[c]?b-this.duration():0,d);if(c=c||0,\"string\"!=typeof b||!isNaN(b)&&null==this._labels[b])null==b&&(b=this.duration());else{if(f=b.indexOf(\"=\"),-1===f)return null==this._labels[b]?d?this._labels[b]=this.duration()+c:c:this._labels[b]+c;c=parseInt(b.charAt(f-1)+\"1\",10)*Number(b.substr(f+1)),b=f>1?this._parseTimeOrLabel(b.substr(0,f-1),0,d):this.duration()}return Number(b)+c},q.seek=function(a,b){return this.totalTime(\"number\"==typeof a?a:this._parseTimeOrLabel(a),b!==!1)},q.stop=function(){return this.paused(!0)},q.gotoAndPlay=function(a,b){return this.play(a,b)},q.gotoAndStop=function(a,b){return this.pause(a,b)},q.render=function(a,b,c){this._gc&&this._enabled(!0,!1);var d,f,g,h,i,l,m,n=this._dirty?this.totalDuration():this._totalDuration,o=this._time,p=this._startTime,q=this._timeScale,r=this._paused;if(a>=n-1e-7)this._totalTime=this._time=n,this._reversed||this._hasPausedChild()||(f=!0,h=\"onComplete\",i=!!this._timeline.autoRemoveChildren,0===this._duration&&(0>=a&&a>=-1e-7||this._rawPrevTime<0||this._rawPrevTime===e)&&this._rawPrevTime!==a&&this._first&&(i=!0,this._rawPrevTime>e&&(h=\"onReverseComplete\"))),this._rawPrevTime=this._duration||!b||a||this._rawPrevTime===a?a:e,a=n+1e-4;else if(1e-7>a)if(this._totalTime=this._time=0,(0!==o||0===this._duration&&this._rawPrevTime!==e&&(this._rawPrevTime>0||0>a&&this._rawPrevTime>=0))&&(h=\"onReverseComplete\",f=this._reversed),0>a)this._active=!1,this._timeline.autoRemoveChildren&&this._reversed?(i=f=!0,h=\"onReverseComplete\"):this._rawPrevTime>=0&&this._first&&(i=!0),this._rawPrevTime=a;else{if(this._rawPrevTime=this._duration||!b||a||this._rawPrevTime===a?a:e,0===a&&f)for(d=this._first;d&&0===d._startTime;)d._duration||(f=!1),d=d._next;a=0,this._initted||(i=!0)}else{if(this._hasPause&&!this._forcingPlayhead&&!b){if(a>=o)for(d=this._first;d&&d._startTime<=a&&!l;)d._duration||\"isPause\"!==d.data||d.ratio||0===d._startTime&&0===this._rawPrevTime||(l=d),d=d._next;else for(d=this._last;d&&d._startTime>=a&&!l;)d._duration||\"isPause\"===d.data&&d._rawPrevTime>0&&(l=d),d=d._prev;l&&(this._time=a=l._startTime,this._totalTime=a+this._cycle*(this._totalDuration+this._repeatDelay))}this._totalTime=this._time=this._rawPrevTime=a}if(this._time!==o&&this._first||c||i||l){if(this._initted||(this._initted=!0),this._active||!this._paused&&this._time!==o&&a>0&&(this._active=!0),0===o&&this.vars.onStart&&0!==this._time&&(b||this._callback(\"onStart\")),m=this._time,m>=o)for(d=this._first;d&&(g=d._next,m===this._time&&(!this._paused||r));)(d._active||d._startTime<=m&&!d._paused&&!d._gc)&&(l===d&&this.pause(),d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)),d=g;else for(d=this._last;d&&(g=d._prev,m===this._time&&(!this._paused||r));){if(d._active||d._startTime<=o&&!d._paused&&!d._gc){if(l===d){for(l=d._prev;l&&l.endTime()>this._time;)l.render(l._reversed?l.totalDuration()-(a-l._startTime)*l._timeScale:(a-l._startTime)*l._timeScale,b,c),l=l._prev;l=null,this.pause()}d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)}d=g}this._onUpdate&&(b||(j.length&&k(),this._callback(\"onUpdate\"))),h&&(this._gc||(p===this._startTime||q!==this._timeScale)&&(0===this._time||n>=this.totalDuration())&&(f&&(j.length&&k(),this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[h]&&this._callback(h)))}},q._hasPausedChild=function(){for(var a=this._first;a;){if(a._paused||a instanceof d&&a._hasPausedChild())return!0;a=a._next}return!1},q.getChildren=function(a,b,d,e){e=e||-9999999999;for(var f=[],g=this._first,h=0;g;)g._startTime<e||(g instanceof c?b!==!1&&(f[h++]=g):(d!==!1&&(f[h++]=g),a!==!1&&(f=f.concat(g.getChildren(!0,b,d)),h=f.length))),g=g._next;return f},q.getTweensOf=function(a,b){var d,e,f=this._gc,g=[],h=0;for(f&&this._enabled(!0,!0),d=c.getTweensOf(a),e=d.length;--e>-1;)(d[e].timeline===this||b&&this._contains(d[e]))&&(g[h++]=d[e]);return f&&this._enabled(!1,!0),g},q.recent=function(){return this._recent},q._contains=function(a){for(var b=a.timeline;b;){if(b===this)return!0;b=b.timeline}return!1},q.shiftChildren=function(a,b,c){c=c||0;for(var d,e=this._first,f=this._labels;e;)e._startTime>=c&&(e._startTime+=a),e=e._next;if(b)for(d in f)f[d]>=c&&(f[d]+=a);return this._uncache(!0)},q._kill=function(a,b){if(!a&&!b)return this._enabled(!1,!1);for(var c=b?this.getTweensOf(b):this.getChildren(!0,!0,!1),d=c.length,e=!1;--d>-1;)c[d]._kill(a,b)&&(e=!0);return e},q.clear=function(a){var b=this.getChildren(!1,!0,!0),c=b.length;for(this._time=this._totalTime=0;--c>-1;)b[c]._enabled(!1,!1);return a!==!1&&(this._labels={}),this._uncache(!0)},q.invalidate=function(){for(var b=this._first;b;)b.invalidate(),b=b._next;return a.prototype.invalidate.call(this)},q._enabled=function(a,c){if(a===this._gc)for(var d=this._first;d;)d._enabled(a,!0),d=d._next;return b.prototype._enabled.call(this,a,c)},q.totalTime=function(b,c,d){this._forcingPlayhead=!0;var e=a.prototype.totalTime.apply(this,arguments);return this._forcingPlayhead=!1,e},q.duration=function(a){return arguments.length?(0!==this.duration()&&0!==a&&this.timeScale(this._duration/a),this):(this._dirty&&this.totalDuration(),this._duration)},q.totalDuration=function(a){if(!arguments.length){if(this._dirty){for(var b,c,d=0,e=this._last,f=999999999999;e;)b=e._prev,e._dirty&&e.totalDuration(),e._startTime>f&&this._sortChildren&&!e._paused?this.add(e,e._startTime-e._delay):f=e._startTime,e._startTime<0&&!e._paused&&(d-=e._startTime,this._timeline.smoothChildTiming&&(this._startTime+=e._startTime/this._timeScale),this.shiftChildren(-e._startTime,!1,-9999999999),f=0),c=e._startTime+e._totalDuration/e._timeScale,c>d&&(d=c),e=b;this._duration=this._totalDuration=d,this._dirty=!1}return this._totalDuration}return a&&this.totalDuration()?this.timeScale(this._totalDuration/a):this},q.paused=function(b){if(!b)for(var c=this._first,d=this._time;c;)c._startTime===d&&\"isPause\"===c.data&&(c._rawPrevTime=0),c=c._next;return a.prototype.paused.apply(this,arguments)},q.usesFrames=function(){for(var b=this._timeline;b._timeline;)b=b._timeline;return b===a._rootFramesTimeline},q.rawTime=function(){return this._paused?this._totalTime:(this._timeline.rawTime()-this._startTime)*this._timeScale},d},!0),_gsScope._gsDefine(\"TimelineMax\",[\"TimelineLite\",\"TweenLite\",\"easing.Ease\"],function(a,b,c){var d=function(b){a.call(this,b),this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._dirty=!0},e=1e-10,f=b._internals,g=f.lazyTweens,h=f.lazyRender,i=new c(null,null,1,0),j=d.prototype=new a;return j.constructor=d,j.kill()._gc=!1,d.version=\"1.18.2\",j.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),a.prototype.invalidate.call(this)},j.addCallback=function(a,c,d,e){return this.add(b.delayedCall(0,a,d,e),c)},j.removeCallback=function(a,b){if(a)if(null==b)this._kill(null,a);else for(var c=this.getTweensOf(a,!1),d=c.length,e=this._parseTimeOrLabel(b);--d>-1;)c[d]._startTime===e&&c[d]._enabled(!1,!1);return this},j.removePause=function(b){return this.removeCallback(a._internals.pauseCallback,b)},j.tweenTo=function(a,c){c=c||{};var d,e,f,g={ease:i,useFrames:this.usesFrames(),immediateRender:!1};for(e in c)g[e]=c[e];return g.time=this._parseTimeOrLabel(a),d=Math.abs(Number(g.time)-this._time)/this._timeScale||.001,f=new b(this,d,g),g.onStart=function(){f.target.paused(!0),f.vars.time!==f.target.time()&&d===f.duration()&&f.duration(Math.abs(f.vars.time-f.target.time())/f.target._timeScale),c.onStart&&f._callback(\"onStart\")},f},j.tweenFromTo=function(a,b,c){c=c||{},a=this._parseTimeOrLabel(a),c.startAt={onComplete:this.seek,onCompleteParams:[a],callbackScope:this},c.immediateRender=c.immediateRender!==!1;var d=this.tweenTo(b,c);return d.duration(Math.abs(d.vars.time-a)/this._timeScale||.001)},j.render=function(a,b,c){this._gc&&this._enabled(!0,!1);var d,f,i,j,k,l,m,n,o=this._dirty?this.totalDuration():this._totalDuration,p=this._duration,q=this._time,r=this._totalTime,s=this._startTime,t=this._timeScale,u=this._rawPrevTime,v=this._paused,w=this._cycle;if(a>=o-1e-7)this._locked||(this._totalTime=o,this._cycle=this._repeat),this._reversed||this._hasPausedChild()||(f=!0,j=\"onComplete\",k=!!this._timeline.autoRemoveChildren,0===this._duration&&(0>=a&&a>=-1e-7||0>u||u===e)&&u!==a&&this._first&&(k=!0,u>e&&(j=\"onReverseComplete\"))),this._rawPrevTime=this._duration||!b||a||this._rawPrevTime===a?a:e,this._yoyo&&0!==(1&this._cycle)?this._time=a=0:(this._time=p,a=p+1e-4);else if(1e-7>a)if(this._locked||(this._totalTime=this._cycle=0),this._time=0,(0!==q||0===p&&u!==e&&(u>0||0>a&&u>=0)&&!this._locked)&&(j=\"onReverseComplete\",f=this._reversed),0>a)this._active=!1,this._timeline.autoRemoveChildren&&this._reversed?(k=f=!0,j=\"onReverseComplete\"):u>=0&&this._first&&(k=!0),this._rawPrevTime=a;else{if(this._rawPrevTime=p||!b||a||this._rawPrevTime===a?a:e,0===a&&f)for(d=this._first;d&&0===d._startTime;)d._duration||(f=!1),d=d._next;a=0,this._initted||(k=!0)}else if(0===p&&0>u&&(k=!0),this._time=this._rawPrevTime=a,this._locked||(this._totalTime=a,0!==this._repeat&&(l=p+this._repeatDelay,this._cycle=this._totalTime/l>>0,0!==this._cycle&&this._cycle===this._totalTime/l&&this._cycle--,this._time=this._totalTime-this._cycle*l,this._yoyo&&0!==(1&this._cycle)&&(this._time=p-this._time),this._time>p?(this._time=p,a=p+1e-4):this._time<0?this._time=a=0:a=this._time)),this._hasPause&&!this._forcingPlayhead&&!b){if(a=this._time,a>=q)for(d=this._first;d&&d._startTime<=a&&!m;)d._duration||\"isPause\"!==d.data||d.ratio||0===d._startTime&&0===this._rawPrevTime||(m=d),d=d._next;else for(d=this._last;d&&d._startTime>=a&&!m;)d._duration||\"isPause\"===d.data&&d._rawPrevTime>0&&(m=d),d=d._prev;m&&(this._time=a=m._startTime,this._totalTime=a+this._cycle*(this._totalDuration+this._repeatDelay))}if(this._cycle!==w&&!this._locked){var x=this._yoyo&&0!==(1&w),y=x===(this._yoyo&&0!==(1&this._cycle)),z=this._totalTime,A=this._cycle,B=this._rawPrevTime,C=this._time;if(this._totalTime=w*p,this._cycle<w?x=!x:this._totalTime+=p,this._time=q,this._rawPrevTime=0===p?u-1e-4:u,this._cycle=w,this._locked=!0,q=x?0:p,this.render(q,b,0===p),b||this._gc||this.vars.onRepeat&&this._callback(\"onRepeat\"),q!==this._time)return;if(y&&(q=x?p+1e-4:-1e-4,this.render(q,!0,!1)),this._locked=!1,this._paused&&!v)return;this._time=C,this._totalTime=z,this._cycle=A,this._rawPrevTime=B}if(!(this._time!==q&&this._first||c||k||m))return void(r!==this._totalTime&&this._onUpdate&&(b||this._callback(\"onUpdate\")));if(this._initted||(this._initted=!0),this._active||!this._paused&&this._totalTime!==r&&a>0&&(this._active=!0),0===r&&this.vars.onStart&&0!==this._totalTime&&(b||this._callback(\"onStart\")),n=this._time,n>=q)for(d=this._first;d&&(i=d._next,n===this._time&&(!this._paused||v));)(d._active||d._startTime<=this._time&&!d._paused&&!d._gc)&&(m===d&&this.pause(),d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)),d=i;else for(d=this._last;d&&(i=d._prev,n===this._time&&(!this._paused||v));){if(d._active||d._startTime<=q&&!d._paused&&!d._gc){if(m===d){for(m=d._prev;m&&m.endTime()>this._time;)m.render(m._reversed?m.totalDuration()-(a-m._startTime)*m._timeScale:(a-m._startTime)*m._timeScale,b,c),m=m._prev;m=null,this.pause()}d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)}d=i}this._onUpdate&&(b||(g.length&&h(),this._callback(\"onUpdate\"))),j&&(this._locked||this._gc||(s===this._startTime||t!==this._timeScale)&&(0===this._time||o>=this.totalDuration())&&(f&&(g.length&&h(),this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[j]&&this._callback(j)))},j.getActive=function(a,b,c){null==a&&(a=!0),null==b&&(b=!0),null==c&&(c=!1);var d,e,f=[],g=this.getChildren(a,b,c),h=0,i=g.length;for(d=0;i>d;d++)e=g[d],e.isActive()&&(f[h++]=e);return f},j.getLabelAfter=function(a){a||0!==a&&(a=this._time);var b,c=this.getLabelsArray(),d=c.length;for(b=0;d>b;b++)if(c[b].time>a)return c[b].name;return null},j.getLabelBefore=function(a){null==a&&(a=this._time);for(var b=this.getLabelsArray(),c=b.length;--c>-1;)if(b[c].time<a)return b[c].name;return null},j.getLabelsArray=function(){var a,b=[],c=0;for(a in this._labels)b[c++]={time:this._labels[a],name:a};return b.sort(function(a,b){return a.time-b.time}),b},j.progress=function(a,b){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-a:a)+this._cycle*(this._duration+this._repeatDelay),b):this._time/this.duration()},j.totalProgress=function(a,b){return arguments.length?this.totalTime(this.totalDuration()*a,b):this._totalTime/this.totalDuration()},j.totalDuration=function(b){return arguments.length?-1!==this._repeat&&b?this.timeScale(this.totalDuration()/b):this:(this._dirty&&(a.prototype.totalDuration.call(this),this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat),this._totalDuration)},j.time=function(a,b){return arguments.length?(this._dirty&&this.totalDuration(),a>this._duration&&(a=this._duration),this._yoyo&&0!==(1&this._cycle)?a=this._duration-a+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(a+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(a,b)):this._time},j.repeat=function(a){return arguments.length?(this._repeat=a,this._uncache(!0)):this._repeat},j.repeatDelay=function(a){return arguments.length?(this._repeatDelay=a,this._uncache(!0)):this._repeatDelay},j.yoyo=function(a){return arguments.length?(this._yoyo=a,this):this._yoyo},j.currentLabel=function(a){return arguments.length?this.seek(a,!0):this.getLabelBefore(this._time+1e-8)},d},!0),function(){var a=180/Math.PI,b=[],c=[],d=[],e={},f=_gsScope._gsDefine.globals,g=function(a,b,c,d){this.a=a,this.b=b,this.c=c,this.d=d,this.da=d-a,this.ca=c-a,this.ba=b-a},h=\",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,\",i=function(a,b,c,d){var e={a:a},f={},g={},h={c:d},i=(a+b)/2,j=(b+c)/2,k=(c+d)/2,l=(i+j)/2,m=(j+k)/2,n=(m-l)/8;return e.b=i+(a-i)/4,f.b=l+n,e.c=f.a=(e.b+f.b)/2,f.c=g.a=(l+m)/2,g.b=m-n,h.b=k+(d-k)/4,g.c=h.a=(g.b+h.b)/2,[e,f,g,h]},j=function(a,e,f,g,h){var j,k,l,m,n,o,p,q,r,s,t,u,v,w=a.length-1,x=0,y=a[0].a;for(j=0;w>j;j++)n=a[x],k=n.a,l=n.d,m=a[x+1].d,h?(t=b[j],u=c[j],v=(u+t)*e*.25/(g?.5:d[j]||.5),o=l-(l-k)*(g?.5*e:0!==t?v/t:0),p=l+(m-l)*(g?.5*e:0!==u?v/u:0),q=l-(o+((p-o)*(3*t/(t+u)+.5)/4||0))):(o=l-(l-k)*e*.5,p=l+(m-l)*e*.5,q=l-(o+p)/2),o+=q,p+=q,n.c=r=o,0!==j?n.b=y:n.b=y=n.a+.6*(n.c-n.a),n.da=l-k,n.ca=r-k,n.ba=y-k,f?(s=i(k,y,r,l),a.splice(x,1,s[0],s[1],s[2],s[3]),x+=4):x++,y=p;n=a[x],n.b=y,n.c=y+.4*(n.d-y),n.da=n.d-n.a,n.ca=n.c-n.a,n.ba=y-n.a,f&&(s=i(n.a,y,n.c,n.d),a.splice(x,1,s[0],s[1],s[2],s[3]))},k=function(a,d,e,f){var h,i,j,k,l,m,n=[];if(f)for(a=[f].concat(a),i=a.length;--i>-1;)\"string\"==typeof(m=a[i][d])&&\"=\"===m.charAt(1)&&(a[i][d]=f[d]+Number(m.charAt(0)+m.substr(2)));if(h=a.length-2,0>h)return n[0]=new g(a[0][d],0,0,a[-1>h?0:1][d]),n;for(i=0;h>i;i++)j=a[i][d],k=a[i+1][d],n[i]=new g(j,0,0,k),e&&(l=a[i+2][d],b[i]=(b[i]||0)+(k-j)*(k-j),c[i]=(c[i]||0)+(l-k)*(l-k));return n[i]=new g(a[i][d],0,0,a[i+1][d]),n},l=function(a,f,g,i,l,m){var n,o,p,q,r,s,t,u,v={},w=[],x=m||a[0];l=\"string\"==typeof l?\",\"+l+\",\":h,null==f&&(f=1);for(o in a[0])w.push(o);if(a.length>1){for(u=a[a.length-1],t=!0,n=w.length;--n>-1;)if(o=w[n],Math.abs(x[o]-u[o])>.05){t=!1;break}t&&(a=a.concat(),m&&a.unshift(m),a.push(a[1]),m=a[a.length-3])}for(b.length=c.length=d.length=0,n=w.length;--n>-1;)o=w[n],e[o]=-1!==l.indexOf(\",\"+o+\",\"),v[o]=k(a,o,e[o],m);for(n=b.length;--n>-1;)b[n]=Math.sqrt(b[n]),c[n]=Math.sqrt(c[n]);if(!i){for(n=w.length;--n>-1;)if(e[o])for(p=v[w[n]],s=p.length-1,q=0;s>q;q++)r=p[q+1].da/c[q]+p[q].da/b[q],d[q]=(d[q]||0)+r*r;for(n=d.length;--n>-1;)d[n]=Math.sqrt(d[n])}for(n=w.length,q=g?4:1;--n>-1;)o=w[n],p=v[o],j(p,f,g,i,e[o]),t&&(p.splice(0,q),p.splice(p.length-q,q));return v},m=function(a,b,c){b=b||\"soft\";var d,e,f,h,i,j,k,l,m,n,o,p={},q=\"cubic\"===b?3:2,r=\"soft\"===b,s=[];if(r&&c&&(a=[c].concat(a)),null==a||a.length<q+1)throw\"invalid Bezier data\";for(m in a[0])s.push(m);for(j=s.length;--j>-1;){for(m=s[j],p[m]=i=[],n=0,l=a.length,k=0;l>k;k++)d=null==c?a[k][m]:\"string\"==typeof(o=a[k][m])&&\"=\"===o.charAt(1)?c[m]+Number(o.charAt(0)+o.substr(2)):Number(o),r&&k>1&&l-1>k&&(i[n++]=(d+i[n-2])/2),i[n++]=d;for(l=n-q+1,n=0,k=0;l>k;k+=q)d=i[k],e=i[k+1],f=i[k+2],h=2===q?0:i[k+3],i[n++]=o=3===q?new g(d,e,f,h):new g(d,(2*e+d)/3,(2*e+f)/3,f);i.length=n}return p},n=function(a,b,c){for(var d,e,f,g,h,i,j,k,l,m,n,o=1/c,p=a.length;--p>-1;)for(m=a[p],f=m.a,g=m.d-f,h=m.c-f,i=m.b-f,d=e=0,k=1;c>=k;k++)j=o*k,l=1-j,d=e-(e=(j*j*g+3*l*(j*h+l*i))*j),n=p*c+k-1,b[n]=(b[n]||0)+d*d},o=function(a,b){b=b>>0||6;var c,d,e,f,g=[],h=[],i=0,j=0,k=b-1,l=[],m=[];for(c in a)n(a[c],g,b);for(e=g.length,d=0;e>d;d++)i+=Math.sqrt(g[d]),f=d%b,m[f]=i,f===k&&(j+=i,f=d/b>>0,l[f]=m,h[f]=j,i=0,m=[]);return{length:j,lengths:h,segments:l}},p=_gsScope._gsDefine.plugin({propName:\"bezier\",priority:-1,version:\"1.3.4\",API:2,global:!0,init:function(a,b,c){this._target=a,b instanceof Array&&(b={values:b}),this._func={},this._round={},this._props=[],this._timeRes=null==b.timeResolution?6:parseInt(b.timeResolution,10);\nvar d,e,f,g,h,i=b.values||[],j={},k=i[0],n=b.autoRotate||c.vars.orientToBezier;this._autoRotate=n?n instanceof Array?n:[[\"x\",\"y\",\"rotation\",n===!0?0:Number(n)||0]]:null;for(d in k)this._props.push(d);for(f=this._props.length;--f>-1;)d=this._props[f],this._overwriteProps.push(d),e=this._func[d]=\"function\"==typeof a[d],j[d]=e?a[d.indexOf(\"set\")||\"function\"!=typeof a[\"get\"+d.substr(3)]?d:\"get\"+d.substr(3)]():parseFloat(a[d]),h||j[d]!==i[0][d]&&(h=j);if(this._beziers=\"cubic\"!==b.type&&\"quadratic\"!==b.type&&\"soft\"!==b.type?l(i,isNaN(b.curviness)?1:b.curviness,!1,\"thruBasic\"===b.type,b.correlate,h):m(i,b.type,j),this._segCount=this._beziers[d].length,this._timeRes){var p=o(this._beziers,this._timeRes);this._length=p.length,this._lengths=p.lengths,this._segments=p.segments,this._l1=this._li=this._s1=this._si=0,this._l2=this._lengths[0],this._curSeg=this._segments[0],this._s2=this._curSeg[0],this._prec=1/this._curSeg.length}if(n=this._autoRotate)for(this._initialRotations=[],n[0]instanceof Array||(this._autoRotate=n=[n]),f=n.length;--f>-1;){for(g=0;3>g;g++)d=n[f][g],this._func[d]=\"function\"==typeof a[d]?a[d.indexOf(\"set\")||\"function\"!=typeof a[\"get\"+d.substr(3)]?d:\"get\"+d.substr(3)]:!1;d=n[f][2],this._initialRotations[f]=this._func[d]?this._func[d].call(this._target):this._target[d]}return this._startRatio=c.vars.runBackwards?1:0,!0},set:function(b){var c,d,e,f,g,h,i,j,k,l,m=this._segCount,n=this._func,o=this._target,p=b!==this._startRatio;if(this._timeRes){if(k=this._lengths,l=this._curSeg,b*=this._length,e=this._li,b>this._l2&&m-1>e){for(j=m-1;j>e&&(this._l2=k[++e])<=b;);this._l1=k[e-1],this._li=e,this._curSeg=l=this._segments[e],this._s2=l[this._s1=this._si=0]}else if(b<this._l1&&e>0){for(;e>0&&(this._l1=k[--e])>=b;);0===e&&b<this._l1?this._l1=0:e++,this._l2=k[e],this._li=e,this._curSeg=l=this._segments[e],this._s1=l[(this._si=l.length-1)-1]||0,this._s2=l[this._si]}if(c=e,b-=this._l1,e=this._si,b>this._s2&&e<l.length-1){for(j=l.length-1;j>e&&(this._s2=l[++e])<=b;);this._s1=l[e-1],this._si=e}else if(b<this._s1&&e>0){for(;e>0&&(this._s1=l[--e])>=b;);0===e&&b<this._s1?this._s1=0:e++,this._s2=l[e],this._si=e}h=(e+(b-this._s1)/(this._s2-this._s1))*this._prec}else c=0>b?0:b>=1?m-1:m*b>>0,h=(b-c*(1/m))*m;for(d=1-h,e=this._props.length;--e>-1;)f=this._props[e],g=this._beziers[f][c],i=(h*h*g.da+3*d*(h*g.ca+d*g.ba))*h+g.a,this._round[f]&&(i=Math.round(i)),n[f]?o[f](i):o[f]=i;if(this._autoRotate){var q,r,s,t,u,v,w,x=this._autoRotate;for(e=x.length;--e>-1;)f=x[e][2],v=x[e][3]||0,w=x[e][4]===!0?1:a,g=this._beziers[x[e][0]],q=this._beziers[x[e][1]],g&&q&&(g=g[c],q=q[c],r=g.a+(g.b-g.a)*h,t=g.b+(g.c-g.b)*h,r+=(t-r)*h,t+=(g.c+(g.d-g.c)*h-t)*h,s=q.a+(q.b-q.a)*h,u=q.b+(q.c-q.b)*h,s+=(u-s)*h,u+=(q.c+(q.d-q.c)*h-u)*h,i=p?Math.atan2(u-s,t-r)*w+v:this._initialRotations[e],n[f]?o[f](i):o[f]=i)}}}),q=p.prototype;p.bezierThrough=l,p.cubicToQuadratic=i,p._autoCSS=!0,p.quadraticToCubic=function(a,b,c){return new g(a,(2*b+a)/3,(2*b+c)/3,c)},p._cssRegister=function(){var a=f.CSSPlugin;if(a){var b=a._internals,c=b._parseToProxy,d=b._setPluginRatio,e=b.CSSPropTween;b._registerComplexSpecialProp(\"bezier\",{parser:function(a,b,f,g,h,i){b instanceof Array&&(b={values:b}),i=new p;var j,k,l,m=b.values,n=m.length-1,o=[],q={};if(0>n)return h;for(j=0;n>=j;j++)l=c(a,m[j],g,h,i,n!==j),o[j]=l.end;for(k in b)q[k]=b[k];return q.values=o,h=new e(a,\"bezier\",0,0,l.pt,2),h.data=l,h.plugin=i,h.setRatio=d,0===q.autoRotate&&(q.autoRotate=!0),!q.autoRotate||q.autoRotate instanceof Array||(j=q.autoRotate===!0?0:Number(q.autoRotate),q.autoRotate=null!=l.end.left?[[\"left\",\"top\",\"rotation\",j,!1]]:null!=l.end.x?[[\"x\",\"y\",\"rotation\",j,!1]]:!1),q.autoRotate&&(g._transform||g._enableTransforms(!1),l.autoRotate=g._target._gsTransform),i._onInitTween(l.proxy,q,g._tween),h}})}},q._roundProps=function(a,b){for(var c=this._overwriteProps,d=c.length;--d>-1;)(a[c[d]]||a.bezier||a.bezierThrough)&&(this._round[c[d]]=b)},q._kill=function(a){var b,c,d=this._props;for(b in this._beziers)if(b in a)for(delete this._beziers[b],delete this._func[b],c=d.length;--c>-1;)d[c]===b&&d.splice(c,1);return this._super._kill.call(this,a)}}(),_gsScope._gsDefine(\"plugins.CSSPlugin\",[\"plugins.TweenPlugin\",\"TweenLite\"],function(a,b){var c,d,e,f,g=function(){a.call(this,\"css\"),this._overwriteProps.length=0,this.setRatio=g.prototype.setRatio},h=_gsScope._gsDefine.globals,i={},j=g.prototype=new a(\"css\");j.constructor=g,g.version=\"1.18.2\",g.API=2,g.defaultTransformPerspective=0,g.defaultSkewType=\"compensated\",g.defaultSmoothOrigin=!0,j=\"px\",g.suffixMap={top:j,right:j,bottom:j,left:j,width:j,height:j,fontSize:j,padding:j,margin:j,perspective:j,lineHeight:\"\"};var k,l,m,n,o,p,q=/(?:\\d|\\-\\d|\\.\\d|\\-\\.\\d)+/g,r=/(?:\\d|\\-\\d|\\.\\d|\\-\\.\\d|\\+=\\d|\\-=\\d|\\+=.\\d|\\-=\\.\\d)+/g,s=/(?:\\+=|\\-=|\\-|\\b)[\\d\\-\\.]+[a-zA-Z0-9]*(?:%|\\b)/gi,t=/(?![+-]?\\d*\\.?\\d+|[+-]|e[+-]\\d+)[^0-9]/g,u=/(?:\\d|\\-|\\+|=|#|\\.)*/g,v=/opacity *= *([^)]*)/i,w=/opacity:([^;]*)/i,x=/alpha\\(opacity *=.+?\\)/i,y=/^(rgb|hsl)/,z=/([A-Z])/g,A=/-([a-z])/gi,B=/(^(?:url\\(\\\"|url\\())|(?:(\\\"\\))$|\\)$)/gi,C=function(a,b){return b.toUpperCase()},D=/(?:Left|Right|Width)/i,E=/(M11|M12|M21|M22)=[\\d\\-\\.e]+/gi,F=/progid\\:DXImageTransform\\.Microsoft\\.Matrix\\(.+?\\)/i,G=/,(?=[^\\)]*(?:\\(|$))/gi,H=Math.PI/180,I=180/Math.PI,J={},K=document,L=function(a){return K.createElementNS?K.createElementNS(\"http://www.w3.org/1999/xhtml\",a):K.createElement(a)},M=L(\"div\"),N=L(\"img\"),O=g._internals={_specialProps:i},P=navigator.userAgent,Q=function(){var a=P.indexOf(\"Android\"),b=L(\"a\");return m=-1!==P.indexOf(\"Safari\")&&-1===P.indexOf(\"Chrome\")&&(-1===a||Number(P.substr(a+8,1))>3),o=m&&Number(P.substr(P.indexOf(\"Version/\")+8,1))<6,n=-1!==P.indexOf(\"Firefox\"),(/MSIE ([0-9]{1,}[\\.0-9]{0,})/.exec(P)||/Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(P))&&(p=parseFloat(RegExp.$1)),b?(b.style.cssText=\"top:1px;opacity:.55;\",/^0.55/.test(b.style.opacity)):!1}(),R=function(a){return v.test(\"string\"==typeof a?a:(a.currentStyle?a.currentStyle.filter:a.style.filter)||\"\")?parseFloat(RegExp.$1)/100:1},S=function(a){window.console&&console.log(a)},T=\"\",U=\"\",V=function(a,b){b=b||M;var c,d,e=b.style;if(void 0!==e[a])return a;for(a=a.charAt(0).toUpperCase()+a.substr(1),c=[\"O\",\"Moz\",\"ms\",\"Ms\",\"Webkit\"],d=5;--d>-1&&void 0===e[c[d]+a];);return d>=0?(U=3===d?\"ms\":c[d],T=\"-\"+U.toLowerCase()+\"-\",U+a):null},W=K.defaultView?K.defaultView.getComputedStyle:function(){},X=g.getStyle=function(a,b,c,d,e){var f;return Q||\"opacity\"!==b?(!d&&a.style[b]?f=a.style[b]:(c=c||W(a))?f=c[b]||c.getPropertyValue(b)||c.getPropertyValue(b.replace(z,\"-$1\").toLowerCase()):a.currentStyle&&(f=a.currentStyle[b]),null==e||f&&\"none\"!==f&&\"auto\"!==f&&\"auto auto\"!==f?f:e):R(a)},Y=O.convertToPixels=function(a,c,d,e,f){if(\"px\"===e||!e)return d;if(\"auto\"===e||!d)return 0;var h,i,j,k=D.test(c),l=a,m=M.style,n=0>d;if(n&&(d=-d),\"%\"===e&&-1!==c.indexOf(\"border\"))h=d/100*(k?a.clientWidth:a.clientHeight);else{if(m.cssText=\"border:0 solid red;position:\"+X(a,\"position\")+\";line-height:0;\",\"%\"!==e&&l.appendChild&&\"v\"!==e.charAt(0)&&\"rem\"!==e)m[k?\"borderLeftWidth\":\"borderTopWidth\"]=d+e;else{if(l=a.parentNode||K.body,i=l._gsCache,j=b.ticker.frame,i&&k&&i.time===j)return i.width*d/100;m[k?\"width\":\"height\"]=d+e}l.appendChild(M),h=parseFloat(M[k?\"offsetWidth\":\"offsetHeight\"]),l.removeChild(M),k&&\"%\"===e&&g.cacheWidths!==!1&&(i=l._gsCache=l._gsCache||{},i.time=j,i.width=h/d*100),0!==h||f||(h=Y(a,c,d,e,!0))}return n?-h:h},Z=O.calculateOffset=function(a,b,c){if(\"absolute\"!==X(a,\"position\",c))return 0;var d=\"left\"===b?\"Left\":\"Top\",e=X(a,\"margin\"+d,c);return a[\"offset\"+d]-(Y(a,b,parseFloat(e),e.replace(u,\"\"))||0)},$=function(a,b){var c,d,e,f={};if(b=b||W(a,null))if(c=b.length)for(;--c>-1;)e=b[c],(-1===e.indexOf(\"-transform\")||za===e)&&(f[e.replace(A,C)]=b.getPropertyValue(e));else for(c in b)(-1===c.indexOf(\"Transform\")||ya===c)&&(f[c]=b[c]);else if(b=a.currentStyle||a.style)for(c in b)\"string\"==typeof c&&void 0===f[c]&&(f[c.replace(A,C)]=b[c]);return Q||(f.opacity=R(a)),d=La(a,b,!1),f.rotation=d.rotation,f.skewX=d.skewX,f.scaleX=d.scaleX,f.scaleY=d.scaleY,f.x=d.x,f.y=d.y,Ba&&(f.z=d.z,f.rotationX=d.rotationX,f.rotationY=d.rotationY,f.scaleZ=d.scaleZ),f.filters&&delete f.filters,f},_=function(a,b,c,d,e){var f,g,h,i={},j=a.style;for(g in c)\"cssText\"!==g&&\"length\"!==g&&isNaN(g)&&(b[g]!==(f=c[g])||e&&e[g])&&-1===g.indexOf(\"Origin\")&&(\"number\"==typeof f||\"string\"==typeof f)&&(i[g]=\"auto\"!==f||\"left\"!==g&&\"top\"!==g?\"\"!==f&&\"auto\"!==f&&\"none\"!==f||\"string\"!=typeof b[g]||\"\"===b[g].replace(t,\"\")?f:0:Z(a,g),void 0!==j[g]&&(h=new oa(j,g,j[g],h)));if(d)for(g in d)\"className\"!==g&&(i[g]=d[g]);return{difs:i,firstMPT:h}},aa={width:[\"Left\",\"Right\"],height:[\"Top\",\"Bottom\"]},ba=[\"marginLeft\",\"marginRight\",\"marginTop\",\"marginBottom\"],ca=function(a,b,c){var d=parseFloat(\"width\"===b?a.offsetWidth:a.offsetHeight),e=aa[b],f=e.length;for(c=c||W(a,null);--f>-1;)d-=parseFloat(X(a,\"padding\"+e[f],c,!0))||0,d-=parseFloat(X(a,\"border\"+e[f]+\"Width\",c,!0))||0;return d},da=function(a,b){if(\"contain\"===a||\"auto\"===a||\"auto auto\"===a)return a+\" \";(null==a||\"\"===a)&&(a=\"0 0\");var c=a.split(\" \"),d=-1!==a.indexOf(\"left\")?\"0%\":-1!==a.indexOf(\"right\")?\"100%\":c[0],e=-1!==a.indexOf(\"top\")?\"0%\":-1!==a.indexOf(\"bottom\")?\"100%\":c[1];return null==e?e=\"center\"===d?\"50%\":\"0\":\"center\"===e&&(e=\"50%\"),(\"center\"===d||isNaN(parseFloat(d))&&-1===(d+\"\").indexOf(\"=\"))&&(d=\"50%\"),a=d+\" \"+e+(c.length>2?\" \"+c[2]:\"\"),b&&(b.oxp=-1!==d.indexOf(\"%\"),b.oyp=-1!==e.indexOf(\"%\"),b.oxr=\"=\"===d.charAt(1),b.oyr=\"=\"===e.charAt(1),b.ox=parseFloat(d.replace(t,\"\")),b.oy=parseFloat(e.replace(t,\"\")),b.v=a),b||a},ea=function(a,b){return\"string\"==typeof a&&\"=\"===a.charAt(1)?parseInt(a.charAt(0)+\"1\",10)*parseFloat(a.substr(2)):parseFloat(a)-parseFloat(b)},fa=function(a,b){return null==a?b:\"string\"==typeof a&&\"=\"===a.charAt(1)?parseInt(a.charAt(0)+\"1\",10)*parseFloat(a.substr(2))+b:parseFloat(a)},ga=function(a,b,c,d){var e,f,g,h,i,j=1e-6;return null==a?h=b:\"number\"==typeof a?h=a:(e=360,f=a.split(\"_\"),i=\"=\"===a.charAt(1),g=(i?parseInt(a.charAt(0)+\"1\",10)*parseFloat(f[0].substr(2)):parseFloat(f[0]))*(-1===a.indexOf(\"rad\")?1:I)-(i?0:b),f.length&&(d&&(d[c]=b+g),-1!==a.indexOf(\"short\")&&(g%=e,g!==g%(e/2)&&(g=0>g?g+e:g-e)),-1!==a.indexOf(\"_cw\")&&0>g?g=(g+9999999999*e)%e-(g/e|0)*e:-1!==a.indexOf(\"ccw\")&&g>0&&(g=(g-9999999999*e)%e-(g/e|0)*e)),h=b+g),j>h&&h>-j&&(h=0),h},ha={aqua:[0,255,255],lime:[0,255,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,255],navy:[0,0,128],white:[255,255,255],fuchsia:[255,0,255],olive:[128,128,0],yellow:[255,255,0],orange:[255,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[255,0,0],pink:[255,192,203],cyan:[0,255,255],transparent:[255,255,255,0]},ia=function(a,b,c){return a=0>a?a+1:a>1?a-1:a,255*(1>6*a?b+(c-b)*a*6:.5>a?c:2>3*a?b+(c-b)*(2/3-a)*6:b)+.5|0},ja=g.parseColor=function(a,b){var c,d,e,f,g,h,i,j,k,l,m;if(a)if(\"number\"==typeof a)c=[a>>16,a>>8&255,255&a];else{if(\",\"===a.charAt(a.length-1)&&(a=a.substr(0,a.length-1)),ha[a])c=ha[a];else if(\"#\"===a.charAt(0))4===a.length&&(d=a.charAt(1),e=a.charAt(2),f=a.charAt(3),a=\"#\"+d+d+e+e+f+f),a=parseInt(a.substr(1),16),c=[a>>16,a>>8&255,255&a];else if(\"hsl\"===a.substr(0,3))if(c=m=a.match(q),b){if(-1!==a.indexOf(\"=\"))return a.match(r)}else g=Number(c[0])%360/360,h=Number(c[1])/100,i=Number(c[2])/100,e=.5>=i?i*(h+1):i+h-i*h,d=2*i-e,c.length>3&&(c[3]=Number(a[3])),c[0]=ia(g+1/3,d,e),c[1]=ia(g,d,e),c[2]=ia(g-1/3,d,e);else c=a.match(q)||ha.transparent;c[0]=Number(c[0]),c[1]=Number(c[1]),c[2]=Number(c[2]),c.length>3&&(c[3]=Number(c[3]))}else c=ha.black;return b&&!m&&(d=c[0]/255,e=c[1]/255,f=c[2]/255,j=Math.max(d,e,f),k=Math.min(d,e,f),i=(j+k)/2,j===k?g=h=0:(l=j-k,h=i>.5?l/(2-j-k):l/(j+k),g=j===d?(e-f)/l+(f>e?6:0):j===e?(f-d)/l+2:(d-e)/l+4,g*=60),c[0]=g+.5|0,c[1]=100*h+.5|0,c[2]=100*i+.5|0),c},ka=function(a,b){var c,d,e,f=a.match(la)||[],g=0,h=f.length?\"\":a;for(c=0;c<f.length;c++)d=f[c],e=a.substr(g,a.indexOf(d,g)-g),g+=e.length+d.length,d=ja(d,b),3===d.length&&d.push(1),h+=e+(b?\"hsla(\"+d[0]+\",\"+d[1]+\"%,\"+d[2]+\"%,\"+d[3]:\"rgba(\"+d.join(\",\"))+\")\";return h},la=\"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3}){1,2}\\\\b\";for(j in ha)la+=\"|\"+j+\"\\\\b\";la=new RegExp(la+\")\",\"gi\"),g.colorStringFilter=function(a){var b,c=a[0]+a[1];la.lastIndex=0,la.test(c)&&(b=-1!==c.indexOf(\"hsl(\")||-1!==c.indexOf(\"hsla(\"),a[0]=ka(a[0],b),a[1]=ka(a[1],b))},b.defaultStringFilter||(b.defaultStringFilter=g.colorStringFilter);var ma=function(a,b,c,d){if(null==a)return function(a){return a};var e,f=b?(a.match(la)||[\"\"])[0]:\"\",g=a.split(f).join(\"\").match(s)||[],h=a.substr(0,a.indexOf(g[0])),i=\")\"===a.charAt(a.length-1)?\")\":\"\",j=-1!==a.indexOf(\" \")?\" \":\",\",k=g.length,l=k>0?g[0].replace(q,\"\"):\"\";return k?e=b?function(a){var b,m,n,o;if(\"number\"==typeof a)a+=l;else if(d&&G.test(a)){for(o=a.replace(G,\"|\").split(\"|\"),n=0;n<o.length;n++)o[n]=e(o[n]);return o.join(\",\")}if(b=(a.match(la)||[f])[0],m=a.split(b).join(\"\").match(s)||[],n=m.length,k>n--)for(;++n<k;)m[n]=c?m[(n-1)/2|0]:g[n];return h+m.join(j)+j+b+i+(-1!==a.indexOf(\"inset\")?\" inset\":\"\")}:function(a){var b,f,m;if(\"number\"==typeof a)a+=l;else if(d&&G.test(a)){for(f=a.replace(G,\"|\").split(\"|\"),m=0;m<f.length;m++)f[m]=e(f[m]);return f.join(\",\")}if(b=a.match(s)||[],m=b.length,k>m--)for(;++m<k;)b[m]=c?b[(m-1)/2|0]:g[m];return h+b.join(j)+i}:function(a){return a}},na=function(a){return a=a.split(\",\"),function(b,c,d,e,f,g,h){var i,j=(c+\"\").split(\" \");for(h={},i=0;4>i;i++)h[a[i]]=j[i]=j[i]||j[(i-1)/2>>0];return e.parse(b,h,f,g)}},oa=(O._setPluginRatio=function(a){this.plugin.setRatio(a);for(var b,c,d,e,f,g=this.data,h=g.proxy,i=g.firstMPT,j=1e-6;i;)b=h[i.v],i.r?b=Math.round(b):j>b&&b>-j&&(b=0),i.t[i.p]=b,i=i._next;if(g.autoRotate&&(g.autoRotate.rotation=h.rotation),1===a||0===a)for(i=g.firstMPT,f=1===a?\"e\":\"b\";i;){if(c=i.t,c.type){if(1===c.type){for(e=c.xs0+c.s+c.xs1,d=1;d<c.l;d++)e+=c[\"xn\"+d]+c[\"xs\"+(d+1)];c[f]=e}}else c[f]=c.s+c.xs0;i=i._next}},function(a,b,c,d,e){this.t=a,this.p=b,this.v=c,this.r=e,d&&(d._prev=this,this._next=d)}),pa=(O._parseToProxy=function(a,b,c,d,e,f){var g,h,i,j,k,l=d,m={},n={},o=c._transform,p=J;for(c._transform=null,J=b,d=k=c.parse(a,b,d,e),J=p,f&&(c._transform=o,l&&(l._prev=null,l._prev&&(l._prev._next=null)));d&&d!==l;){if(d.type<=1&&(h=d.p,n[h]=d.s+d.c,m[h]=d.s,f||(j=new oa(d,\"s\",h,j,d.r),d.c=0),1===d.type))for(g=d.l;--g>0;)i=\"xn\"+g,h=d.p+\"_\"+i,n[h]=d.data[i],m[h]=d[i],f||(j=new oa(d,i,h,j,d.rxp[i]));d=d._next}return{proxy:m,end:n,firstMPT:j,pt:k}},O.CSSPropTween=function(a,b,d,e,g,h,i,j,k,l,m){this.t=a,this.p=b,this.s=d,this.c=e,this.n=i||b,a instanceof pa||f.push(this.n),this.r=j,this.type=h||0,k&&(this.pr=k,c=!0),this.b=void 0===l?d:l,this.e=void 0===m?d+e:m,g&&(this._next=g,g._prev=this)}),qa=function(a,b,c,d,e,f){var g=new pa(a,b,c,d-c,e,-1,f);return g.b=c,g.e=g.xs0=d,g},ra=g.parseComplex=function(a,b,c,d,e,f,g,h,i,j){c=c||f||\"\",g=new pa(a,b,0,0,g,j?2:1,null,!1,h,c,d),d+=\"\";var l,m,n,o,p,s,t,u,v,w,x,y,z,A=c.split(\", \").join(\",\").split(\" \"),B=d.split(\", \").join(\",\").split(\" \"),C=A.length,D=k!==!1;for((-1!==d.indexOf(\",\")||-1!==c.indexOf(\",\"))&&(A=A.join(\" \").replace(G,\", \").split(\" \"),B=B.join(\" \").replace(G,\", \").split(\" \"),C=A.length),C!==B.length&&(A=(f||\"\").split(\" \"),C=A.length),g.plugin=i,g.setRatio=j,la.lastIndex=0,l=0;C>l;l++)if(o=A[l],p=B[l],u=parseFloat(o),u||0===u)g.appendXtra(\"\",u,ea(p,u),p.replace(r,\"\"),D&&-1!==p.indexOf(\"px\"),!0);else if(e&&la.test(o))y=\",\"===p.charAt(p.length-1)?\"),\":\")\",z=-1!==p.indexOf(\"hsl\")&&Q,o=ja(o,z),p=ja(p,z),v=o.length+p.length>6,v&&!Q&&0===p[3]?(g[\"xs\"+g.l]+=g.l?\" transparent\":\"transparent\",g.e=g.e.split(B[l]).join(\"transparent\")):(Q||(v=!1),z?g.appendXtra(v?\"hsla(\":\"hsl(\",o[0],ea(p[0],o[0]),\",\",!1,!0).appendXtra(\"\",o[1],ea(p[1],o[1]),\"%,\",!1).appendXtra(\"\",o[2],ea(p[2],o[2]),v?\"%,\":\"%\"+y,!1):g.appendXtra(v?\"rgba(\":\"rgb(\",o[0],p[0]-o[0],\",\",!0,!0).appendXtra(\"\",o[1],p[1]-o[1],\",\",!0).appendXtra(\"\",o[2],p[2]-o[2],v?\",\":y,!0),v&&(o=o.length<4?1:o[3],g.appendXtra(\"\",o,(p.length<4?1:p[3])-o,y,!1))),la.lastIndex=0;else if(s=o.match(q)){if(t=p.match(r),!t||t.length!==s.length)return g;for(n=0,m=0;m<s.length;m++)x=s[m],w=o.indexOf(x,n),g.appendXtra(o.substr(n,w-n),Number(x),ea(t[m],x),\"\",D&&\"px\"===o.substr(w+x.length,2),0===m),n=w+x.length;g[\"xs\"+g.l]+=o.substr(n)}else g[\"xs\"+g.l]+=g.l?\" \"+p:p;if(-1!==d.indexOf(\"=\")&&g.data){for(y=g.xs0+g.data.s,l=1;l<g.l;l++)y+=g[\"xs\"+l]+g.data[\"xn\"+l];g.e=y+g[\"xs\"+l]}return g.l||(g.type=-1,g.xs0=g.e),g.xfirst||g},sa=9;for(j=pa.prototype,j.l=j.pr=0;--sa>0;)j[\"xn\"+sa]=0,j[\"xs\"+sa]=\"\";j.xs0=\"\",j._next=j._prev=j.xfirst=j.data=j.plugin=j.setRatio=j.rxp=null,j.appendXtra=function(a,b,c,d,e,f){var g=this,h=g.l;return g[\"xs\"+h]+=f&&h?\" \"+a:a||\"\",c||0===h||g.plugin?(g.l++,g.type=g.setRatio?2:1,g[\"xs\"+g.l]=d||\"\",h>0?(g.data[\"xn\"+h]=b+c,g.rxp[\"xn\"+h]=e,g[\"xn\"+h]=b,g.plugin||(g.xfirst=new pa(g,\"xn\"+h,b,c,g.xfirst||g,0,g.n,e,g.pr),g.xfirst.xs0=0),g):(g.data={s:b+c},g.rxp={},g.s=b,g.c=c,g.r=e,g)):(g[\"xs\"+h]+=b+(d||\"\"),g)};var ta=function(a,b){b=b||{},this.p=b.prefix?V(a)||a:a,i[a]=i[this.p]=this,this.format=b.formatter||ma(b.defaultValue,b.color,b.collapsible,b.multi),b.parser&&(this.parse=b.parser),this.clrs=b.color,this.multi=b.multi,this.keyword=b.keyword,this.dflt=b.defaultValue,this.pr=b.priority||0},ua=O._registerComplexSpecialProp=function(a,b,c){\"object\"!=typeof b&&(b={parser:c});var d,e,f=a.split(\",\"),g=b.defaultValue;for(c=c||[g],d=0;d<f.length;d++)b.prefix=0===d&&b.prefix,b.defaultValue=c[d]||g,e=new ta(f[d],b)},va=function(a){if(!i[a]){var b=a.charAt(0).toUpperCase()+a.substr(1)+\"Plugin\";ua(a,{parser:function(a,c,d,e,f,g,j){var k=h.com.greensock.plugins[b];return k?(k._cssRegister(),i[d].parse(a,c,d,e,f,g,j)):(S(\"Error: \"+b+\" js file not loaded.\"),f)}})}};j=ta.prototype,j.parseComplex=function(a,b,c,d,e,f){var g,h,i,j,k,l,m=this.keyword;if(this.multi&&(G.test(c)||G.test(b)?(h=b.replace(G,\"|\").split(\"|\"),i=c.replace(G,\"|\").split(\"|\")):m&&(h=[b],i=[c])),i){for(j=i.length>h.length?i.length:h.length,g=0;j>g;g++)b=h[g]=h[g]||this.dflt,c=i[g]=i[g]||this.dflt,m&&(k=b.indexOf(m),l=c.indexOf(m),k!==l&&(-1===l?h[g]=h[g].split(m).join(\"\"):-1===k&&(h[g]+=\" \"+m)));b=h.join(\", \"),c=i.join(\", \")}return ra(a,this.p,b,c,this.clrs,this.dflt,d,this.pr,e,f)},j.parse=function(a,b,c,d,f,g,h){return this.parseComplex(a.style,this.format(X(a,this.p,e,!1,this.dflt)),this.format(b),f,g)},g.registerSpecialProp=function(a,b,c){ua(a,{parser:function(a,d,e,f,g,h,i){var j=new pa(a,e,0,0,g,2,e,!1,c);return j.plugin=h,j.setRatio=b(a,d,f._tween,e),j},priority:c})},g.useSVGTransformAttr=m||n;var wa,xa=\"scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent\".split(\",\"),ya=V(\"transform\"),za=T+\"transform\",Aa=V(\"transformOrigin\"),Ba=null!==V(\"perspective\"),Ca=O.Transform=function(){this.perspective=parseFloat(g.defaultTransformPerspective)||0,this.force3D=g.defaultForce3D!==!1&&Ba?g.defaultForce3D||\"auto\":!1},Da=window.SVGElement,Ea=function(a,b,c){var d,e=K.createElementNS(\"http://www.w3.org/2000/svg\",a),f=/([a-z])([A-Z])/g;for(d in c)e.setAttributeNS(null,d.replace(f,\"$1-$2\").toLowerCase(),c[d]);return b.appendChild(e),e},Fa=K.documentElement,Ga=function(){var a,b,c,d=p||/Android/i.test(P)&&!window.chrome;return K.createElementNS&&!d&&(a=Ea(\"svg\",Fa),b=Ea(\"rect\",a,{width:100,height:50,x:100}),c=b.getBoundingClientRect().width,b.style[Aa]=\"50% 50%\",b.style[ya]=\"scaleX(0.5)\",d=c===b.getBoundingClientRect().width&&!(n&&Ba),Fa.removeChild(a)),d}(),Ha=function(a,b,c,d,e){var f,h,i,j,k,l,m,n,o,p,q,r,s,t,u=a._gsTransform,v=Ka(a,!0);u&&(s=u.xOrigin,t=u.yOrigin),(!d||(f=d.split(\" \")).length<2)&&(m=a.getBBox(),b=da(b).split(\" \"),f=[(-1!==b[0].indexOf(\"%\")?parseFloat(b[0])/100*m.width:parseFloat(b[0]))+m.x,(-1!==b[1].indexOf(\"%\")?parseFloat(b[1])/100*m.height:parseFloat(b[1]))+m.y]),c.xOrigin=j=parseFloat(f[0]),c.yOrigin=k=parseFloat(f[1]),d&&v!==Ja&&(l=v[0],m=v[1],n=v[2],o=v[3],p=v[4],q=v[5],r=l*o-m*n,h=j*(o/r)+k*(-n/r)+(n*q-o*p)/r,i=j*(-m/r)+k*(l/r)-(l*q-m*p)/r,j=c.xOrigin=f[0]=h,k=c.yOrigin=f[1]=i),u&&(e||e!==!1&&g.defaultSmoothOrigin!==!1?(h=j-s,i=k-t,u.xOffset+=h*v[0]+i*v[2]-h,u.yOffset+=h*v[1]+i*v[3]-i):u.xOffset=u.yOffset=0),a.setAttribute(\"data-svg-origin\",f.join(\" \"))},Ia=function(a){return!!(Da&&\"function\"==typeof a.getBBox&&a.getCTM&&(!a.parentNode||a.parentNode.getBBox&&a.parentNode.getCTM))},Ja=[1,0,0,1,0,0],Ka=function(a,b){var c,d,e,f,g,h=a._gsTransform||new Ca,i=1e5;if(ya?d=X(a,za,null,!0):a.currentStyle&&(d=a.currentStyle.filter.match(E),d=d&&4===d.length?[d[0].substr(4),Number(d[2].substr(4)),Number(d[1].substr(4)),d[3].substr(4),h.x||0,h.y||0].join(\",\"):\"\"),c=!d||\"none\"===d||\"matrix(1, 0, 0, 1, 0, 0)\"===d,(h.svg||a.getBBox&&Ia(a))&&(c&&-1!==(a.style[ya]+\"\").indexOf(\"matrix\")&&(d=a.style[ya],c=0),e=a.getAttribute(\"transform\"),c&&e&&(-1!==e.indexOf(\"matrix\")?(d=e,c=0):-1!==e.indexOf(\"translate\")&&(d=\"matrix(1,0,0,1,\"+e.match(/(?:\\-|\\b)[\\d\\-\\.e]+\\b/gi).join(\",\")+\")\",c=0))),c)return Ja;for(e=(d||\"\").match(/(?:\\-|\\b)[\\d\\-\\.e]+\\b/gi)||[],sa=e.length;--sa>-1;)f=Number(e[sa]),e[sa]=(g=f-(f|=0))?(g*i+(0>g?-.5:.5)|0)/i+f:f;return b&&e.length>6?[e[0],e[1],e[4],e[5],e[12],e[13]]:e},La=O.getTransform=function(a,c,d,f){if(a._gsTransform&&d&&!f)return a._gsTransform;var h,i,j,k,l,m,n=d?a._gsTransform||new Ca:new Ca,o=n.scaleX<0,p=2e-5,q=1e5,r=Ba?parseFloat(X(a,Aa,c,!1,\"0 0 0\").split(\" \")[2])||n.zOrigin||0:0,s=parseFloat(g.defaultTransformPerspective)||0;if(n.svg=!(!a.getBBox||!Ia(a)),n.svg&&(Ha(a,X(a,Aa,e,!1,\"50% 50%\")+\"\",n,a.getAttribute(\"data-svg-origin\")),wa=g.useSVGTransformAttr||Ga),h=Ka(a),h!==Ja){if(16===h.length){var t,u,v,w,x,y=h[0],z=h[1],A=h[2],B=h[3],C=h[4],D=h[5],E=h[6],F=h[7],G=h[8],H=h[9],J=h[10],K=h[12],L=h[13],M=h[14],N=h[11],O=Math.atan2(E,J);n.zOrigin&&(M=-n.zOrigin,K=G*M-h[12],L=H*M-h[13],M=J*M+n.zOrigin-h[14]),n.rotationX=O*I,O&&(w=Math.cos(-O),x=Math.sin(-O),t=C*w+G*x,u=D*w+H*x,v=E*w+J*x,G=C*-x+G*w,H=D*-x+H*w,J=E*-x+J*w,N=F*-x+N*w,C=t,D=u,E=v),O=Math.atan2(-A,J),n.rotationY=O*I,O&&(w=Math.cos(-O),x=Math.sin(-O),t=y*w-G*x,u=z*w-H*x,v=A*w-J*x,H=z*x+H*w,J=A*x+J*w,N=B*x+N*w,y=t,z=u,A=v),O=Math.atan2(z,y),n.rotation=O*I,O&&(w=Math.cos(-O),x=Math.sin(-O),y=y*w+C*x,u=z*w+D*x,D=z*-x+D*w,E=A*-x+E*w,z=u),n.rotationX&&Math.abs(n.rotationX)+Math.abs(n.rotation)>359.9&&(n.rotationX=n.rotation=0,n.rotationY=180-n.rotationY),n.scaleX=(Math.sqrt(y*y+z*z)*q+.5|0)/q,n.scaleY=(Math.sqrt(D*D+H*H)*q+.5|0)/q,n.scaleZ=(Math.sqrt(E*E+J*J)*q+.5|0)/q,n.skewX=0,n.perspective=N?1/(0>N?-N:N):0,n.x=K,n.y=L,n.z=M,n.svg&&(n.x-=n.xOrigin-(n.xOrigin*y-n.yOrigin*C),n.y-=n.yOrigin-(n.yOrigin*z-n.xOrigin*D))}else if((!Ba||f||!h.length||n.x!==h[4]||n.y!==h[5]||!n.rotationX&&!n.rotationY)&&(void 0===n.x||\"none\"!==X(a,\"display\",c))){var P=h.length>=6,Q=P?h[0]:1,R=h[1]||0,S=h[2]||0,T=P?h[3]:1;n.x=h[4]||0,n.y=h[5]||0,j=Math.sqrt(Q*Q+R*R),k=Math.sqrt(T*T+S*S),l=Q||R?Math.atan2(R,Q)*I:n.rotation||0,m=S||T?Math.atan2(S,T)*I+l:n.skewX||0,Math.abs(m)>90&&Math.abs(m)<270&&(o?(j*=-1,m+=0>=l?180:-180,l+=0>=l?180:-180):(k*=-1,m+=0>=m?180:-180)),n.scaleX=j,n.scaleY=k,n.rotation=l,n.skewX=m,Ba&&(n.rotationX=n.rotationY=n.z=0,n.perspective=s,n.scaleZ=1),n.svg&&(n.x-=n.xOrigin-(n.xOrigin*Q+n.yOrigin*S),n.y-=n.yOrigin-(n.xOrigin*R+n.yOrigin*T))}n.zOrigin=r;for(i in n)n[i]<p&&n[i]>-p&&(n[i]=0)}return d&&(a._gsTransform=n,n.svg&&(wa&&a.style[ya]?b.delayedCall(.001,function(){Pa(a.style,ya)}):!wa&&a.getAttribute(\"transform\")&&b.delayedCall(.001,function(){a.removeAttribute(\"transform\")}))),n},Ma=function(a){var b,c,d=this.data,e=-d.rotation*H,f=e+d.skewX*H,g=1e5,h=(Math.cos(e)*d.scaleX*g|0)/g,i=(Math.sin(e)*d.scaleX*g|0)/g,j=(Math.sin(f)*-d.scaleY*g|0)/g,k=(Math.cos(f)*d.scaleY*g|0)/g,l=this.t.style,m=this.t.currentStyle;if(m){c=i,i=-j,j=-c,b=m.filter,l.filter=\"\";var n,o,q=this.t.offsetWidth,r=this.t.offsetHeight,s=\"absolute\"!==m.position,t=\"progid:DXImageTransform.Microsoft.Matrix(M11=\"+h+\", M12=\"+i+\", M21=\"+j+\", M22=\"+k,w=d.x+q*d.xPercent/100,x=d.y+r*d.yPercent/100;if(null!=d.ox&&(n=(d.oxp?q*d.ox*.01:d.ox)-q/2,o=(d.oyp?r*d.oy*.01:d.oy)-r/2,w+=n-(n*h+o*i),x+=o-(n*j+o*k)),s?(n=q/2,o=r/2,t+=\", Dx=\"+(n-(n*h+o*i)+w)+\", Dy=\"+(o-(n*j+o*k)+x)+\")\"):t+=\", sizingMethod='auto expand')\",-1!==b.indexOf(\"DXImageTransform.Microsoft.Matrix(\")?l.filter=b.replace(F,t):l.filter=t+\" \"+b,(0===a||1===a)&&1===h&&0===i&&0===j&&1===k&&(s&&-1===t.indexOf(\"Dx=0, Dy=0\")||v.test(b)&&100!==parseFloat(RegExp.$1)||-1===b.indexOf(b.indexOf(\"Alpha\"))&&l.removeAttribute(\"filter\")),!s){var y,z,A,B=8>p?1:-1;for(n=d.ieOffsetX||0,o=d.ieOffsetY||0,d.ieOffsetX=Math.round((q-((0>h?-h:h)*q+(0>i?-i:i)*r))/2+w),d.ieOffsetY=Math.round((r-((0>k?-k:k)*r+(0>j?-j:j)*q))/2+x),sa=0;4>sa;sa++)z=ba[sa],y=m[z],c=-1!==y.indexOf(\"px\")?parseFloat(y):Y(this.t,z,parseFloat(y),y.replace(u,\"\"))||0,A=c!==d[z]?2>sa?-d.ieOffsetX:-d.ieOffsetY:2>sa?n-d.ieOffsetX:o-d.ieOffsetY,l[z]=(d[z]=Math.round(c-A*(0===sa||2===sa?1:B)))+\"px\"}}},Na=O.set3DTransformRatio=O.setTransformRatio=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u,v,w,x,y,z=this.data,A=this.t.style,B=z.rotation,C=z.rotationX,D=z.rotationY,E=z.scaleX,F=z.scaleY,G=z.scaleZ,I=z.x,J=z.y,K=z.z,L=z.svg,M=z.perspective,N=z.force3D;if(((1===a||0===a)&&\"auto\"===N&&(this.tween._totalTime===this.tween._totalDuration||!this.tween._totalTime)||!N)&&!K&&!M&&!D&&!C&&1===G||wa&&L||!Ba)return void(B||z.skewX||L?(B*=H,x=z.skewX*H,y=1e5,b=Math.cos(B)*E,e=Math.sin(B)*E,c=Math.sin(B-x)*-F,f=Math.cos(B-x)*F,x&&\"simple\"===z.skewType&&(s=Math.tan(x),s=Math.sqrt(1+s*s),c*=s,f*=s,z.skewY&&(b*=s,e*=s)),L&&(I+=z.xOrigin-(z.xOrigin*b+z.yOrigin*c)+z.xOffset,J+=z.yOrigin-(z.xOrigin*e+z.yOrigin*f)+z.yOffset,wa&&(z.xPercent||z.yPercent)&&(p=this.t.getBBox(),I+=.01*z.xPercent*p.width,J+=.01*z.yPercent*p.height),p=1e-6,p>I&&I>-p&&(I=0),p>J&&J>-p&&(J=0)),u=(b*y|0)/y+\",\"+(e*y|0)/y+\",\"+(c*y|0)/y+\",\"+(f*y|0)/y+\",\"+I+\",\"+J+\")\",L&&wa?this.t.setAttribute(\"transform\",\"matrix(\"+u):A[ya]=(z.xPercent||z.yPercent?\"translate(\"+z.xPercent+\"%,\"+z.yPercent+\"%) matrix(\":\"matrix(\")+u):A[ya]=(z.xPercent||z.yPercent?\"translate(\"+z.xPercent+\"%,\"+z.yPercent+\"%) matrix(\":\"matrix(\")+E+\",0,0,\"+F+\",\"+I+\",\"+J+\")\");if(n&&(p=1e-4,p>E&&E>-p&&(E=G=2e-5),p>F&&F>-p&&(F=G=2e-5),!M||z.z||z.rotationX||z.rotationY||(M=0)),B||z.skewX)B*=H,q=b=Math.cos(B),r=e=Math.sin(B),z.skewX&&(B-=z.skewX*H,q=Math.cos(B),r=Math.sin(B),\"simple\"===z.skewType&&(s=Math.tan(z.skewX*H),s=Math.sqrt(1+s*s),q*=s,r*=s,z.skewY&&(b*=s,e*=s))),c=-r,f=q;else{if(!(D||C||1!==G||M||L))return void(A[ya]=(z.xPercent||z.yPercent?\"translate(\"+z.xPercent+\"%,\"+z.yPercent+\"%) translate3d(\":\"translate3d(\")+I+\"px,\"+J+\"px,\"+K+\"px)\"+(1!==E||1!==F?\" scale(\"+E+\",\"+F+\")\":\"\"));b=f=1,c=e=0}j=1,d=g=h=i=k=l=0,m=M?-1/M:0,o=z.zOrigin,p=1e-6,v=\",\",w=\"0\",B=D*H,B&&(q=Math.cos(B),r=Math.sin(B),h=-r,k=m*-r,d=b*r,g=e*r,j=q,m*=q,b*=q,e*=q),B=C*H,B&&(q=Math.cos(B),r=Math.sin(B),s=c*q+d*r,t=f*q+g*r,i=j*r,l=m*r,d=c*-r+d*q,g=f*-r+g*q,j*=q,m*=q,c=s,f=t),1!==G&&(d*=G,g*=G,j*=G,m*=G),1!==F&&(c*=F,f*=F,i*=F,l*=F),1!==E&&(b*=E,e*=E,h*=E,k*=E),(o||L)&&(o&&(I+=d*-o,J+=g*-o,K+=j*-o+o),L&&(I+=z.xOrigin-(z.xOrigin*b+z.yOrigin*c)+z.xOffset,J+=z.yOrigin-(z.xOrigin*e+z.yOrigin*f)+z.yOffset),p>I&&I>-p&&(I=w),p>J&&J>-p&&(J=w),p>K&&K>-p&&(K=0)),u=z.xPercent||z.yPercent?\"translate(\"+z.xPercent+\"%,\"+z.yPercent+\"%) matrix3d(\":\"matrix3d(\",u+=(p>b&&b>-p?w:b)+v+(p>e&&e>-p?w:e)+v+(p>h&&h>-p?w:h),u+=v+(p>k&&k>-p?w:k)+v+(p>c&&c>-p?w:c)+v+(p>f&&f>-p?w:f),C||D||1!==G?(u+=v+(p>i&&i>-p?w:i)+v+(p>l&&l>-p?w:l)+v+(p>d&&d>-p?w:d),u+=v+(p>g&&g>-p?w:g)+v+(p>j&&j>-p?w:j)+v+(p>m&&m>-p?w:m)+v):u+=\",0,0,0,0,1,0,\",u+=I+v+J+v+K+v+(M?1+-K/M:1)+\")\",A[ya]=u};j=Ca.prototype,j.x=j.y=j.z=j.skewX=j.skewY=j.rotation=j.rotationX=j.rotationY=j.zOrigin=j.xPercent=j.yPercent=j.xOffset=j.yOffset=0,j.scaleX=j.scaleY=j.scaleZ=1,ua(\"transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin\",{parser:function(a,b,c,d,f,h,i){if(d._lastParsedTransform===i)return f;d._lastParsedTransform=i;var j,k,l,m,n,o,p,q,r,s,t=a._gsTransform,u=a.style,v=1e-6,w=xa.length,x=i,y={},z=\"transformOrigin\";if(i.display?(m=X(a,\"display\"),u.display=\"block\",j=La(a,e,!0,i.parseTransform),u.display=m):j=La(a,e,!0,i.parseTransform),d._transform=j,\"string\"==typeof x.transform&&ya)m=M.style,m[ya]=x.transform,m.display=\"block\",m.position=\"absolute\",K.body.appendChild(M),k=La(M,null,!1),K.body.removeChild(M),k.perspective||(k.perspective=j.perspective),null!=x.xPercent&&(k.xPercent=fa(x.xPercent,j.xPercent)),null!=x.yPercent&&(k.yPercent=fa(x.yPercent,j.yPercent));else if(\"object\"==typeof x){if(k={scaleX:fa(null!=x.scaleX?x.scaleX:x.scale,j.scaleX),scaleY:fa(null!=x.scaleY?x.scaleY:x.scale,j.scaleY),scaleZ:fa(x.scaleZ,j.scaleZ),x:fa(x.x,j.x),y:fa(x.y,j.y),z:fa(x.z,j.z),xPercent:fa(x.xPercent,j.xPercent),yPercent:fa(x.yPercent,j.yPercent),perspective:fa(x.transformPerspective,j.perspective)},q=x.directionalRotation,null!=q)if(\"object\"==typeof q)for(m in q)x[m]=q[m];else x.rotation=q;\"string\"==typeof x.x&&-1!==x.x.indexOf(\"%\")&&(k.x=0,k.xPercent=fa(x.x,j.xPercent)),\"string\"==typeof x.y&&-1!==x.y.indexOf(\"%\")&&(k.y=0,k.yPercent=fa(x.y,j.yPercent)),k.rotation=ga(\"rotation\"in x?x.rotation:\"shortRotation\"in x?x.shortRotation+\"_short\":\"rotationZ\"in x?x.rotationZ:j.rotation,j.rotation,\"rotation\",y),Ba&&(k.rotationX=ga(\"rotationX\"in x?x.rotationX:\"shortRotationX\"in x?x.shortRotationX+\"_short\":j.rotationX||0,j.rotationX,\"rotationX\",y),k.rotationY=ga(\"rotationY\"in x?x.rotationY:\"shortRotationY\"in x?x.shortRotationY+\"_short\":j.rotationY||0,j.rotationY,\"rotationY\",y)),k.skewX=null==x.skewX?j.skewX:ga(x.skewX,j.skewX),k.skewY=null==x.skewY?j.skewY:ga(x.skewY,j.skewY),(l=k.skewY-j.skewY)&&(k.skewX+=l,k.rotation+=l)}for(Ba&&null!=x.force3D&&(j.force3D=x.force3D,p=!0),j.skewType=x.skewType||j.skewType||g.defaultSkewType,o=j.force3D||j.z||j.rotationX||j.rotationY||k.z||k.rotationX||k.rotationY||k.perspective,o||null==x.scale||(k.scaleZ=1);--w>-1;)c=xa[w],n=k[c]-j[c],(n>v||-v>n||null!=x[c]||null!=J[c])&&(p=!0,f=new pa(j,c,j[c],n,f),c in y&&(f.e=y[c]),f.xs0=0,f.plugin=h,d._overwriteProps.push(f.n));return n=x.transformOrigin,j.svg&&(n||x.svgOrigin)&&(r=j.xOffset,s=j.yOffset,Ha(a,da(n),k,x.svgOrigin,x.smoothOrigin),f=qa(j,\"xOrigin\",(t?j:k).xOrigin,k.xOrigin,f,z),f=qa(j,\"yOrigin\",(t?j:k).yOrigin,k.yOrigin,f,z),(r!==j.xOffset||s!==j.yOffset)&&(f=qa(j,\"xOffset\",t?r:j.xOffset,j.xOffset,f,z),f=qa(j,\"yOffset\",t?s:j.yOffset,j.yOffset,f,z)),n=wa?null:\"0px 0px\"),(n||Ba&&o&&j.zOrigin)&&(ya?(p=!0,c=Aa,n=(n||X(a,c,e,!1,\"50% 50%\"))+\"\",f=new pa(u,c,0,0,f,-1,z),f.b=u[c],f.plugin=h,Ba?(m=j.zOrigin,n=n.split(\" \"),j.zOrigin=(n.length>2&&(0===m||\"0px\"!==n[2])?parseFloat(n[2]):m)||0,f.xs0=f.e=n[0]+\" \"+(n[1]||\"50%\")+\" 0px\",f=new pa(j,\"zOrigin\",0,0,f,-1,f.n),f.b=m,f.xs0=f.e=j.zOrigin):f.xs0=f.e=n):da(n+\"\",j)),p&&(d._transformType=j.svg&&wa||!o&&3!==this._transformType?2:3),f},prefix:!0}),ua(\"boxShadow\",{defaultValue:\"0px 0px 0px 0px #999\",prefix:!0,color:!0,multi:!0,keyword:\"inset\"}),ua(\"borderRadius\",{defaultValue:\"0px\",parser:function(a,b,c,f,g,h){b=this.format(b);var i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y=[\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderBottomRightRadius\",\"borderBottomLeftRadius\"],z=a.style;for(q=parseFloat(a.offsetWidth),r=parseFloat(a.offsetHeight),i=b.split(\" \"),j=0;j<y.length;j++)this.p.indexOf(\"border\")&&(y[j]=V(y[j])),m=l=X(a,y[j],e,!1,\"0px\"),-1!==m.indexOf(\" \")&&(l=m.split(\" \"),m=l[0],l=l[1]),n=k=i[j],o=parseFloat(m),t=m.substr((o+\"\").length),u=\"=\"===n.charAt(1),u?(p=parseInt(n.charAt(0)+\"1\",10),n=n.substr(2),p*=parseFloat(n),s=n.substr((p+\"\").length-(0>p?1:0))||\"\"):(p=parseFloat(n),s=n.substr((p+\"\").length)),\"\"===s&&(s=d[c]||t),s!==t&&(v=Y(a,\"borderLeft\",o,t),w=Y(a,\"borderTop\",o,t),\"%\"===s?(m=v/q*100+\"%\",l=w/r*100+\"%\"):\"em\"===s?(x=Y(a,\"borderLeft\",1,\"em\"),m=v/x+\"em\",l=w/x+\"em\"):(m=v+\"px\",l=w+\"px\"),u&&(n=parseFloat(m)+p+s,k=parseFloat(l)+p+s)),g=ra(z,y[j],m+\" \"+l,n+\" \"+k,!1,\"0px\",g);return g},prefix:!0,formatter:ma(\"0px 0px 0px 0px\",!1,!0)}),ua(\"backgroundPosition\",{\ndefaultValue:\"0 0\",parser:function(a,b,c,d,f,g){var h,i,j,k,l,m,n=\"background-position\",o=e||W(a,null),q=this.format((o?p?o.getPropertyValue(n+\"-x\")+\" \"+o.getPropertyValue(n+\"-y\"):o.getPropertyValue(n):a.currentStyle.backgroundPositionX+\" \"+a.currentStyle.backgroundPositionY)||\"0 0\"),r=this.format(b);if(-1!==q.indexOf(\"%\")!=(-1!==r.indexOf(\"%\"))&&(m=X(a,\"backgroundImage\").replace(B,\"\"),m&&\"none\"!==m)){for(h=q.split(\" \"),i=r.split(\" \"),N.setAttribute(\"src\",m),j=2;--j>-1;)q=h[j],k=-1!==q.indexOf(\"%\"),k!==(-1!==i[j].indexOf(\"%\"))&&(l=0===j?a.offsetWidth-N.width:a.offsetHeight-N.height,h[j]=k?parseFloat(q)/100*l+\"px\":parseFloat(q)/l*100+\"%\");q=h.join(\" \")}return this.parseComplex(a.style,q,r,f,g)},formatter:da}),ua(\"backgroundSize\",{defaultValue:\"0 0\",formatter:da}),ua(\"perspective\",{defaultValue:\"0px\",prefix:!0}),ua(\"perspectiveOrigin\",{defaultValue:\"50% 50%\",prefix:!0}),ua(\"transformStyle\",{prefix:!0}),ua(\"backfaceVisibility\",{prefix:!0}),ua(\"userSelect\",{prefix:!0}),ua(\"margin\",{parser:na(\"marginTop,marginRight,marginBottom,marginLeft\")}),ua(\"padding\",{parser:na(\"paddingTop,paddingRight,paddingBottom,paddingLeft\")}),ua(\"clip\",{defaultValue:\"rect(0px,0px,0px,0px)\",parser:function(a,b,c,d,f,g){var h,i,j;return 9>p?(i=a.currentStyle,j=8>p?\" \":\",\",h=\"rect(\"+i.clipTop+j+i.clipRight+j+i.clipBottom+j+i.clipLeft+\")\",b=this.format(b).split(\",\").join(j)):(h=this.format(X(a,this.p,e,!1,this.dflt)),b=this.format(b)),this.parseComplex(a.style,h,b,f,g)}}),ua(\"textShadow\",{defaultValue:\"0px 0px 0px #999\",color:!0,multi:!0}),ua(\"autoRound,strictUnits\",{parser:function(a,b,c,d,e){return e}}),ua(\"border\",{defaultValue:\"0px solid #000\",parser:function(a,b,c,d,f,g){return this.parseComplex(a.style,this.format(X(a,\"borderTopWidth\",e,!1,\"0px\")+\" \"+X(a,\"borderTopStyle\",e,!1,\"solid\")+\" \"+X(a,\"borderTopColor\",e,!1,\"#000\")),this.format(b),f,g)},color:!0,formatter:function(a){var b=a.split(\" \");return b[0]+\" \"+(b[1]||\"solid\")+\" \"+(a.match(la)||[\"#000\"])[0]}}),ua(\"borderWidth\",{parser:na(\"borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth\")}),ua(\"float,cssFloat,styleFloat\",{parser:function(a,b,c,d,e,f){var g=a.style,h=\"cssFloat\"in g?\"cssFloat\":\"styleFloat\";return new pa(g,h,0,0,e,-1,c,!1,0,g[h],b)}});var Oa=function(a){var b,c=this.t,d=c.filter||X(this.data,\"filter\")||\"\",e=this.s+this.c*a|0;100===e&&(-1===d.indexOf(\"atrix(\")&&-1===d.indexOf(\"radient(\")&&-1===d.indexOf(\"oader(\")?(c.removeAttribute(\"filter\"),b=!X(this.data,\"filter\")):(c.filter=d.replace(x,\"\"),b=!0)),b||(this.xn1&&(c.filter=d=d||\"alpha(opacity=\"+e+\")\"),-1===d.indexOf(\"pacity\")?0===e&&this.xn1||(c.filter=d+\" alpha(opacity=\"+e+\")\"):c.filter=d.replace(v,\"opacity=\"+e))};ua(\"opacity,alpha,autoAlpha\",{defaultValue:\"1\",parser:function(a,b,c,d,f,g){var h=parseFloat(X(a,\"opacity\",e,!1,\"1\")),i=a.style,j=\"autoAlpha\"===c;return\"string\"==typeof b&&\"=\"===b.charAt(1)&&(b=(\"-\"===b.charAt(0)?-1:1)*parseFloat(b.substr(2))+h),j&&1===h&&\"hidden\"===X(a,\"visibility\",e)&&0!==b&&(h=0),Q?f=new pa(i,\"opacity\",h,b-h,f):(f=new pa(i,\"opacity\",100*h,100*(b-h),f),f.xn1=j?1:0,i.zoom=1,f.type=2,f.b=\"alpha(opacity=\"+f.s+\")\",f.e=\"alpha(opacity=\"+(f.s+f.c)+\")\",f.data=a,f.plugin=g,f.setRatio=Oa),j&&(f=new pa(i,\"visibility\",0,0,f,-1,null,!1,0,0!==h?\"inherit\":\"hidden\",0===b?\"hidden\":\"inherit\"),f.xs0=\"inherit\",d._overwriteProps.push(f.n),d._overwriteProps.push(c)),f}});var Pa=function(a,b){b&&(a.removeProperty?((\"ms\"===b.substr(0,2)||\"webkit\"===b.substr(0,6))&&(b=\"-\"+b),a.removeProperty(b.replace(z,\"-$1\").toLowerCase())):a.removeAttribute(b))},Qa=function(a){if(this.t._gsClassPT=this,1===a||0===a){this.t.setAttribute(\"class\",0===a?this.b:this.e);for(var b=this.data,c=this.t.style;b;)b.v?c[b.p]=b.v:Pa(c,b.p),b=b._next;1===a&&this.t._gsClassPT===this&&(this.t._gsClassPT=null)}else this.t.getAttribute(\"class\")!==this.e&&this.t.setAttribute(\"class\",this.e)};ua(\"className\",{parser:function(a,b,d,f,g,h,i){var j,k,l,m,n,o=a.getAttribute(\"class\")||\"\",p=a.style.cssText;if(g=f._classNamePT=new pa(a,d,0,0,g,2),g.setRatio=Qa,g.pr=-11,c=!0,g.b=o,k=$(a,e),l=a._gsClassPT){for(m={},n=l.data;n;)m[n.p]=1,n=n._next;l.setRatio(1)}return a._gsClassPT=g,g.e=\"=\"!==b.charAt(1)?b:o.replace(new RegExp(\"\\\\s*\\\\b\"+b.substr(2)+\"\\\\b\"),\"\")+(\"+\"===b.charAt(0)?\" \"+b.substr(2):\"\"),a.setAttribute(\"class\",g.e),j=_(a,k,$(a),i,m),a.setAttribute(\"class\",o),g.data=j.firstMPT,a.style.cssText=p,g=g.xfirst=f.parse(a,j.difs,g,h)}});var Ra=function(a){if((1===a||0===a)&&this.data._totalTime===this.data._totalDuration&&\"isFromStart\"!==this.data.data){var b,c,d,e,f,g=this.t.style,h=i.transform.parse;if(\"all\"===this.e)g.cssText=\"\",e=!0;else for(b=this.e.split(\" \").join(\"\").split(\",\"),d=b.length;--d>-1;)c=b[d],i[c]&&(i[c].parse===h?e=!0:c=\"transformOrigin\"===c?Aa:i[c].p),Pa(g,c);e&&(Pa(g,ya),f=this.t._gsTransform,f&&(f.svg&&(this.t.removeAttribute(\"data-svg-origin\"),this.t.removeAttribute(\"transform\")),delete this.t._gsTransform))}};for(ua(\"clearProps\",{parser:function(a,b,d,e,f){return f=new pa(a,d,0,0,f,2),f.setRatio=Ra,f.e=b,f.pr=-10,f.data=e._tween,c=!0,f}}),j=\"bezier,throwProps,physicsProps,physics2D\".split(\",\"),sa=j.length;sa--;)va(j[sa]);j=g.prototype,j._firstPT=j._lastParsedTransform=j._transform=null,j._onInitTween=function(a,b,h){if(!a.nodeType)return!1;this._target=a,this._tween=h,this._vars=b,k=b.autoRound,c=!1,d=b.suffixMap||g.suffixMap,e=W(a,\"\"),f=this._overwriteProps;var j,n,p,q,r,s,t,u,v,x=a.style;if(l&&\"\"===x.zIndex&&(j=X(a,\"zIndex\",e),(\"auto\"===j||\"\"===j)&&this._addLazySet(x,\"zIndex\",0)),\"string\"==typeof b&&(q=x.cssText,j=$(a,e),x.cssText=q+\";\"+b,j=_(a,j,$(a)).difs,!Q&&w.test(b)&&(j.opacity=parseFloat(RegExp.$1)),b=j,x.cssText=q),b.className?this._firstPT=n=i.className.parse(a,b.className,\"className\",this,null,null,b):this._firstPT=n=this.parse(a,b,null),this._transformType){for(v=3===this._transformType,ya?m&&(l=!0,\"\"===x.zIndex&&(t=X(a,\"zIndex\",e),(\"auto\"===t||\"\"===t)&&this._addLazySet(x,\"zIndex\",0)),o&&this._addLazySet(x,\"WebkitBackfaceVisibility\",this._vars.WebkitBackfaceVisibility||(v?\"visible\":\"hidden\"))):x.zoom=1,p=n;p&&p._next;)p=p._next;u=new pa(a,\"transform\",0,0,null,2),this._linkCSSP(u,null,p),u.setRatio=ya?Na:Ma,u.data=this._transform||La(a,e,!0),u.tween=h,u.pr=-1,f.pop()}if(c){for(;n;){for(s=n._next,p=q;p&&p.pr>n.pr;)p=p._next;(n._prev=p?p._prev:r)?n._prev._next=n:q=n,(n._next=p)?p._prev=n:r=n,n=s}this._firstPT=q}return!0},j.parse=function(a,b,c,f){var g,h,j,l,m,n,o,p,q,r,s=a.style;for(g in b)n=b[g],h=i[g],h?c=h.parse(a,n,g,this,c,f,b):(m=X(a,g,e)+\"\",q=\"string\"==typeof n,\"color\"===g||\"fill\"===g||\"stroke\"===g||-1!==g.indexOf(\"Color\")||q&&y.test(n)?(q||(n=ja(n),n=(n.length>3?\"rgba(\":\"rgb(\")+n.join(\",\")+\")\"),c=ra(s,g,m,n,!0,\"transparent\",c,0,f)):!q||-1===n.indexOf(\" \")&&-1===n.indexOf(\",\")?(j=parseFloat(m),o=j||0===j?m.substr((j+\"\").length):\"\",(\"\"===m||\"auto\"===m)&&(\"width\"===g||\"height\"===g?(j=ca(a,g,e),o=\"px\"):\"left\"===g||\"top\"===g?(j=Z(a,g,e),o=\"px\"):(j=\"opacity\"!==g?0:1,o=\"\")),r=q&&\"=\"===n.charAt(1),r?(l=parseInt(n.charAt(0)+\"1\",10),n=n.substr(2),l*=parseFloat(n),p=n.replace(u,\"\")):(l=parseFloat(n),p=q?n.replace(u,\"\"):\"\"),\"\"===p&&(p=g in d?d[g]:o),n=l||0===l?(r?l+j:l)+p:b[g],o!==p&&\"\"!==p&&(l||0===l)&&j&&(j=Y(a,g,j,o),\"%\"===p?(j/=Y(a,g,100,\"%\")/100,b.strictUnits!==!0&&(m=j+\"%\")):\"em\"===p||\"rem\"===p||\"vw\"===p||\"vh\"===p?j/=Y(a,g,1,p):\"px\"!==p&&(l=Y(a,g,l,p),p=\"px\"),r&&(l||0===l)&&(n=l+j+p)),r&&(l+=j),!j&&0!==j||!l&&0!==l?void 0!==s[g]&&(n||n+\"\"!=\"NaN\"&&null!=n)?(c=new pa(s,g,l||j||0,0,c,-1,g,!1,0,m,n),c.xs0=\"none\"!==n||\"display\"!==g&&-1===g.indexOf(\"Style\")?n:m):S(\"invalid \"+g+\" tween value: \"+b[g]):(c=new pa(s,g,j,l-j,c,0,g,k!==!1&&(\"px\"===p||\"zIndex\"===g),0,m,n),c.xs0=p)):c=ra(s,g,m,n,!0,null,c,0,f)),f&&c&&!c.plugin&&(c.plugin=f);return c},j.setRatio=function(a){var b,c,d,e=this._firstPT,f=1e-6;if(1!==a||this._tween._time!==this._tween._duration&&0!==this._tween._time)if(a||this._tween._time!==this._tween._duration&&0!==this._tween._time||this._tween._rawPrevTime===-1e-6)for(;e;){if(b=e.c*a+e.s,e.r?b=Math.round(b):f>b&&b>-f&&(b=0),e.type)if(1===e.type)if(d=e.l,2===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2;else if(3===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2+e.xn2+e.xs3;else if(4===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2+e.xn2+e.xs3+e.xn3+e.xs4;else if(5===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2+e.xn2+e.xs3+e.xn3+e.xs4+e.xn4+e.xs5;else{for(c=e.xs0+b+e.xs1,d=1;d<e.l;d++)c+=e[\"xn\"+d]+e[\"xs\"+(d+1)];e.t[e.p]=c}else-1===e.type?e.t[e.p]=e.xs0:e.setRatio&&e.setRatio(a);else e.t[e.p]=b+e.xs0;e=e._next}else for(;e;)2!==e.type?e.t[e.p]=e.b:e.setRatio(a),e=e._next;else for(;e;){if(2!==e.type)if(e.r&&-1!==e.type)if(b=Math.round(e.s+e.c),e.type){if(1===e.type){for(d=e.l,c=e.xs0+b+e.xs1,d=1;d<e.l;d++)c+=e[\"xn\"+d]+e[\"xs\"+(d+1)];e.t[e.p]=c}}else e.t[e.p]=b+e.xs0;else e.t[e.p]=e.e;else e.setRatio(a);e=e._next}},j._enableTransforms=function(a){this._transform=this._transform||La(this._target,e,!0),this._transformType=this._transform.svg&&wa||!a&&3!==this._transformType?2:3};var Sa=function(a){this.t[this.p]=this.e,this.data._linkCSSP(this,this._next,null,!0)};j._addLazySet=function(a,b,c){var d=this._firstPT=new pa(a,b,0,0,this._firstPT,2);d.e=c,d.setRatio=Sa,d.data=this},j._linkCSSP=function(a,b,c,d){return a&&(b&&(b._prev=a),a._next&&(a._next._prev=a._prev),a._prev?a._prev._next=a._next:this._firstPT===a&&(this._firstPT=a._next,d=!0),c?c._next=a:d||null!==this._firstPT||(this._firstPT=a),a._next=b,a._prev=c),a},j._kill=function(b){var c,d,e,f=b;if(b.autoAlpha||b.alpha){f={};for(d in b)f[d]=b[d];f.opacity=1,f.autoAlpha&&(f.visibility=1)}return b.className&&(c=this._classNamePT)&&(e=c.xfirst,e&&e._prev?this._linkCSSP(e._prev,c._next,e._prev._prev):e===this._firstPT&&(this._firstPT=c._next),c._next&&this._linkCSSP(c._next,c._next._next,e._prev),this._classNamePT=null),a.prototype._kill.call(this,f)};var Ta=function(a,b,c){var d,e,f,g;if(a.slice)for(e=a.length;--e>-1;)Ta(a[e],b,c);else for(d=a.childNodes,e=d.length;--e>-1;)f=d[e],g=f.type,f.style&&(b.push($(f)),c&&c.push(f)),1!==g&&9!==g&&11!==g||!f.childNodes.length||Ta(f,b,c)};return g.cascadeTo=function(a,c,d){var e,f,g,h,i=b.to(a,c,d),j=[i],k=[],l=[],m=[],n=b._internals.reservedProps;for(a=i._targets||i.target,Ta(a,k,m),i.render(c,!0,!0),Ta(a,l),i.render(0,!0,!0),i._enabled(!0),e=m.length;--e>-1;)if(f=_(m[e],k[e],l[e]),f.firstMPT){f=f.difs;for(g in d)n[g]&&(f[g]=d[g]);h={};for(g in f)h[g]=k[e][g];j.push(b.fromTo(m[e],c,h,f))}return j},a.activate([g]),g},!0),function(){var a=_gsScope._gsDefine.plugin({propName:\"roundProps\",version:\"1.5\",priority:-1,API:2,init:function(a,b,c){return this._tween=c,!0}}),b=function(a){for(;a;)a.f||a.blob||(a.r=1),a=a._next},c=a.prototype;c._onInitAllProps=function(){for(var a,c,d,e=this._tween,f=e.vars.roundProps.join?e.vars.roundProps:e.vars.roundProps.split(\",\"),g=f.length,h={},i=e._propLookup.roundProps;--g>-1;)h[f[g]]=1;for(g=f.length;--g>-1;)for(a=f[g],c=e._firstPT;c;)d=c._next,c.pg?c.t._roundProps(h,!0):c.n===a&&(2===c.f&&c.t?b(c.t._firstPT):(this._add(c.t,a,c.s,c.c),d&&(d._prev=c._prev),c._prev?c._prev._next=d:e._firstPT===c&&(e._firstPT=d),c._next=c._prev=null,e._propLookup[a]=i)),c=d;return!1},c._add=function(a,b,c,d){this._addTween(a,b,c,c+d,b,!0),this._overwriteProps.push(b)}}(),function(){_gsScope._gsDefine.plugin({propName:\"attr\",API:2,version:\"0.5.0\",init:function(a,b,c){var d;if(\"function\"!=typeof a.setAttribute)return!1;for(d in b)this._addTween(a,\"setAttribute\",a.getAttribute(d)+\"\",b[d]+\"\",d,!1,d),this._overwriteProps.push(d);return!0}})}(),_gsScope._gsDefine.plugin({propName:\"directionalRotation\",version:\"0.2.1\",API:2,init:function(a,b,c){\"object\"!=typeof b&&(b={rotation:b}),this.finals={};var d,e,f,g,h,i,j=b.useRadians===!0?2*Math.PI:360,k=1e-6;for(d in b)\"useRadians\"!==d&&(i=(b[d]+\"\").split(\"_\"),e=i[0],f=parseFloat(\"function\"!=typeof a[d]?a[d]:a[d.indexOf(\"set\")||\"function\"!=typeof a[\"get\"+d.substr(3)]?d:\"get\"+d.substr(3)]()),g=this.finals[d]=\"string\"==typeof e&&\"=\"===e.charAt(1)?f+parseInt(e.charAt(0)+\"1\",10)*Number(e.substr(2)):Number(e)||0,h=g-f,i.length&&(e=i.join(\"_\"),-1!==e.indexOf(\"short\")&&(h%=j,h!==h%(j/2)&&(h=0>h?h+j:h-j)),-1!==e.indexOf(\"_cw\")&&0>h?h=(h+9999999999*j)%j-(h/j|0)*j:-1!==e.indexOf(\"ccw\")&&h>0&&(h=(h-9999999999*j)%j-(h/j|0)*j)),(h>k||-k>h)&&(this._addTween(a,d,f,f+h,d),this._overwriteProps.push(d)));return!0},set:function(a){var b;if(1!==a)this._super.setRatio.call(this,a);else for(b=this._firstPT;b;)b.f?b.t[b.p](this.finals[b.p]):b.t[b.p]=this.finals[b.p],b=b._next}})._autoCSS=!0,_gsScope._gsDefine(\"easing.Back\",[\"easing.Ease\"],function(a){var b,c,d,e=_gsScope.GreenSockGlobals||_gsScope,f=e.com.greensock,g=2*Math.PI,h=Math.PI/2,i=f._class,j=function(b,c){var d=i(\"easing.\"+b,function(){},!0),e=d.prototype=new a;return e.constructor=d,e.getRatio=c,d},k=a.register||function(){},l=function(a,b,c,d,e){var f=i(\"easing.\"+a,{easeOut:new b,easeIn:new c,easeInOut:new d},!0);return k(f,a),f},m=function(a,b,c){this.t=a,this.v=b,c&&(this.next=c,c.prev=this,this.c=c.v-b,this.gap=c.t-a)},n=function(b,c){var d=i(\"easing.\"+b,function(a){this._p1=a||0===a?a:1.70158,this._p2=1.525*this._p1},!0),e=d.prototype=new a;return e.constructor=d,e.getRatio=c,e.config=function(a){return new d(a)},d},o=l(\"Back\",n(\"BackOut\",function(a){return(a-=1)*a*((this._p1+1)*a+this._p1)+1}),n(\"BackIn\",function(a){return a*a*((this._p1+1)*a-this._p1)}),n(\"BackInOut\",function(a){return(a*=2)<1?.5*a*a*((this._p2+1)*a-this._p2):.5*((a-=2)*a*((this._p2+1)*a+this._p2)+2)})),p=i(\"easing.SlowMo\",function(a,b,c){b=b||0===b?b:.7,null==a?a=.7:a>1&&(a=1),this._p=1!==a?b:0,this._p1=(1-a)/2,this._p2=a,this._p3=this._p1+this._p2,this._calcEnd=c===!0},!0),q=p.prototype=new a;return q.constructor=p,q.getRatio=function(a){var b=a+(.5-a)*this._p;return a<this._p1?this._calcEnd?1-(a=1-a/this._p1)*a:b-(a=1-a/this._p1)*a*a*a*b:a>this._p3?this._calcEnd?1-(a=(a-this._p3)/this._p1)*a:b+(a-b)*(a=(a-this._p3)/this._p1)*a*a*a:this._calcEnd?1:b},p.ease=new p(.7,.7),q.config=p.config=function(a,b,c){return new p(a,b,c)},b=i(\"easing.SteppedEase\",function(a){a=a||1,this._p1=1/a,this._p2=a+1},!0),q=b.prototype=new a,q.constructor=b,q.getRatio=function(a){return 0>a?a=0:a>=1&&(a=.999999999),(this._p2*a>>0)*this._p1},q.config=b.config=function(a){return new b(a)},c=i(\"easing.RoughEase\",function(b){b=b||{};for(var c,d,e,f,g,h,i=b.taper||\"none\",j=[],k=0,l=0|(b.points||20),n=l,o=b.randomize!==!1,p=b.clamp===!0,q=b.template instanceof a?b.template:null,r=\"number\"==typeof b.strength?.4*b.strength:.4;--n>-1;)c=o?Math.random():1/l*n,d=q?q.getRatio(c):c,\"none\"===i?e=r:\"out\"===i?(f=1-c,e=f*f*r):\"in\"===i?e=c*c*r:.5>c?(f=2*c,e=f*f*.5*r):(f=2*(1-c),e=f*f*.5*r),o?d+=Math.random()*e-.5*e:n%2?d+=.5*e:d-=.5*e,p&&(d>1?d=1:0>d&&(d=0)),j[k++]={x:c,y:d};for(j.sort(function(a,b){return a.x-b.x}),h=new m(1,1,null),n=l;--n>-1;)g=j[n],h=new m(g.x,g.y,h);this._prev=new m(0,0,0!==h.t?h:h.next)},!0),q=c.prototype=new a,q.constructor=c,q.getRatio=function(a){var b=this._prev;if(a>b.t){for(;b.next&&a>=b.t;)b=b.next;b=b.prev}else for(;b.prev&&a<=b.t;)b=b.prev;return this._prev=b,b.v+(a-b.t)/b.gap*b.c},q.config=function(a){return new c(a)},c.ease=new c,l(\"Bounce\",j(\"BounceOut\",function(a){return 1/2.75>a?7.5625*a*a:2/2.75>a?7.5625*(a-=1.5/2.75)*a+.75:2.5/2.75>a?7.5625*(a-=2.25/2.75)*a+.9375:7.5625*(a-=2.625/2.75)*a+.984375}),j(\"BounceIn\",function(a){return(a=1-a)<1/2.75?1-7.5625*a*a:2/2.75>a?1-(7.5625*(a-=1.5/2.75)*a+.75):2.5/2.75>a?1-(7.5625*(a-=2.25/2.75)*a+.9375):1-(7.5625*(a-=2.625/2.75)*a+.984375)}),j(\"BounceInOut\",function(a){var b=.5>a;return a=b?1-2*a:2*a-1,a=1/2.75>a?7.5625*a*a:2/2.75>a?7.5625*(a-=1.5/2.75)*a+.75:2.5/2.75>a?7.5625*(a-=2.25/2.75)*a+.9375:7.5625*(a-=2.625/2.75)*a+.984375,b?.5*(1-a):.5*a+.5})),l(\"Circ\",j(\"CircOut\",function(a){return Math.sqrt(1-(a-=1)*a)}),j(\"CircIn\",function(a){return-(Math.sqrt(1-a*a)-1)}),j(\"CircInOut\",function(a){return(a*=2)<1?-.5*(Math.sqrt(1-a*a)-1):.5*(Math.sqrt(1-(a-=2)*a)+1)})),d=function(b,c,d){var e=i(\"easing.\"+b,function(a,b){this._p1=a>=1?a:1,this._p2=(b||d)/(1>a?a:1),this._p3=this._p2/g*(Math.asin(1/this._p1)||0),this._p2=g/this._p2},!0),f=e.prototype=new a;return f.constructor=e,f.getRatio=c,f.config=function(a,b){return new e(a,b)},e},l(\"Elastic\",d(\"ElasticOut\",function(a){return this._p1*Math.pow(2,-10*a)*Math.sin((a-this._p3)*this._p2)+1},.3),d(\"ElasticIn\",function(a){return-(this._p1*Math.pow(2,10*(a-=1))*Math.sin((a-this._p3)*this._p2))},.3),d(\"ElasticInOut\",function(a){return(a*=2)<1?-.5*(this._p1*Math.pow(2,10*(a-=1))*Math.sin((a-this._p3)*this._p2)):this._p1*Math.pow(2,-10*(a-=1))*Math.sin((a-this._p3)*this._p2)*.5+1},.45)),l(\"Expo\",j(\"ExpoOut\",function(a){return 1-Math.pow(2,-10*a)}),j(\"ExpoIn\",function(a){return Math.pow(2,10*(a-1))-.001}),j(\"ExpoInOut\",function(a){return(a*=2)<1?.5*Math.pow(2,10*(a-1)):.5*(2-Math.pow(2,-10*(a-1)))})),l(\"Sine\",j(\"SineOut\",function(a){return Math.sin(a*h)}),j(\"SineIn\",function(a){return-Math.cos(a*h)+1}),j(\"SineInOut\",function(a){return-.5*(Math.cos(Math.PI*a)-1)})),i(\"easing.EaseLookup\",{find:function(b){return a.map[b]}},!0),k(e.SlowMo,\"SlowMo\",\"ease,\"),k(c,\"RoughEase\",\"ease,\"),k(b,\"SteppedEase\",\"ease,\"),o},!0)}),_gsScope._gsDefine&&_gsScope._gsQueue.pop()(),function(a,b){\"use strict\";var c=a.GreenSockGlobals=a.GreenSockGlobals||a;if(!c.TweenLite){var d,e,f,g,h,i=function(a){var b,d=a.split(\".\"),e=c;for(b=0;b<d.length;b++)e[d[b]]=e=e[d[b]]||{};return e},j=i(\"com.greensock\"),k=1e-10,l=function(a){var b,c=[],d=a.length;for(b=0;b!==d;c.push(a[b++]));return c},m=function(){},n=function(){var a=Object.prototype.toString,b=a.call([]);return function(c){return null!=c&&(c instanceof Array||\"object\"==typeof c&&!!c.push&&a.call(c)===b)}}(),o={},p=function(d,e,f,g){this.sc=o[d]?o[d].sc:[],o[d]=this,this.gsClass=null,this.func=f;var h=[];this.check=function(j){for(var k,l,m,n,q,r=e.length,s=r;--r>-1;)(k=o[e[r]]||new p(e[r],[])).gsClass?(h[r]=k.gsClass,s--):j&&k.sc.push(this);if(0===s&&f)for(l=(\"com.greensock.\"+d).split(\".\"),m=l.pop(),n=i(l.join(\".\"))[m]=this.gsClass=f.apply(f,h),g&&(c[m]=n,q=\"undefined\"!=typeof module&&module.exports,!q&&\"function\"==typeof define&&define.amd?define((a.GreenSockAMDPath?a.GreenSockAMDPath+\"/\":\"\")+d.split(\".\").pop(),[],function(){return n}):d===b&&q&&(module.exports=n)),r=0;r<this.sc.length;r++)this.sc[r].check()},this.check(!0)},q=a._gsDefine=function(a,b,c,d){return new p(a,b,c,d)},r=j._class=function(a,b,c){return b=b||function(){},q(a,[],function(){return b},c),b};q.globals=c;var s=[0,0,1,1],t=[],u=r(\"easing.Ease\",function(a,b,c,d){this._func=a,this._type=c||0,this._power=d||0,this._params=b?s.concat(b):s},!0),v=u.map={},w=u.register=function(a,b,c,d){for(var e,f,g,h,i=b.split(\",\"),k=i.length,l=(c||\"easeIn,easeOut,easeInOut\").split(\",\");--k>-1;)for(f=i[k],e=d?r(\"easing.\"+f,null,!0):j.easing[f]||{},g=l.length;--g>-1;)h=l[g],v[f+\".\"+h]=v[h+f]=e[h]=a.getRatio?a:a[h]||new a};for(f=u.prototype,f._calcEnd=!1,f.getRatio=function(a){if(this._func)return this._params[0]=a,this._func.apply(null,this._params);var b=this._type,c=this._power,d=1===b?1-a:2===b?a:.5>a?2*a:2*(1-a);return 1===c?d*=d:2===c?d*=d*d:3===c?d*=d*d*d:4===c&&(d*=d*d*d*d),1===b?1-d:2===b?d:.5>a?d/2:1-d/2},d=[\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint,Strong\"],e=d.length;--e>-1;)f=d[e]+\",Power\"+e,w(new u(null,null,1,e),f,\"easeOut\",!0),w(new u(null,null,2,e),f,\"easeIn\"+(0===e?\",easeNone\":\"\")),w(new u(null,null,3,e),f,\"easeInOut\");v.linear=j.easing.Linear.easeIn,v.swing=j.easing.Quad.easeInOut;var x=r(\"events.EventDispatcher\",function(a){this._listeners={},this._eventTarget=a||this});f=x.prototype,f.addEventListener=function(a,b,c,d,e){e=e||0;var f,i,j=this._listeners[a],k=0;for(null==j&&(this._listeners[a]=j=[]),i=j.length;--i>-1;)f=j[i],f.c===b&&f.s===c?j.splice(i,1):0===k&&f.pr<e&&(k=i+1);j.splice(k,0,{c:b,s:c,up:d,pr:e}),this!==g||h||g.wake()},f.removeEventListener=function(a,b){var c,d=this._listeners[a];if(d)for(c=d.length;--c>-1;)if(d[c].c===b)return void d.splice(c,1)},f.dispatchEvent=function(a){var b,c,d,e=this._listeners[a];if(e)for(b=e.length,c=this._eventTarget;--b>-1;)d=e[b],d&&(d.up?d.c.call(d.s||c,{type:a,target:c}):d.c.call(d.s||c))};var y=a.requestAnimationFrame,z=a.cancelAnimationFrame,A=Date.now||function(){return(new Date).getTime()},B=A();for(d=[\"ms\",\"moz\",\"webkit\",\"o\"],e=d.length;--e>-1&&!y;)y=a[d[e]+\"RequestAnimationFrame\"],z=a[d[e]+\"CancelAnimationFrame\"]||a[d[e]+\"CancelRequestAnimationFrame\"];r(\"Ticker\",function(a,b){var c,d,e,f,i,j=this,l=A(),n=b!==!1&&y?\"auto\":!1,o=500,p=33,q=\"tick\",r=function(a){var b,g,h=A()-B;h>o&&(l+=h-p),B+=h,j.time=(B-l)/1e3,b=j.time-i,(!c||b>0||a===!0)&&(j.frame++,i+=b+(b>=f?.004:f-b),g=!0),a!==!0&&(e=d(r)),g&&j.dispatchEvent(q)};x.call(j),j.time=j.frame=0,j.tick=function(){r(!0)},j.lagSmoothing=function(a,b){o=a||1/k,p=Math.min(b,o,0)},j.sleep=function(){null!=e&&(n&&z?z(e):clearTimeout(e),d=m,e=null,j===g&&(h=!1))},j.wake=function(a){null!==e?j.sleep():a?l+=-B+(B=A()):j.frame>10&&(B=A()-o+5),d=0===c?m:n&&y?y:function(a){return setTimeout(a,1e3*(i-j.time)+1|0)},j===g&&(h=!0),r(2)},j.fps=function(a){return arguments.length?(c=a,f=1/(c||60),i=this.time+f,void j.wake()):c},j.useRAF=function(a){return arguments.length?(j.sleep(),n=a,void j.fps(c)):n},j.fps(a),setTimeout(function(){\"auto\"===n&&j.frame<5&&\"hidden\"!==document.visibilityState&&j.useRAF(!1)},1500)}),f=j.Ticker.prototype=new j.events.EventDispatcher,f.constructor=j.Ticker;var C=r(\"core.Animation\",function(a,b){if(this.vars=b=b||{},this._duration=this._totalDuration=a||0,this._delay=Number(b.delay)||0,this._timeScale=1,this._active=b.immediateRender===!0,this.data=b.data,this._reversed=b.reversed===!0,V){h||g.wake();var c=this.vars.useFrames?U:V;c.add(this,c._time),this.vars.paused&&this.paused(!0)}});g=C.ticker=new j.Ticker,f=C.prototype,f._dirty=f._gc=f._initted=f._paused=!1,f._totalTime=f._time=0,f._rawPrevTime=-1,f._next=f._last=f._onUpdate=f._timeline=f.timeline=null,f._paused=!1;var D=function(){h&&A()-B>2e3&&g.wake(),setTimeout(D,2e3)};D(),f.play=function(a,b){return null!=a&&this.seek(a,b),this.reversed(!1).paused(!1)},f.pause=function(a,b){return null!=a&&this.seek(a,b),this.paused(!0)},f.resume=function(a,b){return null!=a&&this.seek(a,b),this.paused(!1)},f.seek=function(a,b){return this.totalTime(Number(a),b!==!1)},f.restart=function(a,b){return this.reversed(!1).paused(!1).totalTime(a?-this._delay:0,b!==!1,!0)},f.reverse=function(a,b){return null!=a&&this.seek(a||this.totalDuration(),b),this.reversed(!0).paused(!1)},f.render=function(a,b,c){},f.invalidate=function(){return this._time=this._totalTime=0,this._initted=this._gc=!1,this._rawPrevTime=-1,(this._gc||!this.timeline)&&this._enabled(!0),this},f.isActive=function(){var a,b=this._timeline,c=this._startTime;return!b||!this._gc&&!this._paused&&b.isActive()&&(a=b.rawTime())>=c&&a<c+this.totalDuration()/this._timeScale},f._enabled=function(a,b){return h||g.wake(),this._gc=!a,this._active=this.isActive(),b!==!0&&(a&&!this.timeline?this._timeline.add(this,this._startTime-this._delay):!a&&this.timeline&&this._timeline._remove(this,!0)),!1},f._kill=function(a,b){return this._enabled(!1,!1)},f.kill=function(a,b){return this._kill(a,b),this},f._uncache=function(a){for(var b=a?this:this.timeline;b;)b._dirty=!0,b=b.timeline;return this},f._swapSelfInParams=function(a){for(var b=a.length,c=a.concat();--b>-1;)\"{self}\"===a[b]&&(c[b]=this);return c},f._callback=function(a){var b=this.vars;b[a].apply(b[a+\"Scope\"]||b.callbackScope||this,b[a+\"Params\"]||t)},f.eventCallback=function(a,b,c,d){if(\"on\"===(a||\"\").substr(0,2)){var e=this.vars;if(1===arguments.length)return e[a];null==b?delete e[a]:(e[a]=b,e[a+\"Params\"]=n(c)&&-1!==c.join(\"\").indexOf(\"{self}\")?this._swapSelfInParams(c):c,e[a+\"Scope\"]=d),\"onUpdate\"===a&&(this._onUpdate=b)}return this},f.delay=function(a){return arguments.length?(this._timeline.smoothChildTiming&&this.startTime(this._startTime+a-this._delay),this._delay=a,this):this._delay},f.duration=function(a){return arguments.length?(this._duration=this._totalDuration=a,this._uncache(!0),this._timeline.smoothChildTiming&&this._time>0&&this._time<this._duration&&0!==a&&this.totalTime(this._totalTime*(a/this._duration),!0),this):(this._dirty=!1,this._duration)},f.totalDuration=function(a){return this._dirty=!1,arguments.length?this.duration(a):this._totalDuration},f.time=function(a,b){return arguments.length?(this._dirty&&this.totalDuration(),this.totalTime(a>this._duration?this._duration:a,b)):this._time},f.totalTime=function(a,b,c){if(h||g.wake(),!arguments.length)return this._totalTime;if(this._timeline){if(0>a&&!c&&(a+=this.totalDuration()),this._timeline.smoothChildTiming){this._dirty&&this.totalDuration();var d=this._totalDuration,e=this._timeline;if(a>d&&!c&&(a=d),this._startTime=(this._paused?this._pauseTime:e._time)-(this._reversed?d-a:a)/this._timeScale,e._dirty||this._uncache(!1),e._timeline)for(;e._timeline;)e._timeline._time!==(e._startTime+e._totalTime)/e._timeScale&&e.totalTime(e._totalTime,!0),e=e._timeline}this._gc&&this._enabled(!0,!1),(this._totalTime!==a||0===this._duration)&&(I.length&&X(),this.render(a,b,!1),I.length&&X())}return this},f.progress=f.totalProgress=function(a,b){var c=this.duration();return arguments.length?this.totalTime(c*a,b):c?this._time/c:this.ratio},f.startTime=function(a){return arguments.length?(a!==this._startTime&&(this._startTime=a,this.timeline&&this.timeline._sortChildren&&this.timeline.add(this,a-this._delay)),this):this._startTime},f.endTime=function(a){return this._startTime+(0!=a?this.totalDuration():this.duration())/this._timeScale},f.timeScale=function(a){if(!arguments.length)return this._timeScale;if(a=a||k,this._timeline&&this._timeline.smoothChildTiming){var b=this._pauseTime,c=b||0===b?b:this._timeline.totalTime();this._startTime=c-(c-this._startTime)*this._timeScale/a}return this._timeScale=a,this._uncache(!1)},f.reversed=function(a){return arguments.length?(a!=this._reversed&&(this._reversed=a,this.totalTime(this._timeline&&!this._timeline.smoothChildTiming?this.totalDuration()-this._totalTime:this._totalTime,!0)),this):this._reversed},f.paused=function(a){if(!arguments.length)return this._paused;var b,c,d=this._timeline;return a!=this._paused&&d&&(h||a||g.wake(),b=d.rawTime(),c=b-this._pauseTime,!a&&d.smoothChildTiming&&(this._startTime+=c,this._uncache(!1)),this._pauseTime=a?b:null,this._paused=a,this._active=this.isActive(),!a&&0!==c&&this._initted&&this.duration()&&(b=d.smoothChildTiming?this._totalTime:(b-this._startTime)/this._timeScale,this.render(b,b===this._totalTime,!0))),this._gc&&!a&&this._enabled(!0,!1),this};var E=r(\"core.SimpleTimeline\",function(a){C.call(this,0,a),this.autoRemoveChildren=this.smoothChildTiming=!0});f=E.prototype=new C,f.constructor=E,f.kill()._gc=!1,f._first=f._last=f._recent=null,f._sortChildren=!1,f.add=f.insert=function(a,b,c,d){var e,f;if(a._startTime=Number(b||0)+a._delay,a._paused&&this!==a._timeline&&(a._pauseTime=a._startTime+(this.rawTime()-a._startTime)/a._timeScale),a.timeline&&a.timeline._remove(a,!0),a.timeline=a._timeline=this,a._gc&&a._enabled(!0,!0),e=this._last,this._sortChildren)for(f=a._startTime;e&&e._startTime>f;)e=e._prev;return e?(a._next=e._next,e._next=a):(a._next=this._first,this._first=a),a._next?a._next._prev=a:this._last=a,a._prev=e,this._recent=a,this._timeline&&this._uncache(!0),this},f._remove=function(a,b){return a.timeline===this&&(b||a._enabled(!1,!0),a._prev?a._prev._next=a._next:this._first===a&&(this._first=a._next),a._next?a._next._prev=a._prev:this._last===a&&(this._last=a._prev),a._next=a._prev=a.timeline=null,a===this._recent&&(this._recent=this._last),this._timeline&&this._uncache(!0)),this},f.render=function(a,b,c){var d,e=this._first;for(this._totalTime=this._time=this._rawPrevTime=a;e;)d=e._next,(e._active||a>=e._startTime&&!e._paused)&&(e._reversed?e.render((e._dirty?e.totalDuration():e._totalDuration)-(a-e._startTime)*e._timeScale,b,c):e.render((a-e._startTime)*e._timeScale,b,c)),e=d},f.rawTime=function(){return h||g.wake(),this._totalTime};var F=r(\"TweenLite\",function(b,c,d){if(C.call(this,c,d),this.render=F.prototype.render,null==b)throw\"Cannot tween a null target.\";this.target=b=\"string\"!=typeof b?b:F.selector(b)||b;var e,f,g,h=b.jquery||b.length&&b!==a&&b[0]&&(b[0]===a||b[0].nodeType&&b[0].style&&!b.nodeType),i=this.vars.overwrite;if(this._overwrite=i=null==i?T[F.defaultOverwrite]:\"number\"==typeof i?i>>0:T[i],(h||b instanceof Array||b.push&&n(b))&&\"number\"!=typeof b[0])for(this._targets=g=l(b),this._propLookup=[],this._siblings=[],e=0;e<g.length;e++)f=g[e],f?\"string\"!=typeof f?f.length&&f!==a&&f[0]&&(f[0]===a||f[0].nodeType&&f[0].style&&!f.nodeType)?(g.splice(e--,1),this._targets=g=g.concat(l(f))):(this._siblings[e]=Y(f,this,!1),1===i&&this._siblings[e].length>1&&$(f,this,null,1,this._siblings[e])):(f=g[e--]=F.selector(f),\"string\"==typeof f&&g.splice(e+1,1)):g.splice(e--,1);else this._propLookup={},this._siblings=Y(b,this,!1),1===i&&this._siblings.length>1&&$(b,this,null,1,this._siblings);(this.vars.immediateRender||0===c&&0===this._delay&&this.vars.immediateRender!==!1)&&(this._time=-k,this.render(-this._delay))},!0),G=function(b){return b&&b.length&&b!==a&&b[0]&&(b[0]===a||b[0].nodeType&&b[0].style&&!b.nodeType)},H=function(a,b){var c,d={};for(c in a)S[c]||c in b&&\"transform\"!==c&&\"x\"!==c&&\"y\"!==c&&\"width\"!==c&&\"height\"!==c&&\"className\"!==c&&\"border\"!==c||!(!P[c]||P[c]&&P[c]._autoCSS)||(d[c]=a[c],delete a[c]);a.css=d};f=F.prototype=new C,f.constructor=F,f.kill()._gc=!1,f.ratio=0,f._firstPT=f._targets=f._overwrittenProps=f._startAt=null,f._notifyPluginsOfEnabled=f._lazy=!1,F.version=\"1.18.2\",F.defaultEase=f._ease=new u(null,null,1,1),F.defaultOverwrite=\"auto\",F.ticker=g,F.autoSleep=120,F.lagSmoothing=function(a,b){g.lagSmoothing(a,b)},F.selector=a.$||a.jQuery||function(b){var c=a.$||a.jQuery;return c?(F.selector=c,c(b)):\"undefined\"==typeof document?b:document.querySelectorAll?document.querySelectorAll(b):document.getElementById(\"#\"===b.charAt(0)?b.substr(1):b)};var I=[],J={},K=/(?:(-|-=|\\+=)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/gi,L=function(a){for(var b,c=this._firstPT,d=1e-6;c;)b=c.blob?a?this.join(\"\"):this.start:c.c*a+c.s,c.r?b=Math.round(b):d>b&&b>-d&&(b=0),c.f?c.fp?c.t[c.p](c.fp,b):c.t[c.p](b):c.t[c.p]=b,c=c._next},M=function(a,b,c,d){var e,f,g,h,i,j,k,l=[a,b],m=0,n=\"\",o=0;for(l.start=a,c&&(c(l),a=l[0],b=l[1]),l.length=0,e=a.match(K)||[],f=b.match(K)||[],d&&(d._next=null,d.blob=1,l._firstPT=d),i=f.length,h=0;i>h;h++)k=f[h],j=b.substr(m,b.indexOf(k,m)-m),n+=j||!h?j:\",\",m+=j.length,o?o=(o+1)%5:\"rgba(\"===j.substr(-5)&&(o=1),k===e[h]||e.length<=h?n+=k:(n&&(l.push(n),n=\"\"),g=parseFloat(e[h]),l.push(g),l._firstPT={_next:l._firstPT,t:l,p:l.length-1,s:g,c:(\"=\"===k.charAt(1)?parseInt(k.charAt(0)+\"1\",10)*parseFloat(k.substr(2)):parseFloat(k)-g)||0,f:0,r:o&&4>o}),m+=k.length;return n+=b.substr(m),n&&l.push(n),l.setRatio=L,l},N=function(a,b,c,d,e,f,g,h){var i,j,k=\"get\"===c?a[b]:c,l=typeof a[b],m=\"string\"==typeof d&&\"=\"===d.charAt(1),n={t:a,p:b,s:k,f:\"function\"===l,pg:0,n:e||b,r:f,pr:0,c:m?parseInt(d.charAt(0)+\"1\",10)*parseFloat(d.substr(2)):parseFloat(d)-k||0};return\"number\"!==l&&(\"function\"===l&&\"get\"===c&&(j=b.indexOf(\"set\")||\"function\"!=typeof a[\"get\"+b.substr(3)]?b:\"get\"+b.substr(3),n.s=k=g?a[j](g):a[j]()),\"string\"==typeof k&&(g||isNaN(k))?(n.fp=g,i=M(k,d,h||F.defaultStringFilter,n),n={t:i,p:\"setRatio\",s:0,c:1,f:2,pg:0,n:e||b,pr:0}):m||(n.s=parseFloat(k),n.c=parseFloat(d)-n.s||0)),n.c?((n._next=this._firstPT)&&(n._next._prev=n),this._firstPT=n,n):void 0},O=F._internals={isArray:n,isSelector:G,lazyTweens:I,blobDif:M},P=F._plugins={},Q=O.tweenLookup={},R=0,S=O.reservedProps={ease:1,delay:1,overwrite:1,onComplete:1,onCompleteParams:1,onCompleteScope:1,useFrames:1,runBackwards:1,startAt:1,onUpdate:1,onUpdateParams:1,onUpdateScope:1,onStart:1,onStartParams:1,onStartScope:1,onReverseComplete:1,onReverseCompleteParams:1,onReverseCompleteScope:1,onRepeat:1,onRepeatParams:1,onRepeatScope:1,easeParams:1,yoyo:1,immediateRender:1,repeat:1,repeatDelay:1,data:1,paused:1,reversed:1,autoCSS:1,lazy:1,onOverwrite:1,callbackScope:1,stringFilter:1},T={none:0,all:1,auto:2,concurrent:3,allOnStart:4,preexisting:5,\"true\":1,\"false\":0},U=C._rootFramesTimeline=new E,V=C._rootTimeline=new E,W=30,X=O.lazyRender=function(){\nvar a,b=I.length;for(J={};--b>-1;)a=I[b],a&&a._lazy!==!1&&(a.render(a._lazy[0],a._lazy[1],!0),a._lazy=!1);I.length=0};V._startTime=g.time,U._startTime=g.frame,V._active=U._active=!0,setTimeout(X,1),C._updateRoot=F.render=function(){var a,b,c;if(I.length&&X(),V.render((g.time-V._startTime)*V._timeScale,!1,!1),U.render((g.frame-U._startTime)*U._timeScale,!1,!1),I.length&&X(),g.frame>=W){W=g.frame+(parseInt(F.autoSleep,10)||120);for(c in Q){for(b=Q[c].tweens,a=b.length;--a>-1;)b[a]._gc&&b.splice(a,1);0===b.length&&delete Q[c]}if(c=V._first,(!c||c._paused)&&F.autoSleep&&!U._first&&1===g._listeners.tick.length){for(;c&&c._paused;)c=c._next;c||g.sleep()}}},g.addEventListener(\"tick\",C._updateRoot);var Y=function(a,b,c){var d,e,f=a._gsTweenID;if(Q[f||(a._gsTweenID=f=\"t\"+R++)]||(Q[f]={target:a,tweens:[]}),b&&(d=Q[f].tweens,d[e=d.length]=b,c))for(;--e>-1;)d[e]===b&&d.splice(e,1);return Q[f].tweens},Z=function(a,b,c,d){var e,f,g=a.vars.onOverwrite;return g&&(e=g(a,b,c,d)),g=F.onOverwrite,g&&(f=g(a,b,c,d)),e!==!1&&f!==!1},$=function(a,b,c,d,e){var f,g,h,i;if(1===d||d>=4){for(i=e.length,f=0;i>f;f++)if((h=e[f])!==b)h._gc||h._kill(null,a,b)&&(g=!0);else if(5===d)break;return g}var j,l=b._startTime+k,m=[],n=0,o=0===b._duration;for(f=e.length;--f>-1;)(h=e[f])===b||h._gc||h._paused||(h._timeline!==b._timeline?(j=j||_(b,0,o),0===_(h,j,o)&&(m[n++]=h)):h._startTime<=l&&h._startTime+h.totalDuration()/h._timeScale>l&&((o||!h._initted)&&l-h._startTime<=2e-10||(m[n++]=h)));for(f=n;--f>-1;)if(h=m[f],2===d&&h._kill(c,a,b)&&(g=!0),2!==d||!h._firstPT&&h._initted){if(2!==d&&!Z(h,b))continue;h._enabled(!1,!1)&&(g=!0)}return g},_=function(a,b,c){for(var d=a._timeline,e=d._timeScale,f=a._startTime;d._timeline;){if(f+=d._startTime,e*=d._timeScale,d._paused)return-100;d=d._timeline}return f/=e,f>b?f-b:c&&f===b||!a._initted&&2*k>f-b?k:(f+=a.totalDuration()/a._timeScale/e)>b+k?0:f-b-k};f._init=function(){var a,b,c,d,e,f=this.vars,g=this._overwrittenProps,h=this._duration,i=!!f.immediateRender,j=f.ease;if(f.startAt){this._startAt&&(this._startAt.render(-1,!0),this._startAt.kill()),e={};for(d in f.startAt)e[d]=f.startAt[d];if(e.overwrite=!1,e.immediateRender=!0,e.lazy=i&&f.lazy!==!1,e.startAt=e.delay=null,this._startAt=F.to(this.target,0,e),i)if(this._time>0)this._startAt=null;else if(0!==h)return}else if(f.runBackwards&&0!==h)if(this._startAt)this._startAt.render(-1,!0),this._startAt.kill(),this._startAt=null;else{0!==this._time&&(i=!1),c={};for(d in f)S[d]&&\"autoCSS\"!==d||(c[d]=f[d]);if(c.overwrite=0,c.data=\"isFromStart\",c.lazy=i&&f.lazy!==!1,c.immediateRender=i,this._startAt=F.to(this.target,0,c),i){if(0===this._time)return}else this._startAt._init(),this._startAt._enabled(!1),this.vars.immediateRender&&(this._startAt=null)}if(this._ease=j=j?j instanceof u?j:\"function\"==typeof j?new u(j,f.easeParams):v[j]||F.defaultEase:F.defaultEase,f.easeParams instanceof Array&&j.config&&(this._ease=j.config.apply(j,f.easeParams)),this._easeType=this._ease._type,this._easePower=this._ease._power,this._firstPT=null,this._targets)for(a=this._targets.length;--a>-1;)this._initProps(this._targets[a],this._propLookup[a]={},this._siblings[a],g?g[a]:null)&&(b=!0);else b=this._initProps(this.target,this._propLookup,this._siblings,g);if(b&&F._onPluginEvent(\"_onInitAllProps\",this),g&&(this._firstPT||\"function\"!=typeof this.target&&this._enabled(!1,!1)),f.runBackwards)for(c=this._firstPT;c;)c.s+=c.c,c.c=-c.c,c=c._next;this._onUpdate=f.onUpdate,this._initted=!0},f._initProps=function(b,c,d,e){var f,g,h,i,j,k;if(null==b)return!1;J[b._gsTweenID]&&X(),this.vars.css||b.style&&b!==a&&b.nodeType&&P.css&&this.vars.autoCSS!==!1&&H(this.vars,b);for(f in this.vars)if(k=this.vars[f],S[f])k&&(k instanceof Array||k.push&&n(k))&&-1!==k.join(\"\").indexOf(\"{self}\")&&(this.vars[f]=k=this._swapSelfInParams(k,this));else if(P[f]&&(i=new P[f])._onInitTween(b,this.vars[f],this)){for(this._firstPT=j={_next:this._firstPT,t:i,p:\"setRatio\",s:0,c:1,f:1,n:f,pg:1,pr:i._priority},g=i._overwriteProps.length;--g>-1;)c[i._overwriteProps[g]]=this._firstPT;(i._priority||i._onInitAllProps)&&(h=!0),(i._onDisable||i._onEnable)&&(this._notifyPluginsOfEnabled=!0),j._next&&(j._next._prev=j)}else c[f]=N.call(this,b,f,\"get\",k,f,0,null,this.vars.stringFilter);return e&&this._kill(e,b)?this._initProps(b,c,d,e):this._overwrite>1&&this._firstPT&&d.length>1&&$(b,this,c,this._overwrite,d)?(this._kill(c,b),this._initProps(b,c,d,e)):(this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration)&&(J[b._gsTweenID]=!0),h)},f.render=function(a,b,c){var d,e,f,g,h=this._time,i=this._duration,j=this._rawPrevTime;if(a>=i-1e-7)this._totalTime=this._time=i,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1,this._reversed||(d=!0,e=\"onComplete\",c=c||this._timeline.autoRemoveChildren),0===i&&(this._initted||!this.vars.lazy||c)&&(this._startTime===this._timeline._duration&&(a=0),(0>j||0>=a&&a>=-1e-7||j===k&&\"isPause\"!==this.data)&&j!==a&&(c=!0,j>k&&(e=\"onReverseComplete\")),this._rawPrevTime=g=!b||a||j===a?a:k);else if(1e-7>a)this._totalTime=this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==h||0===i&&j>0)&&(e=\"onReverseComplete\",d=this._reversed),0>a&&(this._active=!1,0===i&&(this._initted||!this.vars.lazy||c)&&(j>=0&&(j!==k||\"isPause\"!==this.data)&&(c=!0),this._rawPrevTime=g=!b||a||j===a?a:k)),this._initted||(c=!0);else if(this._totalTime=this._time=a,this._easeType){var l=a/i,m=this._easeType,n=this._easePower;(1===m||3===m&&l>=.5)&&(l=1-l),3===m&&(l*=2),1===n?l*=l:2===n?l*=l*l:3===n?l*=l*l*l:4===n&&(l*=l*l*l*l),1===m?this.ratio=1-l:2===m?this.ratio=l:.5>a/i?this.ratio=l/2:this.ratio=1-l/2}else this.ratio=this._ease.getRatio(a/i);if(this._time!==h||c){if(!this._initted){if(this._init(),!this._initted||this._gc)return;if(!c&&this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration))return this._time=this._totalTime=h,this._rawPrevTime=j,I.push(this),void(this._lazy=[a,b]);this._time&&!d?this.ratio=this._ease.getRatio(this._time/i):d&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._lazy!==!1&&(this._lazy=!1),this._active||!this._paused&&this._time!==h&&a>=0&&(this._active=!0),0===h&&(this._startAt&&(a>=0?this._startAt.render(a,b,c):e||(e=\"_dummyGS\")),this.vars.onStart&&(0!==this._time||0===i)&&(b||this._callback(\"onStart\"))),f=this._firstPT;f;)f.f?f.t[f.p](f.c*this.ratio+f.s):f.t[f.p]=f.c*this.ratio+f.s,f=f._next;this._onUpdate&&(0>a&&this._startAt&&a!==-1e-4&&this._startAt.render(a,b,c),b||(this._time!==h||d)&&this._callback(\"onUpdate\")),e&&(!this._gc||c)&&(0>a&&this._startAt&&!this._onUpdate&&a!==-1e-4&&this._startAt.render(a,b,c),d&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[e]&&this._callback(e),0===i&&this._rawPrevTime===k&&g!==k&&(this._rawPrevTime=0))}},f._kill=function(a,b,c){if(\"all\"===a&&(a=null),null==a&&(null==b||b===this.target))return this._lazy=!1,this._enabled(!1,!1);b=\"string\"!=typeof b?b||this._targets||this.target:F.selector(b)||b;var d,e,f,g,h,i,j,k,l,m=c&&this._time&&c._startTime===this._startTime&&this._timeline===c._timeline;if((n(b)||G(b))&&\"number\"!=typeof b[0])for(d=b.length;--d>-1;)this._kill(a,b[d],c)&&(i=!0);else{if(this._targets){for(d=this._targets.length;--d>-1;)if(b===this._targets[d]){h=this._propLookup[d]||{},this._overwrittenProps=this._overwrittenProps||[],e=this._overwrittenProps[d]=a?this._overwrittenProps[d]||{}:\"all\";break}}else{if(b!==this.target)return!1;h=this._propLookup,e=this._overwrittenProps=a?this._overwrittenProps||{}:\"all\"}if(h){if(j=a||h,k=a!==e&&\"all\"!==e&&a!==h&&(\"object\"!=typeof a||!a._tempKill),c&&(F.onOverwrite||this.vars.onOverwrite)){for(f in j)h[f]&&(l||(l=[]),l.push(f));if((l||!a)&&!Z(this,c,b,l))return!1}for(f in j)(g=h[f])&&(m&&(g.f?g.t[g.p](g.s):g.t[g.p]=g.s,i=!0),g.pg&&g.t._kill(j)&&(i=!0),g.pg&&0!==g.t._overwriteProps.length||(g._prev?g._prev._next=g._next:g===this._firstPT&&(this._firstPT=g._next),g._next&&(g._next._prev=g._prev),g._next=g._prev=null),delete h[f]),k&&(e[f]=1);!this._firstPT&&this._initted&&this._enabled(!1,!1)}}return i},f.invalidate=function(){return this._notifyPluginsOfEnabled&&F._onPluginEvent(\"_onDisable\",this),this._firstPT=this._overwrittenProps=this._startAt=this._onUpdate=null,this._notifyPluginsOfEnabled=this._active=this._lazy=!1,this._propLookup=this._targets?{}:[],C.prototype.invalidate.call(this),this.vars.immediateRender&&(this._time=-k,this.render(-this._delay)),this},f._enabled=function(a,b){if(h||g.wake(),a&&this._gc){var c,d=this._targets;if(d)for(c=d.length;--c>-1;)this._siblings[c]=Y(d[c],this,!0);else this._siblings=Y(this.target,this,!0)}return C.prototype._enabled.call(this,a,b),this._notifyPluginsOfEnabled&&this._firstPT?F._onPluginEvent(a?\"_onEnable\":\"_onDisable\",this):!1},F.to=function(a,b,c){return new F(a,b,c)},F.from=function(a,b,c){return c.runBackwards=!0,c.immediateRender=0!=c.immediateRender,new F(a,b,c)},F.fromTo=function(a,b,c,d){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,new F(a,b,d)},F.delayedCall=function(a,b,c,d,e){return new F(b,0,{delay:a,onComplete:b,onCompleteParams:c,callbackScope:d,onReverseComplete:b,onReverseCompleteParams:c,immediateRender:!1,lazy:!1,useFrames:e,overwrite:0})},F.set=function(a,b){return new F(a,0,b)},F.getTweensOf=function(a,b){if(null==a)return[];a=\"string\"!=typeof a?a:F.selector(a)||a;var c,d,e,f;if((n(a)||G(a))&&\"number\"!=typeof a[0]){for(c=a.length,d=[];--c>-1;)d=d.concat(F.getTweensOf(a[c],b));for(c=d.length;--c>-1;)for(f=d[c],e=c;--e>-1;)f===d[e]&&d.splice(c,1)}else for(d=Y(a).concat(),c=d.length;--c>-1;)(d[c]._gc||b&&!d[c].isActive())&&d.splice(c,1);return d},F.killTweensOf=F.killDelayedCallsTo=function(a,b,c){\"object\"==typeof b&&(c=b,b=!1);for(var d=F.getTweensOf(a,b),e=d.length;--e>-1;)d[e]._kill(c,a)};var aa=r(\"plugins.TweenPlugin\",function(a,b){this._overwriteProps=(a||\"\").split(\",\"),this._propName=this._overwriteProps[0],this._priority=b||0,this._super=aa.prototype},!0);if(f=aa.prototype,aa.version=\"1.18.0\",aa.API=2,f._firstPT=null,f._addTween=N,f.setRatio=L,f._kill=function(a){var b,c=this._overwriteProps,d=this._firstPT;if(null!=a[this._propName])this._overwriteProps=[];else for(b=c.length;--b>-1;)null!=a[c[b]]&&c.splice(b,1);for(;d;)null!=a[d.n]&&(d._next&&(d._next._prev=d._prev),d._prev?(d._prev._next=d._next,d._prev=null):this._firstPT===d&&(this._firstPT=d._next)),d=d._next;return!1},f._roundProps=function(a,b){for(var c=this._firstPT;c;)(a[this._propName]||null!=c.n&&a[c.n.split(this._propName+\"_\").join(\"\")])&&(c.r=b),c=c._next},F._onPluginEvent=function(a,b){var c,d,e,f,g,h=b._firstPT;if(\"_onInitAllProps\"===a){for(;h;){for(g=h._next,d=e;d&&d.pr>h.pr;)d=d._next;(h._prev=d?d._prev:f)?h._prev._next=h:e=h,(h._next=d)?d._prev=h:f=h,h=g}h=b._firstPT=e}for(;h;)h.pg&&\"function\"==typeof h.t[a]&&h.t[a]()&&(c=!0),h=h._next;return c},aa.activate=function(a){for(var b=a.length;--b>-1;)a[b].API===aa.API&&(P[(new a[b])._propName]=a[b]);return!0},q.plugin=function(a){if(!(a&&a.propName&&a.init&&a.API))throw\"illegal plugin definition.\";var b,c=a.propName,d=a.priority||0,e=a.overwriteProps,f={init:\"_onInitTween\",set:\"setRatio\",kill:\"_kill\",round:\"_roundProps\",initAll:\"_onInitAllProps\"},g=r(\"plugins.\"+c.charAt(0).toUpperCase()+c.substr(1)+\"Plugin\",function(){aa.call(this,c,d),this._overwriteProps=e||[]},a.global===!0),h=g.prototype=new aa(c);h.constructor=g,g.API=a.API;for(b in f)\"function\"==typeof a[b]&&(h[f[b]]=a[b]);return g.version=a.version,aa.activate([g]),g},d=a._gsQueue){for(e=0;e<d.length;e++)d[e]();for(f in o)o[f].func||a.console.log(\"GSAP encountered missing dependency: com.greensock.\"+f)}h=!1}}(\"undefined\"!=typeof module&&module.exports&&\"undefined\"!=typeof global?global:this||window,\"TweenMax\");\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC92ZW5kb3IvVHdlZW5NYXgubWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFZFUlNJT046IDEuMTguMlxuICogREFURTogMjAxNS0xMi0yMlxuICogVVBEQVRFUyBBTkQgRE9DUyBBVDogaHR0cDovL2dyZWVuc29jay5jb21cbiAqIFxuICogSW5jbHVkZXMgYWxsIG9mIHRoZSBmb2xsb3dpbmc6IFR3ZWVuTGl0ZSwgVHdlZW5NYXgsIFRpbWVsaW5lTGl0ZSwgVGltZWxpbmVNYXgsIEVhc2VQYWNrLCBDU1NQbHVnaW4sIFJvdW5kUHJvcHNQbHVnaW4sIEJlemllclBsdWdpbiwgQXR0clBsdWdpbiwgRGlyZWN0aW9uYWxSb3RhdGlvblBsdWdpblxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE2LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICogXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqKi9cbnZhciBfZ3NTY29wZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6dGhpc3x8d2luZG93OyhfZ3NTY29wZS5fZ3NRdWV1ZXx8KF9nc1Njb3BlLl9nc1F1ZXVlPVtdKSkucHVzaChmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO19nc1Njb3BlLl9nc0RlZmluZShcIlR3ZWVuTWF4XCIsW1wiY29yZS5BbmltYXRpb25cIixcImNvcmUuU2ltcGxlVGltZWxpbmVcIixcIlR3ZWVuTGl0ZVwiXSxmdW5jdGlvbihhLGIsYyl7dmFyIGQ9ZnVuY3Rpb24oYSl7dmFyIGIsYz1bXSxkPWEubGVuZ3RoO2ZvcihiPTA7YiE9PWQ7Yy5wdXNoKGFbYisrXSkpO3JldHVybiBjfSxlPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9YS5jeWNsZTtmb3IoZCBpbiBmKWU9ZltkXSxhW2RdPVwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZS5jYWxsKGJbY10sYyk6ZVtjJWUubGVuZ3RoXTtkZWxldGUgYS5jeWNsZX0sZj1mdW5jdGlvbihhLGIsZCl7Yy5jYWxsKHRoaXMsYSxiLGQpLHRoaXMuX2N5Y2xlPTAsdGhpcy5feW95bz10aGlzLnZhcnMueW95bz09PSEwLHRoaXMuX3JlcGVhdD10aGlzLnZhcnMucmVwZWF0fHwwLHRoaXMuX3JlcGVhdERlbGF5PXRoaXMudmFycy5yZXBlYXREZWxheXx8MCx0aGlzLl9kaXJ0eT0hMCx0aGlzLnJlbmRlcj1mLnByb3RvdHlwZS5yZW5kZXJ9LGc9MWUtMTAsaD1jLl9pbnRlcm5hbHMsaT1oLmlzU2VsZWN0b3Isaj1oLmlzQXJyYXksaz1mLnByb3RvdHlwZT1jLnRvKHt9LC4xLHt9KSxsPVtdO2YudmVyc2lvbj1cIjEuMTguMlwiLGsuY29uc3RydWN0b3I9ZixrLmtpbGwoKS5fZ2M9ITEsZi5raWxsVHdlZW5zT2Y9Zi5raWxsRGVsYXllZENhbGxzVG89Yy5raWxsVHdlZW5zT2YsZi5nZXRUd2VlbnNPZj1jLmdldFR3ZWVuc09mLGYubGFnU21vb3RoaW5nPWMubGFnU21vb3RoaW5nLGYudGlja2VyPWMudGlja2VyLGYucmVuZGVyPWMucmVuZGVyLGsuaW52YWxpZGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl95b3lvPXRoaXMudmFycy55b3lvPT09ITAsdGhpcy5fcmVwZWF0PXRoaXMudmFycy5yZXBlYXR8fDAsdGhpcy5fcmVwZWF0RGVsYXk9dGhpcy52YXJzLnJlcGVhdERlbGF5fHwwLHRoaXMuX3VuY2FjaGUoITApLGMucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKX0say51cGRhdGVUbz1mdW5jdGlvbihhLGIpe3ZhciBkLGU9dGhpcy5yYXRpbyxmPXRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXJ8fGEuaW1tZWRpYXRlUmVuZGVyO2ImJnRoaXMuX3N0YXJ0VGltZTx0aGlzLl90aW1lbGluZS5fdGltZSYmKHRoaXMuX3N0YXJ0VGltZT10aGlzLl90aW1lbGluZS5fdGltZSx0aGlzLl91bmNhY2hlKCExKSx0aGlzLl9nYz90aGlzLl9lbmFibGVkKCEwLCExKTp0aGlzLl90aW1lbGluZS5pbnNlcnQodGhpcyx0aGlzLl9zdGFydFRpbWUtdGhpcy5fZGVsYXkpKTtmb3IoZCBpbiBhKXRoaXMudmFyc1tkXT1hW2RdO2lmKHRoaXMuX2luaXR0ZWR8fGYpaWYoYil0aGlzLl9pbml0dGVkPSExLGYmJnRoaXMucmVuZGVyKDAsITAsITApO2Vsc2UgaWYodGhpcy5fZ2MmJnRoaXMuX2VuYWJsZWQoITAsITEpLHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQmJnRoaXMuX2ZpcnN0UFQmJmMuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsdGhpcyksdGhpcy5fdGltZS90aGlzLl9kdXJhdGlvbj4uOTk4KXt2YXIgZz10aGlzLl90b3RhbFRpbWU7dGhpcy5yZW5kZXIoMCwhMCwhMSksdGhpcy5faW5pdHRlZD0hMSx0aGlzLnJlbmRlcihnLCEwLCExKX1lbHNlIGlmKHRoaXMuX2luaXR0ZWQ9ITEsdGhpcy5faW5pdCgpLHRoaXMuX3RpbWU+MHx8Zilmb3IodmFyIGgsaT0xLygxLWUpLGo9dGhpcy5fZmlyc3RQVDtqOyloPWoucytqLmMsai5jKj1pLGoucz1oLWouYyxqPWouX25leHQ7cmV0dXJuIHRoaXN9LGsucmVuZGVyPWZ1bmN0aW9uKGEsYixjKXt0aGlzLl9pbml0dGVkfHwwPT09dGhpcy5fZHVyYXRpb24mJnRoaXMudmFycy5yZXBlYXQmJnRoaXMuaW52YWxpZGF0ZSgpO3ZhciBkLGUsZixpLGosayxsLG0sbj10aGlzLl9kaXJ0eT90aGlzLnRvdGFsRHVyYXRpb24oKTp0aGlzLl90b3RhbER1cmF0aW9uLG89dGhpcy5fdGltZSxwPXRoaXMuX3RvdGFsVGltZSxxPXRoaXMuX2N5Y2xlLHI9dGhpcy5fZHVyYXRpb24scz10aGlzLl9yYXdQcmV2VGltZTtpZihhPj1uLTFlLTc/KHRoaXMuX3RvdGFsVGltZT1uLHRoaXMuX2N5Y2xlPXRoaXMuX3JlcGVhdCx0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpPyh0aGlzLl90aW1lPTAsdGhpcy5yYXRpbz10aGlzLl9lYXNlLl9jYWxjRW5kP3RoaXMuX2Vhc2UuZ2V0UmF0aW8oMCk6MCk6KHRoaXMuX3RpbWU9cix0aGlzLnJhdGlvPXRoaXMuX2Vhc2UuX2NhbGNFbmQ/dGhpcy5fZWFzZS5nZXRSYXRpbygxKToxKSx0aGlzLl9yZXZlcnNlZHx8KGQ9ITAsZT1cIm9uQ29tcGxldGVcIixjPWN8fHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiksMD09PXImJih0aGlzLl9pbml0dGVkfHwhdGhpcy52YXJzLmxhenl8fGMpJiYodGhpcy5fc3RhcnRUaW1lPT09dGhpcy5fdGltZWxpbmUuX2R1cmF0aW9uJiYoYT0wKSwoMD5zfHwwPj1hJiZhPj0tMWUtN3x8cz09PWcmJlwiaXNQYXVzZVwiIT09dGhpcy5kYXRhKSYmcyE9PWEmJihjPSEwLHM+ZyYmKGU9XCJvblJldmVyc2VDb21wbGV0ZVwiKSksdGhpcy5fcmF3UHJldlRpbWU9bT0hYnx8YXx8cz09PWE/YTpnKSk6MWUtNz5hPyh0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT10aGlzLl9jeWNsZT0wLHRoaXMucmF0aW89dGhpcy5fZWFzZS5fY2FsY0VuZD90aGlzLl9lYXNlLmdldFJhdGlvKDApOjAsKDAhPT1wfHwwPT09ciYmcz4wKSYmKGU9XCJvblJldmVyc2VDb21wbGV0ZVwiLGQ9dGhpcy5fcmV2ZXJzZWQpLDA+YSYmKHRoaXMuX2FjdGl2ZT0hMSwwPT09ciYmKHRoaXMuX2luaXR0ZWR8fCF0aGlzLnZhcnMubGF6eXx8YykmJihzPj0wJiYoYz0hMCksdGhpcy5fcmF3UHJldlRpbWU9bT0hYnx8YXx8cz09PWE/YTpnKSksdGhpcy5faW5pdHRlZHx8KGM9ITApKToodGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9YSwwIT09dGhpcy5fcmVwZWF0JiYoaT1yK3RoaXMuX3JlcGVhdERlbGF5LHRoaXMuX2N5Y2xlPXRoaXMuX3RvdGFsVGltZS9pPj4wLDAhPT10aGlzLl9jeWNsZSYmdGhpcy5fY3ljbGU9PT10aGlzLl90b3RhbFRpbWUvaSYmdGhpcy5fY3ljbGUtLSx0aGlzLl90aW1lPXRoaXMuX3RvdGFsVGltZS10aGlzLl9jeWNsZSppLHRoaXMuX3lveW8mJjAhPT0oMSZ0aGlzLl9jeWNsZSkmJih0aGlzLl90aW1lPXItdGhpcy5fdGltZSksdGhpcy5fdGltZT5yP3RoaXMuX3RpbWU9cjp0aGlzLl90aW1lPDAmJih0aGlzLl90aW1lPTApKSx0aGlzLl9lYXNlVHlwZT8oaj10aGlzLl90aW1lL3Isaz10aGlzLl9lYXNlVHlwZSxsPXRoaXMuX2Vhc2VQb3dlciwoMT09PWt8fDM9PT1rJiZqPj0uNSkmJihqPTEtaiksMz09PWsmJihqKj0yKSwxPT09bD9qKj1qOjI9PT1sP2oqPWoqajozPT09bD9qKj1qKmoqajo0PT09bCYmKGoqPWoqaipqKmopLDE9PT1rP3RoaXMucmF0aW89MS1qOjI9PT1rP3RoaXMucmF0aW89ajp0aGlzLl90aW1lL3I8LjU/dGhpcy5yYXRpbz1qLzI6dGhpcy5yYXRpbz0xLWovMik6dGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUvcikpLG89PT10aGlzLl90aW1lJiYhYyYmcT09PXRoaXMuX2N5Y2xlKXJldHVybiB2b2lkKHAhPT10aGlzLl90b3RhbFRpbWUmJnRoaXMuX29uVXBkYXRlJiYoYnx8dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKSkpO2lmKCF0aGlzLl9pbml0dGVkKXtpZih0aGlzLl9pbml0KCksIXRoaXMuX2luaXR0ZWR8fHRoaXMuX2djKXJldHVybjtpZighYyYmdGhpcy5fZmlyc3RQVCYmKHRoaXMudmFycy5sYXp5IT09ITEmJnRoaXMuX2R1cmF0aW9ufHx0aGlzLnZhcnMubGF6eSYmIXRoaXMuX2R1cmF0aW9uKSlyZXR1cm4gdGhpcy5fdGltZT1vLHRoaXMuX3RvdGFsVGltZT1wLHRoaXMuX3Jhd1ByZXZUaW1lPXMsdGhpcy5fY3ljbGU9cSxoLmxhenlUd2VlbnMucHVzaCh0aGlzKSx2b2lkKHRoaXMuX2xhenk9W2EsYl0pO3RoaXMuX3RpbWUmJiFkP3RoaXMucmF0aW89dGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lL3IpOmQmJnRoaXMuX2Vhc2UuX2NhbGNFbmQmJih0aGlzLnJhdGlvPXRoaXMuX2Vhc2UuZ2V0UmF0aW8oMD09PXRoaXMuX3RpbWU/MDoxKSl9Zm9yKHRoaXMuX2xhenkhPT0hMSYmKHRoaXMuX2xhenk9ITEpLHRoaXMuX2FjdGl2ZXx8IXRoaXMuX3BhdXNlZCYmdGhpcy5fdGltZSE9PW8mJmE+PTAmJih0aGlzLl9hY3RpdmU9ITApLDA9PT1wJiYoMj09PXRoaXMuX2luaXR0ZWQmJmE+MCYmdGhpcy5faW5pdCgpLHRoaXMuX3N0YXJ0QXQmJihhPj0wP3RoaXMuX3N0YXJ0QXQucmVuZGVyKGEsYixjKTplfHwoZT1cIl9kdW1teUdTXCIpKSx0aGlzLnZhcnMub25TdGFydCYmKDAhPT10aGlzLl90b3RhbFRpbWV8fDA9PT1yKSYmKGJ8fHRoaXMuX2NhbGxiYWNrKFwib25TdGFydFwiKSkpLGY9dGhpcy5fZmlyc3RQVDtmOylmLmY/Zi50W2YucF0oZi5jKnRoaXMucmF0aW8rZi5zKTpmLnRbZi5wXT1mLmMqdGhpcy5yYXRpbytmLnMsZj1mLl9uZXh0O3RoaXMuX29uVXBkYXRlJiYoMD5hJiZ0aGlzLl9zdGFydEF0JiZ0aGlzLl9zdGFydFRpbWUmJnRoaXMuX3N0YXJ0QXQucmVuZGVyKGEsYixjKSxifHwodGhpcy5fdG90YWxUaW1lIT09cHx8ZCkmJnRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpLHRoaXMuX2N5Y2xlIT09cSYmKGJ8fHRoaXMuX2djfHx0aGlzLnZhcnMub25SZXBlYXQmJnRoaXMuX2NhbGxiYWNrKFwib25SZXBlYXRcIikpLGUmJighdGhpcy5fZ2N8fGMpJiYoMD5hJiZ0aGlzLl9zdGFydEF0JiYhdGhpcy5fb25VcGRhdGUmJnRoaXMuX3N0YXJ0VGltZSYmdGhpcy5fc3RhcnRBdC5yZW5kZXIoYSxiLGMpLGQmJih0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX2VuYWJsZWQoITEsITEpLHRoaXMuX2FjdGl2ZT0hMSksIWImJnRoaXMudmFyc1tlXSYmdGhpcy5fY2FsbGJhY2soZSksMD09PXImJnRoaXMuX3Jhd1ByZXZUaW1lPT09ZyYmbSE9PWcmJih0aGlzLl9yYXdQcmV2VGltZT0wKSl9LGYudG89ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuZXcgZihhLGIsYyl9LGYuZnJvbT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGMucnVuQmFja3dhcmRzPSEwLGMuaW1tZWRpYXRlUmVuZGVyPTAhPWMuaW1tZWRpYXRlUmVuZGVyLG5ldyBmKGEsYixjKX0sZi5mcm9tVG89ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIGQuc3RhcnRBdD1jLGQuaW1tZWRpYXRlUmVuZGVyPTAhPWQuaW1tZWRpYXRlUmVuZGVyJiYwIT1jLmltbWVkaWF0ZVJlbmRlcixuZXcgZihhLGIsZCl9LGYuc3RhZ2dlclRvPWYuYWxsVG89ZnVuY3Rpb24oYSxiLGcsaCxrLG0sbil7aD1ofHwwO3ZhciBvLHAscSxyLHM9MCx0PVtdLHU9ZnVuY3Rpb24oKXtnLm9uQ29tcGxldGUmJmcub25Db21wbGV0ZS5hcHBseShnLm9uQ29tcGxldGVTY29wZXx8dGhpcyxhcmd1bWVudHMpLGsuYXBwbHkobnx8Zy5jYWxsYmFja1Njb3BlfHx0aGlzLG18fGwpfSx2PWcuY3ljbGUsdz1nLnN0YXJ0QXQmJmcuc3RhcnRBdC5jeWNsZTtmb3IoaihhKXx8KFwic3RyaW5nXCI9PXR5cGVvZiBhJiYoYT1jLnNlbGVjdG9yKGEpfHxhKSxpKGEpJiYoYT1kKGEpKSksYT1hfHxbXSwwPmgmJihhPWQoYSksYS5yZXZlcnNlKCksaCo9LTEpLG89YS5sZW5ndGgtMSxxPTA7bz49cTtxKyspe3A9e307Zm9yKHIgaW4gZylwW3JdPWdbcl07aWYodiYmZShwLGEscSksdyl7dz1wLnN0YXJ0QXQ9e307Zm9yKHIgaW4gZy5zdGFydEF0KXdbcl09Zy5zdGFydEF0W3JdO2UocC5zdGFydEF0LGEscSl9cC5kZWxheT1zKyhwLmRlbGF5fHwwKSxxPT09byYmayYmKHAub25Db21wbGV0ZT11KSx0W3FdPW5ldyBmKGFbcV0sYixwKSxzKz1ofXJldHVybiB0fSxmLnN0YWdnZXJGcm9tPWYuYWxsRnJvbT1mdW5jdGlvbihhLGIsYyxkLGUsZyxoKXtyZXR1cm4gYy5ydW5CYWNrd2FyZHM9ITAsYy5pbW1lZGlhdGVSZW5kZXI9MCE9Yy5pbW1lZGlhdGVSZW5kZXIsZi5zdGFnZ2VyVG8oYSxiLGMsZCxlLGcsaCl9LGYuc3RhZ2dlckZyb21Ubz1mLmFsbEZyb21Ubz1mdW5jdGlvbihhLGIsYyxkLGUsZyxoLGkpe3JldHVybiBkLnN0YXJ0QXQ9YyxkLmltbWVkaWF0ZVJlbmRlcj0wIT1kLmltbWVkaWF0ZVJlbmRlciYmMCE9Yy5pbW1lZGlhdGVSZW5kZXIsZi5zdGFnZ2VyVG8oYSxiLGQsZSxnLGgsaSl9LGYuZGVsYXllZENhbGw9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gbmV3IGYoYiwwLHtkZWxheTphLG9uQ29tcGxldGU6YixvbkNvbXBsZXRlUGFyYW1zOmMsY2FsbGJhY2tTY29wZTpkLG9uUmV2ZXJzZUNvbXBsZXRlOmIsb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6YyxpbW1lZGlhdGVSZW5kZXI6ITEsdXNlRnJhbWVzOmUsb3ZlcndyaXRlOjB9KX0sZi5zZXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IGYoYSwwLGIpfSxmLmlzVHdlZW5pbmc9ZnVuY3Rpb24oYSl7cmV0dXJuIGMuZ2V0VHdlZW5zT2YoYSwhMCkubGVuZ3RoPjB9O3ZhciBtPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBkPVtdLGU9MCxmPWEuX2ZpcnN0O2Y7KWYgaW5zdGFuY2VvZiBjP2RbZSsrXT1mOihiJiYoZFtlKytdPWYpLGQ9ZC5jb25jYXQobShmLGIpKSxlPWQubGVuZ3RoKSxmPWYuX25leHQ7cmV0dXJuIGR9LG49Zi5nZXRBbGxUd2VlbnM9ZnVuY3Rpb24oYil7cmV0dXJuIG0oYS5fcm9vdFRpbWVsaW5lLGIpLmNvbmNhdChtKGEuX3Jvb3RGcmFtZXNUaW1lbGluZSxiKSl9O2Yua2lsbEFsbD1mdW5jdGlvbihhLGMsZCxlKXtudWxsPT1jJiYoYz0hMCksbnVsbD09ZCYmKGQ9ITApO3ZhciBmLGcsaCxpPW4oMCE9ZSksaj1pLmxlbmd0aCxrPWMmJmQmJmU7Zm9yKGg9MDtqPmg7aCsrKWc9aVtoXSwoa3x8ZyBpbnN0YW5jZW9mIGJ8fChmPWcudGFyZ2V0PT09Zy52YXJzLm9uQ29tcGxldGUpJiZkfHxjJiYhZikmJihhP2cudG90YWxUaW1lKGcuX3JldmVyc2VkPzA6Zy50b3RhbER1cmF0aW9uKCkpOmcuX2VuYWJsZWQoITEsITEpKX0sZi5raWxsQ2hpbGRUd2VlbnNPZj1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEpe3ZhciBlLGcsayxsLG0sbj1oLnR3ZWVuTG9va3VwO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhJiYoYT1jLnNlbGVjdG9yKGEpfHxhKSxpKGEpJiYoYT1kKGEpKSxqKGEpKWZvcihsPWEubGVuZ3RoOy0tbD4tMTspZi5raWxsQ2hpbGRUd2VlbnNPZihhW2xdLGIpO2Vsc2V7ZT1bXTtmb3IoayBpbiBuKWZvcihnPW5ba10udGFyZ2V0LnBhcmVudE5vZGU7ZzspZz09PWEmJihlPWUuY29uY2F0KG5ba10udHdlZW5zKSksZz1nLnBhcmVudE5vZGU7Zm9yKG09ZS5sZW5ndGgsbD0wO20+bDtsKyspYiYmZVtsXS50b3RhbFRpbWUoZVtsXS50b3RhbER1cmF0aW9uKCkpLGVbbF0uX2VuYWJsZWQoITEsITEpfX19O3ZhciBvPWZ1bmN0aW9uKGEsYyxkLGUpe2M9YyE9PSExLGQ9ZCE9PSExLGU9ZSE9PSExO2Zvcih2YXIgZixnLGg9bihlKSxpPWMmJmQmJmUsaj1oLmxlbmd0aDstLWo+LTE7KWc9aFtqXSwoaXx8ZyBpbnN0YW5jZW9mIGJ8fChmPWcudGFyZ2V0PT09Zy52YXJzLm9uQ29tcGxldGUpJiZkfHxjJiYhZikmJmcucGF1c2VkKGEpfTtyZXR1cm4gZi5wYXVzZUFsbD1mdW5jdGlvbihhLGIsYyl7byghMCxhLGIsYyl9LGYucmVzdW1lQWxsPWZ1bmN0aW9uKGEsYixjKXtvKCExLGEsYixjKX0sZi5nbG9iYWxUaW1lU2NhbGU9ZnVuY3Rpb24oYil7dmFyIGQ9YS5fcm9vdFRpbWVsaW5lLGU9Yy50aWNrZXIudGltZTtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYj1ifHxnLGQuX3N0YXJ0VGltZT1lLShlLWQuX3N0YXJ0VGltZSkqZC5fdGltZVNjYWxlL2IsZD1hLl9yb290RnJhbWVzVGltZWxpbmUsZT1jLnRpY2tlci5mcmFtZSxkLl9zdGFydFRpbWU9ZS0oZS1kLl9zdGFydFRpbWUpKmQuX3RpbWVTY2FsZS9iLGQuX3RpbWVTY2FsZT1hLl9yb290VGltZWxpbmUuX3RpbWVTY2FsZT1iLGIpOmQuX3RpbWVTY2FsZX0say5wcm9ncmVzcz1mdW5jdGlvbihhKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90aGlzLnRvdGFsVGltZSh0aGlzLmR1cmF0aW9uKCkqKHRoaXMuX3lveW8mJjAhPT0oMSZ0aGlzLl9jeWNsZSk/MS1hOmEpK3RoaXMuX2N5Y2xlKih0aGlzLl9kdXJhdGlvbit0aGlzLl9yZXBlYXREZWxheSksITEpOnRoaXMuX3RpbWUvdGhpcy5kdXJhdGlvbigpfSxrLnRvdGFsUHJvZ3Jlc3M9ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dGhpcy50b3RhbFRpbWUodGhpcy50b3RhbER1cmF0aW9uKCkqYSwhMSk6dGhpcy5fdG90YWxUaW1lL3RoaXMudG90YWxEdXJhdGlvbigpfSxrLnRpbWU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZGlydHkmJnRoaXMudG90YWxEdXJhdGlvbigpLGE+dGhpcy5fZHVyYXRpb24mJihhPXRoaXMuX2R1cmF0aW9uKSx0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpP2E9dGhpcy5fZHVyYXRpb24tYSt0aGlzLl9jeWNsZSoodGhpcy5fZHVyYXRpb24rdGhpcy5fcmVwZWF0RGVsYXkpOjAhPT10aGlzLl9yZXBlYXQmJihhKz10aGlzLl9jeWNsZSoodGhpcy5fZHVyYXRpb24rdGhpcy5fcmVwZWF0RGVsYXkpKSx0aGlzLnRvdGFsVGltZShhLGIpKTp0aGlzLl90aW1lfSxrLmR1cmF0aW9uPWZ1bmN0aW9uKGIpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP2EucHJvdG90eXBlLmR1cmF0aW9uLmNhbGwodGhpcyxiKTp0aGlzLl9kdXJhdGlvbn0say50b3RhbER1cmF0aW9uPWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPy0xPT09dGhpcy5fcmVwZWF0P3RoaXM6dGhpcy5kdXJhdGlvbigoYS10aGlzLl9yZXBlYXQqdGhpcy5fcmVwZWF0RGVsYXkpLyh0aGlzLl9yZXBlYXQrMSkpOih0aGlzLl9kaXJ0eSYmKHRoaXMuX3RvdGFsRHVyYXRpb249LTE9PT10aGlzLl9yZXBlYXQ/OTk5OTk5OTk5OTk5OnRoaXMuX2R1cmF0aW9uKih0aGlzLl9yZXBlYXQrMSkrdGhpcy5fcmVwZWF0RGVsYXkqdGhpcy5fcmVwZWF0LHRoaXMuX2RpcnR5PSExKSx0aGlzLl90b3RhbER1cmF0aW9uKX0say5yZXBlYXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3JlcGVhdD1hLHRoaXMuX3VuY2FjaGUoITApKTp0aGlzLl9yZXBlYXR9LGsucmVwZWF0RGVsYXk9ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3JlcGVhdERlbGF5PWEsdGhpcy5fdW5jYWNoZSghMCkpOnRoaXMuX3JlcGVhdERlbGF5fSxrLnlveW89ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3lveW89YSx0aGlzKTp0aGlzLl95b3lvfSxmfSwhMCksX2dzU2NvcGUuX2dzRGVmaW5lKFwiVGltZWxpbmVMaXRlXCIsW1wiY29yZS5BbmltYXRpb25cIixcImNvcmUuU2ltcGxlVGltZWxpbmVcIixcIlR3ZWVuTGl0ZVwiXSxmdW5jdGlvbihhLGIsYyl7dmFyIGQ9ZnVuY3Rpb24oYSl7Yi5jYWxsKHRoaXMsYSksdGhpcy5fbGFiZWxzPXt9LHRoaXMuYXV0b1JlbW92ZUNoaWxkcmVuPXRoaXMudmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW49PT0hMCx0aGlzLnNtb290aENoaWxkVGltaW5nPXRoaXMudmFycy5zbW9vdGhDaGlsZFRpbWluZz09PSEwLHRoaXMuX3NvcnRDaGlsZHJlbj0hMCx0aGlzLl9vblVwZGF0ZT10aGlzLnZhcnMub25VcGRhdGU7dmFyIGMsZCxlPXRoaXMudmFycztmb3IoZCBpbiBlKWM9ZVtkXSxpKGMpJiYtMSE9PWMuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpJiYoZVtkXT10aGlzLl9zd2FwU2VsZkluUGFyYW1zKGMpKTtpKGUudHdlZW5zKSYmdGhpcy5hZGQoZS50d2VlbnMsMCxlLmFsaWduLGUuc3RhZ2dlcil9LGU9MWUtMTAsZj1jLl9pbnRlcm5hbHMsZz1kLl9pbnRlcm5hbHM9e30saD1mLmlzU2VsZWN0b3IsaT1mLmlzQXJyYXksaj1mLmxhenlUd2VlbnMsaz1mLmxhenlSZW5kZXIsbD1fZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxtPWZ1bmN0aW9uKGEpe3ZhciBiLGM9e307Zm9yKGIgaW4gYSljW2JdPWFbYl07cmV0dXJuIGN9LG49ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZj1hLmN5Y2xlO2ZvcihkIGluIGYpZT1mW2RdLGFbZF09XCJmdW5jdGlvblwiPT10eXBlb2YgZT9lLmNhbGwoYltjXSxjKTplW2MlZS5sZW5ndGhdO2RlbGV0ZSBhLmN5Y2xlfSxvPWcucGF1c2VDYWxsYmFjaz1mdW5jdGlvbigpe30scD1mdW5jdGlvbihhKXt2YXIgYixjPVtdLGQ9YS5sZW5ndGg7Zm9yKGI9MDtiIT09ZDtjLnB1c2goYVtiKytdKSk7cmV0dXJuIGN9LHE9ZC5wcm90b3R5cGU9bmV3IGI7cmV0dXJuIGQudmVyc2lvbj1cIjEuMTguMlwiLHEuY29uc3RydWN0b3I9ZCxxLmtpbGwoKS5fZ2M9cS5fZm9yY2luZ1BsYXloZWFkPXEuX2hhc1BhdXNlPSExLHEudG89ZnVuY3Rpb24oYSxiLGQsZSl7dmFyIGY9ZC5yZXBlYXQmJmwuVHdlZW5NYXh8fGM7cmV0dXJuIGI/dGhpcy5hZGQobmV3IGYoYSxiLGQpLGUpOnRoaXMuc2V0KGEsZCxlKX0scS5mcm9tPWZ1bmN0aW9uKGEsYixkLGUpe3JldHVybiB0aGlzLmFkZCgoZC5yZXBlYXQmJmwuVHdlZW5NYXh8fGMpLmZyb20oYSxiLGQpLGUpfSxxLmZyb21Ubz1mdW5jdGlvbihhLGIsZCxlLGYpe3ZhciBnPWUucmVwZWF0JiZsLlR3ZWVuTWF4fHxjO3JldHVybiBiP3RoaXMuYWRkKGcuZnJvbVRvKGEsYixkLGUpLGYpOnRoaXMuc2V0KGEsZSxmKX0scS5zdGFnZ2VyVG89ZnVuY3Rpb24oYSxiLGUsZixnLGksaixrKXt2YXIgbCxvLHE9bmV3IGQoe29uQ29tcGxldGU6aSxvbkNvbXBsZXRlUGFyYW1zOmosY2FsbGJhY2tTY29wZTprLHNtb290aENoaWxkVGltaW5nOnRoaXMuc21vb3RoQ2hpbGRUaW1pbmd9KSxyPWUuY3ljbGU7Zm9yKFwic3RyaW5nXCI9PXR5cGVvZiBhJiYoYT1jLnNlbGVjdG9yKGEpfHxhKSxhPWF8fFtdLGgoYSkmJihhPXAoYSkpLGY9Znx8MCwwPmYmJihhPXAoYSksYS5yZXZlcnNlKCksZio9LTEpLG89MDtvPGEubGVuZ3RoO28rKylsPW0oZSksbC5zdGFydEF0JiYobC5zdGFydEF0PW0obC5zdGFydEF0KSxsLnN0YXJ0QXQuY3ljbGUmJm4obC5zdGFydEF0LGEsbykpLHImJm4obCxhLG8pLHEudG8oYVtvXSxiLGwsbypmKTtyZXR1cm4gdGhpcy5hZGQocSxnKX0scS5zdGFnZ2VyRnJvbT1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGgpe3JldHVybiBjLmltbWVkaWF0ZVJlbmRlcj0wIT1jLmltbWVkaWF0ZVJlbmRlcixjLnJ1bkJhY2t3YXJkcz0hMCx0aGlzLnN0YWdnZXJUbyhhLGIsYyxkLGUsZixnLGgpfSxxLnN0YWdnZXJGcm9tVG89ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGkpe3JldHVybiBkLnN0YXJ0QXQ9YyxkLmltbWVkaWF0ZVJlbmRlcj0wIT1kLmltbWVkaWF0ZVJlbmRlciYmMCE9Yy5pbW1lZGlhdGVSZW5kZXIsdGhpcy5zdGFnZ2VyVG8oYSxiLGQsZSxmLGcsaCxpKX0scS5jYWxsPWZ1bmN0aW9uKGEsYixkLGUpe3JldHVybiB0aGlzLmFkZChjLmRlbGF5ZWRDYWxsKDAsYSxiLGQpLGUpfSxxLnNldD1mdW5jdGlvbihhLGIsZCl7cmV0dXJuIGQ9dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChkLDAsITApLG51bGw9PWIuaW1tZWRpYXRlUmVuZGVyJiYoYi5pbW1lZGlhdGVSZW5kZXI9ZD09PXRoaXMuX3RpbWUmJiF0aGlzLl9wYXVzZWQpLHRoaXMuYWRkKG5ldyBjKGEsMCxiKSxkKX0sZC5leHBvcnRSb290PWZ1bmN0aW9uKGEsYil7YT1hfHx7fSxudWxsPT1hLnNtb290aENoaWxkVGltaW5nJiYoYS5zbW9vdGhDaGlsZFRpbWluZz0hMCk7dmFyIGUsZixnPW5ldyBkKGEpLGg9Zy5fdGltZWxpbmU7Zm9yKG51bGw9PWImJihiPSEwKSxoLl9yZW1vdmUoZywhMCksZy5fc3RhcnRUaW1lPTAsZy5fcmF3UHJldlRpbWU9Zy5fdGltZT1nLl90b3RhbFRpbWU9aC5fdGltZSxlPWguX2ZpcnN0O2U7KWY9ZS5fbmV4dCxiJiZlIGluc3RhbmNlb2YgYyYmZS50YXJnZXQ9PT1lLnZhcnMub25Db21wbGV0ZXx8Zy5hZGQoZSxlLl9zdGFydFRpbWUtZS5fZGVsYXkpLGU9ZjtyZXR1cm4gaC5hZGQoZywwKSxnfSxxLmFkZD1mdW5jdGlvbihlLGYsZyxoKXt2YXIgaixrLGwsbSxuLG87aWYoXCJudW1iZXJcIiE9dHlwZW9mIGYmJihmPXRoaXMuX3BhcnNlVGltZU9yTGFiZWwoZiwwLCEwLGUpKSwhKGUgaW5zdGFuY2VvZiBhKSl7aWYoZSBpbnN0YW5jZW9mIEFycmF5fHxlJiZlLnB1c2gmJmkoZSkpe2ZvcihnPWd8fFwibm9ybWFsXCIsaD1ofHwwLGo9ZixrPWUubGVuZ3RoLGw9MDtrPmw7bCsrKWkobT1lW2xdKSYmKG09bmV3IGQoe3R3ZWVuczptfSkpLHRoaXMuYWRkKG0saiksXCJzdHJpbmdcIiE9dHlwZW9mIG0mJlwiZnVuY3Rpb25cIiE9dHlwZW9mIG0mJihcInNlcXVlbmNlXCI9PT1nP2o9bS5fc3RhcnRUaW1lK20udG90YWxEdXJhdGlvbigpL20uX3RpbWVTY2FsZTpcInN0YXJ0XCI9PT1nJiYobS5fc3RhcnRUaW1lLT1tLmRlbGF5KCkpKSxqKz1oO3JldHVybiB0aGlzLl91bmNhY2hlKCEwKX1pZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gdGhpcy5hZGRMYWJlbChlLGYpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3dcIkNhbm5vdCBhZGQgXCIrZStcIiBpbnRvIHRoZSB0aW1lbGluZTsgaXQgaXMgbm90IGEgdHdlZW4sIHRpbWVsaW5lLCBmdW5jdGlvbiwgb3Igc3RyaW5nLlwiO2U9Yy5kZWxheWVkQ2FsbCgwLGUpfWlmKGIucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsZSxmKSwodGhpcy5fZ2N8fHRoaXMuX3RpbWU9PT10aGlzLl9kdXJhdGlvbikmJiF0aGlzLl9wYXVzZWQmJnRoaXMuX2R1cmF0aW9uPHRoaXMuZHVyYXRpb24oKSlmb3Iobj10aGlzLG89bi5yYXdUaW1lKCk+ZS5fc3RhcnRUaW1lO24uX3RpbWVsaW5lOylvJiZuLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZz9uLnRvdGFsVGltZShuLl90b3RhbFRpbWUsITApOm4uX2djJiZuLl9lbmFibGVkKCEwLCExKSxuPW4uX3RpbWVsaW5lO3JldHVybiB0aGlzfSxxLnJlbW92ZT1mdW5jdGlvbihiKXtpZihiIGluc3RhbmNlb2YgYSl7dGhpcy5fcmVtb3ZlKGIsITEpO3ZhciBjPWIuX3RpbWVsaW5lPWIudmFycy51c2VGcmFtZXM/YS5fcm9vdEZyYW1lc1RpbWVsaW5lOmEuX3Jvb3RUaW1lbGluZTtyZXR1cm4gYi5fc3RhcnRUaW1lPShiLl9wYXVzZWQ/Yi5fcGF1c2VUaW1lOmMuX3RpbWUpLShiLl9yZXZlcnNlZD9iLnRvdGFsRHVyYXRpb24oKS1iLl90b3RhbFRpbWU6Yi5fdG90YWxUaW1lKS9iLl90aW1lU2NhbGUsdGhpc31pZihiIGluc3RhbmNlb2YgQXJyYXl8fGImJmIucHVzaCYmaShiKSl7Zm9yKHZhciBkPWIubGVuZ3RoOy0tZD4tMTspdGhpcy5yZW1vdmUoYltkXSk7cmV0dXJuIHRoaXN9cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGI/dGhpcy5yZW1vdmVMYWJlbChiKTp0aGlzLmtpbGwobnVsbCxiKX0scS5fcmVtb3ZlPWZ1bmN0aW9uKGEsYyl7Yi5wcm90b3R5cGUuX3JlbW92ZS5jYWxsKHRoaXMsYSxjKTt2YXIgZD10aGlzLl9sYXN0O3JldHVybiBkP3RoaXMuX3RpbWU+ZC5fc3RhcnRUaW1lK2QuX3RvdGFsRHVyYXRpb24vZC5fdGltZVNjYWxlJiYodGhpcy5fdGltZT10aGlzLmR1cmF0aW9uKCksdGhpcy5fdG90YWxUaW1lPXRoaXMuX3RvdGFsRHVyYXRpb24pOnRoaXMuX3RpbWU9dGhpcy5fdG90YWxUaW1lPXRoaXMuX2R1cmF0aW9uPXRoaXMuX3RvdGFsRHVyYXRpb249MCx0aGlzfSxxLmFwcGVuZD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmFkZChhLHRoaXMuX3BhcnNlVGltZU9yTGFiZWwobnVsbCxiLCEwLGEpKX0scS5pbnNlcnQ9cS5pbnNlcnRNdWx0aXBsZT1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5hZGQoYSxifHwwLGMsZCl9LHEuYXBwZW5kTXVsdGlwbGU9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMuYWRkKGEsdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLGIsITAsYSksYyxkKX0scS5hZGRMYWJlbD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9sYWJlbHNbYV09dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChiKSx0aGlzfSxxLmFkZFBhdXNlPWZ1bmN0aW9uKGEsYixkLGUpe3ZhciBmPWMuZGVsYXllZENhbGwoMCxvLGQsZXx8dGhpcyk7cmV0dXJuIGYudmFycy5vbkNvbXBsZXRlPWYudmFycy5vblJldmVyc2VDb21wbGV0ZT1iLGYuZGF0YT1cImlzUGF1c2VcIix0aGlzLl9oYXNQYXVzZT0hMCx0aGlzLmFkZChmLGEpfSxxLnJlbW92ZUxhYmVsPWZ1bmN0aW9uKGEpe3JldHVybiBkZWxldGUgdGhpcy5fbGFiZWxzW2FdLHRoaXN9LHEuZ2V0TGFiZWxUaW1lPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT10aGlzLl9sYWJlbHNbYV0/dGhpcy5fbGFiZWxzW2FdOi0xfSxxLl9wYXJzZVRpbWVPckxhYmVsPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmO2lmKGUgaW5zdGFuY2VvZiBhJiZlLnRpbWVsaW5lPT09dGhpcyl0aGlzLnJlbW92ZShlKTtlbHNlIGlmKGUmJihlIGluc3RhbmNlb2YgQXJyYXl8fGUucHVzaCYmaShlKSkpZm9yKGY9ZS5sZW5ndGg7LS1mPi0xOyllW2ZdaW5zdGFuY2VvZiBhJiZlW2ZdLnRpbWVsaW5lPT09dGhpcyYmdGhpcy5yZW1vdmUoZVtmXSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGMpcmV0dXJuIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwoYyxkJiZcIm51bWJlclwiPT10eXBlb2YgYiYmbnVsbD09dGhpcy5fbGFiZWxzW2NdP2ItdGhpcy5kdXJhdGlvbigpOjAsZCk7aWYoYz1jfHwwLFwic3RyaW5nXCIhPXR5cGVvZiBifHwhaXNOYU4oYikmJm51bGw9PXRoaXMuX2xhYmVsc1tiXSludWxsPT1iJiYoYj10aGlzLmR1cmF0aW9uKCkpO2Vsc2V7aWYoZj1iLmluZGV4T2YoXCI9XCIpLC0xPT09ZilyZXR1cm4gbnVsbD09dGhpcy5fbGFiZWxzW2JdP2Q/dGhpcy5fbGFiZWxzW2JdPXRoaXMuZHVyYXRpb24oKStjOmM6dGhpcy5fbGFiZWxzW2JdK2M7Yz1wYXJzZUludChiLmNoYXJBdChmLTEpK1wiMVwiLDEwKSpOdW1iZXIoYi5zdWJzdHIoZisxKSksYj1mPjE/dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChiLnN1YnN0cigwLGYtMSksMCxkKTp0aGlzLmR1cmF0aW9uKCl9cmV0dXJuIE51bWJlcihiKStjfSxxLnNlZWs9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy50b3RhbFRpbWUoXCJudW1iZXJcIj09dHlwZW9mIGE/YTp0aGlzLl9wYXJzZVRpbWVPckxhYmVsKGEpLGIhPT0hMSl9LHEuc3RvcD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhdXNlZCghMCl9LHEuZ290b0FuZFBsYXk9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5wbGF5KGEsYil9LHEuZ290b0FuZFN0b3A9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5wYXVzZShhLGIpfSxxLnJlbmRlcj1mdW5jdGlvbihhLGIsYyl7dGhpcy5fZ2MmJnRoaXMuX2VuYWJsZWQoITAsITEpO3ZhciBkLGYsZyxoLGksbCxtLG49dGhpcy5fZGlydHk/dGhpcy50b3RhbER1cmF0aW9uKCk6dGhpcy5fdG90YWxEdXJhdGlvbixvPXRoaXMuX3RpbWUscD10aGlzLl9zdGFydFRpbWUscT10aGlzLl90aW1lU2NhbGUscj10aGlzLl9wYXVzZWQ7aWYoYT49bi0xZS03KXRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPW4sdGhpcy5fcmV2ZXJzZWR8fHRoaXMuX2hhc1BhdXNlZENoaWxkKCl8fChmPSEwLGg9XCJvbkNvbXBsZXRlXCIsaT0hIXRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiwwPT09dGhpcy5fZHVyYXRpb24mJigwPj1hJiZhPj0tMWUtN3x8dGhpcy5fcmF3UHJldlRpbWU8MHx8dGhpcy5fcmF3UHJldlRpbWU9PT1lKSYmdGhpcy5fcmF3UHJldlRpbWUhPT1hJiZ0aGlzLl9maXJzdCYmKGk9ITAsdGhpcy5fcmF3UHJldlRpbWU+ZSYmKGg9XCJvblJldmVyc2VDb21wbGV0ZVwiKSkpLHRoaXMuX3Jhd1ByZXZUaW1lPXRoaXMuX2R1cmF0aW9ufHwhYnx8YXx8dGhpcy5fcmF3UHJldlRpbWU9PT1hP2E6ZSxhPW4rMWUtNDtlbHNlIGlmKDFlLTc+YSlpZih0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT0wLCgwIT09b3x8MD09PXRoaXMuX2R1cmF0aW9uJiZ0aGlzLl9yYXdQcmV2VGltZSE9PWUmJih0aGlzLl9yYXdQcmV2VGltZT4wfHwwPmEmJnRoaXMuX3Jhd1ByZXZUaW1lPj0wKSkmJihoPVwib25SZXZlcnNlQ29tcGxldGVcIixmPXRoaXMuX3JldmVyc2VkKSwwPmEpdGhpcy5fYWN0aXZlPSExLHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiYmdGhpcy5fcmV2ZXJzZWQ/KGk9Zj0hMCxoPVwib25SZXZlcnNlQ29tcGxldGVcIik6dGhpcy5fcmF3UHJldlRpbWU+PTAmJnRoaXMuX2ZpcnN0JiYoaT0hMCksdGhpcy5fcmF3UHJldlRpbWU9YTtlbHNle2lmKHRoaXMuX3Jhd1ByZXZUaW1lPXRoaXMuX2R1cmF0aW9ufHwhYnx8YXx8dGhpcy5fcmF3UHJldlRpbWU9PT1hP2E6ZSwwPT09YSYmZilmb3IoZD10aGlzLl9maXJzdDtkJiYwPT09ZC5fc3RhcnRUaW1lOylkLl9kdXJhdGlvbnx8KGY9ITEpLGQ9ZC5fbmV4dDthPTAsdGhpcy5faW5pdHRlZHx8KGk9ITApfWVsc2V7aWYodGhpcy5faGFzUGF1c2UmJiF0aGlzLl9mb3JjaW5nUGxheWhlYWQmJiFiKXtpZihhPj1vKWZvcihkPXRoaXMuX2ZpcnN0O2QmJmQuX3N0YXJ0VGltZTw9YSYmIWw7KWQuX2R1cmF0aW9ufHxcImlzUGF1c2VcIiE9PWQuZGF0YXx8ZC5yYXRpb3x8MD09PWQuX3N0YXJ0VGltZSYmMD09PXRoaXMuX3Jhd1ByZXZUaW1lfHwobD1kKSxkPWQuX25leHQ7ZWxzZSBmb3IoZD10aGlzLl9sYXN0O2QmJmQuX3N0YXJ0VGltZT49YSYmIWw7KWQuX2R1cmF0aW9ufHxcImlzUGF1c2VcIj09PWQuZGF0YSYmZC5fcmF3UHJldlRpbWU+MCYmKGw9ZCksZD1kLl9wcmV2O2wmJih0aGlzLl90aW1lPWE9bC5fc3RhcnRUaW1lLHRoaXMuX3RvdGFsVGltZT1hK3RoaXMuX2N5Y2xlKih0aGlzLl90b3RhbER1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KSl9dGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9dGhpcy5fcmF3UHJldlRpbWU9YX1pZih0aGlzLl90aW1lIT09byYmdGhpcy5fZmlyc3R8fGN8fGl8fGwpe2lmKHRoaXMuX2luaXR0ZWR8fCh0aGlzLl9pbml0dGVkPSEwKSx0aGlzLl9hY3RpdmV8fCF0aGlzLl9wYXVzZWQmJnRoaXMuX3RpbWUhPT1vJiZhPjAmJih0aGlzLl9hY3RpdmU9ITApLDA9PT1vJiZ0aGlzLnZhcnMub25TdGFydCYmMCE9PXRoaXMuX3RpbWUmJihifHx0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIikpLG09dGhpcy5fdGltZSxtPj1vKWZvcihkPXRoaXMuX2ZpcnN0O2QmJihnPWQuX25leHQsbT09PXRoaXMuX3RpbWUmJighdGhpcy5fcGF1c2VkfHxyKSk7KShkLl9hY3RpdmV8fGQuX3N0YXJ0VGltZTw9bSYmIWQuX3BhdXNlZCYmIWQuX2djKSYmKGw9PT1kJiZ0aGlzLnBhdXNlKCksZC5fcmV2ZXJzZWQ/ZC5yZW5kZXIoKGQuX2RpcnR5P2QudG90YWxEdXJhdGlvbigpOmQuX3RvdGFsRHVyYXRpb24pLShhLWQuX3N0YXJ0VGltZSkqZC5fdGltZVNjYWxlLGIsYyk6ZC5yZW5kZXIoKGEtZC5fc3RhcnRUaW1lKSpkLl90aW1lU2NhbGUsYixjKSksZD1nO2Vsc2UgZm9yKGQ9dGhpcy5fbGFzdDtkJiYoZz1kLl9wcmV2LG09PT10aGlzLl90aW1lJiYoIXRoaXMuX3BhdXNlZHx8cikpOyl7aWYoZC5fYWN0aXZlfHxkLl9zdGFydFRpbWU8PW8mJiFkLl9wYXVzZWQmJiFkLl9nYyl7aWYobD09PWQpe2ZvcihsPWQuX3ByZXY7bCYmbC5lbmRUaW1lKCk+dGhpcy5fdGltZTspbC5yZW5kZXIobC5fcmV2ZXJzZWQ/bC50b3RhbER1cmF0aW9uKCktKGEtbC5fc3RhcnRUaW1lKSpsLl90aW1lU2NhbGU6KGEtbC5fc3RhcnRUaW1lKSpsLl90aW1lU2NhbGUsYixjKSxsPWwuX3ByZXY7bD1udWxsLHRoaXMucGF1c2UoKX1kLl9yZXZlcnNlZD9kLnJlbmRlcigoZC5fZGlydHk/ZC50b3RhbER1cmF0aW9uKCk6ZC5fdG90YWxEdXJhdGlvbiktKGEtZC5fc3RhcnRUaW1lKSpkLl90aW1lU2NhbGUsYixjKTpkLnJlbmRlcigoYS1kLl9zdGFydFRpbWUpKmQuX3RpbWVTY2FsZSxiLGMpfWQ9Z310aGlzLl9vblVwZGF0ZSYmKGJ8fChqLmxlbmd0aCYmaygpLHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpKSxoJiYodGhpcy5fZ2N8fChwPT09dGhpcy5fc3RhcnRUaW1lfHxxIT09dGhpcy5fdGltZVNjYWxlKSYmKDA9PT10aGlzLl90aW1lfHxuPj10aGlzLnRvdGFsRHVyYXRpb24oKSkmJihmJiYoai5sZW5ndGgmJmsoKSx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX2VuYWJsZWQoITEsITEpLHRoaXMuX2FjdGl2ZT0hMSksIWImJnRoaXMudmFyc1toXSYmdGhpcy5fY2FsbGJhY2soaCkpKX19LHEuX2hhc1BhdXNlZENoaWxkPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuX2ZpcnN0O2E7KXtpZihhLl9wYXVzZWR8fGEgaW5zdGFuY2VvZiBkJiZhLl9oYXNQYXVzZWRDaGlsZCgpKXJldHVybiEwO2E9YS5fbmV4dH1yZXR1cm4hMX0scS5nZXRDaGlsZHJlbj1mdW5jdGlvbihhLGIsZCxlKXtlPWV8fC05OTk5OTk5OTk5O2Zvcih2YXIgZj1bXSxnPXRoaXMuX2ZpcnN0LGg9MDtnOylnLl9zdGFydFRpbWU8ZXx8KGcgaW5zdGFuY2VvZiBjP2IhPT0hMSYmKGZbaCsrXT1nKTooZCE9PSExJiYoZltoKytdPWcpLGEhPT0hMSYmKGY9Zi5jb25jYXQoZy5nZXRDaGlsZHJlbighMCxiLGQpKSxoPWYubGVuZ3RoKSkpLGc9Zy5fbmV4dDtyZXR1cm4gZn0scS5nZXRUd2VlbnNPZj1mdW5jdGlvbihhLGIpe3ZhciBkLGUsZj10aGlzLl9nYyxnPVtdLGg9MDtmb3IoZiYmdGhpcy5fZW5hYmxlZCghMCwhMCksZD1jLmdldFR3ZWVuc09mKGEpLGU9ZC5sZW5ndGg7LS1lPi0xOykoZFtlXS50aW1lbGluZT09PXRoaXN8fGImJnRoaXMuX2NvbnRhaW5zKGRbZV0pKSYmKGdbaCsrXT1kW2VdKTtyZXR1cm4gZiYmdGhpcy5fZW5hYmxlZCghMSwhMCksZ30scS5yZWNlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVjZW50fSxxLl9jb250YWlucz1mdW5jdGlvbihhKXtmb3IodmFyIGI9YS50aW1lbGluZTtiOyl7aWYoYj09PXRoaXMpcmV0dXJuITA7Yj1iLnRpbWVsaW5lfXJldHVybiExfSxxLnNoaWZ0Q2hpbGRyZW49ZnVuY3Rpb24oYSxiLGMpe2M9Y3x8MDtmb3IodmFyIGQsZT10aGlzLl9maXJzdCxmPXRoaXMuX2xhYmVscztlOyllLl9zdGFydFRpbWU+PWMmJihlLl9zdGFydFRpbWUrPWEpLGU9ZS5fbmV4dDtpZihiKWZvcihkIGluIGYpZltkXT49YyYmKGZbZF0rPWEpO3JldHVybiB0aGlzLl91bmNhY2hlKCEwKX0scS5fa2lsbD1mdW5jdGlvbihhLGIpe2lmKCFhJiYhYilyZXR1cm4gdGhpcy5fZW5hYmxlZCghMSwhMSk7Zm9yKHZhciBjPWI/dGhpcy5nZXRUd2VlbnNPZihiKTp0aGlzLmdldENoaWxkcmVuKCEwLCEwLCExKSxkPWMubGVuZ3RoLGU9ITE7LS1kPi0xOyljW2RdLl9raWxsKGEsYikmJihlPSEwKTtyZXR1cm4gZX0scS5jbGVhcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldENoaWxkcmVuKCExLCEwLCEwKSxjPWIubGVuZ3RoO2Zvcih0aGlzLl90aW1lPXRoaXMuX3RvdGFsVGltZT0wOy0tYz4tMTspYltjXS5fZW5hYmxlZCghMSwhMSk7cmV0dXJuIGEhPT0hMSYmKHRoaXMuX2xhYmVscz17fSksdGhpcy5fdW5jYWNoZSghMCl9LHEuaW52YWxpZGF0ZT1mdW5jdGlvbigpe2Zvcih2YXIgYj10aGlzLl9maXJzdDtiOyliLmludmFsaWRhdGUoKSxiPWIuX25leHQ7cmV0dXJuIGEucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKX0scS5fZW5hYmxlZD1mdW5jdGlvbihhLGMpe2lmKGE9PT10aGlzLl9nYylmb3IodmFyIGQ9dGhpcy5fZmlyc3Q7ZDspZC5fZW5hYmxlZChhLCEwKSxkPWQuX25leHQ7cmV0dXJuIGIucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcyxhLGMpfSxxLnRvdGFsVGltZT1mdW5jdGlvbihiLGMsZCl7dGhpcy5fZm9yY2luZ1BsYXloZWFkPSEwO3ZhciBlPWEucHJvdG90eXBlLnRvdGFsVGltZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHRoaXMuX2ZvcmNpbmdQbGF5aGVhZD0hMSxlfSxxLmR1cmF0aW9uPWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPygwIT09dGhpcy5kdXJhdGlvbigpJiYwIT09YSYmdGhpcy50aW1lU2NhbGUodGhpcy5fZHVyYXRpb24vYSksdGhpcyk6KHRoaXMuX2RpcnR5JiZ0aGlzLnRvdGFsRHVyYXRpb24oKSx0aGlzLl9kdXJhdGlvbil9LHEudG90YWxEdXJhdGlvbj1mdW5jdGlvbihhKXtpZighYXJndW1lbnRzLmxlbmd0aCl7aWYodGhpcy5fZGlydHkpe2Zvcih2YXIgYixjLGQ9MCxlPXRoaXMuX2xhc3QsZj05OTk5OTk5OTk5OTk7ZTspYj1lLl9wcmV2LGUuX2RpcnR5JiZlLnRvdGFsRHVyYXRpb24oKSxlLl9zdGFydFRpbWU+ZiYmdGhpcy5fc29ydENoaWxkcmVuJiYhZS5fcGF1c2VkP3RoaXMuYWRkKGUsZS5fc3RhcnRUaW1lLWUuX2RlbGF5KTpmPWUuX3N0YXJ0VGltZSxlLl9zdGFydFRpbWU8MCYmIWUuX3BhdXNlZCYmKGQtPWUuX3N0YXJ0VGltZSx0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZyYmKHRoaXMuX3N0YXJ0VGltZSs9ZS5fc3RhcnRUaW1lL3RoaXMuX3RpbWVTY2FsZSksdGhpcy5zaGlmdENoaWxkcmVuKC1lLl9zdGFydFRpbWUsITEsLTk5OTk5OTk5OTkpLGY9MCksYz1lLl9zdGFydFRpbWUrZS5fdG90YWxEdXJhdGlvbi9lLl90aW1lU2NhbGUsYz5kJiYoZD1jKSxlPWI7dGhpcy5fZHVyYXRpb249dGhpcy5fdG90YWxEdXJhdGlvbj1kLHRoaXMuX2RpcnR5PSExfXJldHVybiB0aGlzLl90b3RhbER1cmF0aW9ufXJldHVybiBhJiZ0aGlzLnRvdGFsRHVyYXRpb24oKT90aGlzLnRpbWVTY2FsZSh0aGlzLl90b3RhbER1cmF0aW9uL2EpOnRoaXN9LHEucGF1c2VkPWZ1bmN0aW9uKGIpe2lmKCFiKWZvcih2YXIgYz10aGlzLl9maXJzdCxkPXRoaXMuX3RpbWU7YzspYy5fc3RhcnRUaW1lPT09ZCYmXCJpc1BhdXNlXCI9PT1jLmRhdGEmJihjLl9yYXdQcmV2VGltZT0wKSxjPWMuX25leHQ7cmV0dXJuIGEucHJvdG90eXBlLnBhdXNlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHEudXNlc0ZyYW1lcz1mdW5jdGlvbigpe2Zvcih2YXIgYj10aGlzLl90aW1lbGluZTtiLl90aW1lbGluZTspYj1iLl90aW1lbGluZTtyZXR1cm4gYj09PWEuX3Jvb3RGcmFtZXNUaW1lbGluZX0scS5yYXdUaW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BhdXNlZD90aGlzLl90b3RhbFRpbWU6KHRoaXMuX3RpbWVsaW5lLnJhd1RpbWUoKS10aGlzLl9zdGFydFRpbWUpKnRoaXMuX3RpbWVTY2FsZX0sZH0sITApLF9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTWF4XCIsW1wiVGltZWxpbmVMaXRlXCIsXCJUd2VlbkxpdGVcIixcImVhc2luZy5FYXNlXCJdLGZ1bmN0aW9uKGEsYixjKXt2YXIgZD1mdW5jdGlvbihiKXthLmNhbGwodGhpcyxiKSx0aGlzLl9yZXBlYXQ9dGhpcy52YXJzLnJlcGVhdHx8MCx0aGlzLl9yZXBlYXREZWxheT10aGlzLnZhcnMucmVwZWF0RGVsYXl8fDAsdGhpcy5fY3ljbGU9MCx0aGlzLl95b3lvPXRoaXMudmFycy55b3lvPT09ITAsdGhpcy5fZGlydHk9ITB9LGU9MWUtMTAsZj1iLl9pbnRlcm5hbHMsZz1mLmxhenlUd2VlbnMsaD1mLmxhenlSZW5kZXIsaT1uZXcgYyhudWxsLG51bGwsMSwwKSxqPWQucHJvdG90eXBlPW5ldyBhO3JldHVybiBqLmNvbnN0cnVjdG9yPWQsai5raWxsKCkuX2djPSExLGQudmVyc2lvbj1cIjEuMTguMlwiLGouaW52YWxpZGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl95b3lvPXRoaXMudmFycy55b3lvPT09ITAsdGhpcy5fcmVwZWF0PXRoaXMudmFycy5yZXBlYXR8fDAsdGhpcy5fcmVwZWF0RGVsYXk9dGhpcy52YXJzLnJlcGVhdERlbGF5fHwwLHRoaXMuX3VuY2FjaGUoITApLGEucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKX0sai5hZGRDYWxsYmFjaz1mdW5jdGlvbihhLGMsZCxlKXtyZXR1cm4gdGhpcy5hZGQoYi5kZWxheWVkQ2FsbCgwLGEsZCxlKSxjKX0sai5yZW1vdmVDYWxsYmFjaz1mdW5jdGlvbihhLGIpe2lmKGEpaWYobnVsbD09Yil0aGlzLl9raWxsKG51bGwsYSk7ZWxzZSBmb3IodmFyIGM9dGhpcy5nZXRUd2VlbnNPZihhLCExKSxkPWMubGVuZ3RoLGU9dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChiKTstLWQ+LTE7KWNbZF0uX3N0YXJ0VGltZT09PWUmJmNbZF0uX2VuYWJsZWQoITEsITEpO3JldHVybiB0aGlzfSxqLnJlbW92ZVBhdXNlPWZ1bmN0aW9uKGIpe3JldHVybiB0aGlzLnJlbW92ZUNhbGxiYWNrKGEuX2ludGVybmFscy5wYXVzZUNhbGxiYWNrLGIpfSxqLnR3ZWVuVG89ZnVuY3Rpb24oYSxjKXtjPWN8fHt9O3ZhciBkLGUsZixnPXtlYXNlOmksdXNlRnJhbWVzOnRoaXMudXNlc0ZyYW1lcygpLGltbWVkaWF0ZVJlbmRlcjohMX07Zm9yKGUgaW4gYylnW2VdPWNbZV07cmV0dXJuIGcudGltZT10aGlzLl9wYXJzZVRpbWVPckxhYmVsKGEpLGQ9TWF0aC5hYnMoTnVtYmVyKGcudGltZSktdGhpcy5fdGltZSkvdGhpcy5fdGltZVNjYWxlfHwuMDAxLGY9bmV3IGIodGhpcyxkLGcpLGcub25TdGFydD1mdW5jdGlvbigpe2YudGFyZ2V0LnBhdXNlZCghMCksZi52YXJzLnRpbWUhPT1mLnRhcmdldC50aW1lKCkmJmQ9PT1mLmR1cmF0aW9uKCkmJmYuZHVyYXRpb24oTWF0aC5hYnMoZi52YXJzLnRpbWUtZi50YXJnZXQudGltZSgpKS9mLnRhcmdldC5fdGltZVNjYWxlKSxjLm9uU3RhcnQmJmYuX2NhbGxiYWNrKFwib25TdGFydFwiKX0sZn0sai50d2VlbkZyb21Ubz1mdW5jdGlvbihhLGIsYyl7Yz1jfHx7fSxhPXRoaXMuX3BhcnNlVGltZU9yTGFiZWwoYSksYy5zdGFydEF0PXtvbkNvbXBsZXRlOnRoaXMuc2VlayxvbkNvbXBsZXRlUGFyYW1zOlthXSxjYWxsYmFja1Njb3BlOnRoaXN9LGMuaW1tZWRpYXRlUmVuZGVyPWMuaW1tZWRpYXRlUmVuZGVyIT09ITE7dmFyIGQ9dGhpcy50d2VlblRvKGIsYyk7cmV0dXJuIGQuZHVyYXRpb24oTWF0aC5hYnMoZC52YXJzLnRpbWUtYSkvdGhpcy5fdGltZVNjYWxlfHwuMDAxKX0sai5yZW5kZXI9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuX2djJiZ0aGlzLl9lbmFibGVkKCEwLCExKTt2YXIgZCxmLGksaixrLGwsbSxuLG89dGhpcy5fZGlydHk/dGhpcy50b3RhbER1cmF0aW9uKCk6dGhpcy5fdG90YWxEdXJhdGlvbixwPXRoaXMuX2R1cmF0aW9uLHE9dGhpcy5fdGltZSxyPXRoaXMuX3RvdGFsVGltZSxzPXRoaXMuX3N0YXJ0VGltZSx0PXRoaXMuX3RpbWVTY2FsZSx1PXRoaXMuX3Jhd1ByZXZUaW1lLHY9dGhpcy5fcGF1c2VkLHc9dGhpcy5fY3ljbGU7aWYoYT49by0xZS03KXRoaXMuX2xvY2tlZHx8KHRoaXMuX3RvdGFsVGltZT1vLHRoaXMuX2N5Y2xlPXRoaXMuX3JlcGVhdCksdGhpcy5fcmV2ZXJzZWR8fHRoaXMuX2hhc1BhdXNlZENoaWxkKCl8fChmPSEwLGo9XCJvbkNvbXBsZXRlXCIsaz0hIXRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiwwPT09dGhpcy5fZHVyYXRpb24mJigwPj1hJiZhPj0tMWUtN3x8MD51fHx1PT09ZSkmJnUhPT1hJiZ0aGlzLl9maXJzdCYmKGs9ITAsdT5lJiYoaj1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIpKSksdGhpcy5fcmF3UHJldlRpbWU9dGhpcy5fZHVyYXRpb258fCFifHxhfHx0aGlzLl9yYXdQcmV2VGltZT09PWE/YTplLHRoaXMuX3lveW8mJjAhPT0oMSZ0aGlzLl9jeWNsZSk/dGhpcy5fdGltZT1hPTA6KHRoaXMuX3RpbWU9cCxhPXArMWUtNCk7ZWxzZSBpZigxZS03PmEpaWYodGhpcy5fbG9ja2VkfHwodGhpcy5fdG90YWxUaW1lPXRoaXMuX2N5Y2xlPTApLHRoaXMuX3RpbWU9MCwoMCE9PXF8fDA9PT1wJiZ1IT09ZSYmKHU+MHx8MD5hJiZ1Pj0wKSYmIXRoaXMuX2xvY2tlZCkmJihqPVwib25SZXZlcnNlQ29tcGxldGVcIixmPXRoaXMuX3JldmVyc2VkKSwwPmEpdGhpcy5fYWN0aXZlPSExLHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiYmdGhpcy5fcmV2ZXJzZWQ/KGs9Zj0hMCxqPVwib25SZXZlcnNlQ29tcGxldGVcIik6dT49MCYmdGhpcy5fZmlyc3QmJihrPSEwKSx0aGlzLl9yYXdQcmV2VGltZT1hO2Vsc2V7aWYodGhpcy5fcmF3UHJldlRpbWU9cHx8IWJ8fGF8fHRoaXMuX3Jhd1ByZXZUaW1lPT09YT9hOmUsMD09PWEmJmYpZm9yKGQ9dGhpcy5fZmlyc3Q7ZCYmMD09PWQuX3N0YXJ0VGltZTspZC5fZHVyYXRpb258fChmPSExKSxkPWQuX25leHQ7YT0wLHRoaXMuX2luaXR0ZWR8fChrPSEwKX1lbHNlIGlmKDA9PT1wJiYwPnUmJihrPSEwKSx0aGlzLl90aW1lPXRoaXMuX3Jhd1ByZXZUaW1lPWEsdGhpcy5fbG9ja2VkfHwodGhpcy5fdG90YWxUaW1lPWEsMCE9PXRoaXMuX3JlcGVhdCYmKGw9cCt0aGlzLl9yZXBlYXREZWxheSx0aGlzLl9jeWNsZT10aGlzLl90b3RhbFRpbWUvbD4+MCwwIT09dGhpcy5fY3ljbGUmJnRoaXMuX2N5Y2xlPT09dGhpcy5fdG90YWxUaW1lL2wmJnRoaXMuX2N5Y2xlLS0sdGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWUtdGhpcy5fY3ljbGUqbCx0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpJiYodGhpcy5fdGltZT1wLXRoaXMuX3RpbWUpLHRoaXMuX3RpbWU+cD8odGhpcy5fdGltZT1wLGE9cCsxZS00KTp0aGlzLl90aW1lPDA/dGhpcy5fdGltZT1hPTA6YT10aGlzLl90aW1lKSksdGhpcy5faGFzUGF1c2UmJiF0aGlzLl9mb3JjaW5nUGxheWhlYWQmJiFiKXtpZihhPXRoaXMuX3RpbWUsYT49cSlmb3IoZD10aGlzLl9maXJzdDtkJiZkLl9zdGFydFRpbWU8PWEmJiFtOylkLl9kdXJhdGlvbnx8XCJpc1BhdXNlXCIhPT1kLmRhdGF8fGQucmF0aW98fDA9PT1kLl9zdGFydFRpbWUmJjA9PT10aGlzLl9yYXdQcmV2VGltZXx8KG09ZCksZD1kLl9uZXh0O2Vsc2UgZm9yKGQ9dGhpcy5fbGFzdDtkJiZkLl9zdGFydFRpbWU+PWEmJiFtOylkLl9kdXJhdGlvbnx8XCJpc1BhdXNlXCI9PT1kLmRhdGEmJmQuX3Jhd1ByZXZUaW1lPjAmJihtPWQpLGQ9ZC5fcHJldjttJiYodGhpcy5fdGltZT1hPW0uX3N0YXJ0VGltZSx0aGlzLl90b3RhbFRpbWU9YSt0aGlzLl9jeWNsZSoodGhpcy5fdG90YWxEdXJhdGlvbit0aGlzLl9yZXBlYXREZWxheSkpfWlmKHRoaXMuX2N5Y2xlIT09dyYmIXRoaXMuX2xvY2tlZCl7dmFyIHg9dGhpcy5feW95byYmMCE9PSgxJncpLHk9eD09PSh0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpKSx6PXRoaXMuX3RvdGFsVGltZSxBPXRoaXMuX2N5Y2xlLEI9dGhpcy5fcmF3UHJldlRpbWUsQz10aGlzLl90aW1lO2lmKHRoaXMuX3RvdGFsVGltZT13KnAsdGhpcy5fY3ljbGU8dz94PSF4OnRoaXMuX3RvdGFsVGltZSs9cCx0aGlzLl90aW1lPXEsdGhpcy5fcmF3UHJldlRpbWU9MD09PXA/dS0xZS00OnUsdGhpcy5fY3ljbGU9dyx0aGlzLl9sb2NrZWQ9ITAscT14PzA6cCx0aGlzLnJlbmRlcihxLGIsMD09PXApLGJ8fHRoaXMuX2djfHx0aGlzLnZhcnMub25SZXBlYXQmJnRoaXMuX2NhbGxiYWNrKFwib25SZXBlYXRcIikscSE9PXRoaXMuX3RpbWUpcmV0dXJuO2lmKHkmJihxPXg/cCsxZS00Oi0xZS00LHRoaXMucmVuZGVyKHEsITAsITEpKSx0aGlzLl9sb2NrZWQ9ITEsdGhpcy5fcGF1c2VkJiYhdilyZXR1cm47dGhpcy5fdGltZT1DLHRoaXMuX3RvdGFsVGltZT16LHRoaXMuX2N5Y2xlPUEsdGhpcy5fcmF3UHJldlRpbWU9Qn1pZighKHRoaXMuX3RpbWUhPT1xJiZ0aGlzLl9maXJzdHx8Y3x8a3x8bSkpcmV0dXJuIHZvaWQociE9PXRoaXMuX3RvdGFsVGltZSYmdGhpcy5fb25VcGRhdGUmJihifHx0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpKSk7aWYodGhpcy5faW5pdHRlZHx8KHRoaXMuX2luaXR0ZWQ9ITApLHRoaXMuX2FjdGl2ZXx8IXRoaXMuX3BhdXNlZCYmdGhpcy5fdG90YWxUaW1lIT09ciYmYT4wJiYodGhpcy5fYWN0aXZlPSEwKSwwPT09ciYmdGhpcy52YXJzLm9uU3RhcnQmJjAhPT10aGlzLl90b3RhbFRpbWUmJihifHx0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIikpLG49dGhpcy5fdGltZSxuPj1xKWZvcihkPXRoaXMuX2ZpcnN0O2QmJihpPWQuX25leHQsbj09PXRoaXMuX3RpbWUmJighdGhpcy5fcGF1c2VkfHx2KSk7KShkLl9hY3RpdmV8fGQuX3N0YXJ0VGltZTw9dGhpcy5fdGltZSYmIWQuX3BhdXNlZCYmIWQuX2djKSYmKG09PT1kJiZ0aGlzLnBhdXNlKCksZC5fcmV2ZXJzZWQ/ZC5yZW5kZXIoKGQuX2RpcnR5P2QudG90YWxEdXJhdGlvbigpOmQuX3RvdGFsRHVyYXRpb24pLShhLWQuX3N0YXJ0VGltZSkqZC5fdGltZVNjYWxlLGIsYyk6ZC5yZW5kZXIoKGEtZC5fc3RhcnRUaW1lKSpkLl90aW1lU2NhbGUsYixjKSksZD1pO2Vsc2UgZm9yKGQ9dGhpcy5fbGFzdDtkJiYoaT1kLl9wcmV2LG49PT10aGlzLl90aW1lJiYoIXRoaXMuX3BhdXNlZHx8dikpOyl7aWYoZC5fYWN0aXZlfHxkLl9zdGFydFRpbWU8PXEmJiFkLl9wYXVzZWQmJiFkLl9nYyl7aWYobT09PWQpe2ZvcihtPWQuX3ByZXY7bSYmbS5lbmRUaW1lKCk+dGhpcy5fdGltZTspbS5yZW5kZXIobS5fcmV2ZXJzZWQ/bS50b3RhbER1cmF0aW9uKCktKGEtbS5fc3RhcnRUaW1lKSptLl90aW1lU2NhbGU6KGEtbS5fc3RhcnRUaW1lKSptLl90aW1lU2NhbGUsYixjKSxtPW0uX3ByZXY7bT1udWxsLHRoaXMucGF1c2UoKX1kLl9yZXZlcnNlZD9kLnJlbmRlcigoZC5fZGlydHk/ZC50b3RhbER1cmF0aW9uKCk6ZC5fdG90YWxEdXJhdGlvbiktKGEtZC5fc3RhcnRUaW1lKSpkLl90aW1lU2NhbGUsYixjKTpkLnJlbmRlcigoYS1kLl9zdGFydFRpbWUpKmQuX3RpbWVTY2FsZSxiLGMpfWQ9aX10aGlzLl9vblVwZGF0ZSYmKGJ8fChnLmxlbmd0aCYmaCgpLHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpKSxqJiYodGhpcy5fbG9ja2VkfHx0aGlzLl9nY3x8KHM9PT10aGlzLl9zdGFydFRpbWV8fHQhPT10aGlzLl90aW1lU2NhbGUpJiYoMD09PXRoaXMuX3RpbWV8fG8+PXRoaXMudG90YWxEdXJhdGlvbigpKSYmKGYmJihnLmxlbmd0aCYmaCgpLHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiYmdGhpcy5fZW5hYmxlZCghMSwhMSksdGhpcy5fYWN0aXZlPSExKSwhYiYmdGhpcy52YXJzW2pdJiZ0aGlzLl9jYWxsYmFjayhqKSkpfSxqLmdldEFjdGl2ZT1mdW5jdGlvbihhLGIsYyl7bnVsbD09YSYmKGE9ITApLG51bGw9PWImJihiPSEwKSxudWxsPT1jJiYoYz0hMSk7dmFyIGQsZSxmPVtdLGc9dGhpcy5nZXRDaGlsZHJlbihhLGIsYyksaD0wLGk9Zy5sZW5ndGg7Zm9yKGQ9MDtpPmQ7ZCsrKWU9Z1tkXSxlLmlzQWN0aXZlKCkmJihmW2grK109ZSk7cmV0dXJuIGZ9LGouZ2V0TGFiZWxBZnRlcj1mdW5jdGlvbihhKXthfHwwIT09YSYmKGE9dGhpcy5fdGltZSk7dmFyIGIsYz10aGlzLmdldExhYmVsc0FycmF5KCksZD1jLmxlbmd0aDtmb3IoYj0wO2Q+YjtiKyspaWYoY1tiXS50aW1lPmEpcmV0dXJuIGNbYl0ubmFtZTtyZXR1cm4gbnVsbH0sai5nZXRMYWJlbEJlZm9yZT1mdW5jdGlvbihhKXtudWxsPT1hJiYoYT10aGlzLl90aW1lKTtmb3IodmFyIGI9dGhpcy5nZXRMYWJlbHNBcnJheSgpLGM9Yi5sZW5ndGg7LS1jPi0xOylpZihiW2NdLnRpbWU8YSlyZXR1cm4gYltjXS5uYW1lO3JldHVybiBudWxsfSxqLmdldExhYmVsc0FycmF5PWZ1bmN0aW9uKCl7dmFyIGEsYj1bXSxjPTA7Zm9yKGEgaW4gdGhpcy5fbGFiZWxzKWJbYysrXT17dGltZTp0aGlzLl9sYWJlbHNbYV0sbmFtZTphfTtyZXR1cm4gYi5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEudGltZS1iLnRpbWV9KSxifSxqLnByb2dyZXNzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dGhpcy50b3RhbFRpbWUodGhpcy5kdXJhdGlvbigpKih0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpPzEtYTphKSt0aGlzLl9jeWNsZSoodGhpcy5fZHVyYXRpb24rdGhpcy5fcmVwZWF0RGVsYXkpLGIpOnRoaXMuX3RpbWUvdGhpcy5kdXJhdGlvbigpfSxqLnRvdGFsUHJvZ3Jlc3M9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90aGlzLnRvdGFsVGltZSh0aGlzLnRvdGFsRHVyYXRpb24oKSphLGIpOnRoaXMuX3RvdGFsVGltZS90aGlzLnRvdGFsRHVyYXRpb24oKX0sai50b3RhbER1cmF0aW9uPWZ1bmN0aW9uKGIpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPy0xIT09dGhpcy5fcmVwZWF0JiZiP3RoaXMudGltZVNjYWxlKHRoaXMudG90YWxEdXJhdGlvbigpL2IpOnRoaXM6KHRoaXMuX2RpcnR5JiYoYS5wcm90b3R5cGUudG90YWxEdXJhdGlvbi5jYWxsKHRoaXMpLHRoaXMuX3RvdGFsRHVyYXRpb249LTE9PT10aGlzLl9yZXBlYXQ/OTk5OTk5OTk5OTk5OnRoaXMuX2R1cmF0aW9uKih0aGlzLl9yZXBlYXQrMSkrdGhpcy5fcmVwZWF0RGVsYXkqdGhpcy5fcmVwZWF0KSx0aGlzLl90b3RhbER1cmF0aW9uKX0sai50aW1lPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX2RpcnR5JiZ0aGlzLnRvdGFsRHVyYXRpb24oKSxhPnRoaXMuX2R1cmF0aW9uJiYoYT10aGlzLl9kdXJhdGlvbiksdGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKT9hPXRoaXMuX2R1cmF0aW9uLWErdGhpcy5fY3ljbGUqKHRoaXMuX2R1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KTowIT09dGhpcy5fcmVwZWF0JiYoYSs9dGhpcy5fY3ljbGUqKHRoaXMuX2R1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KSksdGhpcy50b3RhbFRpbWUoYSxiKSk6dGhpcy5fdGltZX0sai5yZXBlYXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3JlcGVhdD1hLHRoaXMuX3VuY2FjaGUoITApKTp0aGlzLl9yZXBlYXR9LGoucmVwZWF0RGVsYXk9ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3JlcGVhdERlbGF5PWEsdGhpcy5fdW5jYWNoZSghMCkpOnRoaXMuX3JlcGVhdERlbGF5fSxqLnlveW89ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3lveW89YSx0aGlzKTp0aGlzLl95b3lvfSxqLmN1cnJlbnRMYWJlbD1mdW5jdGlvbihhKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90aGlzLnNlZWsoYSwhMCk6dGhpcy5nZXRMYWJlbEJlZm9yZSh0aGlzLl90aW1lKzFlLTgpfSxkfSwhMCksZnVuY3Rpb24oKXt2YXIgYT0xODAvTWF0aC5QSSxiPVtdLGM9W10sZD1bXSxlPXt9LGY9X2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsZz1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLmE9YSx0aGlzLmI9Yix0aGlzLmM9Yyx0aGlzLmQ9ZCx0aGlzLmRhPWQtYSx0aGlzLmNhPWMtYSx0aGlzLmJhPWItYX0saD1cIix4LHkseixsZWZ0LHRvcCxyaWdodCxib3R0b20sbWFyZ2luVG9wLG1hcmdpbkxlZnQsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLHBhZGRpbmdMZWZ0LHBhZGRpbmdUb3AscGFkZGluZ1JpZ2h0LHBhZGRpbmdCb3R0b20sYmFja2dyb3VuZFBvc2l0aW9uLGJhY2tncm91bmRQb3NpdGlvbl95LFwiLGk9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9e2E6YX0sZj17fSxnPXt9LGg9e2M6ZH0saT0oYStiKS8yLGo9KGIrYykvMixrPShjK2QpLzIsbD0oaStqKS8yLG09KGoraykvMixuPShtLWwpLzg7cmV0dXJuIGUuYj1pKyhhLWkpLzQsZi5iPWwrbixlLmM9Zi5hPShlLmIrZi5iKS8yLGYuYz1nLmE9KGwrbSkvMixnLmI9bS1uLGguYj1rKyhkLWspLzQsZy5jPWguYT0oZy5iK2guYikvMixbZSxmLGcsaF19LGo9ZnVuY3Rpb24oYSxlLGYsZyxoKXt2YXIgaixrLGwsbSxuLG8scCxxLHIscyx0LHUsdix3PWEubGVuZ3RoLTEseD0wLHk9YVswXS5hO2ZvcihqPTA7dz5qO2orKyluPWFbeF0saz1uLmEsbD1uLmQsbT1hW3grMV0uZCxoPyh0PWJbal0sdT1jW2pdLHY9KHUrdCkqZSouMjUvKGc/LjU6ZFtqXXx8LjUpLG89bC0obC1rKSooZz8uNSplOjAhPT10P3YvdDowKSxwPWwrKG0tbCkqKGc/LjUqZTowIT09dT92L3U6MCkscT1sLShvKygocC1vKSooMyp0Lyh0K3UpKy41KS80fHwwKSkpOihvPWwtKGwtaykqZSouNSxwPWwrKG0tbCkqZSouNSxxPWwtKG8rcCkvMiksbys9cSxwKz1xLG4uYz1yPW8sMCE9PWo/bi5iPXk6bi5iPXk9bi5hKy42KihuLmMtbi5hKSxuLmRhPWwtayxuLmNhPXItayxuLmJhPXktayxmPyhzPWkoayx5LHIsbCksYS5zcGxpY2UoeCwxLHNbMF0sc1sxXSxzWzJdLHNbM10pLHgrPTQpOngrKyx5PXA7bj1hW3hdLG4uYj15LG4uYz15Ky40KihuLmQteSksbi5kYT1uLmQtbi5hLG4uY2E9bi5jLW4uYSxuLmJhPXktbi5hLGYmJihzPWkobi5hLHksbi5jLG4uZCksYS5zcGxpY2UoeCwxLHNbMF0sc1sxXSxzWzJdLHNbM10pKX0saz1mdW5jdGlvbihhLGQsZSxmKXt2YXIgaCxpLGosayxsLG0sbj1bXTtpZihmKWZvcihhPVtmXS5jb25jYXQoYSksaT1hLmxlbmd0aDstLWk+LTE7KVwic3RyaW5nXCI9PXR5cGVvZihtPWFbaV1bZF0pJiZcIj1cIj09PW0uY2hhckF0KDEpJiYoYVtpXVtkXT1mW2RdK051bWJlcihtLmNoYXJBdCgwKSttLnN1YnN0cigyKSkpO2lmKGg9YS5sZW5ndGgtMiwwPmgpcmV0dXJuIG5bMF09bmV3IGcoYVswXVtkXSwwLDAsYVstMT5oPzA6MV1bZF0pLG47Zm9yKGk9MDtoPmk7aSsrKWo9YVtpXVtkXSxrPWFbaSsxXVtkXSxuW2ldPW5ldyBnKGosMCwwLGspLGUmJihsPWFbaSsyXVtkXSxiW2ldPShiW2ldfHwwKSsoay1qKSooay1qKSxjW2ldPShjW2ldfHwwKSsobC1rKSoobC1rKSk7cmV0dXJuIG5baV09bmV3IGcoYVtpXVtkXSwwLDAsYVtpKzFdW2RdKSxufSxsPWZ1bmN0aW9uKGEsZixnLGksbCxtKXt2YXIgbixvLHAscSxyLHMsdCx1LHY9e30sdz1bXSx4PW18fGFbMF07bD1cInN0cmluZ1wiPT10eXBlb2YgbD9cIixcIitsK1wiLFwiOmgsbnVsbD09ZiYmKGY9MSk7Zm9yKG8gaW4gYVswXSl3LnB1c2gobyk7aWYoYS5sZW5ndGg+MSl7Zm9yKHU9YVthLmxlbmd0aC0xXSx0PSEwLG49dy5sZW5ndGg7LS1uPi0xOylpZihvPXdbbl0sTWF0aC5hYnMoeFtvXS11W29dKT4uMDUpe3Q9ITE7YnJlYWt9dCYmKGE9YS5jb25jYXQoKSxtJiZhLnVuc2hpZnQobSksYS5wdXNoKGFbMV0pLG09YVthLmxlbmd0aC0zXSl9Zm9yKGIubGVuZ3RoPWMubGVuZ3RoPWQubGVuZ3RoPTAsbj13Lmxlbmd0aDstLW4+LTE7KW89d1tuXSxlW29dPS0xIT09bC5pbmRleE9mKFwiLFwiK28rXCIsXCIpLHZbb109ayhhLG8sZVtvXSxtKTtmb3Iobj1iLmxlbmd0aDstLW4+LTE7KWJbbl09TWF0aC5zcXJ0KGJbbl0pLGNbbl09TWF0aC5zcXJ0KGNbbl0pO2lmKCFpKXtmb3Iobj13Lmxlbmd0aDstLW4+LTE7KWlmKGVbb10pZm9yKHA9dlt3W25dXSxzPXAubGVuZ3RoLTEscT0wO3M+cTtxKyspcj1wW3ErMV0uZGEvY1txXStwW3FdLmRhL2JbcV0sZFtxXT0oZFtxXXx8MCkrcipyO2ZvcihuPWQubGVuZ3RoOy0tbj4tMTspZFtuXT1NYXRoLnNxcnQoZFtuXSl9Zm9yKG49dy5sZW5ndGgscT1nPzQ6MTstLW4+LTE7KW89d1tuXSxwPXZbb10saihwLGYsZyxpLGVbb10pLHQmJihwLnNwbGljZSgwLHEpLHAuc3BsaWNlKHAubGVuZ3RoLXEscSkpO3JldHVybiB2fSxtPWZ1bmN0aW9uKGEsYixjKXtiPWJ8fFwic29mdFwiO3ZhciBkLGUsZixoLGksaixrLGwsbSxuLG8scD17fSxxPVwiY3ViaWNcIj09PWI/MzoyLHI9XCJzb2Z0XCI9PT1iLHM9W107aWYociYmYyYmKGE9W2NdLmNvbmNhdChhKSksbnVsbD09YXx8YS5sZW5ndGg8cSsxKXRocm93XCJpbnZhbGlkIEJlemllciBkYXRhXCI7Zm9yKG0gaW4gYVswXSlzLnB1c2gobSk7Zm9yKGo9cy5sZW5ndGg7LS1qPi0xOyl7Zm9yKG09c1tqXSxwW21dPWk9W10sbj0wLGw9YS5sZW5ndGgsaz0wO2w+aztrKyspZD1udWxsPT1jP2Fba11bbV06XCJzdHJpbmdcIj09dHlwZW9mKG89YVtrXVttXSkmJlwiPVwiPT09by5jaGFyQXQoMSk/Y1ttXStOdW1iZXIoby5jaGFyQXQoMCkrby5zdWJzdHIoMikpOk51bWJlcihvKSxyJiZrPjEmJmwtMT5rJiYoaVtuKytdPShkK2lbbi0yXSkvMiksaVtuKytdPWQ7Zm9yKGw9bi1xKzEsbj0wLGs9MDtsPms7ays9cSlkPWlba10sZT1pW2srMV0sZj1pW2srMl0saD0yPT09cT8wOmlbayszXSxpW24rK109bz0zPT09cT9uZXcgZyhkLGUsZixoKTpuZXcgZyhkLCgyKmUrZCkvMywoMiplK2YpLzMsZik7aS5sZW5ndGg9bn1yZXR1cm4gcH0sbj1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkLGUsZixnLGgsaSxqLGssbCxtLG4sbz0xL2MscD1hLmxlbmd0aDstLXA+LTE7KWZvcihtPWFbcF0sZj1tLmEsZz1tLmQtZixoPW0uYy1mLGk9bS5iLWYsZD1lPTAsaz0xO2M+PWs7aysrKWo9byprLGw9MS1qLGQ9ZS0oZT0oaipqKmcrMypsKihqKmgrbCppKSkqaiksbj1wKmMray0xLGJbbl09KGJbbl18fDApK2QqZH0sbz1mdW5jdGlvbihhLGIpe2I9Yj4+MHx8Njt2YXIgYyxkLGUsZixnPVtdLGg9W10saT0wLGo9MCxrPWItMSxsPVtdLG09W107Zm9yKGMgaW4gYSluKGFbY10sZyxiKTtmb3IoZT1nLmxlbmd0aCxkPTA7ZT5kO2QrKylpKz1NYXRoLnNxcnQoZ1tkXSksZj1kJWIsbVtmXT1pLGY9PT1rJiYoais9aSxmPWQvYj4+MCxsW2ZdPW0saFtmXT1qLGk9MCxtPVtdKTtyZXR1cm57bGVuZ3RoOmosbGVuZ3RoczpoLHNlZ21lbnRzOmx9fSxwPV9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe3Byb3BOYW1lOlwiYmV6aWVyXCIscHJpb3JpdHk6LTEsdmVyc2lvbjpcIjEuMy40XCIsQVBJOjIsZ2xvYmFsOiEwLGluaXQ6ZnVuY3Rpb24oYSxiLGMpe3RoaXMuX3RhcmdldD1hLGIgaW5zdGFuY2VvZiBBcnJheSYmKGI9e3ZhbHVlczpifSksdGhpcy5fZnVuYz17fSx0aGlzLl9yb3VuZD17fSx0aGlzLl9wcm9wcz1bXSx0aGlzLl90aW1lUmVzPW51bGw9PWIudGltZVJlc29sdXRpb24/NjpwYXJzZUludChiLnRpbWVSZXNvbHV0aW9uLDEwKTtcbnZhciBkLGUsZixnLGgsaT1iLnZhbHVlc3x8W10saj17fSxrPWlbMF0sbj1iLmF1dG9Sb3RhdGV8fGMudmFycy5vcmllbnRUb0Jlemllcjt0aGlzLl9hdXRvUm90YXRlPW4/biBpbnN0YW5jZW9mIEFycmF5P246W1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsbj09PSEwPzA6TnVtYmVyKG4pfHwwXV06bnVsbDtmb3IoZCBpbiBrKXRoaXMuX3Byb3BzLnB1c2goZCk7Zm9yKGY9dGhpcy5fcHJvcHMubGVuZ3RoOy0tZj4tMTspZD10aGlzLl9wcm9wc1tmXSx0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKGQpLGU9dGhpcy5fZnVuY1tkXT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBhW2RdLGpbZF09ZT9hW2QuaW5kZXhPZihcInNldFwiKXx8XCJmdW5jdGlvblwiIT10eXBlb2YgYVtcImdldFwiK2Quc3Vic3RyKDMpXT9kOlwiZ2V0XCIrZC5zdWJzdHIoMyldKCk6cGFyc2VGbG9hdChhW2RdKSxofHxqW2RdIT09aVswXVtkXSYmKGg9aik7aWYodGhpcy5fYmV6aWVycz1cImN1YmljXCIhPT1iLnR5cGUmJlwicXVhZHJhdGljXCIhPT1iLnR5cGUmJlwic29mdFwiIT09Yi50eXBlP2woaSxpc05hTihiLmN1cnZpbmVzcyk/MTpiLmN1cnZpbmVzcywhMSxcInRocnVCYXNpY1wiPT09Yi50eXBlLGIuY29ycmVsYXRlLGgpOm0oaSxiLnR5cGUsaiksdGhpcy5fc2VnQ291bnQ9dGhpcy5fYmV6aWVyc1tkXS5sZW5ndGgsdGhpcy5fdGltZVJlcyl7dmFyIHA9byh0aGlzLl9iZXppZXJzLHRoaXMuX3RpbWVSZXMpO3RoaXMuX2xlbmd0aD1wLmxlbmd0aCx0aGlzLl9sZW5ndGhzPXAubGVuZ3Rocyx0aGlzLl9zZWdtZW50cz1wLnNlZ21lbnRzLHRoaXMuX2wxPXRoaXMuX2xpPXRoaXMuX3MxPXRoaXMuX3NpPTAsdGhpcy5fbDI9dGhpcy5fbGVuZ3Roc1swXSx0aGlzLl9jdXJTZWc9dGhpcy5fc2VnbWVudHNbMF0sdGhpcy5fczI9dGhpcy5fY3VyU2VnWzBdLHRoaXMuX3ByZWM9MS90aGlzLl9jdXJTZWcubGVuZ3RofWlmKG49dGhpcy5fYXV0b1JvdGF0ZSlmb3IodGhpcy5faW5pdGlhbFJvdGF0aW9ucz1bXSxuWzBdaW5zdGFuY2VvZiBBcnJheXx8KHRoaXMuX2F1dG9Sb3RhdGU9bj1bbl0pLGY9bi5sZW5ndGg7LS1mPi0xOyl7Zm9yKGc9MDszPmc7ZysrKWQ9bltmXVtnXSx0aGlzLl9mdW5jW2RdPVwiZnVuY3Rpb25cIj09dHlwZW9mIGFbZF0/YVtkLmluZGV4T2YoXCJzZXRcIil8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGFbXCJnZXRcIitkLnN1YnN0cigzKV0/ZDpcImdldFwiK2Quc3Vic3RyKDMpXTohMTtkPW5bZl1bMl0sdGhpcy5faW5pdGlhbFJvdGF0aW9uc1tmXT10aGlzLl9mdW5jW2RdP3RoaXMuX2Z1bmNbZF0uY2FsbCh0aGlzLl90YXJnZXQpOnRoaXMuX3RhcmdldFtkXX1yZXR1cm4gdGhpcy5fc3RhcnRSYXRpbz1jLnZhcnMucnVuQmFja3dhcmRzPzE6MCwhMH0sc2V0OmZ1bmN0aW9uKGIpe3ZhciBjLGQsZSxmLGcsaCxpLGosayxsLG09dGhpcy5fc2VnQ291bnQsbj10aGlzLl9mdW5jLG89dGhpcy5fdGFyZ2V0LHA9YiE9PXRoaXMuX3N0YXJ0UmF0aW87aWYodGhpcy5fdGltZVJlcyl7aWYoaz10aGlzLl9sZW5ndGhzLGw9dGhpcy5fY3VyU2VnLGIqPXRoaXMuX2xlbmd0aCxlPXRoaXMuX2xpLGI+dGhpcy5fbDImJm0tMT5lKXtmb3Ioaj1tLTE7aj5lJiYodGhpcy5fbDI9a1srK2VdKTw9YjspO3RoaXMuX2wxPWtbZS0xXSx0aGlzLl9saT1lLHRoaXMuX2N1clNlZz1sPXRoaXMuX3NlZ21lbnRzW2VdLHRoaXMuX3MyPWxbdGhpcy5fczE9dGhpcy5fc2k9MF19ZWxzZSBpZihiPHRoaXMuX2wxJiZlPjApe2Zvcig7ZT4wJiYodGhpcy5fbDE9a1stLWVdKT49YjspOzA9PT1lJiZiPHRoaXMuX2wxP3RoaXMuX2wxPTA6ZSsrLHRoaXMuX2wyPWtbZV0sdGhpcy5fbGk9ZSx0aGlzLl9jdXJTZWc9bD10aGlzLl9zZWdtZW50c1tlXSx0aGlzLl9zMT1sWyh0aGlzLl9zaT1sLmxlbmd0aC0xKS0xXXx8MCx0aGlzLl9zMj1sW3RoaXMuX3NpXX1pZihjPWUsYi09dGhpcy5fbDEsZT10aGlzLl9zaSxiPnRoaXMuX3MyJiZlPGwubGVuZ3RoLTEpe2ZvcihqPWwubGVuZ3RoLTE7aj5lJiYodGhpcy5fczI9bFsrK2VdKTw9YjspO3RoaXMuX3MxPWxbZS0xXSx0aGlzLl9zaT1lfWVsc2UgaWYoYjx0aGlzLl9zMSYmZT4wKXtmb3IoO2U+MCYmKHRoaXMuX3MxPWxbLS1lXSk+PWI7KTswPT09ZSYmYjx0aGlzLl9zMT90aGlzLl9zMT0wOmUrKyx0aGlzLl9zMj1sW2VdLHRoaXMuX3NpPWV9aD0oZSsoYi10aGlzLl9zMSkvKHRoaXMuX3MyLXRoaXMuX3MxKSkqdGhpcy5fcHJlY31lbHNlIGM9MD5iPzA6Yj49MT9tLTE6bSpiPj4wLGg9KGItYyooMS9tKSkqbTtmb3IoZD0xLWgsZT10aGlzLl9wcm9wcy5sZW5ndGg7LS1lPi0xOylmPXRoaXMuX3Byb3BzW2VdLGc9dGhpcy5fYmV6aWVyc1tmXVtjXSxpPShoKmgqZy5kYSszKmQqKGgqZy5jYStkKmcuYmEpKSpoK2cuYSx0aGlzLl9yb3VuZFtmXSYmKGk9TWF0aC5yb3VuZChpKSksbltmXT9vW2ZdKGkpOm9bZl09aTtpZih0aGlzLl9hdXRvUm90YXRlKXt2YXIgcSxyLHMsdCx1LHYsdyx4PXRoaXMuX2F1dG9Sb3RhdGU7Zm9yKGU9eC5sZW5ndGg7LS1lPi0xOylmPXhbZV1bMl0sdj14W2VdWzNdfHwwLHc9eFtlXVs0XT09PSEwPzE6YSxnPXRoaXMuX2JlemllcnNbeFtlXVswXV0scT10aGlzLl9iZXppZXJzW3hbZV1bMV1dLGcmJnEmJihnPWdbY10scT1xW2NdLHI9Zy5hKyhnLmItZy5hKSpoLHQ9Zy5iKyhnLmMtZy5iKSpoLHIrPSh0LXIpKmgsdCs9KGcuYysoZy5kLWcuYykqaC10KSpoLHM9cS5hKyhxLmItcS5hKSpoLHU9cS5iKyhxLmMtcS5iKSpoLHMrPSh1LXMpKmgsdSs9KHEuYysocS5kLXEuYykqaC11KSpoLGk9cD9NYXRoLmF0YW4yKHUtcyx0LXIpKncrdjp0aGlzLl9pbml0aWFsUm90YXRpb25zW2VdLG5bZl0/b1tmXShpKTpvW2ZdPWkpfX19KSxxPXAucHJvdG90eXBlO3AuYmV6aWVyVGhyb3VnaD1sLHAuY3ViaWNUb1F1YWRyYXRpYz1pLHAuX2F1dG9DU1M9ITAscC5xdWFkcmF0aWNUb0N1YmljPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IGcoYSwoMipiK2EpLzMsKDIqYitjKS8zLGMpfSxwLl9jc3NSZWdpc3Rlcj1mdW5jdGlvbigpe3ZhciBhPWYuQ1NTUGx1Z2luO2lmKGEpe3ZhciBiPWEuX2ludGVybmFscyxjPWIuX3BhcnNlVG9Qcm94eSxkPWIuX3NldFBsdWdpblJhdGlvLGU9Yi5DU1NQcm9wVHdlZW47Yi5fcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiZXppZXJcIix7cGFyc2VyOmZ1bmN0aW9uKGEsYixmLGcsaCxpKXtiIGluc3RhbmNlb2YgQXJyYXkmJihiPXt2YWx1ZXM6Yn0pLGk9bmV3IHA7dmFyIGosayxsLG09Yi52YWx1ZXMsbj1tLmxlbmd0aC0xLG89W10scT17fTtpZigwPm4pcmV0dXJuIGg7Zm9yKGo9MDtuPj1qO2orKylsPWMoYSxtW2pdLGcsaCxpLG4hPT1qKSxvW2pdPWwuZW5kO2ZvcihrIGluIGIpcVtrXT1iW2tdO3JldHVybiBxLnZhbHVlcz1vLGg9bmV3IGUoYSxcImJlemllclwiLDAsMCxsLnB0LDIpLGguZGF0YT1sLGgucGx1Z2luPWksaC5zZXRSYXRpbz1kLDA9PT1xLmF1dG9Sb3RhdGUmJihxLmF1dG9Sb3RhdGU9ITApLCFxLmF1dG9Sb3RhdGV8fHEuYXV0b1JvdGF0ZSBpbnN0YW5jZW9mIEFycmF5fHwoaj1xLmF1dG9Sb3RhdGU9PT0hMD8wOk51bWJlcihxLmF1dG9Sb3RhdGUpLHEuYXV0b1JvdGF0ZT1udWxsIT1sLmVuZC5sZWZ0P1tbXCJsZWZ0XCIsXCJ0b3BcIixcInJvdGF0aW9uXCIsaiwhMV1dOm51bGwhPWwuZW5kLng/W1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsaiwhMV1dOiExKSxxLmF1dG9Sb3RhdGUmJihnLl90cmFuc2Zvcm18fGcuX2VuYWJsZVRyYW5zZm9ybXMoITEpLGwuYXV0b1JvdGF0ZT1nLl90YXJnZXQuX2dzVHJhbnNmb3JtKSxpLl9vbkluaXRUd2VlbihsLnByb3h5LHEsZy5fdHdlZW4pLGh9fSl9fSxxLl9yb3VuZFByb3BzPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuX292ZXJ3cml0ZVByb3BzLGQ9Yy5sZW5ndGg7LS1kPi0xOykoYVtjW2RdXXx8YS5iZXppZXJ8fGEuYmV6aWVyVGhyb3VnaCkmJih0aGlzLl9yb3VuZFtjW2RdXT1iKX0scS5fa2lsbD1mdW5jdGlvbihhKXt2YXIgYixjLGQ9dGhpcy5fcHJvcHM7Zm9yKGIgaW4gdGhpcy5fYmV6aWVycylpZihiIGluIGEpZm9yKGRlbGV0ZSB0aGlzLl9iZXppZXJzW2JdLGRlbGV0ZSB0aGlzLl9mdW5jW2JdLGM9ZC5sZW5ndGg7LS1jPi0xOylkW2NdPT09YiYmZC5zcGxpY2UoYywxKTtyZXR1cm4gdGhpcy5fc3VwZXIuX2tpbGwuY2FsbCh0aGlzLGEpfX0oKSxfZ3NTY29wZS5fZ3NEZWZpbmUoXCJwbHVnaW5zLkNTU1BsdWdpblwiLFtcInBsdWdpbnMuVHdlZW5QbHVnaW5cIixcIlR3ZWVuTGl0ZVwiXSxmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmLGc9ZnVuY3Rpb24oKXthLmNhbGwodGhpcyxcImNzc1wiKSx0aGlzLl9vdmVyd3JpdGVQcm9wcy5sZW5ndGg9MCx0aGlzLnNldFJhdGlvPWcucHJvdG90eXBlLnNldFJhdGlvfSxoPV9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLGk9e30saj1nLnByb3RvdHlwZT1uZXcgYShcImNzc1wiKTtqLmNvbnN0cnVjdG9yPWcsZy52ZXJzaW9uPVwiMS4xOC4yXCIsZy5BUEk9MixnLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZT0wLGcuZGVmYXVsdFNrZXdUeXBlPVwiY29tcGVuc2F0ZWRcIixnLmRlZmF1bHRTbW9vdGhPcmlnaW49ITAsaj1cInB4XCIsZy5zdWZmaXhNYXA9e3RvcDpqLHJpZ2h0OmosYm90dG9tOmosbGVmdDpqLHdpZHRoOmosaGVpZ2h0OmosZm9udFNpemU6aixwYWRkaW5nOmosbWFyZ2luOmoscGVyc3BlY3RpdmU6aixsaW5lSGVpZ2h0OlwiXCJ9O3ZhciBrLGwsbSxuLG8scCxxPS8oPzpcXGR8XFwtXFxkfFxcLlxcZHxcXC1cXC5cXGQpKy9nLHI9Lyg/OlxcZHxcXC1cXGR8XFwuXFxkfFxcLVxcLlxcZHxcXCs9XFxkfFxcLT1cXGR8XFwrPS5cXGR8XFwtPVxcLlxcZCkrL2cscz0vKD86XFwrPXxcXC09fFxcLXxcXGIpW1xcZFxcLVxcLl0rW2EtekEtWjAtOV0qKD86JXxcXGIpL2dpLHQ9Lyg/IVsrLV0/XFxkKlxcLj9cXGQrfFsrLV18ZVsrLV1cXGQrKVteMC05XS9nLHU9Lyg/OlxcZHxcXC18XFwrfD18I3xcXC4pKi9nLHY9L29wYWNpdHkgKj0gKihbXildKikvaSx3PS9vcGFjaXR5OihbXjtdKikvaSx4PS9hbHBoYVxcKG9wYWNpdHkgKj0uKz9cXCkvaSx5PS9eKHJnYnxoc2wpLyx6PS8oW0EtWl0pL2csQT0vLShbYS16XSkvZ2ksQj0vKF4oPzp1cmxcXChcXFwifHVybFxcKCkpfCg/OihcXFwiXFwpKSR8XFwpJCkvZ2ksQz1mdW5jdGlvbihhLGIpe3JldHVybiBiLnRvVXBwZXJDYXNlKCl9LEQ9Lyg/OkxlZnR8UmlnaHR8V2lkdGgpL2ksRT0vKE0xMXxNMTJ8TTIxfE0yMik9W1xcZFxcLVxcLmVdKy9naSxGPS9wcm9naWRcXDpEWEltYWdlVHJhbnNmb3JtXFwuTWljcm9zb2Z0XFwuTWF0cml4XFwoLis/XFwpL2ksRz0vLCg/PVteXFwpXSooPzpcXCh8JCkpL2dpLEg9TWF0aC5QSS8xODAsST0xODAvTWF0aC5QSSxKPXt9LEs9ZG9jdW1lbnQsTD1mdW5jdGlvbihhKXtyZXR1cm4gSy5jcmVhdGVFbGVtZW50TlM/Sy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsYSk6Sy5jcmVhdGVFbGVtZW50KGEpfSxNPUwoXCJkaXZcIiksTj1MKFwiaW1nXCIpLE89Zy5faW50ZXJuYWxzPXtfc3BlY2lhbFByb3BzOml9LFA9bmF2aWdhdG9yLnVzZXJBZ2VudCxRPWZ1bmN0aW9uKCl7dmFyIGE9UC5pbmRleE9mKFwiQW5kcm9pZFwiKSxiPUwoXCJhXCIpO3JldHVybiBtPS0xIT09UC5pbmRleE9mKFwiU2FmYXJpXCIpJiYtMT09PVAuaW5kZXhPZihcIkNocm9tZVwiKSYmKC0xPT09YXx8TnVtYmVyKFAuc3Vic3RyKGErOCwxKSk+Myksbz1tJiZOdW1iZXIoUC5zdWJzdHIoUC5pbmRleE9mKFwiVmVyc2lvbi9cIikrOCwxKSk8NixuPS0xIT09UC5pbmRleE9mKFwiRmlyZWZveFwiKSwoL01TSUUgKFswLTldezEsfVtcXC4wLTldezAsfSkvLmV4ZWMoUCl8fC9UcmlkZW50XFwvLipydjooWzAtOV17MSx9W1xcLjAtOV17MCx9KS8uZXhlYyhQKSkmJihwPXBhcnNlRmxvYXQoUmVnRXhwLiQxKSksYj8oYi5zdHlsZS5jc3NUZXh0PVwidG9wOjFweDtvcGFjaXR5Oi41NTtcIiwvXjAuNTUvLnRlc3QoYi5zdHlsZS5vcGFjaXR5KSk6ITF9KCksUj1mdW5jdGlvbihhKXtyZXR1cm4gdi50ZXN0KFwic3RyaW5nXCI9PXR5cGVvZiBhP2E6KGEuY3VycmVudFN0eWxlP2EuY3VycmVudFN0eWxlLmZpbHRlcjphLnN0eWxlLmZpbHRlcil8fFwiXCIpP3BhcnNlRmxvYXQoUmVnRXhwLiQxKS8xMDA6MX0sUz1mdW5jdGlvbihhKXt3aW5kb3cuY29uc29sZSYmY29uc29sZS5sb2coYSl9LFQ9XCJcIixVPVwiXCIsVj1mdW5jdGlvbihhLGIpe2I9Ynx8TTt2YXIgYyxkLGU9Yi5zdHlsZTtpZih2b2lkIDAhPT1lW2FdKXJldHVybiBhO2ZvcihhPWEuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHIoMSksYz1bXCJPXCIsXCJNb3pcIixcIm1zXCIsXCJNc1wiLFwiV2Via2l0XCJdLGQ9NTstLWQ+LTEmJnZvaWQgMD09PWVbY1tkXSthXTspO3JldHVybiBkPj0wPyhVPTM9PT1kP1wibXNcIjpjW2RdLFQ9XCItXCIrVS50b0xvd2VyQ2FzZSgpK1wiLVwiLFUrYSk6bnVsbH0sVz1LLmRlZmF1bHRWaWV3P0suZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZTpmdW5jdGlvbigpe30sWD1nLmdldFN0eWxlPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY7cmV0dXJuIFF8fFwib3BhY2l0eVwiIT09Yj8oIWQmJmEuc3R5bGVbYl0/Zj1hLnN0eWxlW2JdOihjPWN8fFcoYSkpP2Y9Y1tiXXx8Yy5nZXRQcm9wZXJ0eVZhbHVlKGIpfHxjLmdldFByb3BlcnR5VmFsdWUoYi5yZXBsYWNlKHosXCItJDFcIikudG9Mb3dlckNhc2UoKSk6YS5jdXJyZW50U3R5bGUmJihmPWEuY3VycmVudFN0eWxlW2JdKSxudWxsPT1lfHxmJiZcIm5vbmVcIiE9PWYmJlwiYXV0b1wiIT09ZiYmXCJhdXRvIGF1dG9cIiE9PWY/ZjplKTpSKGEpfSxZPU8uY29udmVydFRvUGl4ZWxzPWZ1bmN0aW9uKGEsYyxkLGUsZil7aWYoXCJweFwiPT09ZXx8IWUpcmV0dXJuIGQ7aWYoXCJhdXRvXCI9PT1lfHwhZClyZXR1cm4gMDt2YXIgaCxpLGosaz1ELnRlc3QoYyksbD1hLG09TS5zdHlsZSxuPTA+ZDtpZihuJiYoZD0tZCksXCIlXCI9PT1lJiYtMSE9PWMuaW5kZXhPZihcImJvcmRlclwiKSloPWQvMTAwKihrP2EuY2xpZW50V2lkdGg6YS5jbGllbnRIZWlnaHQpO2Vsc2V7aWYobS5jc3NUZXh0PVwiYm9yZGVyOjAgc29saWQgcmVkO3Bvc2l0aW9uOlwiK1goYSxcInBvc2l0aW9uXCIpK1wiO2xpbmUtaGVpZ2h0OjA7XCIsXCIlXCIhPT1lJiZsLmFwcGVuZENoaWxkJiZcInZcIiE9PWUuY2hhckF0KDApJiZcInJlbVwiIT09ZSltW2s/XCJib3JkZXJMZWZ0V2lkdGhcIjpcImJvcmRlclRvcFdpZHRoXCJdPWQrZTtlbHNle2lmKGw9YS5wYXJlbnROb2RlfHxLLmJvZHksaT1sLl9nc0NhY2hlLGo9Yi50aWNrZXIuZnJhbWUsaSYmayYmaS50aW1lPT09ailyZXR1cm4gaS53aWR0aCpkLzEwMDttW2s/XCJ3aWR0aFwiOlwiaGVpZ2h0XCJdPWQrZX1sLmFwcGVuZENoaWxkKE0pLGg9cGFyc2VGbG9hdChNW2s/XCJvZmZzZXRXaWR0aFwiOlwib2Zmc2V0SGVpZ2h0XCJdKSxsLnJlbW92ZUNoaWxkKE0pLGsmJlwiJVwiPT09ZSYmZy5jYWNoZVdpZHRocyE9PSExJiYoaT1sLl9nc0NhY2hlPWwuX2dzQ2FjaGV8fHt9LGkudGltZT1qLGkud2lkdGg9aC9kKjEwMCksMCE9PWh8fGZ8fChoPVkoYSxjLGQsZSwhMCkpfXJldHVybiBuPy1oOmh9LFo9Ty5jYWxjdWxhdGVPZmZzZXQ9ZnVuY3Rpb24oYSxiLGMpe2lmKFwiYWJzb2x1dGVcIiE9PVgoYSxcInBvc2l0aW9uXCIsYykpcmV0dXJuIDA7dmFyIGQ9XCJsZWZ0XCI9PT1iP1wiTGVmdFwiOlwiVG9wXCIsZT1YKGEsXCJtYXJnaW5cIitkLGMpO3JldHVybiBhW1wib2Zmc2V0XCIrZF0tKFkoYSxiLHBhcnNlRmxvYXQoZSksZS5yZXBsYWNlKHUsXCJcIikpfHwwKX0sJD1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmPXt9O2lmKGI9Ynx8VyhhLG51bGwpKWlmKGM9Yi5sZW5ndGgpZm9yKDstLWM+LTE7KWU9YltjXSwoLTE9PT1lLmluZGV4T2YoXCItdHJhbnNmb3JtXCIpfHx6YT09PWUpJiYoZltlLnJlcGxhY2UoQSxDKV09Yi5nZXRQcm9wZXJ0eVZhbHVlKGUpKTtlbHNlIGZvcihjIGluIGIpKC0xPT09Yy5pbmRleE9mKFwiVHJhbnNmb3JtXCIpfHx5YT09PWMpJiYoZltjXT1iW2NdKTtlbHNlIGlmKGI9YS5jdXJyZW50U3R5bGV8fGEuc3R5bGUpZm9yKGMgaW4gYilcInN0cmluZ1wiPT10eXBlb2YgYyYmdm9pZCAwPT09ZltjXSYmKGZbYy5yZXBsYWNlKEEsQyldPWJbY10pO3JldHVybiBRfHwoZi5vcGFjaXR5PVIoYSkpLGQ9TGEoYSxiLCExKSxmLnJvdGF0aW9uPWQucm90YXRpb24sZi5za2V3WD1kLnNrZXdYLGYuc2NhbGVYPWQuc2NhbGVYLGYuc2NhbGVZPWQuc2NhbGVZLGYueD1kLngsZi55PWQueSxCYSYmKGYuej1kLnosZi5yb3RhdGlvblg9ZC5yb3RhdGlvblgsZi5yb3RhdGlvblk9ZC5yb3RhdGlvblksZi5zY2FsZVo9ZC5zY2FsZVopLGYuZmlsdGVycyYmZGVsZXRlIGYuZmlsdGVycyxmfSxfPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGYsZyxoLGk9e30saj1hLnN0eWxlO2ZvcihnIGluIGMpXCJjc3NUZXh0XCIhPT1nJiZcImxlbmd0aFwiIT09ZyYmaXNOYU4oZykmJihiW2ddIT09KGY9Y1tnXSl8fGUmJmVbZ10pJiYtMT09PWcuaW5kZXhPZihcIk9yaWdpblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiBmfHxcInN0cmluZ1wiPT10eXBlb2YgZikmJihpW2ddPVwiYXV0b1wiIT09Znx8XCJsZWZ0XCIhPT1nJiZcInRvcFwiIT09Zz9cIlwiIT09ZiYmXCJhdXRvXCIhPT1mJiZcIm5vbmVcIiE9PWZ8fFwic3RyaW5nXCIhPXR5cGVvZiBiW2ddfHxcIlwiPT09YltnXS5yZXBsYWNlKHQsXCJcIik/ZjowOlooYSxnKSx2b2lkIDAhPT1qW2ddJiYoaD1uZXcgb2EoaixnLGpbZ10saCkpKTtpZihkKWZvcihnIGluIGQpXCJjbGFzc05hbWVcIiE9PWcmJihpW2ddPWRbZ10pO3JldHVybntkaWZzOmksZmlyc3RNUFQ6aH19LGFhPXt3aWR0aDpbXCJMZWZ0XCIsXCJSaWdodFwiXSxoZWlnaHQ6W1wiVG9wXCIsXCJCb3R0b21cIl19LGJhPVtcIm1hcmdpbkxlZnRcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Ub3BcIixcIm1hcmdpbkJvdHRvbVwiXSxjYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9cGFyc2VGbG9hdChcIndpZHRoXCI9PT1iP2Eub2Zmc2V0V2lkdGg6YS5vZmZzZXRIZWlnaHQpLGU9YWFbYl0sZj1lLmxlbmd0aDtmb3IoYz1jfHxXKGEsbnVsbCk7LS1mPi0xOylkLT1wYXJzZUZsb2F0KFgoYSxcInBhZGRpbmdcIitlW2ZdLGMsITApKXx8MCxkLT1wYXJzZUZsb2F0KFgoYSxcImJvcmRlclwiK2VbZl0rXCJXaWR0aFwiLGMsITApKXx8MDtyZXR1cm4gZH0sZGE9ZnVuY3Rpb24oYSxiKXtpZihcImNvbnRhaW5cIj09PWF8fFwiYXV0b1wiPT09YXx8XCJhdXRvIGF1dG9cIj09PWEpcmV0dXJuIGErXCIgXCI7KG51bGw9PWF8fFwiXCI9PT1hKSYmKGE9XCIwIDBcIik7dmFyIGM9YS5zcGxpdChcIiBcIiksZD0tMSE9PWEuaW5kZXhPZihcImxlZnRcIik/XCIwJVwiOi0xIT09YS5pbmRleE9mKFwicmlnaHRcIik/XCIxMDAlXCI6Y1swXSxlPS0xIT09YS5pbmRleE9mKFwidG9wXCIpP1wiMCVcIjotMSE9PWEuaW5kZXhPZihcImJvdHRvbVwiKT9cIjEwMCVcIjpjWzFdO3JldHVybiBudWxsPT1lP2U9XCJjZW50ZXJcIj09PWQ/XCI1MCVcIjpcIjBcIjpcImNlbnRlclwiPT09ZSYmKGU9XCI1MCVcIiksKFwiY2VudGVyXCI9PT1kfHxpc05hTihwYXJzZUZsb2F0KGQpKSYmLTE9PT0oZCtcIlwiKS5pbmRleE9mKFwiPVwiKSkmJihkPVwiNTAlXCIpLGE9ZCtcIiBcIitlKyhjLmxlbmd0aD4yP1wiIFwiK2NbMl06XCJcIiksYiYmKGIub3hwPS0xIT09ZC5pbmRleE9mKFwiJVwiKSxiLm95cD0tMSE9PWUuaW5kZXhPZihcIiVcIiksYi5veHI9XCI9XCI9PT1kLmNoYXJBdCgxKSxiLm95cj1cIj1cIj09PWUuY2hhckF0KDEpLGIub3g9cGFyc2VGbG9hdChkLnJlcGxhY2UodCxcIlwiKSksYi5veT1wYXJzZUZsb2F0KGUucmVwbGFjZSh0LFwiXCIpKSxiLnY9YSksYnx8YX0sZWE9ZnVuY3Rpb24oYSxiKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYSYmXCI9XCI9PT1hLmNoYXJBdCgxKT9wYXJzZUludChhLmNoYXJBdCgwKStcIjFcIiwxMCkqcGFyc2VGbG9hdChhLnN1YnN0cigyKSk6cGFyc2VGbG9hdChhKS1wYXJzZUZsb2F0KGIpfSxmYT1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsPT1hP2I6XCJzdHJpbmdcIj09dHlwZW9mIGEmJlwiPVwiPT09YS5jaGFyQXQoMSk/cGFyc2VJbnQoYS5jaGFyQXQoMCkrXCIxXCIsMTApKnBhcnNlRmxvYXQoYS5zdWJzdHIoMikpK2I6cGFyc2VGbG9hdChhKX0sZ2E9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZixnLGgsaSxqPTFlLTY7cmV0dXJuIG51bGw9PWE/aD1iOlwibnVtYmVyXCI9PXR5cGVvZiBhP2g9YTooZT0zNjAsZj1hLnNwbGl0KFwiX1wiKSxpPVwiPVwiPT09YS5jaGFyQXQoMSksZz0oaT9wYXJzZUludChhLmNoYXJBdCgwKStcIjFcIiwxMCkqcGFyc2VGbG9hdChmWzBdLnN1YnN0cigyKSk6cGFyc2VGbG9hdChmWzBdKSkqKC0xPT09YS5pbmRleE9mKFwicmFkXCIpPzE6SSktKGk/MDpiKSxmLmxlbmd0aCYmKGQmJihkW2NdPWIrZyksLTEhPT1hLmluZGV4T2YoXCJzaG9ydFwiKSYmKGclPWUsZyE9PWclKGUvMikmJihnPTA+Zz9nK2U6Zy1lKSksLTEhPT1hLmluZGV4T2YoXCJfY3dcIikmJjA+Zz9nPShnKzk5OTk5OTk5OTkqZSklZS0oZy9lfDApKmU6LTEhPT1hLmluZGV4T2YoXCJjY3dcIikmJmc+MCYmKGc9KGctOTk5OTk5OTk5OSplKSVlLShnL2V8MCkqZSkpLGg9YitnKSxqPmgmJmg+LWomJihoPTApLGh9LGhhPXthcXVhOlswLDI1NSwyNTVdLGxpbWU6WzAsMjU1LDBdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLGJsYWNrOlswLDAsMF0sbWFyb29uOlsxMjgsMCwwXSx0ZWFsOlswLDEyOCwxMjhdLGJsdWU6WzAsMCwyNTVdLG5hdnk6WzAsMCwxMjhdLHdoaXRlOlsyNTUsMjU1LDI1NV0sZnVjaHNpYTpbMjU1LDAsMjU1XSxvbGl2ZTpbMTI4LDEyOCwwXSx5ZWxsb3c6WzI1NSwyNTUsMF0sb3JhbmdlOlsyNTUsMTY1LDBdLGdyYXk6WzEyOCwxMjgsMTI4XSxwdXJwbGU6WzEyOCwwLDEyOF0sZ3JlZW46WzAsMTI4LDBdLHJlZDpbMjU1LDAsMF0scGluazpbMjU1LDE5MiwyMDNdLGN5YW46WzAsMjU1LDI1NV0sdHJhbnNwYXJlbnQ6WzI1NSwyNTUsMjU1LDBdfSxpYT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGE9MD5hP2ErMTphPjE/YS0xOmEsMjU1KigxPjYqYT9iKyhjLWIpKmEqNjouNT5hP2M6Mj4zKmE/YisoYy1iKSooMi8zLWEpKjY6YikrLjV8MH0samE9Zy5wYXJzZUNvbG9yPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGYsZyxoLGksaixrLGwsbTtpZihhKWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhKWM9W2E+PjE2LGE+PjgmMjU1LDI1NSZhXTtlbHNle2lmKFwiLFwiPT09YS5jaGFyQXQoYS5sZW5ndGgtMSkmJihhPWEuc3Vic3RyKDAsYS5sZW5ndGgtMSkpLGhhW2FdKWM9aGFbYV07ZWxzZSBpZihcIiNcIj09PWEuY2hhckF0KDApKTQ9PT1hLmxlbmd0aCYmKGQ9YS5jaGFyQXQoMSksZT1hLmNoYXJBdCgyKSxmPWEuY2hhckF0KDMpLGE9XCIjXCIrZCtkK2UrZStmK2YpLGE9cGFyc2VJbnQoYS5zdWJzdHIoMSksMTYpLGM9W2E+PjE2LGE+PjgmMjU1LDI1NSZhXTtlbHNlIGlmKFwiaHNsXCI9PT1hLnN1YnN0cigwLDMpKWlmKGM9bT1hLm1hdGNoKHEpLGIpe2lmKC0xIT09YS5pbmRleE9mKFwiPVwiKSlyZXR1cm4gYS5tYXRjaChyKX1lbHNlIGc9TnVtYmVyKGNbMF0pJTM2MC8zNjAsaD1OdW1iZXIoY1sxXSkvMTAwLGk9TnVtYmVyKGNbMl0pLzEwMCxlPS41Pj1pP2kqKGgrMSk6aStoLWkqaCxkPTIqaS1lLGMubGVuZ3RoPjMmJihjWzNdPU51bWJlcihhWzNdKSksY1swXT1pYShnKzEvMyxkLGUpLGNbMV09aWEoZyxkLGUpLGNbMl09aWEoZy0xLzMsZCxlKTtlbHNlIGM9YS5tYXRjaChxKXx8aGEudHJhbnNwYXJlbnQ7Y1swXT1OdW1iZXIoY1swXSksY1sxXT1OdW1iZXIoY1sxXSksY1syXT1OdW1iZXIoY1syXSksYy5sZW5ndGg+MyYmKGNbM109TnVtYmVyKGNbM10pKX1lbHNlIGM9aGEuYmxhY2s7cmV0dXJuIGImJiFtJiYoZD1jWzBdLzI1NSxlPWNbMV0vMjU1LGY9Y1syXS8yNTUsaj1NYXRoLm1heChkLGUsZiksaz1NYXRoLm1pbihkLGUsZiksaT0oaitrKS8yLGo9PT1rP2c9aD0wOihsPWotayxoPWk+LjU/bC8oMi1qLWspOmwvKGorayksZz1qPT09ZD8oZS1mKS9sKyhmPmU/NjowKTpqPT09ZT8oZi1kKS9sKzI6KGQtZSkvbCs0LGcqPTYwKSxjWzBdPWcrLjV8MCxjWzFdPTEwMCpoKy41fDAsY1syXT0xMDAqaSsuNXwwKSxjfSxrYT1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmPWEubWF0Y2gobGEpfHxbXSxnPTAsaD1mLmxlbmd0aD9cIlwiOmE7Zm9yKGM9MDtjPGYubGVuZ3RoO2MrKylkPWZbY10sZT1hLnN1YnN0cihnLGEuaW5kZXhPZihkLGcpLWcpLGcrPWUubGVuZ3RoK2QubGVuZ3RoLGQ9amEoZCxiKSwzPT09ZC5sZW5ndGgmJmQucHVzaCgxKSxoKz1lKyhiP1wiaHNsYShcIitkWzBdK1wiLFwiK2RbMV0rXCIlLFwiK2RbMl0rXCIlLFwiK2RbM106XCJyZ2JhKFwiK2Quam9pbihcIixcIikpK1wiKVwiO3JldHVybiBofSxsYT1cIig/OlxcXFxiKD86KD86cmdifHJnYmF8aHNsfGhzbGEpXFxcXCguKz9cXFxcKSl8XFxcXEIjKD86WzAtOWEtZl17M30pezEsMn1cXFxcYlwiO2ZvcihqIGluIGhhKWxhKz1cInxcIitqK1wiXFxcXGJcIjtsYT1uZXcgUmVnRXhwKGxhK1wiKVwiLFwiZ2lcIiksZy5jb2xvclN0cmluZ0ZpbHRlcj1mdW5jdGlvbihhKXt2YXIgYixjPWFbMF0rYVsxXTtsYS5sYXN0SW5kZXg9MCxsYS50ZXN0KGMpJiYoYj0tMSE9PWMuaW5kZXhPZihcImhzbChcIil8fC0xIT09Yy5pbmRleE9mKFwiaHNsYShcIiksYVswXT1rYShhWzBdLGIpLGFbMV09a2EoYVsxXSxiKSl9LGIuZGVmYXVsdFN0cmluZ0ZpbHRlcnx8KGIuZGVmYXVsdFN0cmluZ0ZpbHRlcj1nLmNvbG9yU3RyaW5nRmlsdGVyKTt2YXIgbWE9ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbD09YSlyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGF9O3ZhciBlLGY9Yj8oYS5tYXRjaChsYSl8fFtcIlwiXSlbMF06XCJcIixnPWEuc3BsaXQoZikuam9pbihcIlwiKS5tYXRjaChzKXx8W10saD1hLnN1YnN0cigwLGEuaW5kZXhPZihnWzBdKSksaT1cIilcIj09PWEuY2hhckF0KGEubGVuZ3RoLTEpP1wiKVwiOlwiXCIsaj0tMSE9PWEuaW5kZXhPZihcIiBcIik/XCIgXCI6XCIsXCIsaz1nLmxlbmd0aCxsPWs+MD9nWzBdLnJlcGxhY2UocSxcIlwiKTpcIlwiO3JldHVybiBrP2U9Yj9mdW5jdGlvbihhKXt2YXIgYixtLG4sbztpZihcIm51bWJlclwiPT10eXBlb2YgYSlhKz1sO2Vsc2UgaWYoZCYmRy50ZXN0KGEpKXtmb3Iobz1hLnJlcGxhY2UoRyxcInxcIikuc3BsaXQoXCJ8XCIpLG49MDtuPG8ubGVuZ3RoO24rKylvW25dPWUob1tuXSk7cmV0dXJuIG8uam9pbihcIixcIil9aWYoYj0oYS5tYXRjaChsYSl8fFtmXSlbMF0sbT1hLnNwbGl0KGIpLmpvaW4oXCJcIikubWF0Y2gocyl8fFtdLG49bS5sZW5ndGgsaz5uLS0pZm9yKDsrK248azspbVtuXT1jP21bKG4tMSkvMnwwXTpnW25dO3JldHVybiBoK20uam9pbihqKStqK2IraSsoLTEhPT1hLmluZGV4T2YoXCJpbnNldFwiKT9cIiBpbnNldFwiOlwiXCIpfTpmdW5jdGlvbihhKXt2YXIgYixmLG07aWYoXCJudW1iZXJcIj09dHlwZW9mIGEpYSs9bDtlbHNlIGlmKGQmJkcudGVzdChhKSl7Zm9yKGY9YS5yZXBsYWNlKEcsXCJ8XCIpLnNwbGl0KFwifFwiKSxtPTA7bTxmLmxlbmd0aDttKyspZlttXT1lKGZbbV0pO3JldHVybiBmLmpvaW4oXCIsXCIpfWlmKGI9YS5tYXRjaChzKXx8W10sbT1iLmxlbmd0aCxrPm0tLSlmb3IoOysrbTxrOyliW21dPWM/YlsobS0xKS8yfDBdOmdbbV07cmV0dXJuIGgrYi5qb2luKGopK2l9OmZ1bmN0aW9uKGEpe3JldHVybiBhfX0sbmE9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9YS5zcGxpdChcIixcIiksZnVuY3Rpb24oYixjLGQsZSxmLGcsaCl7dmFyIGksaj0oYytcIlwiKS5zcGxpdChcIiBcIik7Zm9yKGg9e30saT0wOzQ+aTtpKyspaFthW2ldXT1qW2ldPWpbaV18fGpbKGktMSkvMj4+MF07cmV0dXJuIGUucGFyc2UoYixoLGYsZyl9fSxvYT0oTy5fc2V0UGx1Z2luUmF0aW89ZnVuY3Rpb24oYSl7dGhpcy5wbHVnaW4uc2V0UmF0aW8oYSk7Zm9yKHZhciBiLGMsZCxlLGYsZz10aGlzLmRhdGEsaD1nLnByb3h5LGk9Zy5maXJzdE1QVCxqPTFlLTY7aTspYj1oW2kudl0saS5yP2I9TWF0aC5yb3VuZChiKTpqPmImJmI+LWomJihiPTApLGkudFtpLnBdPWIsaT1pLl9uZXh0O2lmKGcuYXV0b1JvdGF0ZSYmKGcuYXV0b1JvdGF0ZS5yb3RhdGlvbj1oLnJvdGF0aW9uKSwxPT09YXx8MD09PWEpZm9yKGk9Zy5maXJzdE1QVCxmPTE9PT1hP1wiZVwiOlwiYlwiO2k7KXtpZihjPWkudCxjLnR5cGUpe2lmKDE9PT1jLnR5cGUpe2ZvcihlPWMueHMwK2MucytjLnhzMSxkPTE7ZDxjLmw7ZCsrKWUrPWNbXCJ4blwiK2RdK2NbXCJ4c1wiKyhkKzEpXTtjW2ZdPWV9fWVsc2UgY1tmXT1jLnMrYy54czA7aT1pLl9uZXh0fX0sZnVuY3Rpb24oYSxiLGMsZCxlKXt0aGlzLnQ9YSx0aGlzLnA9Yix0aGlzLnY9Yyx0aGlzLnI9ZSxkJiYoZC5fcHJldj10aGlzLHRoaXMuX25leHQ9ZCl9KSxwYT0oTy5fcGFyc2VUb1Byb3h5PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZyxoLGksaixrLGw9ZCxtPXt9LG49e30sbz1jLl90cmFuc2Zvcm0scD1KO2ZvcihjLl90cmFuc2Zvcm09bnVsbCxKPWIsZD1rPWMucGFyc2UoYSxiLGQsZSksSj1wLGYmJihjLl90cmFuc2Zvcm09byxsJiYobC5fcHJldj1udWxsLGwuX3ByZXYmJihsLl9wcmV2Ll9uZXh0PW51bGwpKSk7ZCYmZCE9PWw7KXtpZihkLnR5cGU8PTEmJihoPWQucCxuW2hdPWQucytkLmMsbVtoXT1kLnMsZnx8KGo9bmV3IG9hKGQsXCJzXCIsaCxqLGQuciksZC5jPTApLDE9PT1kLnR5cGUpKWZvcihnPWQubDstLWc+MDspaT1cInhuXCIrZyxoPWQucCtcIl9cIitpLG5baF09ZC5kYXRhW2ldLG1baF09ZFtpXSxmfHwoaj1uZXcgb2EoZCxpLGgsaixkLnJ4cFtpXSkpO2Q9ZC5fbmV4dH1yZXR1cm57cHJveHk6bSxlbmQ6bixmaXJzdE1QVDpqLHB0Omt9fSxPLkNTU1Byb3BUd2Vlbj1mdW5jdGlvbihhLGIsZCxlLGcsaCxpLGosayxsLG0pe3RoaXMudD1hLHRoaXMucD1iLHRoaXMucz1kLHRoaXMuYz1lLHRoaXMubj1pfHxiLGEgaW5zdGFuY2VvZiBwYXx8Zi5wdXNoKHRoaXMubiksdGhpcy5yPWosdGhpcy50eXBlPWh8fDAsayYmKHRoaXMucHI9ayxjPSEwKSx0aGlzLmI9dm9pZCAwPT09bD9kOmwsdGhpcy5lPXZvaWQgMD09PW0/ZCtlOm0sZyYmKHRoaXMuX25leHQ9ZyxnLl9wcmV2PXRoaXMpfSkscWE9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPW5ldyBwYShhLGIsYyxkLWMsZSwtMSxmKTtyZXR1cm4gZy5iPWMsZy5lPWcueHMwPWQsZ30scmE9Zy5wYXJzZUNvbXBsZXg9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGksail7Yz1jfHxmfHxcIlwiLGc9bmV3IHBhKGEsYiwwLDAsZyxqPzI6MSxudWxsLCExLGgsYyxkKSxkKz1cIlwiO3ZhciBsLG0sbixvLHAscyx0LHUsdix3LHgseSx6LEE9Yy5zcGxpdChcIiwgXCIpLmpvaW4oXCIsXCIpLnNwbGl0KFwiIFwiKSxCPWQuc3BsaXQoXCIsIFwiKS5qb2luKFwiLFwiKS5zcGxpdChcIiBcIiksQz1BLmxlbmd0aCxEPWshPT0hMTtmb3IoKC0xIT09ZC5pbmRleE9mKFwiLFwiKXx8LTEhPT1jLmluZGV4T2YoXCIsXCIpKSYmKEE9QS5qb2luKFwiIFwiKS5yZXBsYWNlKEcsXCIsIFwiKS5zcGxpdChcIiBcIiksQj1CLmpvaW4oXCIgXCIpLnJlcGxhY2UoRyxcIiwgXCIpLnNwbGl0KFwiIFwiKSxDPUEubGVuZ3RoKSxDIT09Qi5sZW5ndGgmJihBPShmfHxcIlwiKS5zcGxpdChcIiBcIiksQz1BLmxlbmd0aCksZy5wbHVnaW49aSxnLnNldFJhdGlvPWosbGEubGFzdEluZGV4PTAsbD0wO0M+bDtsKyspaWYobz1BW2xdLHA9QltsXSx1PXBhcnNlRmxvYXQobyksdXx8MD09PXUpZy5hcHBlbmRYdHJhKFwiXCIsdSxlYShwLHUpLHAucmVwbGFjZShyLFwiXCIpLEQmJi0xIT09cC5pbmRleE9mKFwicHhcIiksITApO2Vsc2UgaWYoZSYmbGEudGVzdChvKSl5PVwiLFwiPT09cC5jaGFyQXQocC5sZW5ndGgtMSk/XCIpLFwiOlwiKVwiLHo9LTEhPT1wLmluZGV4T2YoXCJoc2xcIikmJlEsbz1qYShvLHopLHA9amEocCx6KSx2PW8ubGVuZ3RoK3AubGVuZ3RoPjYsdiYmIVEmJjA9PT1wWzNdPyhnW1wieHNcIitnLmxdKz1nLmw/XCIgdHJhbnNwYXJlbnRcIjpcInRyYW5zcGFyZW50XCIsZy5lPWcuZS5zcGxpdChCW2xdKS5qb2luKFwidHJhbnNwYXJlbnRcIikpOihRfHwodj0hMSksej9nLmFwcGVuZFh0cmEodj9cImhzbGEoXCI6XCJoc2woXCIsb1swXSxlYShwWzBdLG9bMF0pLFwiLFwiLCExLCEwKS5hcHBlbmRYdHJhKFwiXCIsb1sxXSxlYShwWzFdLG9bMV0pLFwiJSxcIiwhMSkuYXBwZW5kWHRyYShcIlwiLG9bMl0sZWEocFsyXSxvWzJdKSx2P1wiJSxcIjpcIiVcIit5LCExKTpnLmFwcGVuZFh0cmEodj9cInJnYmEoXCI6XCJyZ2IoXCIsb1swXSxwWzBdLW9bMF0sXCIsXCIsITAsITApLmFwcGVuZFh0cmEoXCJcIixvWzFdLHBbMV0tb1sxXSxcIixcIiwhMCkuYXBwZW5kWHRyYShcIlwiLG9bMl0scFsyXS1vWzJdLHY/XCIsXCI6eSwhMCksdiYmKG89by5sZW5ndGg8ND8xOm9bM10sZy5hcHBlbmRYdHJhKFwiXCIsbywocC5sZW5ndGg8ND8xOnBbM10pLW8seSwhMSkpKSxsYS5sYXN0SW5kZXg9MDtlbHNlIGlmKHM9by5tYXRjaChxKSl7aWYodD1wLm1hdGNoKHIpLCF0fHx0Lmxlbmd0aCE9PXMubGVuZ3RoKXJldHVybiBnO2ZvcihuPTAsbT0wO208cy5sZW5ndGg7bSsrKXg9c1ttXSx3PW8uaW5kZXhPZih4LG4pLGcuYXBwZW5kWHRyYShvLnN1YnN0cihuLHctbiksTnVtYmVyKHgpLGVhKHRbbV0seCksXCJcIixEJiZcInB4XCI9PT1vLnN1YnN0cih3K3gubGVuZ3RoLDIpLDA9PT1tKSxuPXcreC5sZW5ndGg7Z1tcInhzXCIrZy5sXSs9by5zdWJzdHIobil9ZWxzZSBnW1wieHNcIitnLmxdKz1nLmw/XCIgXCIrcDpwO2lmKC0xIT09ZC5pbmRleE9mKFwiPVwiKSYmZy5kYXRhKXtmb3IoeT1nLnhzMCtnLmRhdGEucyxsPTE7bDxnLmw7bCsrKXkrPWdbXCJ4c1wiK2xdK2cuZGF0YVtcInhuXCIrbF07Zy5lPXkrZ1tcInhzXCIrbF19cmV0dXJuIGcubHx8KGcudHlwZT0tMSxnLnhzMD1nLmUpLGcueGZpcnN0fHxnfSxzYT05O2ZvcihqPXBhLnByb3RvdHlwZSxqLmw9ai5wcj0wOy0tc2E+MDspaltcInhuXCIrc2FdPTAsaltcInhzXCIrc2FdPVwiXCI7ai54czA9XCJcIixqLl9uZXh0PWouX3ByZXY9ai54Zmlyc3Q9ai5kYXRhPWoucGx1Z2luPWouc2V0UmF0aW89ai5yeHA9bnVsbCxqLmFwcGVuZFh0cmE9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPXRoaXMsaD1nLmw7cmV0dXJuIGdbXCJ4c1wiK2hdKz1mJiZoP1wiIFwiK2E6YXx8XCJcIixjfHwwPT09aHx8Zy5wbHVnaW4/KGcubCsrLGcudHlwZT1nLnNldFJhdGlvPzI6MSxnW1wieHNcIitnLmxdPWR8fFwiXCIsaD4wPyhnLmRhdGFbXCJ4blwiK2hdPWIrYyxnLnJ4cFtcInhuXCIraF09ZSxnW1wieG5cIitoXT1iLGcucGx1Z2lufHwoZy54Zmlyc3Q9bmV3IHBhKGcsXCJ4blwiK2gsYixjLGcueGZpcnN0fHxnLDAsZy5uLGUsZy5wciksZy54Zmlyc3QueHMwPTApLGcpOihnLmRhdGE9e3M6YitjfSxnLnJ4cD17fSxnLnM9YixnLmM9YyxnLnI9ZSxnKSk6KGdbXCJ4c1wiK2hdKz1iKyhkfHxcIlwiKSxnKX07dmFyIHRhPWZ1bmN0aW9uKGEsYil7Yj1ifHx7fSx0aGlzLnA9Yi5wcmVmaXg/VihhKXx8YTphLGlbYV09aVt0aGlzLnBdPXRoaXMsdGhpcy5mb3JtYXQ9Yi5mb3JtYXR0ZXJ8fG1hKGIuZGVmYXVsdFZhbHVlLGIuY29sb3IsYi5jb2xsYXBzaWJsZSxiLm11bHRpKSxiLnBhcnNlciYmKHRoaXMucGFyc2U9Yi5wYXJzZXIpLHRoaXMuY2xycz1iLmNvbG9yLHRoaXMubXVsdGk9Yi5tdWx0aSx0aGlzLmtleXdvcmQ9Yi5rZXl3b3JkLHRoaXMuZGZsdD1iLmRlZmF1bHRWYWx1ZSx0aGlzLnByPWIucHJpb3JpdHl8fDB9LHVhPU8uX3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wPWZ1bmN0aW9uKGEsYixjKXtcIm9iamVjdFwiIT10eXBlb2YgYiYmKGI9e3BhcnNlcjpjfSk7dmFyIGQsZSxmPWEuc3BsaXQoXCIsXCIpLGc9Yi5kZWZhdWx0VmFsdWU7Zm9yKGM9Y3x8W2ddLGQ9MDtkPGYubGVuZ3RoO2QrKyliLnByZWZpeD0wPT09ZCYmYi5wcmVmaXgsYi5kZWZhdWx0VmFsdWU9Y1tkXXx8ZyxlPW5ldyB0YShmW2RdLGIpfSx2YT1mdW5jdGlvbihhKXtpZighaVthXSl7dmFyIGI9YS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnN1YnN0cigxKStcIlBsdWdpblwiO3VhKGEse3BhcnNlcjpmdW5jdGlvbihhLGMsZCxlLGYsZyxqKXt2YXIgaz1oLmNvbS5ncmVlbnNvY2sucGx1Z2luc1tiXTtyZXR1cm4gaz8oay5fY3NzUmVnaXN0ZXIoKSxpW2RdLnBhcnNlKGEsYyxkLGUsZixnLGopKTooUyhcIkVycm9yOiBcIitiK1wiIGpzIGZpbGUgbm90IGxvYWRlZC5cIiksZil9fSl9fTtqPXRhLnByb3RvdHlwZSxqLnBhcnNlQ29tcGxleD1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGcsaCxpLGosayxsLG09dGhpcy5rZXl3b3JkO2lmKHRoaXMubXVsdGkmJihHLnRlc3QoYyl8fEcudGVzdChiKT8oaD1iLnJlcGxhY2UoRyxcInxcIikuc3BsaXQoXCJ8XCIpLGk9Yy5yZXBsYWNlKEcsXCJ8XCIpLnNwbGl0KFwifFwiKSk6bSYmKGg9W2JdLGk9W2NdKSksaSl7Zm9yKGo9aS5sZW5ndGg+aC5sZW5ndGg/aS5sZW5ndGg6aC5sZW5ndGgsZz0wO2o+ZztnKyspYj1oW2ddPWhbZ118fHRoaXMuZGZsdCxjPWlbZ109aVtnXXx8dGhpcy5kZmx0LG0mJihrPWIuaW5kZXhPZihtKSxsPWMuaW5kZXhPZihtKSxrIT09bCYmKC0xPT09bD9oW2ddPWhbZ10uc3BsaXQobSkuam9pbihcIlwiKTotMT09PWsmJihoW2ddKz1cIiBcIittKSkpO2I9aC5qb2luKFwiLCBcIiksYz1pLmpvaW4oXCIsIFwiKX1yZXR1cm4gcmEoYSx0aGlzLnAsYixjLHRoaXMuY2xycyx0aGlzLmRmbHQsZCx0aGlzLnByLGUsZil9LGoucGFyc2U9ZnVuY3Rpb24oYSxiLGMsZCxmLGcsaCl7cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KGEuc3R5bGUsdGhpcy5mb3JtYXQoWChhLHRoaXMucCxlLCExLHRoaXMuZGZsdCkpLHRoaXMuZm9ybWF0KGIpLGYsZyl9LGcucmVnaXN0ZXJTcGVjaWFsUHJvcD1mdW5jdGlvbihhLGIsYyl7dWEoYSx7cGFyc2VyOmZ1bmN0aW9uKGEsZCxlLGYsZyxoLGkpe3ZhciBqPW5ldyBwYShhLGUsMCwwLGcsMixlLCExLGMpO3JldHVybiBqLnBsdWdpbj1oLGouc2V0UmF0aW89YihhLGQsZi5fdHdlZW4sZSksan0scHJpb3JpdHk6Y30pfSxnLnVzZVNWR1RyYW5zZm9ybUF0dHI9bXx8bjt2YXIgd2EseGE9XCJzY2FsZVgsc2NhbGVZLHNjYWxlWix4LHkseixza2V3WCxza2V3WSxyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHBlcnNwZWN0aXZlLHhQZXJjZW50LHlQZXJjZW50XCIuc3BsaXQoXCIsXCIpLHlhPVYoXCJ0cmFuc2Zvcm1cIiksemE9VCtcInRyYW5zZm9ybVwiLEFhPVYoXCJ0cmFuc2Zvcm1PcmlnaW5cIiksQmE9bnVsbCE9PVYoXCJwZXJzcGVjdGl2ZVwiKSxDYT1PLlRyYW5zZm9ybT1mdW5jdGlvbigpe3RoaXMucGVyc3BlY3RpdmU9cGFyc2VGbG9hdChnLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSl8fDAsdGhpcy5mb3JjZTNEPWcuZGVmYXVsdEZvcmNlM0QhPT0hMSYmQmE/Zy5kZWZhdWx0Rm9yY2UzRHx8XCJhdXRvXCI6ITF9LERhPXdpbmRvdy5TVkdFbGVtZW50LEVhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlPUsuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixhKSxmPS8oW2Etel0pKFtBLVpdKS9nO2ZvcihkIGluIGMpZS5zZXRBdHRyaWJ1dGVOUyhudWxsLGQucmVwbGFjZShmLFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKSxjW2RdKTtyZXR1cm4gYi5hcHBlbmRDaGlsZChlKSxlfSxGYT1LLmRvY3VtZW50RWxlbWVudCxHYT1mdW5jdGlvbigpe3ZhciBhLGIsYyxkPXB8fC9BbmRyb2lkL2kudGVzdChQKSYmIXdpbmRvdy5jaHJvbWU7cmV0dXJuIEsuY3JlYXRlRWxlbWVudE5TJiYhZCYmKGE9RWEoXCJzdmdcIixGYSksYj1FYShcInJlY3RcIixhLHt3aWR0aDoxMDAsaGVpZ2h0OjUwLHg6MTAwfSksYz1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLGIuc3R5bGVbQWFdPVwiNTAlIDUwJVwiLGIuc3R5bGVbeWFdPVwic2NhbGVYKDAuNSlcIixkPWM9PT1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoJiYhKG4mJkJhKSxGYS5yZW1vdmVDaGlsZChhKSksZH0oKSxIYT1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmLGgsaSxqLGssbCxtLG4sbyxwLHEscixzLHQsdT1hLl9nc1RyYW5zZm9ybSx2PUthKGEsITApO3UmJihzPXUueE9yaWdpbix0PXUueU9yaWdpbiksKCFkfHwoZj1kLnNwbGl0KFwiIFwiKSkubGVuZ3RoPDIpJiYobT1hLmdldEJCb3goKSxiPWRhKGIpLnNwbGl0KFwiIFwiKSxmPVsoLTEhPT1iWzBdLmluZGV4T2YoXCIlXCIpP3BhcnNlRmxvYXQoYlswXSkvMTAwKm0ud2lkdGg6cGFyc2VGbG9hdChiWzBdKSkrbS54LCgtMSE9PWJbMV0uaW5kZXhPZihcIiVcIik/cGFyc2VGbG9hdChiWzFdKS8xMDAqbS5oZWlnaHQ6cGFyc2VGbG9hdChiWzFdKSkrbS55XSksYy54T3JpZ2luPWo9cGFyc2VGbG9hdChmWzBdKSxjLnlPcmlnaW49az1wYXJzZUZsb2F0KGZbMV0pLGQmJnYhPT1KYSYmKGw9dlswXSxtPXZbMV0sbj12WzJdLG89dlszXSxwPXZbNF0scT12WzVdLHI9bCpvLW0qbixoPWoqKG8vcikrayooLW4vcikrKG4qcS1vKnApL3IsaT1qKigtbS9yKStrKihsL3IpLShsKnEtbSpwKS9yLGo9Yy54T3JpZ2luPWZbMF09aCxrPWMueU9yaWdpbj1mWzFdPWkpLHUmJihlfHxlIT09ITEmJmcuZGVmYXVsdFNtb290aE9yaWdpbiE9PSExPyhoPWotcyxpPWstdCx1LnhPZmZzZXQrPWgqdlswXStpKnZbMl0taCx1LnlPZmZzZXQrPWgqdlsxXStpKnZbM10taSk6dS54T2Zmc2V0PXUueU9mZnNldD0wKSxhLnNldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiLGYuam9pbihcIiBcIikpfSxJYT1mdW5jdGlvbihhKXtyZXR1cm4hIShEYSYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5nZXRCQm94JiZhLmdldENUTSYmKCFhLnBhcmVudE5vZGV8fGEucGFyZW50Tm9kZS5nZXRCQm94JiZhLnBhcmVudE5vZGUuZ2V0Q1RNKSl9LEphPVsxLDAsMCwxLDAsMF0sS2E9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnLGg9YS5fZ3NUcmFuc2Zvcm18fG5ldyBDYSxpPTFlNTtpZih5YT9kPVgoYSx6YSxudWxsLCEwKTphLmN1cnJlbnRTdHlsZSYmKGQ9YS5jdXJyZW50U3R5bGUuZmlsdGVyLm1hdGNoKEUpLGQ9ZCYmND09PWQubGVuZ3RoP1tkWzBdLnN1YnN0cig0KSxOdW1iZXIoZFsyXS5zdWJzdHIoNCkpLE51bWJlcihkWzFdLnN1YnN0cig0KSksZFszXS5zdWJzdHIoNCksaC54fHwwLGgueXx8MF0uam9pbihcIixcIik6XCJcIiksYz0hZHx8XCJub25lXCI9PT1kfHxcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiPT09ZCwoaC5zdmd8fGEuZ2V0QkJveCYmSWEoYSkpJiYoYyYmLTEhPT0oYS5zdHlsZVt5YV0rXCJcIikuaW5kZXhPZihcIm1hdHJpeFwiKSYmKGQ9YS5zdHlsZVt5YV0sYz0wKSxlPWEuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpLGMmJmUmJigtMSE9PWUuaW5kZXhPZihcIm1hdHJpeFwiKT8oZD1lLGM9MCk6LTEhPT1lLmluZGV4T2YoXCJ0cmFuc2xhdGVcIikmJihkPVwibWF0cml4KDEsMCwwLDEsXCIrZS5tYXRjaCgvKD86XFwtfFxcYilbXFxkXFwtXFwuZV0rXFxiL2dpKS5qb2luKFwiLFwiKStcIilcIixjPTApKSksYylyZXR1cm4gSmE7Zm9yKGU9KGR8fFwiXCIpLm1hdGNoKC8oPzpcXC18XFxiKVtcXGRcXC1cXC5lXStcXGIvZ2kpfHxbXSxzYT1lLmxlbmd0aDstLXNhPi0xOylmPU51bWJlcihlW3NhXSksZVtzYV09KGc9Zi0oZnw9MCkpPyhnKmkrKDA+Zz8tLjU6LjUpfDApL2krZjpmO3JldHVybiBiJiZlLmxlbmd0aD42P1tlWzBdLGVbMV0sZVs0XSxlWzVdLGVbMTJdLGVbMTNdXTplfSxMYT1PLmdldFRyYW5zZm9ybT1mdW5jdGlvbihhLGMsZCxmKXtpZihhLl9nc1RyYW5zZm9ybSYmZCYmIWYpcmV0dXJuIGEuX2dzVHJhbnNmb3JtO3ZhciBoLGksaixrLGwsbSxuPWQ/YS5fZ3NUcmFuc2Zvcm18fG5ldyBDYTpuZXcgQ2Esbz1uLnNjYWxlWDwwLHA9MmUtNSxxPTFlNSxyPUJhP3BhcnNlRmxvYXQoWChhLEFhLGMsITEsXCIwIDAgMFwiKS5zcGxpdChcIiBcIilbMl0pfHxuLnpPcmlnaW58fDA6MCxzPXBhcnNlRmxvYXQoZy5kZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmUpfHwwO2lmKG4uc3ZnPSEoIWEuZ2V0QkJveHx8IUlhKGEpKSxuLnN2ZyYmKEhhKGEsWChhLEFhLGUsITEsXCI1MCUgNTAlXCIpK1wiXCIsbixhLmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKSksd2E9Zy51c2VTVkdUcmFuc2Zvcm1BdHRyfHxHYSksaD1LYShhKSxoIT09SmEpe2lmKDE2PT09aC5sZW5ndGgpe3ZhciB0LHUsdix3LHgseT1oWzBdLHo9aFsxXSxBPWhbMl0sQj1oWzNdLEM9aFs0XSxEPWhbNV0sRT1oWzZdLEY9aFs3XSxHPWhbOF0sSD1oWzldLEo9aFsxMF0sSz1oWzEyXSxMPWhbMTNdLE09aFsxNF0sTj1oWzExXSxPPU1hdGguYXRhbjIoRSxKKTtuLnpPcmlnaW4mJihNPS1uLnpPcmlnaW4sSz1HKk0taFsxMl0sTD1IKk0taFsxM10sTT1KKk0rbi56T3JpZ2luLWhbMTRdKSxuLnJvdGF0aW9uWD1PKkksTyYmKHc9TWF0aC5jb3MoLU8pLHg9TWF0aC5zaW4oLU8pLHQ9Qyp3K0cqeCx1PUQqdytIKngsdj1FKncrSip4LEc9QyoteCtHKncsSD1EKi14K0gqdyxKPUUqLXgrSip3LE49RioteCtOKncsQz10LEQ9dSxFPXYpLE89TWF0aC5hdGFuMigtQSxKKSxuLnJvdGF0aW9uWT1PKkksTyYmKHc9TWF0aC5jb3MoLU8pLHg9TWF0aC5zaW4oLU8pLHQ9eSp3LUcqeCx1PXoqdy1IKngsdj1BKnctSip4LEg9eip4K0gqdyxKPUEqeCtKKncsTj1CKngrTip3LHk9dCx6PXUsQT12KSxPPU1hdGguYXRhbjIoeix5KSxuLnJvdGF0aW9uPU8qSSxPJiYodz1NYXRoLmNvcygtTykseD1NYXRoLnNpbigtTykseT15KncrQyp4LHU9eip3K0QqeCxEPXoqLXgrRCp3LEU9QSoteCtFKncsej11KSxuLnJvdGF0aW9uWCYmTWF0aC5hYnMobi5yb3RhdGlvblgpK01hdGguYWJzKG4ucm90YXRpb24pPjM1OS45JiYobi5yb3RhdGlvblg9bi5yb3RhdGlvbj0wLG4ucm90YXRpb25ZPTE4MC1uLnJvdGF0aW9uWSksbi5zY2FsZVg9KE1hdGguc3FydCh5Knkreip6KSpxKy41fDApL3Esbi5zY2FsZVk9KE1hdGguc3FydChEKkQrSCpIKSpxKy41fDApL3Esbi5zY2FsZVo9KE1hdGguc3FydChFKkUrSipKKSpxKy41fDApL3Esbi5za2V3WD0wLG4ucGVyc3BlY3RpdmU9Tj8xLygwPk4/LU46Tik6MCxuLng9SyxuLnk9TCxuLno9TSxuLnN2ZyYmKG4ueC09bi54T3JpZ2luLShuLnhPcmlnaW4qeS1uLnlPcmlnaW4qQyksbi55LT1uLnlPcmlnaW4tKG4ueU9yaWdpbip6LW4ueE9yaWdpbipEKSl9ZWxzZSBpZigoIUJhfHxmfHwhaC5sZW5ndGh8fG4ueCE9PWhbNF18fG4ueSE9PWhbNV18fCFuLnJvdGF0aW9uWCYmIW4ucm90YXRpb25ZKSYmKHZvaWQgMD09PW4ueHx8XCJub25lXCIhPT1YKGEsXCJkaXNwbGF5XCIsYykpKXt2YXIgUD1oLmxlbmd0aD49NixRPVA/aFswXToxLFI9aFsxXXx8MCxTPWhbMl18fDAsVD1QP2hbM106MTtuLng9aFs0XXx8MCxuLnk9aFs1XXx8MCxqPU1hdGguc3FydChRKlErUipSKSxrPU1hdGguc3FydChUKlQrUypTKSxsPVF8fFI/TWF0aC5hdGFuMihSLFEpKkk6bi5yb3RhdGlvbnx8MCxtPVN8fFQ/TWF0aC5hdGFuMihTLFQpKkkrbDpuLnNrZXdYfHwwLE1hdGguYWJzKG0pPjkwJiZNYXRoLmFicyhtKTwyNzAmJihvPyhqKj0tMSxtKz0wPj1sPzE4MDotMTgwLGwrPTA+PWw/MTgwOi0xODApOihrKj0tMSxtKz0wPj1tPzE4MDotMTgwKSksbi5zY2FsZVg9aixuLnNjYWxlWT1rLG4ucm90YXRpb249bCxuLnNrZXdYPW0sQmEmJihuLnJvdGF0aW9uWD1uLnJvdGF0aW9uWT1uLno9MCxuLnBlcnNwZWN0aXZlPXMsbi5zY2FsZVo9MSksbi5zdmcmJihuLngtPW4ueE9yaWdpbi0obi54T3JpZ2luKlErbi55T3JpZ2luKlMpLG4ueS09bi55T3JpZ2luLShuLnhPcmlnaW4qUituLnlPcmlnaW4qVCkpfW4uek9yaWdpbj1yO2ZvcihpIGluIG4pbltpXTxwJiZuW2ldPi1wJiYobltpXT0wKX1yZXR1cm4gZCYmKGEuX2dzVHJhbnNmb3JtPW4sbi5zdmcmJih3YSYmYS5zdHlsZVt5YV0/Yi5kZWxheWVkQ2FsbCguMDAxLGZ1bmN0aW9uKCl7UGEoYS5zdHlsZSx5YSl9KTohd2EmJmEuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpJiZiLmRlbGF5ZWRDYWxsKC4wMDEsZnVuY3Rpb24oKXthLnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKX0pKSksbn0sTWE9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkPXRoaXMuZGF0YSxlPS1kLnJvdGF0aW9uKkgsZj1lK2Quc2tld1gqSCxnPTFlNSxoPShNYXRoLmNvcyhlKSpkLnNjYWxlWCpnfDApL2csaT0oTWF0aC5zaW4oZSkqZC5zY2FsZVgqZ3wwKS9nLGo9KE1hdGguc2luKGYpKi1kLnNjYWxlWSpnfDApL2csaz0oTWF0aC5jb3MoZikqZC5zY2FsZVkqZ3wwKS9nLGw9dGhpcy50LnN0eWxlLG09dGhpcy50LmN1cnJlbnRTdHlsZTtpZihtKXtjPWksaT0taixqPS1jLGI9bS5maWx0ZXIsbC5maWx0ZXI9XCJcIjt2YXIgbixvLHE9dGhpcy50Lm9mZnNldFdpZHRoLHI9dGhpcy50Lm9mZnNldEhlaWdodCxzPVwiYWJzb2x1dGVcIiE9PW0ucG9zaXRpb24sdD1cInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPVwiK2grXCIsIE0xMj1cIitpK1wiLCBNMjE9XCIraitcIiwgTTIyPVwiK2ssdz1kLngrcSpkLnhQZXJjZW50LzEwMCx4PWQueStyKmQueVBlcmNlbnQvMTAwO2lmKG51bGwhPWQub3gmJihuPShkLm94cD9xKmQub3gqLjAxOmQub3gpLXEvMixvPShkLm95cD9yKmQub3kqLjAxOmQub3kpLXIvMix3Kz1uLShuKmgrbyppKSx4Kz1vLShuKmorbyprKSkscz8obj1xLzIsbz1yLzIsdCs9XCIsIER4PVwiKyhuLShuKmgrbyppKSt3KStcIiwgRHk9XCIrKG8tKG4qaitvKmspK3gpK1wiKVwiKTp0Kz1cIiwgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpXCIsLTEhPT1iLmluZGV4T2YoXCJEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoXCIpP2wuZmlsdGVyPWIucmVwbGFjZShGLHQpOmwuZmlsdGVyPXQrXCIgXCIrYiwoMD09PWF8fDE9PT1hKSYmMT09PWgmJjA9PT1pJiYwPT09aiYmMT09PWsmJihzJiYtMT09PXQuaW5kZXhPZihcIkR4PTAsIER5PTBcIil8fHYudGVzdChiKSYmMTAwIT09cGFyc2VGbG9hdChSZWdFeHAuJDEpfHwtMT09PWIuaW5kZXhPZihiLmluZGV4T2YoXCJBbHBoYVwiKSkmJmwucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpKSwhcyl7dmFyIHkseixBLEI9OD5wPzE6LTE7Zm9yKG49ZC5pZU9mZnNldFh8fDAsbz1kLmllT2Zmc2V0WXx8MCxkLmllT2Zmc2V0WD1NYXRoLnJvdW5kKChxLSgoMD5oPy1oOmgpKnErKDA+aT8taTppKSpyKSkvMit3KSxkLmllT2Zmc2V0WT1NYXRoLnJvdW5kKChyLSgoMD5rPy1rOmspKnIrKDA+aj8tajpqKSpxKSkvMit4KSxzYT0wOzQ+c2E7c2ErKyl6PWJhW3NhXSx5PW1bel0sYz0tMSE9PXkuaW5kZXhPZihcInB4XCIpP3BhcnNlRmxvYXQoeSk6WSh0aGlzLnQseixwYXJzZUZsb2F0KHkpLHkucmVwbGFjZSh1LFwiXCIpKXx8MCxBPWMhPT1kW3pdPzI+c2E/LWQuaWVPZmZzZXRYOi1kLmllT2Zmc2V0WToyPnNhP24tZC5pZU9mZnNldFg6by1kLmllT2Zmc2V0WSxsW3pdPShkW3pdPU1hdGgucm91bmQoYy1BKigwPT09c2F8fDI9PT1zYT8xOkIpKSkrXCJweFwifX19LE5hPU8uc2V0M0RUcmFuc2Zvcm1SYXRpbz1PLnNldFRyYW5zZm9ybVJhdGlvPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxvLHAscSxyLHMsdCx1LHYsdyx4LHksej10aGlzLmRhdGEsQT10aGlzLnQuc3R5bGUsQj16LnJvdGF0aW9uLEM9ei5yb3RhdGlvblgsRD16LnJvdGF0aW9uWSxFPXouc2NhbGVYLEY9ei5zY2FsZVksRz16LnNjYWxlWixJPXoueCxKPXoueSxLPXoueixMPXouc3ZnLE09ei5wZXJzcGVjdGl2ZSxOPXouZm9yY2UzRDtpZigoKDE9PT1hfHwwPT09YSkmJlwiYXV0b1wiPT09TiYmKHRoaXMudHdlZW4uX3RvdGFsVGltZT09PXRoaXMudHdlZW4uX3RvdGFsRHVyYXRpb258fCF0aGlzLnR3ZWVuLl90b3RhbFRpbWUpfHwhTikmJiFLJiYhTSYmIUQmJiFDJiYxPT09R3x8d2EmJkx8fCFCYSlyZXR1cm4gdm9pZChCfHx6LnNrZXdYfHxMPyhCKj1ILHg9ei5za2V3WCpILHk9MWU1LGI9TWF0aC5jb3MoQikqRSxlPU1hdGguc2luKEIpKkUsYz1NYXRoLnNpbihCLXgpKi1GLGY9TWF0aC5jb3MoQi14KSpGLHgmJlwic2ltcGxlXCI9PT16LnNrZXdUeXBlJiYocz1NYXRoLnRhbih4KSxzPU1hdGguc3FydCgxK3MqcyksYyo9cyxmKj1zLHouc2tld1kmJihiKj1zLGUqPXMpKSxMJiYoSSs9ei54T3JpZ2luLSh6LnhPcmlnaW4qYit6LnlPcmlnaW4qYykrei54T2Zmc2V0LEorPXoueU9yaWdpbi0oei54T3JpZ2luKmUrei55T3JpZ2luKmYpK3oueU9mZnNldCx3YSYmKHoueFBlcmNlbnR8fHoueVBlcmNlbnQpJiYocD10aGlzLnQuZ2V0QkJveCgpLEkrPS4wMSp6LnhQZXJjZW50KnAud2lkdGgsSis9LjAxKnoueVBlcmNlbnQqcC5oZWlnaHQpLHA9MWUtNixwPkkmJkk+LXAmJihJPTApLHA+SiYmSj4tcCYmKEo9MCkpLHU9KGIqeXwwKS95K1wiLFwiKyhlKnl8MCkveStcIixcIisoYyp5fDApL3krXCIsXCIrKGYqeXwwKS95K1wiLFwiK0krXCIsXCIrSitcIilcIixMJiZ3YT90aGlzLnQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsXCJtYXRyaXgoXCIrdSk6QVt5YV09KHoueFBlcmNlbnR8fHoueVBlcmNlbnQ/XCJ0cmFuc2xhdGUoXCIrei54UGVyY2VudCtcIiUsXCIrei55UGVyY2VudCtcIiUpIG1hdHJpeChcIjpcIm1hdHJpeChcIikrdSk6QVt5YV09KHoueFBlcmNlbnR8fHoueVBlcmNlbnQ/XCJ0cmFuc2xhdGUoXCIrei54UGVyY2VudCtcIiUsXCIrei55UGVyY2VudCtcIiUpIG1hdHJpeChcIjpcIm1hdHJpeChcIikrRStcIiwwLDAsXCIrRitcIixcIitJK1wiLFwiK0orXCIpXCIpO2lmKG4mJihwPTFlLTQscD5FJiZFPi1wJiYoRT1HPTJlLTUpLHA+RiYmRj4tcCYmKEY9Rz0yZS01KSwhTXx8ei56fHx6LnJvdGF0aW9uWHx8ei5yb3RhdGlvbll8fChNPTApKSxCfHx6LnNrZXdYKUIqPUgscT1iPU1hdGguY29zKEIpLHI9ZT1NYXRoLnNpbihCKSx6LnNrZXdYJiYoQi09ei5za2V3WCpILHE9TWF0aC5jb3MoQikscj1NYXRoLnNpbihCKSxcInNpbXBsZVwiPT09ei5za2V3VHlwZSYmKHM9TWF0aC50YW4oei5za2V3WCpIKSxzPU1hdGguc3FydCgxK3MqcykscSo9cyxyKj1zLHouc2tld1kmJihiKj1zLGUqPXMpKSksYz0tcixmPXE7ZWxzZXtpZighKER8fEN8fDEhPT1HfHxNfHxMKSlyZXR1cm4gdm9pZChBW3lhXT0oei54UGVyY2VudHx8ei55UGVyY2VudD9cInRyYW5zbGF0ZShcIit6LnhQZXJjZW50K1wiJSxcIit6LnlQZXJjZW50K1wiJSkgdHJhbnNsYXRlM2QoXCI6XCJ0cmFuc2xhdGUzZChcIikrSStcInB4LFwiK0orXCJweCxcIitLK1wicHgpXCIrKDEhPT1FfHwxIT09Rj9cIiBzY2FsZShcIitFK1wiLFwiK0YrXCIpXCI6XCJcIikpO2I9Zj0xLGM9ZT0wfWo9MSxkPWc9aD1pPWs9bD0wLG09TT8tMS9NOjAsbz16LnpPcmlnaW4scD0xZS02LHY9XCIsXCIsdz1cIjBcIixCPUQqSCxCJiYocT1NYXRoLmNvcyhCKSxyPU1hdGguc2luKEIpLGg9LXIsaz1tKi1yLGQ9YipyLGc9ZSpyLGo9cSxtKj1xLGIqPXEsZSo9cSksQj1DKkgsQiYmKHE9TWF0aC5jb3MoQikscj1NYXRoLnNpbihCKSxzPWMqcStkKnIsdD1mKnErZypyLGk9aipyLGw9bSpyLGQ9YyotcitkKnEsZz1mKi1yK2cqcSxqKj1xLG0qPXEsYz1zLGY9dCksMSE9PUcmJihkKj1HLGcqPUcsaio9RyxtKj1HKSwxIT09RiYmKGMqPUYsZio9RixpKj1GLGwqPUYpLDEhPT1FJiYoYio9RSxlKj1FLGgqPUUsayo9RSksKG98fEwpJiYobyYmKEkrPWQqLW8sSis9ZyotbyxLKz1qKi1vK28pLEwmJihJKz16LnhPcmlnaW4tKHoueE9yaWdpbipiK3oueU9yaWdpbipjKSt6LnhPZmZzZXQsSis9ei55T3JpZ2luLSh6LnhPcmlnaW4qZSt6LnlPcmlnaW4qZikrei55T2Zmc2V0KSxwPkkmJkk+LXAmJihJPXcpLHA+SiYmSj4tcCYmKEo9dykscD5LJiZLPi1wJiYoSz0wKSksdT16LnhQZXJjZW50fHx6LnlQZXJjZW50P1widHJhbnNsYXRlKFwiK3oueFBlcmNlbnQrXCIlLFwiK3oueVBlcmNlbnQrXCIlKSBtYXRyaXgzZChcIjpcIm1hdHJpeDNkKFwiLHUrPShwPmImJmI+LXA/dzpiKSt2KyhwPmUmJmU+LXA/dzplKSt2KyhwPmgmJmg+LXA/dzpoKSx1Kz12KyhwPmsmJms+LXA/dzprKSt2KyhwPmMmJmM+LXA/dzpjKSt2KyhwPmYmJmY+LXA/dzpmKSxDfHxEfHwxIT09Rz8odSs9disocD5pJiZpPi1wP3c6aSkrdisocD5sJiZsPi1wP3c6bCkrdisocD5kJiZkPi1wP3c6ZCksdSs9disocD5nJiZnPi1wP3c6ZykrdisocD5qJiZqPi1wP3c6aikrdisocD5tJiZtPi1wP3c6bSkrdik6dSs9XCIsMCwwLDAsMCwxLDAsXCIsdSs9SSt2K0orditLK3YrKE0/MSstSy9NOjEpK1wiKVwiLEFbeWFdPXV9O2o9Q2EucHJvdG90eXBlLGoueD1qLnk9ai56PWouc2tld1g9ai5za2V3WT1qLnJvdGF0aW9uPWoucm90YXRpb25YPWoucm90YXRpb25ZPWouek9yaWdpbj1qLnhQZXJjZW50PWoueVBlcmNlbnQ9ai54T2Zmc2V0PWoueU9mZnNldD0wLGouc2NhbGVYPWouc2NhbGVZPWouc2NhbGVaPTEsdWEoXCJ0cmFuc2Zvcm0sc2NhbGUsc2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHoscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxyb3RhdGlvblosc2tld1gsc2tld1ksc2hvcnRSb3RhdGlvbixzaG9ydFJvdGF0aW9uWCxzaG9ydFJvdGF0aW9uWSxzaG9ydFJvdGF0aW9uWix0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlLGRpcmVjdGlvbmFsUm90YXRpb24scGFyc2VUcmFuc2Zvcm0sZm9yY2UzRCxza2V3VHlwZSx4UGVyY2VudCx5UGVyY2VudCxzbW9vdGhPcmlnaW5cIix7cGFyc2VyOmZ1bmN0aW9uKGEsYixjLGQsZixoLGkpe2lmKGQuX2xhc3RQYXJzZWRUcmFuc2Zvcm09PT1pKXJldHVybiBmO2QuX2xhc3RQYXJzZWRUcmFuc2Zvcm09aTt2YXIgaixrLGwsbSxuLG8scCxxLHIscyx0PWEuX2dzVHJhbnNmb3JtLHU9YS5zdHlsZSx2PTFlLTYsdz14YS5sZW5ndGgseD1pLHk9e30sej1cInRyYW5zZm9ybU9yaWdpblwiO2lmKGkuZGlzcGxheT8obT1YKGEsXCJkaXNwbGF5XCIpLHUuZGlzcGxheT1cImJsb2NrXCIsaj1MYShhLGUsITAsaS5wYXJzZVRyYW5zZm9ybSksdS5kaXNwbGF5PW0pOmo9TGEoYSxlLCEwLGkucGFyc2VUcmFuc2Zvcm0pLGQuX3RyYW5zZm9ybT1qLFwic3RyaW5nXCI9PXR5cGVvZiB4LnRyYW5zZm9ybSYmeWEpbT1NLnN0eWxlLG1beWFdPXgudHJhbnNmb3JtLG0uZGlzcGxheT1cImJsb2NrXCIsbS5wb3NpdGlvbj1cImFic29sdXRlXCIsSy5ib2R5LmFwcGVuZENoaWxkKE0pLGs9TGEoTSxudWxsLCExKSxLLmJvZHkucmVtb3ZlQ2hpbGQoTSksay5wZXJzcGVjdGl2ZXx8KGsucGVyc3BlY3RpdmU9ai5wZXJzcGVjdGl2ZSksbnVsbCE9eC54UGVyY2VudCYmKGsueFBlcmNlbnQ9ZmEoeC54UGVyY2VudCxqLnhQZXJjZW50KSksbnVsbCE9eC55UGVyY2VudCYmKGsueVBlcmNlbnQ9ZmEoeC55UGVyY2VudCxqLnlQZXJjZW50KSk7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgeCl7aWYoaz17c2NhbGVYOmZhKG51bGwhPXguc2NhbGVYP3guc2NhbGVYOnguc2NhbGUsai5zY2FsZVgpLHNjYWxlWTpmYShudWxsIT14LnNjYWxlWT94LnNjYWxlWTp4LnNjYWxlLGouc2NhbGVZKSxzY2FsZVo6ZmEoeC5zY2FsZVosai5zY2FsZVopLHg6ZmEoeC54LGoueCkseTpmYSh4Lnksai55KSx6OmZhKHgueixqLnopLHhQZXJjZW50OmZhKHgueFBlcmNlbnQsai54UGVyY2VudCkseVBlcmNlbnQ6ZmEoeC55UGVyY2VudCxqLnlQZXJjZW50KSxwZXJzcGVjdGl2ZTpmYSh4LnRyYW5zZm9ybVBlcnNwZWN0aXZlLGoucGVyc3BlY3RpdmUpfSxxPXguZGlyZWN0aW9uYWxSb3RhdGlvbixudWxsIT1xKWlmKFwib2JqZWN0XCI9PXR5cGVvZiBxKWZvcihtIGluIHEpeFttXT1xW21dO2Vsc2UgeC5yb3RhdGlvbj1xO1wic3RyaW5nXCI9PXR5cGVvZiB4LngmJi0xIT09eC54LmluZGV4T2YoXCIlXCIpJiYoay54PTAsay54UGVyY2VudD1mYSh4Lngsai54UGVyY2VudCkpLFwic3RyaW5nXCI9PXR5cGVvZiB4LnkmJi0xIT09eC55LmluZGV4T2YoXCIlXCIpJiYoay55PTAsay55UGVyY2VudD1mYSh4Lnksai55UGVyY2VudCkpLGsucm90YXRpb249Z2EoXCJyb3RhdGlvblwiaW4geD94LnJvdGF0aW9uOlwic2hvcnRSb3RhdGlvblwiaW4geD94LnNob3J0Um90YXRpb24rXCJfc2hvcnRcIjpcInJvdGF0aW9uWlwiaW4geD94LnJvdGF0aW9uWjpqLnJvdGF0aW9uLGoucm90YXRpb24sXCJyb3RhdGlvblwiLHkpLEJhJiYoay5yb3RhdGlvblg9Z2EoXCJyb3RhdGlvblhcImluIHg/eC5yb3RhdGlvblg6XCJzaG9ydFJvdGF0aW9uWFwiaW4geD94LnNob3J0Um90YXRpb25YK1wiX3Nob3J0XCI6ai5yb3RhdGlvblh8fDAsai5yb3RhdGlvblgsXCJyb3RhdGlvblhcIix5KSxrLnJvdGF0aW9uWT1nYShcInJvdGF0aW9uWVwiaW4geD94LnJvdGF0aW9uWTpcInNob3J0Um90YXRpb25ZXCJpbiB4P3guc2hvcnRSb3RhdGlvblkrXCJfc2hvcnRcIjpqLnJvdGF0aW9uWXx8MCxqLnJvdGF0aW9uWSxcInJvdGF0aW9uWVwiLHkpKSxrLnNrZXdYPW51bGw9PXguc2tld1g/ai5za2V3WDpnYSh4LnNrZXdYLGouc2tld1gpLGsuc2tld1k9bnVsbD09eC5za2V3WT9qLnNrZXdZOmdhKHguc2tld1ksai5za2V3WSksKGw9ay5za2V3WS1qLnNrZXdZKSYmKGsuc2tld1grPWwsay5yb3RhdGlvbis9bCl9Zm9yKEJhJiZudWxsIT14LmZvcmNlM0QmJihqLmZvcmNlM0Q9eC5mb3JjZTNELHA9ITApLGouc2tld1R5cGU9eC5za2V3VHlwZXx8ai5za2V3VHlwZXx8Zy5kZWZhdWx0U2tld1R5cGUsbz1qLmZvcmNlM0R8fGouenx8ai5yb3RhdGlvblh8fGoucm90YXRpb25ZfHxrLnp8fGsucm90YXRpb25YfHxrLnJvdGF0aW9uWXx8ay5wZXJzcGVjdGl2ZSxvfHxudWxsPT14LnNjYWxlfHwoay5zY2FsZVo9MSk7LS13Pi0xOyljPXhhW3ddLG49a1tjXS1qW2NdLChuPnZ8fC12Pm58fG51bGwhPXhbY118fG51bGwhPUpbY10pJiYocD0hMCxmPW5ldyBwYShqLGMsaltjXSxuLGYpLGMgaW4geSYmKGYuZT15W2NdKSxmLnhzMD0wLGYucGx1Z2luPWgsZC5fb3ZlcndyaXRlUHJvcHMucHVzaChmLm4pKTtyZXR1cm4gbj14LnRyYW5zZm9ybU9yaWdpbixqLnN2ZyYmKG58fHguc3ZnT3JpZ2luKSYmKHI9ai54T2Zmc2V0LHM9ai55T2Zmc2V0LEhhKGEsZGEobiksayx4LnN2Z09yaWdpbix4LnNtb290aE9yaWdpbiksZj1xYShqLFwieE9yaWdpblwiLCh0P2o6aykueE9yaWdpbixrLnhPcmlnaW4sZix6KSxmPXFhKGosXCJ5T3JpZ2luXCIsKHQ/ajprKS55T3JpZ2luLGsueU9yaWdpbixmLHopLChyIT09ai54T2Zmc2V0fHxzIT09ai55T2Zmc2V0KSYmKGY9cWEoaixcInhPZmZzZXRcIix0P3I6ai54T2Zmc2V0LGoueE9mZnNldCxmLHopLGY9cWEoaixcInlPZmZzZXRcIix0P3M6ai55T2Zmc2V0LGoueU9mZnNldCxmLHopKSxuPXdhP251bGw6XCIwcHggMHB4XCIpLChufHxCYSYmbyYmai56T3JpZ2luKSYmKHlhPyhwPSEwLGM9QWEsbj0obnx8WChhLGMsZSwhMSxcIjUwJSA1MCVcIikpK1wiXCIsZj1uZXcgcGEodSxjLDAsMCxmLC0xLHopLGYuYj11W2NdLGYucGx1Z2luPWgsQmE/KG09ai56T3JpZ2luLG49bi5zcGxpdChcIiBcIiksai56T3JpZ2luPShuLmxlbmd0aD4yJiYoMD09PW18fFwiMHB4XCIhPT1uWzJdKT9wYXJzZUZsb2F0KG5bMl0pOm0pfHwwLGYueHMwPWYuZT1uWzBdK1wiIFwiKyhuWzFdfHxcIjUwJVwiKStcIiAwcHhcIixmPW5ldyBwYShqLFwiek9yaWdpblwiLDAsMCxmLC0xLGYubiksZi5iPW0sZi54czA9Zi5lPWouek9yaWdpbik6Zi54czA9Zi5lPW4pOmRhKG4rXCJcIixqKSkscCYmKGQuX3RyYW5zZm9ybVR5cGU9ai5zdmcmJndhfHwhbyYmMyE9PXRoaXMuX3RyYW5zZm9ybVR5cGU/MjozKSxmfSxwcmVmaXg6ITB9KSx1YShcImJveFNoYWRvd1wiLHtkZWZhdWx0VmFsdWU6XCIwcHggMHB4IDBweCAwcHggIzk5OVwiLHByZWZpeDohMCxjb2xvcjohMCxtdWx0aTohMCxrZXl3b3JkOlwiaW5zZXRcIn0pLHVhKFwiYm9yZGVyUmFkaXVzXCIse2RlZmF1bHRWYWx1ZTpcIjBweFwiLHBhcnNlcjpmdW5jdGlvbihhLGIsYyxmLGcsaCl7Yj10aGlzLmZvcm1hdChiKTt2YXIgaSxqLGssbCxtLG4sbyxwLHEscixzLHQsdSx2LHcseCx5PVtcImJvcmRlclRvcExlZnRSYWRpdXNcIixcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXCJib3JkZXJCb3R0b21SaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiXSx6PWEuc3R5bGU7Zm9yKHE9cGFyc2VGbG9hdChhLm9mZnNldFdpZHRoKSxyPXBhcnNlRmxvYXQoYS5vZmZzZXRIZWlnaHQpLGk9Yi5zcGxpdChcIiBcIiksaj0wO2o8eS5sZW5ndGg7aisrKXRoaXMucC5pbmRleE9mKFwiYm9yZGVyXCIpJiYoeVtqXT1WKHlbal0pKSxtPWw9WChhLHlbal0sZSwhMSxcIjBweFwiKSwtMSE9PW0uaW5kZXhPZihcIiBcIikmJihsPW0uc3BsaXQoXCIgXCIpLG09bFswXSxsPWxbMV0pLG49az1pW2pdLG89cGFyc2VGbG9hdChtKSx0PW0uc3Vic3RyKChvK1wiXCIpLmxlbmd0aCksdT1cIj1cIj09PW4uY2hhckF0KDEpLHU/KHA9cGFyc2VJbnQobi5jaGFyQXQoMCkrXCIxXCIsMTApLG49bi5zdWJzdHIoMikscCo9cGFyc2VGbG9hdChuKSxzPW4uc3Vic3RyKChwK1wiXCIpLmxlbmd0aC0oMD5wPzE6MCkpfHxcIlwiKToocD1wYXJzZUZsb2F0KG4pLHM9bi5zdWJzdHIoKHArXCJcIikubGVuZ3RoKSksXCJcIj09PXMmJihzPWRbY118fHQpLHMhPT10JiYodj1ZKGEsXCJib3JkZXJMZWZ0XCIsbyx0KSx3PVkoYSxcImJvcmRlclRvcFwiLG8sdCksXCIlXCI9PT1zPyhtPXYvcSoxMDArXCIlXCIsbD13L3IqMTAwK1wiJVwiKTpcImVtXCI9PT1zPyh4PVkoYSxcImJvcmRlckxlZnRcIiwxLFwiZW1cIiksbT12L3grXCJlbVwiLGw9dy94K1wiZW1cIik6KG09ditcInB4XCIsbD13K1wicHhcIiksdSYmKG49cGFyc2VGbG9hdChtKStwK3Msaz1wYXJzZUZsb2F0KGwpK3ArcykpLGc9cmEoeix5W2pdLG0rXCIgXCIrbCxuK1wiIFwiK2ssITEsXCIwcHhcIixnKTtyZXR1cm4gZ30scHJlZml4OiEwLGZvcm1hdHRlcjptYShcIjBweCAwcHggMHB4IDBweFwiLCExLCEwKX0pLHVhKFwiYmFja2dyb3VuZFBvc2l0aW9uXCIse1xuZGVmYXVsdFZhbHVlOlwiMCAwXCIscGFyc2VyOmZ1bmN0aW9uKGEsYixjLGQsZixnKXt2YXIgaCxpLGosayxsLG0sbj1cImJhY2tncm91bmQtcG9zaXRpb25cIixvPWV8fFcoYSxudWxsKSxxPXRoaXMuZm9ybWF0KChvP3A/by5nZXRQcm9wZXJ0eVZhbHVlKG4rXCIteFwiKStcIiBcIitvLmdldFByb3BlcnR5VmFsdWUobitcIi15XCIpOm8uZ2V0UHJvcGVydHlWYWx1ZShuKTphLmN1cnJlbnRTdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25YK1wiIFwiK2EuY3VycmVudFN0eWxlLmJhY2tncm91bmRQb3NpdGlvblkpfHxcIjAgMFwiKSxyPXRoaXMuZm9ybWF0KGIpO2lmKC0xIT09cS5pbmRleE9mKFwiJVwiKSE9KC0xIT09ci5pbmRleE9mKFwiJVwiKSkmJihtPVgoYSxcImJhY2tncm91bmRJbWFnZVwiKS5yZXBsYWNlKEIsXCJcIiksbSYmXCJub25lXCIhPT1tKSl7Zm9yKGg9cS5zcGxpdChcIiBcIiksaT1yLnNwbGl0KFwiIFwiKSxOLnNldEF0dHJpYnV0ZShcInNyY1wiLG0pLGo9MjstLWo+LTE7KXE9aFtqXSxrPS0xIT09cS5pbmRleE9mKFwiJVwiKSxrIT09KC0xIT09aVtqXS5pbmRleE9mKFwiJVwiKSkmJihsPTA9PT1qP2Eub2Zmc2V0V2lkdGgtTi53aWR0aDphLm9mZnNldEhlaWdodC1OLmhlaWdodCxoW2pdPWs/cGFyc2VGbG9hdChxKS8xMDAqbCtcInB4XCI6cGFyc2VGbG9hdChxKS9sKjEwMCtcIiVcIik7cT1oLmpvaW4oXCIgXCIpfXJldHVybiB0aGlzLnBhcnNlQ29tcGxleChhLnN0eWxlLHEscixmLGcpfSxmb3JtYXR0ZXI6ZGF9KSx1YShcImJhY2tncm91bmRTaXplXCIse2RlZmF1bHRWYWx1ZTpcIjAgMFwiLGZvcm1hdHRlcjpkYX0pLHVhKFwicGVyc3BlY3RpdmVcIix7ZGVmYXVsdFZhbHVlOlwiMHB4XCIscHJlZml4OiEwfSksdWEoXCJwZXJzcGVjdGl2ZU9yaWdpblwiLHtkZWZhdWx0VmFsdWU6XCI1MCUgNTAlXCIscHJlZml4OiEwfSksdWEoXCJ0cmFuc2Zvcm1TdHlsZVwiLHtwcmVmaXg6ITB9KSx1YShcImJhY2tmYWNlVmlzaWJpbGl0eVwiLHtwcmVmaXg6ITB9KSx1YShcInVzZXJTZWxlY3RcIix7cHJlZml4OiEwfSksdWEoXCJtYXJnaW5cIix7cGFyc2VyOm5hKFwibWFyZ2luVG9wLG1hcmdpblJpZ2h0LG1hcmdpbkJvdHRvbSxtYXJnaW5MZWZ0XCIpfSksdWEoXCJwYWRkaW5nXCIse3BhcnNlcjpuYShcInBhZGRpbmdUb3AscGFkZGluZ1JpZ2h0LHBhZGRpbmdCb3R0b20scGFkZGluZ0xlZnRcIil9KSx1YShcImNsaXBcIix7ZGVmYXVsdFZhbHVlOlwicmVjdCgwcHgsMHB4LDBweCwwcHgpXCIscGFyc2VyOmZ1bmN0aW9uKGEsYixjLGQsZixnKXt2YXIgaCxpLGo7cmV0dXJuIDk+cD8oaT1hLmN1cnJlbnRTdHlsZSxqPTg+cD9cIiBcIjpcIixcIixoPVwicmVjdChcIitpLmNsaXBUb3AraitpLmNsaXBSaWdodCtqK2kuY2xpcEJvdHRvbStqK2kuY2xpcExlZnQrXCIpXCIsYj10aGlzLmZvcm1hdChiKS5zcGxpdChcIixcIikuam9pbihqKSk6KGg9dGhpcy5mb3JtYXQoWChhLHRoaXMucCxlLCExLHRoaXMuZGZsdCkpLGI9dGhpcy5mb3JtYXQoYikpLHRoaXMucGFyc2VDb21wbGV4KGEuc3R5bGUsaCxiLGYsZyl9fSksdWEoXCJ0ZXh0U2hhZG93XCIse2RlZmF1bHRWYWx1ZTpcIjBweCAwcHggMHB4ICM5OTlcIixjb2xvcjohMCxtdWx0aTohMH0pLHVhKFwiYXV0b1JvdW5kLHN0cmljdFVuaXRzXCIse3BhcnNlcjpmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiBlfX0pLHVhKFwiYm9yZGVyXCIse2RlZmF1bHRWYWx1ZTpcIjBweCBzb2xpZCAjMDAwXCIscGFyc2VyOmZ1bmN0aW9uKGEsYixjLGQsZixnKXtyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgoYS5zdHlsZSx0aGlzLmZvcm1hdChYKGEsXCJib3JkZXJUb3BXaWR0aFwiLGUsITEsXCIwcHhcIikrXCIgXCIrWChhLFwiYm9yZGVyVG9wU3R5bGVcIixlLCExLFwic29saWRcIikrXCIgXCIrWChhLFwiYm9yZGVyVG9wQ29sb3JcIixlLCExLFwiIzAwMFwiKSksdGhpcy5mb3JtYXQoYiksZixnKX0sY29sb3I6ITAsZm9ybWF0dGVyOmZ1bmN0aW9uKGEpe3ZhciBiPWEuc3BsaXQoXCIgXCIpO3JldHVybiBiWzBdK1wiIFwiKyhiWzFdfHxcInNvbGlkXCIpK1wiIFwiKyhhLm1hdGNoKGxhKXx8W1wiIzAwMFwiXSlbMF19fSksdWEoXCJib3JkZXJXaWR0aFwiLHtwYXJzZXI6bmEoXCJib3JkZXJUb3BXaWR0aCxib3JkZXJSaWdodFdpZHRoLGJvcmRlckJvdHRvbVdpZHRoLGJvcmRlckxlZnRXaWR0aFwiKX0pLHVhKFwiZmxvYXQsY3NzRmxvYXQsc3R5bGVGbG9hdFwiLHtwYXJzZXI6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPWEuc3R5bGUsaD1cImNzc0Zsb2F0XCJpbiBnP1wiY3NzRmxvYXRcIjpcInN0eWxlRmxvYXRcIjtyZXR1cm4gbmV3IHBhKGcsaCwwLDAsZSwtMSxjLCExLDAsZ1toXSxiKX19KTt2YXIgT2E9ZnVuY3Rpb24oYSl7dmFyIGIsYz10aGlzLnQsZD1jLmZpbHRlcnx8WCh0aGlzLmRhdGEsXCJmaWx0ZXJcIil8fFwiXCIsZT10aGlzLnMrdGhpcy5jKmF8MDsxMDA9PT1lJiYoLTE9PT1kLmluZGV4T2YoXCJhdHJpeChcIikmJi0xPT09ZC5pbmRleE9mKFwicmFkaWVudChcIikmJi0xPT09ZC5pbmRleE9mKFwib2FkZXIoXCIpPyhjLnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKSxiPSFYKHRoaXMuZGF0YSxcImZpbHRlclwiKSk6KGMuZmlsdGVyPWQucmVwbGFjZSh4LFwiXCIpLGI9ITApKSxifHwodGhpcy54bjEmJihjLmZpbHRlcj1kPWR8fFwiYWxwaGEob3BhY2l0eT1cIitlK1wiKVwiKSwtMT09PWQuaW5kZXhPZihcInBhY2l0eVwiKT8wPT09ZSYmdGhpcy54bjF8fChjLmZpbHRlcj1kK1wiIGFscGhhKG9wYWNpdHk9XCIrZStcIilcIik6Yy5maWx0ZXI9ZC5yZXBsYWNlKHYsXCJvcGFjaXR5PVwiK2UpKX07dWEoXCJvcGFjaXR5LGFscGhhLGF1dG9BbHBoYVwiLHtkZWZhdWx0VmFsdWU6XCIxXCIscGFyc2VyOmZ1bmN0aW9uKGEsYixjLGQsZixnKXt2YXIgaD1wYXJzZUZsb2F0KFgoYSxcIm9wYWNpdHlcIixlLCExLFwiMVwiKSksaT1hLnN0eWxlLGo9XCJhdXRvQWxwaGFcIj09PWM7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGImJlwiPVwiPT09Yi5jaGFyQXQoMSkmJihiPShcIi1cIj09PWIuY2hhckF0KDApPy0xOjEpKnBhcnNlRmxvYXQoYi5zdWJzdHIoMikpK2gpLGomJjE9PT1oJiZcImhpZGRlblwiPT09WChhLFwidmlzaWJpbGl0eVwiLGUpJiYwIT09YiYmKGg9MCksUT9mPW5ldyBwYShpLFwib3BhY2l0eVwiLGgsYi1oLGYpOihmPW5ldyBwYShpLFwib3BhY2l0eVwiLDEwMCpoLDEwMCooYi1oKSxmKSxmLnhuMT1qPzE6MCxpLnpvb209MSxmLnR5cGU9MixmLmI9XCJhbHBoYShvcGFjaXR5PVwiK2YucytcIilcIixmLmU9XCJhbHBoYShvcGFjaXR5PVwiKyhmLnMrZi5jKStcIilcIixmLmRhdGE9YSxmLnBsdWdpbj1nLGYuc2V0UmF0aW89T2EpLGomJihmPW5ldyBwYShpLFwidmlzaWJpbGl0eVwiLDAsMCxmLC0xLG51bGwsITEsMCwwIT09aD9cImluaGVyaXRcIjpcImhpZGRlblwiLDA9PT1iP1wiaGlkZGVuXCI6XCJpbmhlcml0XCIpLGYueHMwPVwiaW5oZXJpdFwiLGQuX292ZXJ3cml0ZVByb3BzLnB1c2goZi5uKSxkLl9vdmVyd3JpdGVQcm9wcy5wdXNoKGMpKSxmfX0pO3ZhciBQYT1mdW5jdGlvbihhLGIpe2ImJihhLnJlbW92ZVByb3BlcnR5PygoXCJtc1wiPT09Yi5zdWJzdHIoMCwyKXx8XCJ3ZWJraXRcIj09PWIuc3Vic3RyKDAsNikpJiYoYj1cIi1cIitiKSxhLnJlbW92ZVByb3BlcnR5KGIucmVwbGFjZSh6LFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpKTphLnJlbW92ZUF0dHJpYnV0ZShiKSl9LFFhPWZ1bmN0aW9uKGEpe2lmKHRoaXMudC5fZ3NDbGFzc1BUPXRoaXMsMT09PWF8fDA9PT1hKXt0aGlzLnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwwPT09YT90aGlzLmI6dGhpcy5lKTtmb3IodmFyIGI9dGhpcy5kYXRhLGM9dGhpcy50LnN0eWxlO2I7KWIudj9jW2IucF09Yi52OlBhKGMsYi5wKSxiPWIuX25leHQ7MT09PWEmJnRoaXMudC5fZ3NDbGFzc1BUPT09dGhpcyYmKHRoaXMudC5fZ3NDbGFzc1BUPW51bGwpfWVsc2UgdGhpcy50LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIT09dGhpcy5lJiZ0aGlzLnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIix0aGlzLmUpfTt1YShcImNsYXNzTmFtZVwiLHtwYXJzZXI6ZnVuY3Rpb24oYSxiLGQsZixnLGgsaSl7dmFyIGosayxsLG0sbixvPWEuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIscD1hLnN0eWxlLmNzc1RleHQ7aWYoZz1mLl9jbGFzc05hbWVQVD1uZXcgcGEoYSxkLDAsMCxnLDIpLGcuc2V0UmF0aW89UWEsZy5wcj0tMTEsYz0hMCxnLmI9byxrPSQoYSxlKSxsPWEuX2dzQ2xhc3NQVCl7Zm9yKG09e30sbj1sLmRhdGE7bjspbVtuLnBdPTEsbj1uLl9uZXh0O2wuc2V0UmF0aW8oMSl9cmV0dXJuIGEuX2dzQ2xhc3NQVD1nLGcuZT1cIj1cIiE9PWIuY2hhckF0KDEpP2I6by5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxccypcXFxcYlwiK2Iuc3Vic3RyKDIpK1wiXFxcXGJcIiksXCJcIikrKFwiK1wiPT09Yi5jaGFyQXQoMCk/XCIgXCIrYi5zdWJzdHIoMik6XCJcIiksYS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGcuZSksaj1fKGEsaywkKGEpLGksbSksYS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLG8pLGcuZGF0YT1qLmZpcnN0TVBULGEuc3R5bGUuY3NzVGV4dD1wLGc9Zy54Zmlyc3Q9Zi5wYXJzZShhLGouZGlmcyxnLGgpfX0pO3ZhciBSYT1mdW5jdGlvbihhKXtpZigoMT09PWF8fDA9PT1hKSYmdGhpcy5kYXRhLl90b3RhbFRpbWU9PT10aGlzLmRhdGEuX3RvdGFsRHVyYXRpb24mJlwiaXNGcm9tU3RhcnRcIiE9PXRoaXMuZGF0YS5kYXRhKXt2YXIgYixjLGQsZSxmLGc9dGhpcy50LnN0eWxlLGg9aS50cmFuc2Zvcm0ucGFyc2U7aWYoXCJhbGxcIj09PXRoaXMuZSlnLmNzc1RleHQ9XCJcIixlPSEwO2Vsc2UgZm9yKGI9dGhpcy5lLnNwbGl0KFwiIFwiKS5qb2luKFwiXCIpLnNwbGl0KFwiLFwiKSxkPWIubGVuZ3RoOy0tZD4tMTspYz1iW2RdLGlbY10mJihpW2NdLnBhcnNlPT09aD9lPSEwOmM9XCJ0cmFuc2Zvcm1PcmlnaW5cIj09PWM/QWE6aVtjXS5wKSxQYShnLGMpO2UmJihQYShnLHlhKSxmPXRoaXMudC5fZ3NUcmFuc2Zvcm0sZiYmKGYuc3ZnJiYodGhpcy50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKSx0aGlzLnQucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpKSxkZWxldGUgdGhpcy50Ll9nc1RyYW5zZm9ybSkpfX07Zm9yKHVhKFwiY2xlYXJQcm9wc1wiLHtwYXJzZXI6ZnVuY3Rpb24oYSxiLGQsZSxmKXtyZXR1cm4gZj1uZXcgcGEoYSxkLDAsMCxmLDIpLGYuc2V0UmF0aW89UmEsZi5lPWIsZi5wcj0tMTAsZi5kYXRhPWUuX3R3ZWVuLGM9ITAsZn19KSxqPVwiYmV6aWVyLHRocm93UHJvcHMscGh5c2ljc1Byb3BzLHBoeXNpY3MyRFwiLnNwbGl0KFwiLFwiKSxzYT1qLmxlbmd0aDtzYS0tOyl2YShqW3NhXSk7aj1nLnByb3RvdHlwZSxqLl9maXJzdFBUPWouX2xhc3RQYXJzZWRUcmFuc2Zvcm09ai5fdHJhbnNmb3JtPW51bGwsai5fb25Jbml0VHdlZW49ZnVuY3Rpb24oYSxiLGgpe2lmKCFhLm5vZGVUeXBlKXJldHVybiExO3RoaXMuX3RhcmdldD1hLHRoaXMuX3R3ZWVuPWgsdGhpcy5fdmFycz1iLGs9Yi5hdXRvUm91bmQsYz0hMSxkPWIuc3VmZml4TWFwfHxnLnN1ZmZpeE1hcCxlPVcoYSxcIlwiKSxmPXRoaXMuX292ZXJ3cml0ZVByb3BzO3ZhciBqLG4scCxxLHIscyx0LHUsdix4PWEuc3R5bGU7aWYobCYmXCJcIj09PXguekluZGV4JiYoaj1YKGEsXCJ6SW5kZXhcIixlKSwoXCJhdXRvXCI9PT1qfHxcIlwiPT09aikmJnRoaXMuX2FkZExhenlTZXQoeCxcInpJbmRleFwiLDApKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmKHE9eC5jc3NUZXh0LGo9JChhLGUpLHguY3NzVGV4dD1xK1wiO1wiK2Isaj1fKGEsaiwkKGEpKS5kaWZzLCFRJiZ3LnRlc3QoYikmJihqLm9wYWNpdHk9cGFyc2VGbG9hdChSZWdFeHAuJDEpKSxiPWoseC5jc3NUZXh0PXEpLGIuY2xhc3NOYW1lP3RoaXMuX2ZpcnN0UFQ9bj1pLmNsYXNzTmFtZS5wYXJzZShhLGIuY2xhc3NOYW1lLFwiY2xhc3NOYW1lXCIsdGhpcyxudWxsLG51bGwsYik6dGhpcy5fZmlyc3RQVD1uPXRoaXMucGFyc2UoYSxiLG51bGwpLHRoaXMuX3RyYW5zZm9ybVR5cGUpe2Zvcih2PTM9PT10aGlzLl90cmFuc2Zvcm1UeXBlLHlhP20mJihsPSEwLFwiXCI9PT14LnpJbmRleCYmKHQ9WChhLFwiekluZGV4XCIsZSksKFwiYXV0b1wiPT09dHx8XCJcIj09PXQpJiZ0aGlzLl9hZGRMYXp5U2V0KHgsXCJ6SW5kZXhcIiwwKSksbyYmdGhpcy5fYWRkTGF6eVNldCh4LFwiV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5XCIsdGhpcy5fdmFycy5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHl8fCh2P1widmlzaWJsZVwiOlwiaGlkZGVuXCIpKSk6eC56b29tPTEscD1uO3AmJnAuX25leHQ7KXA9cC5fbmV4dDt1PW5ldyBwYShhLFwidHJhbnNmb3JtXCIsMCwwLG51bGwsMiksdGhpcy5fbGlua0NTU1AodSxudWxsLHApLHUuc2V0UmF0aW89eWE/TmE6TWEsdS5kYXRhPXRoaXMuX3RyYW5zZm9ybXx8TGEoYSxlLCEwKSx1LnR3ZWVuPWgsdS5wcj0tMSxmLnBvcCgpfWlmKGMpe2Zvcig7bjspe2ZvcihzPW4uX25leHQscD1xO3AmJnAucHI+bi5wcjspcD1wLl9uZXh0OyhuLl9wcmV2PXA/cC5fcHJldjpyKT9uLl9wcmV2Ll9uZXh0PW46cT1uLChuLl9uZXh0PXApP3AuX3ByZXY9bjpyPW4sbj1zfXRoaXMuX2ZpcnN0UFQ9cX1yZXR1cm4hMH0sai5wYXJzZT1mdW5jdGlvbihhLGIsYyxmKXt2YXIgZyxoLGosbCxtLG4sbyxwLHEscixzPWEuc3R5bGU7Zm9yKGcgaW4gYiluPWJbZ10saD1pW2ddLGg/Yz1oLnBhcnNlKGEsbixnLHRoaXMsYyxmLGIpOihtPVgoYSxnLGUpK1wiXCIscT1cInN0cmluZ1wiPT10eXBlb2YgbixcImNvbG9yXCI9PT1nfHxcImZpbGxcIj09PWd8fFwic3Ryb2tlXCI9PT1nfHwtMSE9PWcuaW5kZXhPZihcIkNvbG9yXCIpfHxxJiZ5LnRlc3Qobik/KHF8fChuPWphKG4pLG49KG4ubGVuZ3RoPjM/XCJyZ2JhKFwiOlwicmdiKFwiKStuLmpvaW4oXCIsXCIpK1wiKVwiKSxjPXJhKHMsZyxtLG4sITAsXCJ0cmFuc3BhcmVudFwiLGMsMCxmKSk6IXF8fC0xPT09bi5pbmRleE9mKFwiIFwiKSYmLTE9PT1uLmluZGV4T2YoXCIsXCIpPyhqPXBhcnNlRmxvYXQobSksbz1qfHwwPT09aj9tLnN1YnN0cigoaitcIlwiKS5sZW5ndGgpOlwiXCIsKFwiXCI9PT1tfHxcImF1dG9cIj09PW0pJiYoXCJ3aWR0aFwiPT09Z3x8XCJoZWlnaHRcIj09PWc/KGo9Y2EoYSxnLGUpLG89XCJweFwiKTpcImxlZnRcIj09PWd8fFwidG9wXCI9PT1nPyhqPVooYSxnLGUpLG89XCJweFwiKTooaj1cIm9wYWNpdHlcIiE9PWc/MDoxLG89XCJcIikpLHI9cSYmXCI9XCI9PT1uLmNoYXJBdCgxKSxyPyhsPXBhcnNlSW50KG4uY2hhckF0KDApK1wiMVwiLDEwKSxuPW4uc3Vic3RyKDIpLGwqPXBhcnNlRmxvYXQobikscD1uLnJlcGxhY2UodSxcIlwiKSk6KGw9cGFyc2VGbG9hdChuKSxwPXE/bi5yZXBsYWNlKHUsXCJcIik6XCJcIiksXCJcIj09PXAmJihwPWcgaW4gZD9kW2ddOm8pLG49bHx8MD09PWw/KHI/bCtqOmwpK3A6YltnXSxvIT09cCYmXCJcIiE9PXAmJihsfHwwPT09bCkmJmomJihqPVkoYSxnLGosbyksXCIlXCI9PT1wPyhqLz1ZKGEsZywxMDAsXCIlXCIpLzEwMCxiLnN0cmljdFVuaXRzIT09ITAmJihtPWorXCIlXCIpKTpcImVtXCI9PT1wfHxcInJlbVwiPT09cHx8XCJ2d1wiPT09cHx8XCJ2aFwiPT09cD9qLz1ZKGEsZywxLHApOlwicHhcIiE9PXAmJihsPVkoYSxnLGwscCkscD1cInB4XCIpLHImJihsfHwwPT09bCkmJihuPWwraitwKSksciYmKGwrPWopLCFqJiYwIT09anx8IWwmJjAhPT1sP3ZvaWQgMCE9PXNbZ10mJihufHxuK1wiXCIhPVwiTmFOXCImJm51bGwhPW4pPyhjPW5ldyBwYShzLGcsbHx8anx8MCwwLGMsLTEsZywhMSwwLG0sbiksYy54czA9XCJub25lXCIhPT1ufHxcImRpc3BsYXlcIiE9PWcmJi0xPT09Zy5pbmRleE9mKFwiU3R5bGVcIik/bjptKTpTKFwiaW52YWxpZCBcIitnK1wiIHR3ZWVuIHZhbHVlOiBcIitiW2ddKTooYz1uZXcgcGEocyxnLGosbC1qLGMsMCxnLGshPT0hMSYmKFwicHhcIj09PXB8fFwiekluZGV4XCI9PT1nKSwwLG0sbiksYy54czA9cCkpOmM9cmEocyxnLG0sbiwhMCxudWxsLGMsMCxmKSksZiYmYyYmIWMucGx1Z2luJiYoYy5wbHVnaW49Zik7cmV0dXJuIGN9LGouc2V0UmF0aW89ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGU9dGhpcy5fZmlyc3RQVCxmPTFlLTY7aWYoMSE9PWF8fHRoaXMuX3R3ZWVuLl90aW1lIT09dGhpcy5fdHdlZW4uX2R1cmF0aW9uJiYwIT09dGhpcy5fdHdlZW4uX3RpbWUpaWYoYXx8dGhpcy5fdHdlZW4uX3RpbWUhPT10aGlzLl90d2Vlbi5fZHVyYXRpb24mJjAhPT10aGlzLl90d2Vlbi5fdGltZXx8dGhpcy5fdHdlZW4uX3Jhd1ByZXZUaW1lPT09LTFlLTYpZm9yKDtlOyl7aWYoYj1lLmMqYStlLnMsZS5yP2I9TWF0aC5yb3VuZChiKTpmPmImJmI+LWYmJihiPTApLGUudHlwZSlpZigxPT09ZS50eXBlKWlmKGQ9ZS5sLDI9PT1kKWUudFtlLnBdPWUueHMwK2IrZS54czErZS54bjErZS54czI7ZWxzZSBpZigzPT09ZCllLnRbZS5wXT1lLnhzMCtiK2UueHMxK2UueG4xK2UueHMyK2UueG4yK2UueHMzO2Vsc2UgaWYoND09PWQpZS50W2UucF09ZS54czArYitlLnhzMStlLnhuMStlLnhzMitlLnhuMitlLnhzMytlLnhuMytlLnhzNDtlbHNlIGlmKDU9PT1kKWUudFtlLnBdPWUueHMwK2IrZS54czErZS54bjErZS54czIrZS54bjIrZS54czMrZS54bjMrZS54czQrZS54bjQrZS54czU7ZWxzZXtmb3IoYz1lLnhzMCtiK2UueHMxLGQ9MTtkPGUubDtkKyspYys9ZVtcInhuXCIrZF0rZVtcInhzXCIrKGQrMSldO2UudFtlLnBdPWN9ZWxzZS0xPT09ZS50eXBlP2UudFtlLnBdPWUueHMwOmUuc2V0UmF0aW8mJmUuc2V0UmF0aW8oYSk7ZWxzZSBlLnRbZS5wXT1iK2UueHMwO2U9ZS5fbmV4dH1lbHNlIGZvcig7ZTspMiE9PWUudHlwZT9lLnRbZS5wXT1lLmI6ZS5zZXRSYXRpbyhhKSxlPWUuX25leHQ7ZWxzZSBmb3IoO2U7KXtpZigyIT09ZS50eXBlKWlmKGUuciYmLTEhPT1lLnR5cGUpaWYoYj1NYXRoLnJvdW5kKGUucytlLmMpLGUudHlwZSl7aWYoMT09PWUudHlwZSl7Zm9yKGQ9ZS5sLGM9ZS54czArYitlLnhzMSxkPTE7ZDxlLmw7ZCsrKWMrPWVbXCJ4blwiK2RdK2VbXCJ4c1wiKyhkKzEpXTtlLnRbZS5wXT1jfX1lbHNlIGUudFtlLnBdPWIrZS54czA7ZWxzZSBlLnRbZS5wXT1lLmU7ZWxzZSBlLnNldFJhdGlvKGEpO2U9ZS5fbmV4dH19LGouX2VuYWJsZVRyYW5zZm9ybXM9ZnVuY3Rpb24oYSl7dGhpcy5fdHJhbnNmb3JtPXRoaXMuX3RyYW5zZm9ybXx8TGEodGhpcy5fdGFyZ2V0LGUsITApLHRoaXMuX3RyYW5zZm9ybVR5cGU9dGhpcy5fdHJhbnNmb3JtLnN2ZyYmd2F8fCFhJiYzIT09dGhpcy5fdHJhbnNmb3JtVHlwZT8yOjN9O3ZhciBTYT1mdW5jdGlvbihhKXt0aGlzLnRbdGhpcy5wXT10aGlzLmUsdGhpcy5kYXRhLl9saW5rQ1NTUCh0aGlzLHRoaXMuX25leHQsbnVsbCwhMCl9O2ouX2FkZExhenlTZXQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuX2ZpcnN0UFQ9bmV3IHBhKGEsYiwwLDAsdGhpcy5fZmlyc3RQVCwyKTtkLmU9YyxkLnNldFJhdGlvPVNhLGQuZGF0YT10aGlzfSxqLl9saW5rQ1NTUD1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gYSYmKGImJihiLl9wcmV2PWEpLGEuX25leHQmJihhLl9uZXh0Ll9wcmV2PWEuX3ByZXYpLGEuX3ByZXY/YS5fcHJldi5fbmV4dD1hLl9uZXh0OnRoaXMuX2ZpcnN0UFQ9PT1hJiYodGhpcy5fZmlyc3RQVD1hLl9uZXh0LGQ9ITApLGM/Yy5fbmV4dD1hOmR8fG51bGwhPT10aGlzLl9maXJzdFBUfHwodGhpcy5fZmlyc3RQVD1hKSxhLl9uZXh0PWIsYS5fcHJldj1jKSxhfSxqLl9raWxsPWZ1bmN0aW9uKGIpe3ZhciBjLGQsZSxmPWI7aWYoYi5hdXRvQWxwaGF8fGIuYWxwaGEpe2Y9e307Zm9yKGQgaW4gYilmW2RdPWJbZF07Zi5vcGFjaXR5PTEsZi5hdXRvQWxwaGEmJihmLnZpc2liaWxpdHk9MSl9cmV0dXJuIGIuY2xhc3NOYW1lJiYoYz10aGlzLl9jbGFzc05hbWVQVCkmJihlPWMueGZpcnN0LGUmJmUuX3ByZXY/dGhpcy5fbGlua0NTU1AoZS5fcHJldixjLl9uZXh0LGUuX3ByZXYuX3ByZXYpOmU9PT10aGlzLl9maXJzdFBUJiYodGhpcy5fZmlyc3RQVD1jLl9uZXh0KSxjLl9uZXh0JiZ0aGlzLl9saW5rQ1NTUChjLl9uZXh0LGMuX25leHQuX25leHQsZS5fcHJldiksdGhpcy5fY2xhc3NOYW1lUFQ9bnVsbCksYS5wcm90b3R5cGUuX2tpbGwuY2FsbCh0aGlzLGYpfTt2YXIgVGE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnO2lmKGEuc2xpY2UpZm9yKGU9YS5sZW5ndGg7LS1lPi0xOylUYShhW2VdLGIsYyk7ZWxzZSBmb3IoZD1hLmNoaWxkTm9kZXMsZT1kLmxlbmd0aDstLWU+LTE7KWY9ZFtlXSxnPWYudHlwZSxmLnN0eWxlJiYoYi5wdXNoKCQoZikpLGMmJmMucHVzaChmKSksMSE9PWcmJjkhPT1nJiYxMSE9PWd8fCFmLmNoaWxkTm9kZXMubGVuZ3RofHxUYShmLGIsYyl9O3JldHVybiBnLmNhc2NhZGVUbz1mdW5jdGlvbihhLGMsZCl7dmFyIGUsZixnLGgsaT1iLnRvKGEsYyxkKSxqPVtpXSxrPVtdLGw9W10sbT1bXSxuPWIuX2ludGVybmFscy5yZXNlcnZlZFByb3BzO2ZvcihhPWkuX3RhcmdldHN8fGkudGFyZ2V0LFRhKGEsayxtKSxpLnJlbmRlcihjLCEwLCEwKSxUYShhLGwpLGkucmVuZGVyKDAsITAsITApLGkuX2VuYWJsZWQoITApLGU9bS5sZW5ndGg7LS1lPi0xOylpZihmPV8obVtlXSxrW2VdLGxbZV0pLGYuZmlyc3RNUFQpe2Y9Zi5kaWZzO2ZvcihnIGluIGQpbltnXSYmKGZbZ109ZFtnXSk7aD17fTtmb3IoZyBpbiBmKWhbZ109a1tlXVtnXTtqLnB1c2goYi5mcm9tVG8obVtlXSxjLGgsZikpfXJldHVybiBqfSxhLmFjdGl2YXRlKFtnXSksZ30sITApLGZ1bmN0aW9uKCl7dmFyIGE9X2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7cHJvcE5hbWU6XCJyb3VuZFByb3BzXCIsdmVyc2lvbjpcIjEuNVwiLHByaW9yaXR5Oi0xLEFQSToyLGluaXQ6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLl90d2Vlbj1jLCEwfX0pLGI9ZnVuY3Rpb24oYSl7Zm9yKDthOylhLmZ8fGEuYmxvYnx8KGEucj0xKSxhPWEuX25leHR9LGM9YS5wcm90b3R5cGU7Yy5fb25Jbml0QWxsUHJvcHM9ZnVuY3Rpb24oKXtmb3IodmFyIGEsYyxkLGU9dGhpcy5fdHdlZW4sZj1lLnZhcnMucm91bmRQcm9wcy5qb2luP2UudmFycy5yb3VuZFByb3BzOmUudmFycy5yb3VuZFByb3BzLnNwbGl0KFwiLFwiKSxnPWYubGVuZ3RoLGg9e30saT1lLl9wcm9wTG9va3VwLnJvdW5kUHJvcHM7LS1nPi0xOyloW2ZbZ11dPTE7Zm9yKGc9Zi5sZW5ndGg7LS1nPi0xOylmb3IoYT1mW2ddLGM9ZS5fZmlyc3RQVDtjOylkPWMuX25leHQsYy5wZz9jLnQuX3JvdW5kUHJvcHMoaCwhMCk6Yy5uPT09YSYmKDI9PT1jLmYmJmMudD9iKGMudC5fZmlyc3RQVCk6KHRoaXMuX2FkZChjLnQsYSxjLnMsYy5jKSxkJiYoZC5fcHJldj1jLl9wcmV2KSxjLl9wcmV2P2MuX3ByZXYuX25leHQ9ZDplLl9maXJzdFBUPT09YyYmKGUuX2ZpcnN0UFQ9ZCksYy5fbmV4dD1jLl9wcmV2PW51bGwsZS5fcHJvcExvb2t1cFthXT1pKSksYz1kO3JldHVybiExfSxjLl9hZGQ9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5fYWRkVHdlZW4oYSxiLGMsYytkLGIsITApLHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2goYil9fSgpLGZ1bmN0aW9uKCl7X2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7cHJvcE5hbWU6XCJhdHRyXCIsQVBJOjIsdmVyc2lvbjpcIjAuNS4wXCIsaW5pdDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgYS5zZXRBdHRyaWJ1dGUpcmV0dXJuITE7Zm9yKGQgaW4gYil0aGlzLl9hZGRUd2VlbihhLFwic2V0QXR0cmlidXRlXCIsYS5nZXRBdHRyaWJ1dGUoZCkrXCJcIixiW2RdK1wiXCIsZCwhMSxkKSx0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKGQpO3JldHVybiEwfX0pfSgpLF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe3Byb3BOYW1lOlwiZGlyZWN0aW9uYWxSb3RhdGlvblwiLHZlcnNpb246XCIwLjIuMVwiLEFQSToyLGluaXQ6ZnVuY3Rpb24oYSxiLGMpe1wib2JqZWN0XCIhPXR5cGVvZiBiJiYoYj17cm90YXRpb246Yn0pLHRoaXMuZmluYWxzPXt9O3ZhciBkLGUsZixnLGgsaSxqPWIudXNlUmFkaWFucz09PSEwPzIqTWF0aC5QSTozNjAsaz0xZS02O2ZvcihkIGluIGIpXCJ1c2VSYWRpYW5zXCIhPT1kJiYoaT0oYltkXStcIlwiKS5zcGxpdChcIl9cIiksZT1pWzBdLGY9cGFyc2VGbG9hdChcImZ1bmN0aW9uXCIhPXR5cGVvZiBhW2RdP2FbZF06YVtkLmluZGV4T2YoXCJzZXRcIil8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGFbXCJnZXRcIitkLnN1YnN0cigzKV0/ZDpcImdldFwiK2Quc3Vic3RyKDMpXSgpKSxnPXRoaXMuZmluYWxzW2RdPVwic3RyaW5nXCI9PXR5cGVvZiBlJiZcIj1cIj09PWUuY2hhckF0KDEpP2YrcGFyc2VJbnQoZS5jaGFyQXQoMCkrXCIxXCIsMTApKk51bWJlcihlLnN1YnN0cigyKSk6TnVtYmVyKGUpfHwwLGg9Zy1mLGkubGVuZ3RoJiYoZT1pLmpvaW4oXCJfXCIpLC0xIT09ZS5pbmRleE9mKFwic2hvcnRcIikmJihoJT1qLGghPT1oJShqLzIpJiYoaD0wPmg/aCtqOmgtaikpLC0xIT09ZS5pbmRleE9mKFwiX2N3XCIpJiYwPmg/aD0oaCs5OTk5OTk5OTk5KmopJWotKGgvanwwKSpqOi0xIT09ZS5pbmRleE9mKFwiY2N3XCIpJiZoPjAmJihoPShoLTk5OTk5OTk5OTkqaiklai0oaC9qfDApKmopKSwoaD5rfHwtaz5oKSYmKHRoaXMuX2FkZFR3ZWVuKGEsZCxmLGYraCxkKSx0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKGQpKSk7cmV0dXJuITB9LHNldDpmdW5jdGlvbihhKXt2YXIgYjtpZigxIT09YSl0aGlzLl9zdXBlci5zZXRSYXRpby5jYWxsKHRoaXMsYSk7ZWxzZSBmb3IoYj10aGlzLl9maXJzdFBUO2I7KWIuZj9iLnRbYi5wXSh0aGlzLmZpbmFsc1tiLnBdKTpiLnRbYi5wXT10aGlzLmZpbmFsc1tiLnBdLGI9Yi5fbmV4dH19KS5fYXV0b0NTUz0hMCxfZ3NTY29wZS5fZ3NEZWZpbmUoXCJlYXNpbmcuQmFja1wiLFtcImVhc2luZy5FYXNlXCJdLGZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPV9nc1Njb3BlLkdyZWVuU29ja0dsb2JhbHN8fF9nc1Njb3BlLGY9ZS5jb20uZ3JlZW5zb2NrLGc9MipNYXRoLlBJLGg9TWF0aC5QSS8yLGk9Zi5fY2xhc3Msaj1mdW5jdGlvbihiLGMpe3ZhciBkPWkoXCJlYXNpbmcuXCIrYixmdW5jdGlvbigpe30sITApLGU9ZC5wcm90b3R5cGU9bmV3IGE7cmV0dXJuIGUuY29uc3RydWN0b3I9ZCxlLmdldFJhdGlvPWMsZH0saz1hLnJlZ2lzdGVyfHxmdW5jdGlvbigpe30sbD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWkoXCJlYXNpbmcuXCIrYSx7ZWFzZU91dDpuZXcgYixlYXNlSW46bmV3IGMsZWFzZUluT3V0Om5ldyBkfSwhMCk7cmV0dXJuIGsoZixhKSxmfSxtPWZ1bmN0aW9uKGEsYixjKXt0aGlzLnQ9YSx0aGlzLnY9YixjJiYodGhpcy5uZXh0PWMsYy5wcmV2PXRoaXMsdGhpcy5jPWMudi1iLHRoaXMuZ2FwPWMudC1hKX0sbj1mdW5jdGlvbihiLGMpe3ZhciBkPWkoXCJlYXNpbmcuXCIrYixmdW5jdGlvbihhKXt0aGlzLl9wMT1hfHwwPT09YT9hOjEuNzAxNTgsdGhpcy5fcDI9MS41MjUqdGhpcy5fcDF9LCEwKSxlPWQucHJvdG90eXBlPW5ldyBhO3JldHVybiBlLmNvbnN0cnVjdG9yPWQsZS5nZXRSYXRpbz1jLGUuY29uZmlnPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgZChhKX0sZH0sbz1sKFwiQmFja1wiLG4oXCJCYWNrT3V0XCIsZnVuY3Rpb24oYSl7cmV0dXJuKGEtPTEpKmEqKCh0aGlzLl9wMSsxKSphK3RoaXMuX3AxKSsxfSksbihcIkJhY2tJblwiLGZ1bmN0aW9uKGEpe3JldHVybiBhKmEqKCh0aGlzLl9wMSsxKSphLXRoaXMuX3AxKX0pLG4oXCJCYWNrSW5PdXRcIixmdW5jdGlvbihhKXtyZXR1cm4oYSo9Mik8MT8uNSphKmEqKCh0aGlzLl9wMisxKSphLXRoaXMuX3AyKTouNSooKGEtPTIpKmEqKCh0aGlzLl9wMisxKSphK3RoaXMuX3AyKSsyKX0pKSxwPWkoXCJlYXNpbmcuU2xvd01vXCIsZnVuY3Rpb24oYSxiLGMpe2I9Ynx8MD09PWI/YjouNyxudWxsPT1hP2E9Ljc6YT4xJiYoYT0xKSx0aGlzLl9wPTEhPT1hP2I6MCx0aGlzLl9wMT0oMS1hKS8yLHRoaXMuX3AyPWEsdGhpcy5fcDM9dGhpcy5fcDErdGhpcy5fcDIsdGhpcy5fY2FsY0VuZD1jPT09ITB9LCEwKSxxPXAucHJvdG90eXBlPW5ldyBhO3JldHVybiBxLmNvbnN0cnVjdG9yPXAscS5nZXRSYXRpbz1mdW5jdGlvbihhKXt2YXIgYj1hKyguNS1hKSp0aGlzLl9wO3JldHVybiBhPHRoaXMuX3AxP3RoaXMuX2NhbGNFbmQ/MS0oYT0xLWEvdGhpcy5fcDEpKmE6Yi0oYT0xLWEvdGhpcy5fcDEpKmEqYSphKmI6YT50aGlzLl9wMz90aGlzLl9jYWxjRW5kPzEtKGE9KGEtdGhpcy5fcDMpL3RoaXMuX3AxKSphOmIrKGEtYikqKGE9KGEtdGhpcy5fcDMpL3RoaXMuX3AxKSphKmEqYTp0aGlzLl9jYWxjRW5kPzE6Yn0scC5lYXNlPW5ldyBwKC43LC43KSxxLmNvbmZpZz1wLmNvbmZpZz1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG5ldyBwKGEsYixjKX0sYj1pKFwiZWFzaW5nLlN0ZXBwZWRFYXNlXCIsZnVuY3Rpb24oYSl7YT1hfHwxLHRoaXMuX3AxPTEvYSx0aGlzLl9wMj1hKzF9LCEwKSxxPWIucHJvdG90eXBlPW5ldyBhLHEuY29uc3RydWN0b3I9YixxLmdldFJhdGlvPWZ1bmN0aW9uKGEpe3JldHVybiAwPmE/YT0wOmE+PTEmJihhPS45OTk5OTk5OTkpLCh0aGlzLl9wMiphPj4wKSp0aGlzLl9wMX0scS5jb25maWc9Yi5jb25maWc9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBiKGEpfSxjPWkoXCJlYXNpbmcuUm91Z2hFYXNlXCIsZnVuY3Rpb24oYil7Yj1ifHx7fTtmb3IodmFyIGMsZCxlLGYsZyxoLGk9Yi50YXBlcnx8XCJub25lXCIsaj1bXSxrPTAsbD0wfChiLnBvaW50c3x8MjApLG49bCxvPWIucmFuZG9taXplIT09ITEscD1iLmNsYW1wPT09ITAscT1iLnRlbXBsYXRlIGluc3RhbmNlb2YgYT9iLnRlbXBsYXRlOm51bGwscj1cIm51bWJlclwiPT10eXBlb2YgYi5zdHJlbmd0aD8uNCpiLnN0cmVuZ3RoOi40Oy0tbj4tMTspYz1vP01hdGgucmFuZG9tKCk6MS9sKm4sZD1xP3EuZ2V0UmF0aW8oYyk6YyxcIm5vbmVcIj09PWk/ZT1yOlwib3V0XCI9PT1pPyhmPTEtYyxlPWYqZipyKTpcImluXCI9PT1pP2U9YypjKnI6LjU+Yz8oZj0yKmMsZT1mKmYqLjUqcik6KGY9MiooMS1jKSxlPWYqZiouNSpyKSxvP2QrPU1hdGgucmFuZG9tKCkqZS0uNSplOm4lMj9kKz0uNSplOmQtPS41KmUscCYmKGQ+MT9kPTE6MD5kJiYoZD0wKSksaltrKytdPXt4OmMseTpkfTtmb3Ioai5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEueC1iLnh9KSxoPW5ldyBtKDEsMSxudWxsKSxuPWw7LS1uPi0xOylnPWpbbl0saD1uZXcgbShnLngsZy55LGgpO3RoaXMuX3ByZXY9bmV3IG0oMCwwLDAhPT1oLnQ/aDpoLm5leHQpfSwhMCkscT1jLnByb3RvdHlwZT1uZXcgYSxxLmNvbnN0cnVjdG9yPWMscS5nZXRSYXRpbz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9wcmV2O2lmKGE+Yi50KXtmb3IoO2IubmV4dCYmYT49Yi50OyliPWIubmV4dDtiPWIucHJldn1lbHNlIGZvcig7Yi5wcmV2JiZhPD1iLnQ7KWI9Yi5wcmV2O3JldHVybiB0aGlzLl9wcmV2PWIsYi52KyhhLWIudCkvYi5nYXAqYi5jfSxxLmNvbmZpZz1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoYSl9LGMuZWFzZT1uZXcgYyxsKFwiQm91bmNlXCIsaihcIkJvdW5jZU91dFwiLGZ1bmN0aW9uKGEpe3JldHVybiAxLzIuNzU+YT83LjU2MjUqYSphOjIvMi43NT5hPzcuNTYyNSooYS09MS41LzIuNzUpKmErLjc1OjIuNS8yLjc1PmE/Ny41NjI1KihhLT0yLjI1LzIuNzUpKmErLjkzNzU6Ny41NjI1KihhLT0yLjYyNS8yLjc1KSphKy45ODQzNzV9KSxqKFwiQm91bmNlSW5cIixmdW5jdGlvbihhKXtyZXR1cm4oYT0xLWEpPDEvMi43NT8xLTcuNTYyNSphKmE6Mi8yLjc1PmE/MS0oNy41NjI1KihhLT0xLjUvMi43NSkqYSsuNzUpOjIuNS8yLjc1PmE/MS0oNy41NjI1KihhLT0yLjI1LzIuNzUpKmErLjkzNzUpOjEtKDcuNTYyNSooYS09Mi42MjUvMi43NSkqYSsuOTg0Mzc1KX0pLGooXCJCb3VuY2VJbk91dFwiLGZ1bmN0aW9uKGEpe3ZhciBiPS41PmE7cmV0dXJuIGE9Yj8xLTIqYToyKmEtMSxhPTEvMi43NT5hPzcuNTYyNSphKmE6Mi8yLjc1PmE/Ny41NjI1KihhLT0xLjUvMi43NSkqYSsuNzU6Mi41LzIuNzU+YT83LjU2MjUqKGEtPTIuMjUvMi43NSkqYSsuOTM3NTo3LjU2MjUqKGEtPTIuNjI1LzIuNzUpKmErLjk4NDM3NSxiPy41KigxLWEpOi41KmErLjV9KSksbChcIkNpcmNcIixqKFwiQ2lyY091dFwiLGZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnNxcnQoMS0oYS09MSkqYSl9KSxqKFwiQ2lyY0luXCIsZnVuY3Rpb24oYSl7cmV0dXJuLShNYXRoLnNxcnQoMS1hKmEpLTEpfSksaihcIkNpcmNJbk91dFwiLGZ1bmN0aW9uKGEpe3JldHVybihhKj0yKTwxPy0uNSooTWF0aC5zcXJ0KDEtYSphKS0xKTouNSooTWF0aC5zcXJ0KDEtKGEtPTIpKmEpKzEpfSkpLGQ9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWkoXCJlYXNpbmcuXCIrYixmdW5jdGlvbihhLGIpe3RoaXMuX3AxPWE+PTE/YToxLHRoaXMuX3AyPShifHxkKS8oMT5hP2E6MSksdGhpcy5fcDM9dGhpcy5fcDIvZyooTWF0aC5hc2luKDEvdGhpcy5fcDEpfHwwKSx0aGlzLl9wMj1nL3RoaXMuX3AyfSwhMCksZj1lLnByb3RvdHlwZT1uZXcgYTtyZXR1cm4gZi5jb25zdHJ1Y3Rvcj1lLGYuZ2V0UmF0aW89YyxmLmNvbmZpZz1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgZShhLGIpfSxlfSxsKFwiRWxhc3RpY1wiLGQoXCJFbGFzdGljT3V0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX3AxKk1hdGgucG93KDIsLTEwKmEpKk1hdGguc2luKChhLXRoaXMuX3AzKSp0aGlzLl9wMikrMX0sLjMpLGQoXCJFbGFzdGljSW5cIixmdW5jdGlvbihhKXtyZXR1cm4tKHRoaXMuX3AxKk1hdGgucG93KDIsMTAqKGEtPTEpKSpNYXRoLnNpbigoYS10aGlzLl9wMykqdGhpcy5fcDIpKX0sLjMpLGQoXCJFbGFzdGljSW5PdXRcIixmdW5jdGlvbihhKXtyZXR1cm4oYSo9Mik8MT8tLjUqKHRoaXMuX3AxKk1hdGgucG93KDIsMTAqKGEtPTEpKSpNYXRoLnNpbigoYS10aGlzLl9wMykqdGhpcy5fcDIpKTp0aGlzLl9wMSpNYXRoLnBvdygyLC0xMCooYS09MSkpKk1hdGguc2luKChhLXRoaXMuX3AzKSp0aGlzLl9wMikqLjUrMX0sLjQ1KSksbChcIkV4cG9cIixqKFwiRXhwb091dFwiLGZ1bmN0aW9uKGEpe3JldHVybiAxLU1hdGgucG93KDIsLTEwKmEpfSksaihcIkV4cG9JblwiLGZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnBvdygyLDEwKihhLTEpKS0uMDAxfSksaihcIkV4cG9Jbk91dFwiLGZ1bmN0aW9uKGEpe3JldHVybihhKj0yKTwxPy41Kk1hdGgucG93KDIsMTAqKGEtMSkpOi41KigyLU1hdGgucG93KDIsLTEwKihhLTEpKSl9KSksbChcIlNpbmVcIixqKFwiU2luZU91dFwiLGZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnNpbihhKmgpfSksaihcIlNpbmVJblwiLGZ1bmN0aW9uKGEpe3JldHVybi1NYXRoLmNvcyhhKmgpKzF9KSxqKFwiU2luZUluT3V0XCIsZnVuY3Rpb24oYSl7cmV0dXJuLS41KihNYXRoLmNvcyhNYXRoLlBJKmEpLTEpfSkpLGkoXCJlYXNpbmcuRWFzZUxvb2t1cFwiLHtmaW5kOmZ1bmN0aW9uKGIpe3JldHVybiBhLm1hcFtiXX19LCEwKSxrKGUuU2xvd01vLFwiU2xvd01vXCIsXCJlYXNlLFwiKSxrKGMsXCJSb3VnaEVhc2VcIixcImVhc2UsXCIpLGsoYixcIlN0ZXBwZWRFYXNlXCIsXCJlYXNlLFwiKSxvfSwhMCl9KSxfZ3NTY29wZS5fZ3NEZWZpbmUmJl9nc1Njb3BlLl9nc1F1ZXVlLnBvcCgpKCksZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjt2YXIgYz1hLkdyZWVuU29ja0dsb2JhbHM9YS5HcmVlblNvY2tHbG9iYWxzfHxhO2lmKCFjLlR3ZWVuTGl0ZSl7dmFyIGQsZSxmLGcsaCxpPWZ1bmN0aW9uKGEpe3ZhciBiLGQ9YS5zcGxpdChcIi5cIiksZT1jO2ZvcihiPTA7YjxkLmxlbmd0aDtiKyspZVtkW2JdXT1lPWVbZFtiXV18fHt9O3JldHVybiBlfSxqPWkoXCJjb20uZ3JlZW5zb2NrXCIpLGs9MWUtMTAsbD1mdW5jdGlvbihhKXt2YXIgYixjPVtdLGQ9YS5sZW5ndGg7Zm9yKGI9MDtiIT09ZDtjLnB1c2goYVtiKytdKSk7cmV0dXJuIGN9LG09ZnVuY3Rpb24oKXt9LG49ZnVuY3Rpb24oKXt2YXIgYT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLGI9YS5jYWxsKFtdKTtyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIG51bGwhPWMmJihjIGluc3RhbmNlb2YgQXJyYXl8fFwib2JqZWN0XCI9PXR5cGVvZiBjJiYhIWMucHVzaCYmYS5jYWxsKGMpPT09Yil9fSgpLG89e30scD1mdW5jdGlvbihkLGUsZixnKXt0aGlzLnNjPW9bZF0/b1tkXS5zYzpbXSxvW2RdPXRoaXMsdGhpcy5nc0NsYXNzPW51bGwsdGhpcy5mdW5jPWY7dmFyIGg9W107dGhpcy5jaGVjaz1mdW5jdGlvbihqKXtmb3IodmFyIGssbCxtLG4scSxyPWUubGVuZ3RoLHM9cjstLXI+LTE7KShrPW9bZVtyXV18fG5ldyBwKGVbcl0sW10pKS5nc0NsYXNzPyhoW3JdPWsuZ3NDbGFzcyxzLS0pOmomJmsuc2MucHVzaCh0aGlzKTtpZigwPT09cyYmZilmb3IobD0oXCJjb20uZ3JlZW5zb2NrLlwiK2QpLnNwbGl0KFwiLlwiKSxtPWwucG9wKCksbj1pKGwuam9pbihcIi5cIikpW21dPXRoaXMuZ3NDbGFzcz1mLmFwcGx5KGYsaCksZyYmKGNbbV09bixxPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzLCFxJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKChhLkdyZWVuU29ja0FNRFBhdGg/YS5HcmVlblNvY2tBTURQYXRoK1wiL1wiOlwiXCIpK2Quc3BsaXQoXCIuXCIpLnBvcCgpLFtdLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTpkPT09YiYmcSYmKG1vZHVsZS5leHBvcnRzPW4pKSxyPTA7cjx0aGlzLnNjLmxlbmd0aDtyKyspdGhpcy5zY1tyXS5jaGVjaygpfSx0aGlzLmNoZWNrKCEwKX0scT1hLl9nc0RlZmluZT1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gbmV3IHAoYSxiLGMsZCl9LHI9ai5fY2xhc3M9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBiPWJ8fGZ1bmN0aW9uKCl7fSxxKGEsW10sZnVuY3Rpb24oKXtyZXR1cm4gYn0sYyksYn07cS5nbG9iYWxzPWM7dmFyIHM9WzAsMCwxLDFdLHQ9W10sdT1yKFwiZWFzaW5nLkVhc2VcIixmdW5jdGlvbihhLGIsYyxkKXt0aGlzLl9mdW5jPWEsdGhpcy5fdHlwZT1jfHwwLHRoaXMuX3Bvd2VyPWR8fDAsdGhpcy5fcGFyYW1zPWI/cy5jb25jYXQoYik6c30sITApLHY9dS5tYXA9e30sdz11LnJlZ2lzdGVyPWZ1bmN0aW9uKGEsYixjLGQpe2Zvcih2YXIgZSxmLGcsaCxpPWIuc3BsaXQoXCIsXCIpLGs9aS5sZW5ndGgsbD0oY3x8XCJlYXNlSW4sZWFzZU91dCxlYXNlSW5PdXRcIikuc3BsaXQoXCIsXCIpOy0taz4tMTspZm9yKGY9aVtrXSxlPWQ/cihcImVhc2luZy5cIitmLG51bGwsITApOmouZWFzaW5nW2ZdfHx7fSxnPWwubGVuZ3RoOy0tZz4tMTspaD1sW2ddLHZbZitcIi5cIitoXT12W2grZl09ZVtoXT1hLmdldFJhdGlvP2E6YVtoXXx8bmV3IGF9O2ZvcihmPXUucHJvdG90eXBlLGYuX2NhbGNFbmQ9ITEsZi5nZXRSYXRpbz1mdW5jdGlvbihhKXtpZih0aGlzLl9mdW5jKXJldHVybiB0aGlzLl9wYXJhbXNbMF09YSx0aGlzLl9mdW5jLmFwcGx5KG51bGwsdGhpcy5fcGFyYW1zKTt2YXIgYj10aGlzLl90eXBlLGM9dGhpcy5fcG93ZXIsZD0xPT09Yj8xLWE6Mj09PWI/YTouNT5hPzIqYToyKigxLWEpO3JldHVybiAxPT09Yz9kKj1kOjI9PT1jP2QqPWQqZDozPT09Yz9kKj1kKmQqZDo0PT09YyYmKGQqPWQqZCpkKmQpLDE9PT1iPzEtZDoyPT09Yj9kOi41PmE/ZC8yOjEtZC8yfSxkPVtcIkxpbmVhclwiLFwiUXVhZFwiLFwiQ3ViaWNcIixcIlF1YXJ0XCIsXCJRdWludCxTdHJvbmdcIl0sZT1kLmxlbmd0aDstLWU+LTE7KWY9ZFtlXStcIixQb3dlclwiK2UsdyhuZXcgdShudWxsLG51bGwsMSxlKSxmLFwiZWFzZU91dFwiLCEwKSx3KG5ldyB1KG51bGwsbnVsbCwyLGUpLGYsXCJlYXNlSW5cIisoMD09PWU/XCIsZWFzZU5vbmVcIjpcIlwiKSksdyhuZXcgdShudWxsLG51bGwsMyxlKSxmLFwiZWFzZUluT3V0XCIpO3YubGluZWFyPWouZWFzaW5nLkxpbmVhci5lYXNlSW4sdi5zd2luZz1qLmVhc2luZy5RdWFkLmVhc2VJbk91dDt2YXIgeD1yKFwiZXZlbnRzLkV2ZW50RGlzcGF0Y2hlclwiLGZ1bmN0aW9uKGEpe3RoaXMuX2xpc3RlbmVycz17fSx0aGlzLl9ldmVudFRhcmdldD1hfHx0aGlzfSk7Zj14LnByb3RvdHlwZSxmLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oYSxiLGMsZCxlKXtlPWV8fDA7dmFyIGYsaSxqPXRoaXMuX2xpc3RlbmVyc1thXSxrPTA7Zm9yKG51bGw9PWomJih0aGlzLl9saXN0ZW5lcnNbYV09aj1bXSksaT1qLmxlbmd0aDstLWk+LTE7KWY9altpXSxmLmM9PT1iJiZmLnM9PT1jP2ouc3BsaWNlKGksMSk6MD09PWsmJmYucHI8ZSYmKGs9aSsxKTtqLnNwbGljZShrLDAse2M6YixzOmMsdXA6ZCxwcjplfSksdGhpcyE9PWd8fGh8fGcud2FrZSgpfSxmLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPXRoaXMuX2xpc3RlbmVyc1thXTtpZihkKWZvcihjPWQubGVuZ3RoOy0tYz4tMTspaWYoZFtjXS5jPT09YilyZXR1cm4gdm9pZCBkLnNwbGljZShjLDEpfSxmLmRpc3BhdGNoRXZlbnQ9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGU9dGhpcy5fbGlzdGVuZXJzW2FdO2lmKGUpZm9yKGI9ZS5sZW5ndGgsYz10aGlzLl9ldmVudFRhcmdldDstLWI+LTE7KWQ9ZVtiXSxkJiYoZC51cD9kLmMuY2FsbChkLnN8fGMse3R5cGU6YSx0YXJnZXQ6Y30pOmQuYy5jYWxsKGQuc3x8YykpfTt2YXIgeT1hLnJlcXVlc3RBbmltYXRpb25GcmFtZSx6PWEuY2FuY2VsQW5pbWF0aW9uRnJhbWUsQT1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX0sQj1BKCk7Zm9yKGQ9W1wibXNcIixcIm1velwiLFwid2Via2l0XCIsXCJvXCJdLGU9ZC5sZW5ndGg7LS1lPi0xJiYheTspeT1hW2RbZV0rXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl0sej1hW2RbZV0rXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiXXx8YVtkW2VdK1wiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO3IoXCJUaWNrZXJcIixmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmLGksaj10aGlzLGw9QSgpLG49YiE9PSExJiZ5P1wiYXV0b1wiOiExLG89NTAwLHA9MzMscT1cInRpY2tcIixyPWZ1bmN0aW9uKGEpe3ZhciBiLGcsaD1BKCktQjtoPm8mJihsKz1oLXApLEIrPWgsai50aW1lPShCLWwpLzFlMyxiPWoudGltZS1pLCghY3x8Yj4wfHxhPT09ITApJiYoai5mcmFtZSsrLGkrPWIrKGI+PWY/LjAwNDpmLWIpLGc9ITApLGEhPT0hMCYmKGU9ZChyKSksZyYmai5kaXNwYXRjaEV2ZW50KHEpfTt4LmNhbGwoaiksai50aW1lPWouZnJhbWU9MCxqLnRpY2s9ZnVuY3Rpb24oKXtyKCEwKX0sai5sYWdTbW9vdGhpbmc9ZnVuY3Rpb24oYSxiKXtvPWF8fDEvayxwPU1hdGgubWluKGIsbywwKX0sai5zbGVlcD1mdW5jdGlvbigpe251bGwhPWUmJihuJiZ6P3ooZSk6Y2xlYXJUaW1lb3V0KGUpLGQ9bSxlPW51bGwsaj09PWcmJihoPSExKSl9LGoud2FrZT1mdW5jdGlvbihhKXtudWxsIT09ZT9qLnNsZWVwKCk6YT9sKz0tQisoQj1BKCkpOmouZnJhbWU+MTAmJihCPUEoKS1vKzUpLGQ9MD09PWM/bTpuJiZ5P3k6ZnVuY3Rpb24oYSl7cmV0dXJuIHNldFRpbWVvdXQoYSwxZTMqKGktai50aW1lKSsxfDApfSxqPT09ZyYmKGg9ITApLHIoMil9LGouZnBzPWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhjPWEsZj0xLyhjfHw2MCksaT10aGlzLnRpbWUrZix2b2lkIGoud2FrZSgpKTpjfSxqLnVzZVJBRj1mdW5jdGlvbihhKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oai5zbGVlcCgpLG49YSx2b2lkIGouZnBzKGMpKTpufSxqLmZwcyhhKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XCJhdXRvXCI9PT1uJiZqLmZyYW1lPDUmJlwiaGlkZGVuXCIhPT1kb2N1bWVudC52aXNpYmlsaXR5U3RhdGUmJmoudXNlUkFGKCExKX0sMTUwMCl9KSxmPWouVGlja2VyLnByb3RvdHlwZT1uZXcgai5ldmVudHMuRXZlbnREaXNwYXRjaGVyLGYuY29uc3RydWN0b3I9ai5UaWNrZXI7dmFyIEM9cihcImNvcmUuQW5pbWF0aW9uXCIsZnVuY3Rpb24oYSxiKXtpZih0aGlzLnZhcnM9Yj1ifHx7fSx0aGlzLl9kdXJhdGlvbj10aGlzLl90b3RhbER1cmF0aW9uPWF8fDAsdGhpcy5fZGVsYXk9TnVtYmVyKGIuZGVsYXkpfHwwLHRoaXMuX3RpbWVTY2FsZT0xLHRoaXMuX2FjdGl2ZT1iLmltbWVkaWF0ZVJlbmRlcj09PSEwLHRoaXMuZGF0YT1iLmRhdGEsdGhpcy5fcmV2ZXJzZWQ9Yi5yZXZlcnNlZD09PSEwLFYpe2h8fGcud2FrZSgpO3ZhciBjPXRoaXMudmFycy51c2VGcmFtZXM/VTpWO2MuYWRkKHRoaXMsYy5fdGltZSksdGhpcy52YXJzLnBhdXNlZCYmdGhpcy5wYXVzZWQoITApfX0pO2c9Qy50aWNrZXI9bmV3IGouVGlja2VyLGY9Qy5wcm90b3R5cGUsZi5fZGlydHk9Zi5fZ2M9Zi5faW5pdHRlZD1mLl9wYXVzZWQ9ITEsZi5fdG90YWxUaW1lPWYuX3RpbWU9MCxmLl9yYXdQcmV2VGltZT0tMSxmLl9uZXh0PWYuX2xhc3Q9Zi5fb25VcGRhdGU9Zi5fdGltZWxpbmU9Zi50aW1lbGluZT1udWxsLGYuX3BhdXNlZD0hMTt2YXIgRD1mdW5jdGlvbigpe2gmJkEoKS1CPjJlMyYmZy53YWtlKCksc2V0VGltZW91dChELDJlMyl9O0QoKSxmLnBsYXk9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbCE9YSYmdGhpcy5zZWVrKGEsYiksdGhpcy5yZXZlcnNlZCghMSkucGF1c2VkKCExKX0sZi5wYXVzZT1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hJiZ0aGlzLnNlZWsoYSxiKSx0aGlzLnBhdXNlZCghMCl9LGYucmVzdW1lPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPWEmJnRoaXMuc2VlayhhLGIpLHRoaXMucGF1c2VkKCExKX0sZi5zZWVrPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMudG90YWxUaW1lKE51bWJlcihhKSxiIT09ITEpfSxmLnJlc3RhcnQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5yZXZlcnNlZCghMSkucGF1c2VkKCExKS50b3RhbFRpbWUoYT8tdGhpcy5fZGVsYXk6MCxiIT09ITEsITApfSxmLnJldmVyc2U9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbCE9YSYmdGhpcy5zZWVrKGF8fHRoaXMudG90YWxEdXJhdGlvbigpLGIpLHRoaXMucmV2ZXJzZWQoITApLnBhdXNlZCghMSl9LGYucmVuZGVyPWZ1bmN0aW9uKGEsYixjKXt9LGYuaW52YWxpZGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90aW1lPXRoaXMuX3RvdGFsVGltZT0wLHRoaXMuX2luaXR0ZWQ9dGhpcy5fZ2M9ITEsdGhpcy5fcmF3UHJldlRpbWU9LTEsKHRoaXMuX2djfHwhdGhpcy50aW1lbGluZSkmJnRoaXMuX2VuYWJsZWQoITApLHRoaXN9LGYuaXNBY3RpdmU9ZnVuY3Rpb24oKXt2YXIgYSxiPXRoaXMuX3RpbWVsaW5lLGM9dGhpcy5fc3RhcnRUaW1lO3JldHVybiFifHwhdGhpcy5fZ2MmJiF0aGlzLl9wYXVzZWQmJmIuaXNBY3RpdmUoKSYmKGE9Yi5yYXdUaW1lKCkpPj1jJiZhPGMrdGhpcy50b3RhbER1cmF0aW9uKCkvdGhpcy5fdGltZVNjYWxlfSxmLl9lbmFibGVkPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGh8fGcud2FrZSgpLHRoaXMuX2djPSFhLHRoaXMuX2FjdGl2ZT10aGlzLmlzQWN0aXZlKCksYiE9PSEwJiYoYSYmIXRoaXMudGltZWxpbmU/dGhpcy5fdGltZWxpbmUuYWRkKHRoaXMsdGhpcy5fc3RhcnRUaW1lLXRoaXMuX2RlbGF5KTohYSYmdGhpcy50aW1lbGluZSYmdGhpcy5fdGltZWxpbmUuX3JlbW92ZSh0aGlzLCEwKSksITF9LGYuX2tpbGw9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fZW5hYmxlZCghMSwhMSl9LGYua2lsbD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9raWxsKGEsYiksdGhpc30sZi5fdW5jYWNoZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9YT90aGlzOnRoaXMudGltZWxpbmU7YjspYi5fZGlydHk9ITAsYj1iLnRpbWVsaW5lO3JldHVybiB0aGlzfSxmLl9zd2FwU2VsZkluUGFyYW1zPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hLmxlbmd0aCxjPWEuY29uY2F0KCk7LS1iPi0xOylcIntzZWxmfVwiPT09YVtiXSYmKGNbYl09dGhpcyk7cmV0dXJuIGN9LGYuX2NhbGxiYWNrPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMudmFycztiW2FdLmFwcGx5KGJbYStcIlNjb3BlXCJdfHxiLmNhbGxiYWNrU2NvcGV8fHRoaXMsYlthK1wiUGFyYW1zXCJdfHx0KX0sZi5ldmVudENhbGxiYWNrPWZ1bmN0aW9uKGEsYixjLGQpe2lmKFwib25cIj09PShhfHxcIlwiKS5zdWJzdHIoMCwyKSl7dmFyIGU9dGhpcy52YXJzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBlW2FdO251bGw9PWI/ZGVsZXRlIGVbYV06KGVbYV09YixlW2ErXCJQYXJhbXNcIl09bihjKSYmLTEhPT1jLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKT90aGlzLl9zd2FwU2VsZkluUGFyYW1zKGMpOmMsZVthK1wiU2NvcGVcIl09ZCksXCJvblVwZGF0ZVwiPT09YSYmKHRoaXMuX29uVXBkYXRlPWIpfXJldHVybiB0aGlzfSxmLmRlbGF5PWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZyYmdGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnRUaW1lK2EtdGhpcy5fZGVsYXkpLHRoaXMuX2RlbGF5PWEsdGhpcyk6dGhpcy5fZGVsYXl9LGYuZHVyYXRpb249ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX2R1cmF0aW9uPXRoaXMuX3RvdGFsRHVyYXRpb249YSx0aGlzLl91bmNhY2hlKCEwKSx0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZyYmdGhpcy5fdGltZT4wJiZ0aGlzLl90aW1lPHRoaXMuX2R1cmF0aW9uJiYwIT09YSYmdGhpcy50b3RhbFRpbWUodGhpcy5fdG90YWxUaW1lKihhL3RoaXMuX2R1cmF0aW9uKSwhMCksdGhpcyk6KHRoaXMuX2RpcnR5PSExLHRoaXMuX2R1cmF0aW9uKX0sZi50b3RhbER1cmF0aW9uPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9kaXJ0eT0hMSxhcmd1bWVudHMubGVuZ3RoP3RoaXMuZHVyYXRpb24oYSk6dGhpcy5fdG90YWxEdXJhdGlvbn0sZi50aW1lPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX2RpcnR5JiZ0aGlzLnRvdGFsRHVyYXRpb24oKSx0aGlzLnRvdGFsVGltZShhPnRoaXMuX2R1cmF0aW9uP3RoaXMuX2R1cmF0aW9uOmEsYikpOnRoaXMuX3RpbWV9LGYudG90YWxUaW1lPWZ1bmN0aW9uKGEsYixjKXtpZihofHxnLndha2UoKSwhYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fdG90YWxUaW1lO2lmKHRoaXMuX3RpbWVsaW5lKXtpZigwPmEmJiFjJiYoYSs9dGhpcy50b3RhbER1cmF0aW9uKCkpLHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKXt0aGlzLl9kaXJ0eSYmdGhpcy50b3RhbER1cmF0aW9uKCk7dmFyIGQ9dGhpcy5fdG90YWxEdXJhdGlvbixlPXRoaXMuX3RpbWVsaW5lO2lmKGE+ZCYmIWMmJihhPWQpLHRoaXMuX3N0YXJ0VGltZT0odGhpcy5fcGF1c2VkP3RoaXMuX3BhdXNlVGltZTplLl90aW1lKS0odGhpcy5fcmV2ZXJzZWQ/ZC1hOmEpL3RoaXMuX3RpbWVTY2FsZSxlLl9kaXJ0eXx8dGhpcy5fdW5jYWNoZSghMSksZS5fdGltZWxpbmUpZm9yKDtlLl90aW1lbGluZTspZS5fdGltZWxpbmUuX3RpbWUhPT0oZS5fc3RhcnRUaW1lK2UuX3RvdGFsVGltZSkvZS5fdGltZVNjYWxlJiZlLnRvdGFsVGltZShlLl90b3RhbFRpbWUsITApLGU9ZS5fdGltZWxpbmV9dGhpcy5fZ2MmJnRoaXMuX2VuYWJsZWQoITAsITEpLCh0aGlzLl90b3RhbFRpbWUhPT1hfHwwPT09dGhpcy5fZHVyYXRpb24pJiYoSS5sZW5ndGgmJlgoKSx0aGlzLnJlbmRlcihhLGIsITEpLEkubGVuZ3RoJiZYKCkpfXJldHVybiB0aGlzfSxmLnByb2dyZXNzPWYudG90YWxQcm9ncmVzcz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZHVyYXRpb24oKTtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90aGlzLnRvdGFsVGltZShjKmEsYik6Yz90aGlzLl90aW1lL2M6dGhpcy5yYXRpb30sZi5zdGFydFRpbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGEhPT10aGlzLl9zdGFydFRpbWUmJih0aGlzLl9zdGFydFRpbWU9YSx0aGlzLnRpbWVsaW5lJiZ0aGlzLnRpbWVsaW5lLl9zb3J0Q2hpbGRyZW4mJnRoaXMudGltZWxpbmUuYWRkKHRoaXMsYS10aGlzLl9kZWxheSkpLHRoaXMpOnRoaXMuX3N0YXJ0VGltZX0sZi5lbmRUaW1lPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9zdGFydFRpbWUrKDAhPWE/dGhpcy50b3RhbER1cmF0aW9uKCk6dGhpcy5kdXJhdGlvbigpKS90aGlzLl90aW1lU2NhbGV9LGYudGltZVNjYWxlPWZ1bmN0aW9uKGEpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl90aW1lU2NhbGU7aWYoYT1hfHxrLHRoaXMuX3RpbWVsaW5lJiZ0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZyl7dmFyIGI9dGhpcy5fcGF1c2VUaW1lLGM9Ynx8MD09PWI/Yjp0aGlzLl90aW1lbGluZS50b3RhbFRpbWUoKTt0aGlzLl9zdGFydFRpbWU9Yy0oYy10aGlzLl9zdGFydFRpbWUpKnRoaXMuX3RpbWVTY2FsZS9hfXJldHVybiB0aGlzLl90aW1lU2NhbGU9YSx0aGlzLl91bmNhY2hlKCExKX0sZi5yZXZlcnNlZD1mdW5jdGlvbihhKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYSE9dGhpcy5fcmV2ZXJzZWQmJih0aGlzLl9yZXZlcnNlZD1hLHRoaXMudG90YWxUaW1lKHRoaXMuX3RpbWVsaW5lJiYhdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmc/dGhpcy50b3RhbER1cmF0aW9uKCktdGhpcy5fdG90YWxUaW1lOnRoaXMuX3RvdGFsVGltZSwhMCkpLHRoaXMpOnRoaXMuX3JldmVyc2VkfSxmLnBhdXNlZD1mdW5jdGlvbihhKXtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fcGF1c2VkO3ZhciBiLGMsZD10aGlzLl90aW1lbGluZTtyZXR1cm4gYSE9dGhpcy5fcGF1c2VkJiZkJiYoaHx8YXx8Zy53YWtlKCksYj1kLnJhd1RpbWUoKSxjPWItdGhpcy5fcGF1c2VUaW1lLCFhJiZkLnNtb290aENoaWxkVGltaW5nJiYodGhpcy5fc3RhcnRUaW1lKz1jLHRoaXMuX3VuY2FjaGUoITEpKSx0aGlzLl9wYXVzZVRpbWU9YT9iOm51bGwsdGhpcy5fcGF1c2VkPWEsdGhpcy5fYWN0aXZlPXRoaXMuaXNBY3RpdmUoKSwhYSYmMCE9PWMmJnRoaXMuX2luaXR0ZWQmJnRoaXMuZHVyYXRpb24oKSYmKGI9ZC5zbW9vdGhDaGlsZFRpbWluZz90aGlzLl90b3RhbFRpbWU6KGItdGhpcy5fc3RhcnRUaW1lKS90aGlzLl90aW1lU2NhbGUsdGhpcy5yZW5kZXIoYixiPT09dGhpcy5fdG90YWxUaW1lLCEwKSkpLHRoaXMuX2djJiYhYSYmdGhpcy5fZW5hYmxlZCghMCwhMSksdGhpc307dmFyIEU9cihcImNvcmUuU2ltcGxlVGltZWxpbmVcIixmdW5jdGlvbihhKXtDLmNhbGwodGhpcywwLGEpLHRoaXMuYXV0b1JlbW92ZUNoaWxkcmVuPXRoaXMuc21vb3RoQ2hpbGRUaW1pbmc9ITB9KTtmPUUucHJvdG90eXBlPW5ldyBDLGYuY29uc3RydWN0b3I9RSxmLmtpbGwoKS5fZ2M9ITEsZi5fZmlyc3Q9Zi5fbGFzdD1mLl9yZWNlbnQ9bnVsbCxmLl9zb3J0Q2hpbGRyZW49ITEsZi5hZGQ9Zi5pbnNlcnQ9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZjtpZihhLl9zdGFydFRpbWU9TnVtYmVyKGJ8fDApK2EuX2RlbGF5LGEuX3BhdXNlZCYmdGhpcyE9PWEuX3RpbWVsaW5lJiYoYS5fcGF1c2VUaW1lPWEuX3N0YXJ0VGltZSsodGhpcy5yYXdUaW1lKCktYS5fc3RhcnRUaW1lKS9hLl90aW1lU2NhbGUpLGEudGltZWxpbmUmJmEudGltZWxpbmUuX3JlbW92ZShhLCEwKSxhLnRpbWVsaW5lPWEuX3RpbWVsaW5lPXRoaXMsYS5fZ2MmJmEuX2VuYWJsZWQoITAsITApLGU9dGhpcy5fbGFzdCx0aGlzLl9zb3J0Q2hpbGRyZW4pZm9yKGY9YS5fc3RhcnRUaW1lO2UmJmUuX3N0YXJ0VGltZT5mOyllPWUuX3ByZXY7cmV0dXJuIGU/KGEuX25leHQ9ZS5fbmV4dCxlLl9uZXh0PWEpOihhLl9uZXh0PXRoaXMuX2ZpcnN0LHRoaXMuX2ZpcnN0PWEpLGEuX25leHQ/YS5fbmV4dC5fcHJldj1hOnRoaXMuX2xhc3Q9YSxhLl9wcmV2PWUsdGhpcy5fcmVjZW50PWEsdGhpcy5fdGltZWxpbmUmJnRoaXMuX3VuY2FjaGUoITApLHRoaXN9LGYuX3JlbW92ZT1mdW5jdGlvbihhLGIpe3JldHVybiBhLnRpbWVsaW5lPT09dGhpcyYmKGJ8fGEuX2VuYWJsZWQoITEsITApLGEuX3ByZXY/YS5fcHJldi5fbmV4dD1hLl9uZXh0OnRoaXMuX2ZpcnN0PT09YSYmKHRoaXMuX2ZpcnN0PWEuX25leHQpLGEuX25leHQ/YS5fbmV4dC5fcHJldj1hLl9wcmV2OnRoaXMuX2xhc3Q9PT1hJiYodGhpcy5fbGFzdD1hLl9wcmV2KSxhLl9uZXh0PWEuX3ByZXY9YS50aW1lbGluZT1udWxsLGE9PT10aGlzLl9yZWNlbnQmJih0aGlzLl9yZWNlbnQ9dGhpcy5fbGFzdCksdGhpcy5fdGltZWxpbmUmJnRoaXMuX3VuY2FjaGUoITApKSx0aGlzfSxmLnJlbmRlcj1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZT10aGlzLl9maXJzdDtmb3IodGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9dGhpcy5fcmF3UHJldlRpbWU9YTtlOylkPWUuX25leHQsKGUuX2FjdGl2ZXx8YT49ZS5fc3RhcnRUaW1lJiYhZS5fcGF1c2VkKSYmKGUuX3JldmVyc2VkP2UucmVuZGVyKChlLl9kaXJ0eT9lLnRvdGFsRHVyYXRpb24oKTplLl90b3RhbER1cmF0aW9uKS0oYS1lLl9zdGFydFRpbWUpKmUuX3RpbWVTY2FsZSxiLGMpOmUucmVuZGVyKChhLWUuX3N0YXJ0VGltZSkqZS5fdGltZVNjYWxlLGIsYykpLGU9ZH0sZi5yYXdUaW1lPWZ1bmN0aW9uKCl7cmV0dXJuIGh8fGcud2FrZSgpLHRoaXMuX3RvdGFsVGltZX07dmFyIEY9cihcIlR3ZWVuTGl0ZVwiLGZ1bmN0aW9uKGIsYyxkKXtpZihDLmNhbGwodGhpcyxjLGQpLHRoaXMucmVuZGVyPUYucHJvdG90eXBlLnJlbmRlcixudWxsPT1iKXRocm93XCJDYW5ub3QgdHdlZW4gYSBudWxsIHRhcmdldC5cIjt0aGlzLnRhcmdldD1iPVwic3RyaW5nXCIhPXR5cGVvZiBiP2I6Ri5zZWxlY3RvcihiKXx8Yjt2YXIgZSxmLGcsaD1iLmpxdWVyeXx8Yi5sZW5ndGgmJmIhPT1hJiZiWzBdJiYoYlswXT09PWF8fGJbMF0ubm9kZVR5cGUmJmJbMF0uc3R5bGUmJiFiLm5vZGVUeXBlKSxpPXRoaXMudmFycy5vdmVyd3JpdGU7aWYodGhpcy5fb3ZlcndyaXRlPWk9bnVsbD09aT9UW0YuZGVmYXVsdE92ZXJ3cml0ZV06XCJudW1iZXJcIj09dHlwZW9mIGk/aT4+MDpUW2ldLChofHxiIGluc3RhbmNlb2YgQXJyYXl8fGIucHVzaCYmbihiKSkmJlwibnVtYmVyXCIhPXR5cGVvZiBiWzBdKWZvcih0aGlzLl90YXJnZXRzPWc9bChiKSx0aGlzLl9wcm9wTG9va3VwPVtdLHRoaXMuX3NpYmxpbmdzPVtdLGU9MDtlPGcubGVuZ3RoO2UrKylmPWdbZV0sZj9cInN0cmluZ1wiIT10eXBlb2YgZj9mLmxlbmd0aCYmZiE9PWEmJmZbMF0mJihmWzBdPT09YXx8ZlswXS5ub2RlVHlwZSYmZlswXS5zdHlsZSYmIWYubm9kZVR5cGUpPyhnLnNwbGljZShlLS0sMSksdGhpcy5fdGFyZ2V0cz1nPWcuY29uY2F0KGwoZikpKToodGhpcy5fc2libGluZ3NbZV09WShmLHRoaXMsITEpLDE9PT1pJiZ0aGlzLl9zaWJsaW5nc1tlXS5sZW5ndGg+MSYmJChmLHRoaXMsbnVsbCwxLHRoaXMuX3NpYmxpbmdzW2VdKSk6KGY9Z1tlLS1dPUYuc2VsZWN0b3IoZiksXCJzdHJpbmdcIj09dHlwZW9mIGYmJmcuc3BsaWNlKGUrMSwxKSk6Zy5zcGxpY2UoZS0tLDEpO2Vsc2UgdGhpcy5fcHJvcExvb2t1cD17fSx0aGlzLl9zaWJsaW5ncz1ZKGIsdGhpcywhMSksMT09PWkmJnRoaXMuX3NpYmxpbmdzLmxlbmd0aD4xJiYkKGIsdGhpcyxudWxsLDEsdGhpcy5fc2libGluZ3MpOyh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyfHwwPT09YyYmMD09PXRoaXMuX2RlbGF5JiZ0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyIT09ITEpJiYodGhpcy5fdGltZT0tayx0aGlzLnJlbmRlcigtdGhpcy5fZGVsYXkpKX0sITApLEc9ZnVuY3Rpb24oYil7cmV0dXJuIGImJmIubGVuZ3RoJiZiIT09YSYmYlswXSYmKGJbMF09PT1hfHxiWzBdLm5vZGVUeXBlJiZiWzBdLnN0eWxlJiYhYi5ub2RlVHlwZSl9LEg9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPXt9O2ZvcihjIGluIGEpU1tjXXx8YyBpbiBiJiZcInRyYW5zZm9ybVwiIT09YyYmXCJ4XCIhPT1jJiZcInlcIiE9PWMmJlwid2lkdGhcIiE9PWMmJlwiaGVpZ2h0XCIhPT1jJiZcImNsYXNzTmFtZVwiIT09YyYmXCJib3JkZXJcIiE9PWN8fCEoIVBbY118fFBbY10mJlBbY10uX2F1dG9DU1MpfHwoZFtjXT1hW2NdLGRlbGV0ZSBhW2NdKTthLmNzcz1kfTtmPUYucHJvdG90eXBlPW5ldyBDLGYuY29uc3RydWN0b3I9RixmLmtpbGwoKS5fZ2M9ITEsZi5yYXRpbz0wLGYuX2ZpcnN0UFQ9Zi5fdGFyZ2V0cz1mLl9vdmVyd3JpdHRlblByb3BzPWYuX3N0YXJ0QXQ9bnVsbCxmLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkPWYuX2xhenk9ITEsRi52ZXJzaW9uPVwiMS4xOC4yXCIsRi5kZWZhdWx0RWFzZT1mLl9lYXNlPW5ldyB1KG51bGwsbnVsbCwxLDEpLEYuZGVmYXVsdE92ZXJ3cml0ZT1cImF1dG9cIixGLnRpY2tlcj1nLEYuYXV0b1NsZWVwPTEyMCxGLmxhZ1Ntb290aGluZz1mdW5jdGlvbihhLGIpe2cubGFnU21vb3RoaW5nKGEsYil9LEYuc2VsZWN0b3I9YS4kfHxhLmpRdWVyeXx8ZnVuY3Rpb24oYil7dmFyIGM9YS4kfHxhLmpRdWVyeTtyZXR1cm4gYz8oRi5zZWxlY3Rvcj1jLGMoYikpOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBkb2N1bWVudD9iOmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGw/ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChiKTpkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIiNcIj09PWIuY2hhckF0KDApP2Iuc3Vic3RyKDEpOmIpfTt2YXIgST1bXSxKPXt9LEs9Lyg/OigtfC09fFxcKz0pP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/KVswLTldL2dpLEw9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiLGM9dGhpcy5fZmlyc3RQVCxkPTFlLTY7YzspYj1jLmJsb2I/YT90aGlzLmpvaW4oXCJcIik6dGhpcy5zdGFydDpjLmMqYStjLnMsYy5yP2I9TWF0aC5yb3VuZChiKTpkPmImJmI+LWQmJihiPTApLGMuZj9jLmZwP2MudFtjLnBdKGMuZnAsYik6Yy50W2MucF0oYik6Yy50W2MucF09YixjPWMuX25leHR9LE09ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZixnLGgsaSxqLGssbD1bYSxiXSxtPTAsbj1cIlwiLG89MDtmb3IobC5zdGFydD1hLGMmJihjKGwpLGE9bFswXSxiPWxbMV0pLGwubGVuZ3RoPTAsZT1hLm1hdGNoKEspfHxbXSxmPWIubWF0Y2goSyl8fFtdLGQmJihkLl9uZXh0PW51bGwsZC5ibG9iPTEsbC5fZmlyc3RQVD1kKSxpPWYubGVuZ3RoLGg9MDtpPmg7aCsrKWs9ZltoXSxqPWIuc3Vic3RyKG0sYi5pbmRleE9mKGssbSktbSksbis9anx8IWg/ajpcIixcIixtKz1qLmxlbmd0aCxvP289KG8rMSklNTpcInJnYmEoXCI9PT1qLnN1YnN0cigtNSkmJihvPTEpLGs9PT1lW2hdfHxlLmxlbmd0aDw9aD9uKz1rOihuJiYobC5wdXNoKG4pLG49XCJcIiksZz1wYXJzZUZsb2F0KGVbaF0pLGwucHVzaChnKSxsLl9maXJzdFBUPXtfbmV4dDpsLl9maXJzdFBULHQ6bCxwOmwubGVuZ3RoLTEsczpnLGM6KFwiPVwiPT09ay5jaGFyQXQoMSk/cGFyc2VJbnQoay5jaGFyQXQoMCkrXCIxXCIsMTApKnBhcnNlRmxvYXQoay5zdWJzdHIoMikpOnBhcnNlRmxvYXQoayktZyl8fDAsZjowLHI6byYmND5vfSksbSs9ay5sZW5ndGg7cmV0dXJuIG4rPWIuc3Vic3RyKG0pLG4mJmwucHVzaChuKSxsLnNldFJhdGlvPUwsbH0sTj1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGgpe3ZhciBpLGosaz1cImdldFwiPT09Yz9hW2JdOmMsbD10eXBlb2YgYVtiXSxtPVwic3RyaW5nXCI9PXR5cGVvZiBkJiZcIj1cIj09PWQuY2hhckF0KDEpLG49e3Q6YSxwOmIsczprLGY6XCJmdW5jdGlvblwiPT09bCxwZzowLG46ZXx8YixyOmYscHI6MCxjOm0/cGFyc2VJbnQoZC5jaGFyQXQoMCkrXCIxXCIsMTApKnBhcnNlRmxvYXQoZC5zdWJzdHIoMikpOnBhcnNlRmxvYXQoZCkta3x8MH07cmV0dXJuXCJudW1iZXJcIiE9PWwmJihcImZ1bmN0aW9uXCI9PT1sJiZcImdldFwiPT09YyYmKGo9Yi5pbmRleE9mKFwic2V0XCIpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBhW1wiZ2V0XCIrYi5zdWJzdHIoMyldP2I6XCJnZXRcIitiLnN1YnN0cigzKSxuLnM9az1nP2Fbal0oZyk6YVtqXSgpKSxcInN0cmluZ1wiPT10eXBlb2YgayYmKGd8fGlzTmFOKGspKT8obi5mcD1nLGk9TShrLGQsaHx8Ri5kZWZhdWx0U3RyaW5nRmlsdGVyLG4pLG49e3Q6aSxwOlwic2V0UmF0aW9cIixzOjAsYzoxLGY6MixwZzowLG46ZXx8YixwcjowfSk6bXx8KG4ucz1wYXJzZUZsb2F0KGspLG4uYz1wYXJzZUZsb2F0KGQpLW4uc3x8MCkpLG4uYz8oKG4uX25leHQ9dGhpcy5fZmlyc3RQVCkmJihuLl9uZXh0Ll9wcmV2PW4pLHRoaXMuX2ZpcnN0UFQ9bixuKTp2b2lkIDB9LE89Ri5faW50ZXJuYWxzPXtpc0FycmF5Om4saXNTZWxlY3RvcjpHLGxhenlUd2VlbnM6SSxibG9iRGlmOk19LFA9Ri5fcGx1Z2lucz17fSxRPU8udHdlZW5Mb29rdXA9e30sUj0wLFM9Ty5yZXNlcnZlZFByb3BzPXtlYXNlOjEsZGVsYXk6MSxvdmVyd3JpdGU6MSxvbkNvbXBsZXRlOjEsb25Db21wbGV0ZVBhcmFtczoxLG9uQ29tcGxldGVTY29wZToxLHVzZUZyYW1lczoxLHJ1bkJhY2t3YXJkczoxLHN0YXJ0QXQ6MSxvblVwZGF0ZToxLG9uVXBkYXRlUGFyYW1zOjEsb25VcGRhdGVTY29wZToxLG9uU3RhcnQ6MSxvblN0YXJ0UGFyYW1zOjEsb25TdGFydFNjb3BlOjEsb25SZXZlcnNlQ29tcGxldGU6MSxvblJldmVyc2VDb21wbGV0ZVBhcmFtczoxLG9uUmV2ZXJzZUNvbXBsZXRlU2NvcGU6MSxvblJlcGVhdDoxLG9uUmVwZWF0UGFyYW1zOjEsb25SZXBlYXRTY29wZToxLGVhc2VQYXJhbXM6MSx5b3lvOjEsaW1tZWRpYXRlUmVuZGVyOjEscmVwZWF0OjEscmVwZWF0RGVsYXk6MSxkYXRhOjEscGF1c2VkOjEscmV2ZXJzZWQ6MSxhdXRvQ1NTOjEsbGF6eToxLG9uT3ZlcndyaXRlOjEsY2FsbGJhY2tTY29wZToxLHN0cmluZ0ZpbHRlcjoxfSxUPXtub25lOjAsYWxsOjEsYXV0bzoyLGNvbmN1cnJlbnQ6MyxhbGxPblN0YXJ0OjQscHJlZXhpc3Rpbmc6NSxcInRydWVcIjoxLFwiZmFsc2VcIjowfSxVPUMuX3Jvb3RGcmFtZXNUaW1lbGluZT1uZXcgRSxWPUMuX3Jvb3RUaW1lbGluZT1uZXcgRSxXPTMwLFg9Ty5sYXp5UmVuZGVyPWZ1bmN0aW9uKCl7XG52YXIgYSxiPUkubGVuZ3RoO2ZvcihKPXt9Oy0tYj4tMTspYT1JW2JdLGEmJmEuX2xhenkhPT0hMSYmKGEucmVuZGVyKGEuX2xhenlbMF0sYS5fbGF6eVsxXSwhMCksYS5fbGF6eT0hMSk7SS5sZW5ndGg9MH07Vi5fc3RhcnRUaW1lPWcudGltZSxVLl9zdGFydFRpbWU9Zy5mcmFtZSxWLl9hY3RpdmU9VS5fYWN0aXZlPSEwLHNldFRpbWVvdXQoWCwxKSxDLl91cGRhdGVSb290PUYucmVuZGVyPWZ1bmN0aW9uKCl7dmFyIGEsYixjO2lmKEkubGVuZ3RoJiZYKCksVi5yZW5kZXIoKGcudGltZS1WLl9zdGFydFRpbWUpKlYuX3RpbWVTY2FsZSwhMSwhMSksVS5yZW5kZXIoKGcuZnJhbWUtVS5fc3RhcnRUaW1lKSpVLl90aW1lU2NhbGUsITEsITEpLEkubGVuZ3RoJiZYKCksZy5mcmFtZT49Vyl7Vz1nLmZyYW1lKyhwYXJzZUludChGLmF1dG9TbGVlcCwxMCl8fDEyMCk7Zm9yKGMgaW4gUSl7Zm9yKGI9UVtjXS50d2VlbnMsYT1iLmxlbmd0aDstLWE+LTE7KWJbYV0uX2djJiZiLnNwbGljZShhLDEpOzA9PT1iLmxlbmd0aCYmZGVsZXRlIFFbY119aWYoYz1WLl9maXJzdCwoIWN8fGMuX3BhdXNlZCkmJkYuYXV0b1NsZWVwJiYhVS5fZmlyc3QmJjE9PT1nLl9saXN0ZW5lcnMudGljay5sZW5ndGgpe2Zvcig7YyYmYy5fcGF1c2VkOyljPWMuX25leHQ7Y3x8Zy5zbGVlcCgpfX19LGcuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIixDLl91cGRhdGVSb290KTt2YXIgWT1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPWEuX2dzVHdlZW5JRDtpZihRW2Z8fChhLl9nc1R3ZWVuSUQ9Zj1cInRcIitSKyspXXx8KFFbZl09e3RhcmdldDphLHR3ZWVuczpbXX0pLGImJihkPVFbZl0udHdlZW5zLGRbZT1kLmxlbmd0aF09YixjKSlmb3IoOy0tZT4tMTspZFtlXT09PWImJmQuc3BsaWNlKGUsMSk7cmV0dXJuIFFbZl0udHdlZW5zfSxaPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlLGYsZz1hLnZhcnMub25PdmVyd3JpdGU7cmV0dXJuIGcmJihlPWcoYSxiLGMsZCkpLGc9Ri5vbk92ZXJ3cml0ZSxnJiYoZj1nKGEsYixjLGQpKSxlIT09ITEmJmYhPT0hMX0sJD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmLGcsaCxpO2lmKDE9PT1kfHxkPj00KXtmb3IoaT1lLmxlbmd0aCxmPTA7aT5mO2YrKylpZigoaD1lW2ZdKSE9PWIpaC5fZ2N8fGguX2tpbGwobnVsbCxhLGIpJiYoZz0hMCk7ZWxzZSBpZig1PT09ZClicmVhaztyZXR1cm4gZ312YXIgaixsPWIuX3N0YXJ0VGltZStrLG09W10sbj0wLG89MD09PWIuX2R1cmF0aW9uO2ZvcihmPWUubGVuZ3RoOy0tZj4tMTspKGg9ZVtmXSk9PT1ifHxoLl9nY3x8aC5fcGF1c2VkfHwoaC5fdGltZWxpbmUhPT1iLl90aW1lbGluZT8oaj1qfHxfKGIsMCxvKSwwPT09XyhoLGosbykmJihtW24rK109aCkpOmguX3N0YXJ0VGltZTw9bCYmaC5fc3RhcnRUaW1lK2gudG90YWxEdXJhdGlvbigpL2guX3RpbWVTY2FsZT5sJiYoKG98fCFoLl9pbml0dGVkKSYmbC1oLl9zdGFydFRpbWU8PTJlLTEwfHwobVtuKytdPWgpKSk7Zm9yKGY9bjstLWY+LTE7KWlmKGg9bVtmXSwyPT09ZCYmaC5fa2lsbChjLGEsYikmJihnPSEwKSwyIT09ZHx8IWguX2ZpcnN0UFQmJmguX2luaXR0ZWQpe2lmKDIhPT1kJiYhWihoLGIpKWNvbnRpbnVlO2guX2VuYWJsZWQoITEsITEpJiYoZz0hMCl9cmV0dXJuIGd9LF89ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLl90aW1lbGluZSxlPWQuX3RpbWVTY2FsZSxmPWEuX3N0YXJ0VGltZTtkLl90aW1lbGluZTspe2lmKGYrPWQuX3N0YXJ0VGltZSxlKj1kLl90aW1lU2NhbGUsZC5fcGF1c2VkKXJldHVybi0xMDA7ZD1kLl90aW1lbGluZX1yZXR1cm4gZi89ZSxmPmI/Zi1iOmMmJmY9PT1ifHwhYS5faW5pdHRlZCYmMiprPmYtYj9rOihmKz1hLnRvdGFsRHVyYXRpb24oKS9hLl90aW1lU2NhbGUvZSk+YitrPzA6Zi1iLWt9O2YuX2luaXQ9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGY9dGhpcy52YXJzLGc9dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyxoPXRoaXMuX2R1cmF0aW9uLGk9ISFmLmltbWVkaWF0ZVJlbmRlcixqPWYuZWFzZTtpZihmLnN0YXJ0QXQpe3RoaXMuX3N0YXJ0QXQmJih0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwhMCksdGhpcy5fc3RhcnRBdC5raWxsKCkpLGU9e307Zm9yKGQgaW4gZi5zdGFydEF0KWVbZF09Zi5zdGFydEF0W2RdO2lmKGUub3ZlcndyaXRlPSExLGUuaW1tZWRpYXRlUmVuZGVyPSEwLGUubGF6eT1pJiZmLmxhenkhPT0hMSxlLnN0YXJ0QXQ9ZS5kZWxheT1udWxsLHRoaXMuX3N0YXJ0QXQ9Ri50byh0aGlzLnRhcmdldCwwLGUpLGkpaWYodGhpcy5fdGltZT4wKXRoaXMuX3N0YXJ0QXQ9bnVsbDtlbHNlIGlmKDAhPT1oKXJldHVybn1lbHNlIGlmKGYucnVuQmFja3dhcmRzJiYwIT09aClpZih0aGlzLl9zdGFydEF0KXRoaXMuX3N0YXJ0QXQucmVuZGVyKC0xLCEwKSx0aGlzLl9zdGFydEF0LmtpbGwoKSx0aGlzLl9zdGFydEF0PW51bGw7ZWxzZXswIT09dGhpcy5fdGltZSYmKGk9ITEpLGM9e307Zm9yKGQgaW4gZilTW2RdJiZcImF1dG9DU1NcIiE9PWR8fChjW2RdPWZbZF0pO2lmKGMub3ZlcndyaXRlPTAsYy5kYXRhPVwiaXNGcm9tU3RhcnRcIixjLmxhenk9aSYmZi5sYXp5IT09ITEsYy5pbW1lZGlhdGVSZW5kZXI9aSx0aGlzLl9zdGFydEF0PUYudG8odGhpcy50YXJnZXQsMCxjKSxpKXtpZigwPT09dGhpcy5fdGltZSlyZXR1cm59ZWxzZSB0aGlzLl9zdGFydEF0Ll9pbml0KCksdGhpcy5fc3RhcnRBdC5fZW5hYmxlZCghMSksdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciYmKHRoaXMuX3N0YXJ0QXQ9bnVsbCl9aWYodGhpcy5fZWFzZT1qPWo/aiBpbnN0YW5jZW9mIHU/ajpcImZ1bmN0aW9uXCI9PXR5cGVvZiBqP25ldyB1KGosZi5lYXNlUGFyYW1zKTp2W2pdfHxGLmRlZmF1bHRFYXNlOkYuZGVmYXVsdEVhc2UsZi5lYXNlUGFyYW1zIGluc3RhbmNlb2YgQXJyYXkmJmouY29uZmlnJiYodGhpcy5fZWFzZT1qLmNvbmZpZy5hcHBseShqLGYuZWFzZVBhcmFtcykpLHRoaXMuX2Vhc2VUeXBlPXRoaXMuX2Vhc2UuX3R5cGUsdGhpcy5fZWFzZVBvd2VyPXRoaXMuX2Vhc2UuX3Bvd2VyLHRoaXMuX2ZpcnN0UFQ9bnVsbCx0aGlzLl90YXJnZXRzKWZvcihhPXRoaXMuX3RhcmdldHMubGVuZ3RoOy0tYT4tMTspdGhpcy5faW5pdFByb3BzKHRoaXMuX3RhcmdldHNbYV0sdGhpcy5fcHJvcExvb2t1cFthXT17fSx0aGlzLl9zaWJsaW5nc1thXSxnP2dbYV06bnVsbCkmJihiPSEwKTtlbHNlIGI9dGhpcy5faW5pdFByb3BzKHRoaXMudGFyZ2V0LHRoaXMuX3Byb3BMb29rdXAsdGhpcy5fc2libGluZ3MsZyk7aWYoYiYmRi5fb25QbHVnaW5FdmVudChcIl9vbkluaXRBbGxQcm9wc1wiLHRoaXMpLGcmJih0aGlzLl9maXJzdFBUfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzLnRhcmdldCYmdGhpcy5fZW5hYmxlZCghMSwhMSkpLGYucnVuQmFja3dhcmRzKWZvcihjPXRoaXMuX2ZpcnN0UFQ7YzspYy5zKz1jLmMsYy5jPS1jLmMsYz1jLl9uZXh0O3RoaXMuX29uVXBkYXRlPWYub25VcGRhdGUsdGhpcy5faW5pdHRlZD0hMH0sZi5faW5pdFByb3BzPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmLGcsaCxpLGosaztpZihudWxsPT1iKXJldHVybiExO0pbYi5fZ3NUd2VlbklEXSYmWCgpLHRoaXMudmFycy5jc3N8fGIuc3R5bGUmJmIhPT1hJiZiLm5vZGVUeXBlJiZQLmNzcyYmdGhpcy52YXJzLmF1dG9DU1MhPT0hMSYmSCh0aGlzLnZhcnMsYik7Zm9yKGYgaW4gdGhpcy52YXJzKWlmKGs9dGhpcy52YXJzW2ZdLFNbZl0payYmKGsgaW5zdGFuY2VvZiBBcnJheXx8ay5wdXNoJiZuKGspKSYmLTEhPT1rLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSYmKHRoaXMudmFyc1tmXT1rPXRoaXMuX3N3YXBTZWxmSW5QYXJhbXMoayx0aGlzKSk7ZWxzZSBpZihQW2ZdJiYoaT1uZXcgUFtmXSkuX29uSW5pdFR3ZWVuKGIsdGhpcy52YXJzW2ZdLHRoaXMpKXtmb3IodGhpcy5fZmlyc3RQVD1qPXtfbmV4dDp0aGlzLl9maXJzdFBULHQ6aSxwOlwic2V0UmF0aW9cIixzOjAsYzoxLGY6MSxuOmYscGc6MSxwcjppLl9wcmlvcml0eX0sZz1pLl9vdmVyd3JpdGVQcm9wcy5sZW5ndGg7LS1nPi0xOyljW2kuX292ZXJ3cml0ZVByb3BzW2ddXT10aGlzLl9maXJzdFBUOyhpLl9wcmlvcml0eXx8aS5fb25Jbml0QWxsUHJvcHMpJiYoaD0hMCksKGkuX29uRGlzYWJsZXx8aS5fb25FbmFibGUpJiYodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZD0hMCksai5fbmV4dCYmKGouX25leHQuX3ByZXY9ail9ZWxzZSBjW2ZdPU4uY2FsbCh0aGlzLGIsZixcImdldFwiLGssZiwwLG51bGwsdGhpcy52YXJzLnN0cmluZ0ZpbHRlcik7cmV0dXJuIGUmJnRoaXMuX2tpbGwoZSxiKT90aGlzLl9pbml0UHJvcHMoYixjLGQsZSk6dGhpcy5fb3ZlcndyaXRlPjEmJnRoaXMuX2ZpcnN0UFQmJmQubGVuZ3RoPjEmJiQoYix0aGlzLGMsdGhpcy5fb3ZlcndyaXRlLGQpPyh0aGlzLl9raWxsKGMsYiksdGhpcy5faW5pdFByb3BzKGIsYyxkLGUpKToodGhpcy5fZmlyc3RQVCYmKHRoaXMudmFycy5sYXp5IT09ITEmJnRoaXMuX2R1cmF0aW9ufHx0aGlzLnZhcnMubGF6eSYmIXRoaXMuX2R1cmF0aW9uKSYmKEpbYi5fZ3NUd2VlbklEXT0hMCksaCl9LGYucmVuZGVyPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZyxoPXRoaXMuX3RpbWUsaT10aGlzLl9kdXJhdGlvbixqPXRoaXMuX3Jhd1ByZXZUaW1lO2lmKGE+PWktMWUtNyl0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT1pLHRoaXMucmF0aW89dGhpcy5fZWFzZS5fY2FsY0VuZD90aGlzLl9lYXNlLmdldFJhdGlvKDEpOjEsdGhpcy5fcmV2ZXJzZWR8fChkPSEwLGU9XCJvbkNvbXBsZXRlXCIsYz1jfHx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pLDA9PT1pJiYodGhpcy5faW5pdHRlZHx8IXRoaXMudmFycy5sYXp5fHxjKSYmKHRoaXMuX3N0YXJ0VGltZT09PXRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbiYmKGE9MCksKDA+anx8MD49YSYmYT49LTFlLTd8fGo9PT1rJiZcImlzUGF1c2VcIiE9PXRoaXMuZGF0YSkmJmohPT1hJiYoYz0hMCxqPmsmJihlPVwib25SZXZlcnNlQ29tcGxldGVcIikpLHRoaXMuX3Jhd1ByZXZUaW1lPWc9IWJ8fGF8fGo9PT1hP2E6ayk7ZWxzZSBpZigxZS03PmEpdGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9MCx0aGlzLnJhdGlvPXRoaXMuX2Vhc2UuX2NhbGNFbmQ/dGhpcy5fZWFzZS5nZXRSYXRpbygwKTowLCgwIT09aHx8MD09PWkmJmo+MCkmJihlPVwib25SZXZlcnNlQ29tcGxldGVcIixkPXRoaXMuX3JldmVyc2VkKSwwPmEmJih0aGlzLl9hY3RpdmU9ITEsMD09PWkmJih0aGlzLl9pbml0dGVkfHwhdGhpcy52YXJzLmxhenl8fGMpJiYoaj49MCYmKGohPT1rfHxcImlzUGF1c2VcIiE9PXRoaXMuZGF0YSkmJihjPSEwKSx0aGlzLl9yYXdQcmV2VGltZT1nPSFifHxhfHxqPT09YT9hOmspKSx0aGlzLl9pbml0dGVkfHwoYz0hMCk7ZWxzZSBpZih0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT1hLHRoaXMuX2Vhc2VUeXBlKXt2YXIgbD1hL2ksbT10aGlzLl9lYXNlVHlwZSxuPXRoaXMuX2Vhc2VQb3dlcjsoMT09PW18fDM9PT1tJiZsPj0uNSkmJihsPTEtbCksMz09PW0mJihsKj0yKSwxPT09bj9sKj1sOjI9PT1uP2wqPWwqbDozPT09bj9sKj1sKmwqbDo0PT09biYmKGwqPWwqbCpsKmwpLDE9PT1tP3RoaXMucmF0aW89MS1sOjI9PT1tP3RoaXMucmF0aW89bDouNT5hL2k/dGhpcy5yYXRpbz1sLzI6dGhpcy5yYXRpbz0xLWwvMn1lbHNlIHRoaXMucmF0aW89dGhpcy5fZWFzZS5nZXRSYXRpbyhhL2kpO2lmKHRoaXMuX3RpbWUhPT1ofHxjKXtpZighdGhpcy5faW5pdHRlZCl7aWYodGhpcy5faW5pdCgpLCF0aGlzLl9pbml0dGVkfHx0aGlzLl9nYylyZXR1cm47aWYoIWMmJnRoaXMuX2ZpcnN0UFQmJih0aGlzLnZhcnMubGF6eSE9PSExJiZ0aGlzLl9kdXJhdGlvbnx8dGhpcy52YXJzLmxhenkmJiF0aGlzLl9kdXJhdGlvbikpcmV0dXJuIHRoaXMuX3RpbWU9dGhpcy5fdG90YWxUaW1lPWgsdGhpcy5fcmF3UHJldlRpbWU9aixJLnB1c2godGhpcyksdm9pZCh0aGlzLl9sYXp5PVthLGJdKTt0aGlzLl90aW1lJiYhZD90aGlzLnJhdGlvPXRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZS9pKTpkJiZ0aGlzLl9lYXNlLl9jYWxjRW5kJiYodGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKDA9PT10aGlzLl90aW1lPzA6MSkpfWZvcih0aGlzLl9sYXp5IT09ITEmJih0aGlzLl9sYXp5PSExKSx0aGlzLl9hY3RpdmV8fCF0aGlzLl9wYXVzZWQmJnRoaXMuX3RpbWUhPT1oJiZhPj0wJiYodGhpcy5fYWN0aXZlPSEwKSwwPT09aCYmKHRoaXMuX3N0YXJ0QXQmJihhPj0wP3RoaXMuX3N0YXJ0QXQucmVuZGVyKGEsYixjKTplfHwoZT1cIl9kdW1teUdTXCIpKSx0aGlzLnZhcnMub25TdGFydCYmKDAhPT10aGlzLl90aW1lfHwwPT09aSkmJihifHx0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIikpKSxmPXRoaXMuX2ZpcnN0UFQ7ZjspZi5mP2YudFtmLnBdKGYuYyp0aGlzLnJhdGlvK2Yucyk6Zi50W2YucF09Zi5jKnRoaXMucmF0aW8rZi5zLGY9Zi5fbmV4dDt0aGlzLl9vblVwZGF0ZSYmKDA+YSYmdGhpcy5fc3RhcnRBdCYmYSE9PS0xZS00JiZ0aGlzLl9zdGFydEF0LnJlbmRlcihhLGIsYyksYnx8KHRoaXMuX3RpbWUhPT1ofHxkKSYmdGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKSksZSYmKCF0aGlzLl9nY3x8YykmJigwPmEmJnRoaXMuX3N0YXJ0QXQmJiF0aGlzLl9vblVwZGF0ZSYmYSE9PS0xZS00JiZ0aGlzLl9zdGFydEF0LnJlbmRlcihhLGIsYyksZCYmKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiYmdGhpcy5fZW5hYmxlZCghMSwhMSksdGhpcy5fYWN0aXZlPSExKSwhYiYmdGhpcy52YXJzW2VdJiZ0aGlzLl9jYWxsYmFjayhlKSwwPT09aSYmdGhpcy5fcmF3UHJldlRpbWU9PT1rJiZnIT09ayYmKHRoaXMuX3Jhd1ByZXZUaW1lPTApKX19LGYuX2tpbGw9ZnVuY3Rpb24oYSxiLGMpe2lmKFwiYWxsXCI9PT1hJiYoYT1udWxsKSxudWxsPT1hJiYobnVsbD09Ynx8Yj09PXRoaXMudGFyZ2V0KSlyZXR1cm4gdGhpcy5fbGF6eT0hMSx0aGlzLl9lbmFibGVkKCExLCExKTtiPVwic3RyaW5nXCIhPXR5cGVvZiBiP2J8fHRoaXMuX3RhcmdldHN8fHRoaXMudGFyZ2V0OkYuc2VsZWN0b3IoYil8fGI7dmFyIGQsZSxmLGcsaCxpLGosayxsLG09YyYmdGhpcy5fdGltZSYmYy5fc3RhcnRUaW1lPT09dGhpcy5fc3RhcnRUaW1lJiZ0aGlzLl90aW1lbGluZT09PWMuX3RpbWVsaW5lO2lmKChuKGIpfHxHKGIpKSYmXCJudW1iZXJcIiE9dHlwZW9mIGJbMF0pZm9yKGQ9Yi5sZW5ndGg7LS1kPi0xOyl0aGlzLl9raWxsKGEsYltkXSxjKSYmKGk9ITApO2Vsc2V7aWYodGhpcy5fdGFyZ2V0cyl7Zm9yKGQ9dGhpcy5fdGFyZ2V0cy5sZW5ndGg7LS1kPi0xOylpZihiPT09dGhpcy5fdGFyZ2V0c1tkXSl7aD10aGlzLl9wcm9wTG9va3VwW2RdfHx7fSx0aGlzLl9vdmVyd3JpdHRlblByb3BzPXRoaXMuX292ZXJ3cml0dGVuUHJvcHN8fFtdLGU9dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc1tkXT1hP3RoaXMuX292ZXJ3cml0dGVuUHJvcHNbZF18fHt9OlwiYWxsXCI7YnJlYWt9fWVsc2V7aWYoYiE9PXRoaXMudGFyZ2V0KXJldHVybiExO2g9dGhpcy5fcHJvcExvb2t1cCxlPXRoaXMuX292ZXJ3cml0dGVuUHJvcHM9YT90aGlzLl9vdmVyd3JpdHRlblByb3BzfHx7fTpcImFsbFwifWlmKGgpe2lmKGo9YXx8aCxrPWEhPT1lJiZcImFsbFwiIT09ZSYmYSE9PWgmJihcIm9iamVjdFwiIT10eXBlb2YgYXx8IWEuX3RlbXBLaWxsKSxjJiYoRi5vbk92ZXJ3cml0ZXx8dGhpcy52YXJzLm9uT3ZlcndyaXRlKSl7Zm9yKGYgaW4gailoW2ZdJiYobHx8KGw9W10pLGwucHVzaChmKSk7aWYoKGx8fCFhKSYmIVoodGhpcyxjLGIsbCkpcmV0dXJuITF9Zm9yKGYgaW4gaikoZz1oW2ZdKSYmKG0mJihnLmY/Zy50W2cucF0oZy5zKTpnLnRbZy5wXT1nLnMsaT0hMCksZy5wZyYmZy50Ll9raWxsKGopJiYoaT0hMCksZy5wZyYmMCE9PWcudC5fb3ZlcndyaXRlUHJvcHMubGVuZ3RofHwoZy5fcHJldj9nLl9wcmV2Ll9uZXh0PWcuX25leHQ6Zz09PXRoaXMuX2ZpcnN0UFQmJih0aGlzLl9maXJzdFBUPWcuX25leHQpLGcuX25leHQmJihnLl9uZXh0Ll9wcmV2PWcuX3ByZXYpLGcuX25leHQ9Zy5fcHJldj1udWxsKSxkZWxldGUgaFtmXSksayYmKGVbZl09MSk7IXRoaXMuX2ZpcnN0UFQmJnRoaXMuX2luaXR0ZWQmJnRoaXMuX2VuYWJsZWQoITEsITEpfX1yZXR1cm4gaX0sZi5pbnZhbGlkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQmJkYuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsdGhpcyksdGhpcy5fZmlyc3RQVD10aGlzLl9vdmVyd3JpdHRlblByb3BzPXRoaXMuX3N0YXJ0QXQ9dGhpcy5fb25VcGRhdGU9bnVsbCx0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkPXRoaXMuX2FjdGl2ZT10aGlzLl9sYXp5PSExLHRoaXMuX3Byb3BMb29rdXA9dGhpcy5fdGFyZ2V0cz97fTpbXSxDLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyksdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciYmKHRoaXMuX3RpbWU9LWssdGhpcy5yZW5kZXIoLXRoaXMuX2RlbGF5KSksdGhpc30sZi5fZW5hYmxlZD1mdW5jdGlvbihhLGIpe2lmKGh8fGcud2FrZSgpLGEmJnRoaXMuX2djKXt2YXIgYyxkPXRoaXMuX3RhcmdldHM7aWYoZClmb3IoYz1kLmxlbmd0aDstLWM+LTE7KXRoaXMuX3NpYmxpbmdzW2NdPVkoZFtjXSx0aGlzLCEwKTtlbHNlIHRoaXMuX3NpYmxpbmdzPVkodGhpcy50YXJnZXQsdGhpcywhMCl9cmV0dXJuIEMucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcyxhLGIpLHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQmJnRoaXMuX2ZpcnN0UFQ/Ri5fb25QbHVnaW5FdmVudChhP1wiX29uRW5hYmxlXCI6XCJfb25EaXNhYmxlXCIsdGhpcyk6ITF9LEYudG89ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuZXcgRihhLGIsYyl9LEYuZnJvbT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGMucnVuQmFja3dhcmRzPSEwLGMuaW1tZWRpYXRlUmVuZGVyPTAhPWMuaW1tZWRpYXRlUmVuZGVyLG5ldyBGKGEsYixjKX0sRi5mcm9tVG89ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIGQuc3RhcnRBdD1jLGQuaW1tZWRpYXRlUmVuZGVyPTAhPWQuaW1tZWRpYXRlUmVuZGVyJiYwIT1jLmltbWVkaWF0ZVJlbmRlcixuZXcgRihhLGIsZCl9LEYuZGVsYXllZENhbGw9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gbmV3IEYoYiwwLHtkZWxheTphLG9uQ29tcGxldGU6YixvbkNvbXBsZXRlUGFyYW1zOmMsY2FsbGJhY2tTY29wZTpkLG9uUmV2ZXJzZUNvbXBsZXRlOmIsb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6YyxpbW1lZGlhdGVSZW5kZXI6ITEsbGF6eTohMSx1c2VGcmFtZXM6ZSxvdmVyd3JpdGU6MH0pfSxGLnNldD1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgRihhLDAsYil9LEYuZ2V0VHdlZW5zT2Y9ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1hKXJldHVybltdO2E9XCJzdHJpbmdcIiE9dHlwZW9mIGE/YTpGLnNlbGVjdG9yKGEpfHxhO3ZhciBjLGQsZSxmO2lmKChuKGEpfHxHKGEpKSYmXCJudW1iZXJcIiE9dHlwZW9mIGFbMF0pe2ZvcihjPWEubGVuZ3RoLGQ9W107LS1jPi0xOylkPWQuY29uY2F0KEYuZ2V0VHdlZW5zT2YoYVtjXSxiKSk7Zm9yKGM9ZC5sZW5ndGg7LS1jPi0xOylmb3IoZj1kW2NdLGU9YzstLWU+LTE7KWY9PT1kW2VdJiZkLnNwbGljZShjLDEpfWVsc2UgZm9yKGQ9WShhKS5jb25jYXQoKSxjPWQubGVuZ3RoOy0tYz4tMTspKGRbY10uX2djfHxiJiYhZFtjXS5pc0FjdGl2ZSgpKSYmZC5zcGxpY2UoYywxKTtyZXR1cm4gZH0sRi5raWxsVHdlZW5zT2Y9Ri5raWxsRGVsYXllZENhbGxzVG89ZnVuY3Rpb24oYSxiLGMpe1wib2JqZWN0XCI9PXR5cGVvZiBiJiYoYz1iLGI9ITEpO2Zvcih2YXIgZD1GLmdldFR3ZWVuc09mKGEsYiksZT1kLmxlbmd0aDstLWU+LTE7KWRbZV0uX2tpbGwoYyxhKX07dmFyIGFhPXIoXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsZnVuY3Rpb24oYSxiKXt0aGlzLl9vdmVyd3JpdGVQcm9wcz0oYXx8XCJcIikuc3BsaXQoXCIsXCIpLHRoaXMuX3Byb3BOYW1lPXRoaXMuX292ZXJ3cml0ZVByb3BzWzBdLHRoaXMuX3ByaW9yaXR5PWJ8fDAsdGhpcy5fc3VwZXI9YWEucHJvdG90eXBlfSwhMCk7aWYoZj1hYS5wcm90b3R5cGUsYWEudmVyc2lvbj1cIjEuMTguMFwiLGFhLkFQST0yLGYuX2ZpcnN0UFQ9bnVsbCxmLl9hZGRUd2Vlbj1OLGYuc2V0UmF0aW89TCxmLl9raWxsPWZ1bmN0aW9uKGEpe3ZhciBiLGM9dGhpcy5fb3ZlcndyaXRlUHJvcHMsZD10aGlzLl9maXJzdFBUO2lmKG51bGwhPWFbdGhpcy5fcHJvcE5hbWVdKXRoaXMuX292ZXJ3cml0ZVByb3BzPVtdO2Vsc2UgZm9yKGI9Yy5sZW5ndGg7LS1iPi0xOyludWxsIT1hW2NbYl1dJiZjLnNwbGljZShiLDEpO2Zvcig7ZDspbnVsbCE9YVtkLm5dJiYoZC5fbmV4dCYmKGQuX25leHQuX3ByZXY9ZC5fcHJldiksZC5fcHJldj8oZC5fcHJldi5fbmV4dD1kLl9uZXh0LGQuX3ByZXY9bnVsbCk6dGhpcy5fZmlyc3RQVD09PWQmJih0aGlzLl9maXJzdFBUPWQuX25leHQpKSxkPWQuX25leHQ7cmV0dXJuITF9LGYuX3JvdW5kUHJvcHM9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9dGhpcy5fZmlyc3RQVDtjOykoYVt0aGlzLl9wcm9wTmFtZV18fG51bGwhPWMubiYmYVtjLm4uc3BsaXQodGhpcy5fcHJvcE5hbWUrXCJfXCIpLmpvaW4oXCJcIildKSYmKGMucj1iKSxjPWMuX25leHR9LEYuX29uUGx1Z2luRXZlbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnLGg9Yi5fZmlyc3RQVDtpZihcIl9vbkluaXRBbGxQcm9wc1wiPT09YSl7Zm9yKDtoOyl7Zm9yKGc9aC5fbmV4dCxkPWU7ZCYmZC5wcj5oLnByOylkPWQuX25leHQ7KGguX3ByZXY9ZD9kLl9wcmV2OmYpP2guX3ByZXYuX25leHQ9aDplPWgsKGguX25leHQ9ZCk/ZC5fcHJldj1oOmY9aCxoPWd9aD1iLl9maXJzdFBUPWV9Zm9yKDtoOyloLnBnJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBoLnRbYV0mJmgudFthXSgpJiYoYz0hMCksaD1oLl9uZXh0O3JldHVybiBjfSxhYS5hY3RpdmF0ZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9YS5sZW5ndGg7LS1iPi0xOylhW2JdLkFQST09PWFhLkFQSSYmKFBbKG5ldyBhW2JdKS5fcHJvcE5hbWVdPWFbYl0pO3JldHVybiEwfSxxLnBsdWdpbj1mdW5jdGlvbihhKXtpZighKGEmJmEucHJvcE5hbWUmJmEuaW5pdCYmYS5BUEkpKXRocm93XCJpbGxlZ2FsIHBsdWdpbiBkZWZpbml0aW9uLlwiO3ZhciBiLGM9YS5wcm9wTmFtZSxkPWEucHJpb3JpdHl8fDAsZT1hLm92ZXJ3cml0ZVByb3BzLGY9e2luaXQ6XCJfb25Jbml0VHdlZW5cIixzZXQ6XCJzZXRSYXRpb1wiLGtpbGw6XCJfa2lsbFwiLHJvdW5kOlwiX3JvdW5kUHJvcHNcIixpbml0QWxsOlwiX29uSW5pdEFsbFByb3BzXCJ9LGc9cihcInBsdWdpbnMuXCIrYy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStjLnN1YnN0cigxKStcIlBsdWdpblwiLGZ1bmN0aW9uKCl7YWEuY2FsbCh0aGlzLGMsZCksdGhpcy5fb3ZlcndyaXRlUHJvcHM9ZXx8W119LGEuZ2xvYmFsPT09ITApLGg9Zy5wcm90b3R5cGU9bmV3IGFhKGMpO2guY29uc3RydWN0b3I9ZyxnLkFQST1hLkFQSTtmb3IoYiBpbiBmKVwiZnVuY3Rpb25cIj09dHlwZW9mIGFbYl0mJihoW2ZbYl1dPWFbYl0pO3JldHVybiBnLnZlcnNpb249YS52ZXJzaW9uLGFhLmFjdGl2YXRlKFtnXSksZ30sZD1hLl9nc1F1ZXVlKXtmb3IoZT0wO2U8ZC5sZW5ndGg7ZSsrKWRbZV0oKTtmb3IoZiBpbiBvKW9bZl0uZnVuY3x8YS5jb25zb2xlLmxvZyhcIkdTQVAgZW5jb3VudGVyZWQgbWlzc2luZyBkZXBlbmRlbmN5OiBjb20uZ3JlZW5zb2NrLlwiK2YpfWg9ITF9fShcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6dGhpc3x8d2luZG93LFwiVHdlZW5NYXhcIik7Il19","// File:src/Three.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar THREE = { REVISION: '78' };\n\n//\n\nif ( typeof define === 'function' && define.amd ) {\n\n\tdefine( 'three', THREE );\n\n} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\n\n\tmodule.exports = THREE;\n\n}\n\n// Polyfills\n\nif ( Number.EPSILON === undefined ) {\n\n\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n}\n\n//\n\nif ( Math.sign === undefined ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\tMath.sign = function ( x ) {\n\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t};\n\n}\n\nif ( Function.prototype.name === undefined ) {\n\n\t// Missing in IE9-11.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\tget: function () {\n\n\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\n\t\t}\n\n\t} );\n\n}\n\nif ( Object.assign === undefined ) {\n\n\t// Missing in IE.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t( function () {\n\n\t\tObject.assign = function ( target ) {\n\n\t\t\t'use strict';\n\n\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t}\n\n\t\t\tvar output = Object( target );\n\n\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t};\n\n\t} )();\n\n}\n\n//\n\nObject.assign( THREE, {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\n\n\tMOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },\n\n\t// GL STATE CONSTANTS\n\n\tCullFaceNone: 0,\n\tCullFaceBack: 1,\n\tCullFaceFront: 2,\n\tCullFaceFrontBack: 3,\n\n\tFrontFaceDirectionCW: 0,\n\tFrontFaceDirectionCCW: 1,\n\n\t// SHADOWING TYPES\n\n\tBasicShadowMap: 0,\n\tPCFShadowMap: 1,\n\tPCFSoftShadowMap: 2,\n\n\t// MATERIAL CONSTANTS\n\n\t// side\n\n\tFrontSide: 0,\n\tBackSide: 1,\n\tDoubleSide: 2,\n\n\t// shading\n\n\tFlatShading: 1,\n\tSmoothShading: 2,\n\n\t// colors\n\n\tNoColors: 0,\n\tFaceColors: 1,\n\tVertexColors: 2,\n\n\t// blending modes\n\n\tNoBlending: 0,\n\tNormalBlending: 1,\n\tAdditiveBlending: 2,\n\tSubtractiveBlending: 3,\n\tMultiplyBlending: 4,\n\tCustomBlending: 5,\n\n\t// custom blending equations\n\t// (numbers start from 100 not to clash with other\n\t// mappings to OpenGL constants defined in Texture.js)\n\n\tAddEquation: 100,\n\tSubtractEquation: 101,\n\tReverseSubtractEquation: 102,\n\tMinEquation: 103,\n\tMaxEquation: 104,\n\n\t// custom blending destination factors\n\n\tZeroFactor: 200,\n\tOneFactor: 201,\n\tSrcColorFactor: 202,\n\tOneMinusSrcColorFactor: 203,\n\tSrcAlphaFactor: 204,\n\tOneMinusSrcAlphaFactor: 205,\n\tDstAlphaFactor: 206,\n\tOneMinusDstAlphaFactor: 207,\n\n\t// custom blending source factors\n\n\t//ZeroFactor: 200,\n\t//OneFactor: 201,\n\t//SrcAlphaFactor: 204,\n\t//OneMinusSrcAlphaFactor: 205,\n\t//DstAlphaFactor: 206,\n\t//OneMinusDstAlphaFactor: 207,\n\tDstColorFactor: 208,\n\tOneMinusDstColorFactor: 209,\n\tSrcAlphaSaturateFactor: 210,\n\n\t// depth modes\n\n\tNeverDepth: 0,\n\tAlwaysDepth: 1,\n\tLessDepth: 2,\n\tLessEqualDepth: 3,\n\tEqualDepth: 4,\n\tGreaterEqualDepth: 5,\n\tGreaterDepth: 6,\n\tNotEqualDepth: 7,\n\n\n\t// TEXTURE CONSTANTS\n\n\tMultiplyOperation: 0,\n\tMixOperation: 1,\n\tAddOperation: 2,\n\n\t// Tone Mapping modes\n\n\tNoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)\n\tLinearToneMapping: 1, // only apply exposure.\n\tReinhardToneMapping: 2,\n\tUncharted2ToneMapping: 3, // John Hable\n\tCineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\n\t// Mapping modes\n\n\tUVMapping: 300,\n\n\tCubeReflectionMapping: 301,\n\tCubeRefractionMapping: 302,\n\n\tEquirectangularReflectionMapping: 303,\n\tEquirectangularRefractionMapping: 304,\n\n\tSphericalReflectionMapping: 305,\n\tCubeUVReflectionMapping: 306,\n\tCubeUVRefractionMapping: 307,\n\n\t// Wrapping modes\n\n\tRepeatWrapping: 1000,\n\tClampToEdgeWrapping: 1001,\n\tMirroredRepeatWrapping: 1002,\n\n\t// Filters\n\n\tNearestFilter: 1003,\n\tNearestMipMapNearestFilter: 1004,\n\tNearestMipMapLinearFilter: 1005,\n\tLinearFilter: 1006,\n\tLinearMipMapNearestFilter: 1007,\n\tLinearMipMapLinearFilter: 1008,\n\n\t// Data types\n\n\tUnsignedByteType: 1009,\n\tByteType: 1010,\n\tShortType: 1011,\n\tUnsignedShortType: 1012,\n\tIntType: 1013,\n\tUnsignedIntType: 1014,\n\tFloatType: 1015,\n\tHalfFloatType: 1025,\n\n\t// Pixel types\n\n\t//UnsignedByteType: 1009,\n\tUnsignedShort4444Type: 1016,\n\tUnsignedShort5551Type: 1017,\n\tUnsignedShort565Type: 1018,\n\n\t// Pixel formats\n\n\tAlphaFormat: 1019,\n\tRGBFormat: 1020,\n\tRGBAFormat: 1021,\n\tLuminanceFormat: 1022,\n\tLuminanceAlphaFormat: 1023,\n\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\n\tRGBEFormat: THREE.RGBAFormat, //1024;\n\tDepthFormat: 1026,\n\n\t// DDS / ST3C Compressed texture formats\n\n\tRGB_S3TC_DXT1_Format: 2001,\n\tRGBA_S3TC_DXT1_Format: 2002,\n\tRGBA_S3TC_DXT3_Format: 2003,\n\tRGBA_S3TC_DXT5_Format: 2004,\n\n\t// PVRTC compressed texture formats\n\n\tRGB_PVRTC_4BPPV1_Format: 2100,\n\tRGB_PVRTC_2BPPV1_Format: 2101,\n\tRGBA_PVRTC_4BPPV1_Format: 2102,\n\tRGBA_PVRTC_2BPPV1_Format: 2103,\n\n\t// ETC compressed texture formats\n\n\tRGB_ETC1_Format: 2151,\n\n\t// Loop styles for AnimationAction\n\n\tLoopOnce: 2200,\n\tLoopRepeat: 2201,\n\tLoopPingPong: 2202,\n\n\t// Interpolation\n\n\tInterpolateDiscrete: 2300,\n\tInterpolateLinear: 2301,\n\tInterpolateSmooth: 2302,\n\n\t// Interpolant ending modes\n\n\tZeroCurvatureEnding: 2400,\n\tZeroSlopeEnding: 2401,\n\tWrapAroundEnding: 2402,\n\n\t// Triangle Draw modes\n\n\tTrianglesDrawMode: 0,\n\tTriangleStripDrawMode: 1,\n\tTriangleFanDrawMode: 2,\n\n\t// Texture Encodings\n\n\tLinearEncoding: 3000, // No encoding at all.\n\tsRGBEncoding: 3001,\n\tGammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\n\n\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\n\t// These encodings should not specified as output encodings except in rare situations.\n\tRGBEEncoding: 3002, // AKA Radiance.\n\tLogLuvEncoding: 3003,\n\tRGBM7Encoding: 3004,\n\tRGBM16Encoding: 3005,\n\tRGBDEncoding: 3006, // MaxRange is 256.\n\n\t// Depth packing strategies\n\n\tBasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers\n\tRGBADepthPacking: 3201 // for packing into RGBA buffers.\n\n} );\n\n// File:src/math/Color.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Color = function ( r, g, b ) {\n\n\tif ( g === undefined && b === undefined ) {\n\n\t\t// r is THREE.Color, hex or string\n\t\treturn this.set( r );\n\n\t}\n\n\treturn this.setRGB( r, g, b );\n\n};\n\nTHREE.Color.prototype = {\n\n\tconstructor: THREE.Color,\n\n\tr: 1, g: 1, b: 1,\n\n\tset: function ( value ) {\n\n\t\tif ( value instanceof THREE.Color ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSL: function () {\n\n\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\tif ( t < 0 ) t += 1;\n\t\t\tif ( t > 1 ) t -= 1;\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\treturn p;\n\n\t\t}\n\n\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\th = THREE.Math.euclideanModulo( h, 1 );\n\t\t\ts = THREE.Math.clamp( s, 0, 1 );\n\t\t\tl = THREE.Math.clamp( l, 0, 1 );\n\n\t\t\tif ( s === 0 ) {\n\n\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t} else {\n\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetStyle: function ( style ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar m;\n\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tvar color;\n\t\t\tvar name = m[ 1 ];\n\t\t\tvar components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tvar hex = m[ 1 ];\n\t\t\tvar size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( style && style.length > 0 ) {\n\n\t\t\t// color keywords\n\t\t\tvar hex = THREE.ColorKeywords[ style ];\n\n\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t// red\n\t\t\t\tthis.setHex( hex );\n\n\t\t\t} else {\n\n\t\t\t\t// unknown color\n\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t},\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function () {\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tthis.r = r * r;\n\t\tthis.g = g * g;\n\t\tthis.b = b * b;\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function () {\n\n\t\tthis.r = Math.sqrt( this.r );\n\t\tthis.g = Math.sqrt( this.g );\n\t\tthis.b = Math.sqrt( this.b );\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetHexString: function () {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t},\n\n\tgetHSL: function ( optionalTarget ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tvar max = Math.max( r, g, b );\n\t\tvar min = Math.min( r, g, b );\n\n\t\tvar hue, saturation;\n\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tvar delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\thsl.h = hue;\n\t\thsl.s = saturation;\n\t\thsl.l = lightness;\n\n\t\treturn hsl;\n\n\t},\n\n\tgetStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\toffsetHSL: function ( h, s, l ) {\n\n\t\tvar hsl = this.getHSL();\n\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t},\n\n\taddColors: function ( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n};\n\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n// File:src/math/Quaternion.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Quaternion = function ( x, y, z, w ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Quaternion.prototype = {\n\n\tconstructor: THREE.Quaternion,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget w () {\n\n\t\treturn this._w;\n\n\t},\n\n\tset w ( value ) {\n\n\t\tthis._w = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t},\n\n\tcopy: function ( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( euler, update ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\tvar order = euler.order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromUnitVectors: function () {\n\n\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tvar v1, r;\n\n\t\tvar EPS = 0.000001;\n\n\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\tif ( r < EPS ) {\n\n\t\t\t\tr = 0;\n\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t}\n\n\t\t\tthis._x = v1.x;\n\t\t\tthis._y = v1.y;\n\t\t\tthis._z = v1.z;\n\t\t\tthis._w = r;\n\n\t\t\treturn this.normalize();\n\n\t\t};\n\n\t}(),\n\n\tinverse: function () {\n\n\t\treturn this.conjugate().normalize();\n\n\t},\n\n\tconjugate: function () {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t},\n\n\tpremultiply: function ( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t},\n\n\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tslerp: function ( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\nObject.assign( THREE.Quaternion, {\n\n\tslerp: function( qa, qb, qm, t ) {\n\n\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t},\n\n\tslerpFlat: function(\n\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tvar s = 1 - t,\n\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tvar tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n} );\n\n// File:src/math/Vector2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Vector2 = function ( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n};\n\nTHREE.Vector2.prototype = {\n\n\tconstructor: THREE.Vector2,\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t},\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t},\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t},\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t},\n\n\t//\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector2();\n\t\t\t\tmax = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t},\n\n\tlengthManhattan: function() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tangle: function () {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\treturn angle;\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\trotateAround: function ( center, angle ) {\n\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tvar x = this.x - center.x;\n\t\tvar y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author *kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector3 = function ( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n};\n\nTHREE.Vector3.prototype = {\n\n\tconstructor: THREE.Vector3,\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVectors: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyEuler: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyEuler( euler ) {\n\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyAxisAngle: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\tapplyProjection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 projection matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\n\t\treturn this;\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t},\n\n\tproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function project( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\tunproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function unproject( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\ttransformDirection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector3();\n\t\t\t\tmax = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tcross: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tthis.x = y * v.z - z * v.y;\n\t\tthis.y = z * v.x - x * v.z;\n\t\tthis.z = x * v.y - y * v.x;\n\n\t\treturn this;\n\n\t},\n\n\tcrossVectors: function ( a, b ) {\n\n\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t},\n\n\tprojectOnVector: function ( vector ) {\n\n\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\n\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\n\t},\n\n\tprojectOnPlane: function () {\n\n\t\tvar v1;\n\n\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( v1 );\n\n\t\t};\n\n\t}(),\n\n\treflect: function () {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\tvar v1;\n\n\t\treturn function reflect( normal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t};\n\n\t}(),\n\n\tangleTo: function ( v ) {\n\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t},\n\n\tsetFromSpherical: function( s ) {\n\n\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixPosition: function ( m ) {\n\n\t\treturn this.setFromMatrixColumn( m, 3 );\n\n\t},\n\n\tsetFromMatrixScale: function ( m ) {\n\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\tif ( typeof m === 'number' ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\tvar temp = m\n\t\t\tm = index;\n\t\t\tindex = temp;\n\n\t\t}\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector4.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector4 = function ( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Vector4.prototype = {\n\n\tconstructor: THREE.Vector4,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\tthis.w *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\t this.x = 1;\n\t\t\t this.y = 0;\n\t\t\t this.z = 0;\n\n\t\t} else {\n\n\t\t\t this.x = q.x / s;\n\t\t\t this.y = q.y / s;\n\t\t\t this.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector4();\n\t\t\t\tmax = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\t\tthis.w = attribute.array[ index + 3 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Euler.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Euler = function ( x, y, z, order ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._order = order || THREE.Euler.DefaultOrder;\n\n};\n\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nTHREE.Euler.DefaultOrder = 'XYZ';\n\nTHREE.Euler.prototype = {\n\n\tconstructor: THREE.Euler,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget order () {\n\n\t\treturn this._order;\n\n\t},\n\n\tset order ( value ) {\n\n\t\tthis._order = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order || this._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t},\n\n\tcopy: function ( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\tvar clamp = THREE.Math.clamp;\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._y = 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromQuaternion: function () {\n\n\t\tvar matrix;\n\n\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t};\n\n\t}(),\n\n\tsetFromVector3: function ( v, order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t},\n\n\treorder: function () {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\tvar q = new THREE.Quaternion();\n\n\t\treturn function reorder( newOrder ) {\n\n\t\t\tq.setFromEuler( this );\n\t\t\t\n\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t},\n\n\ttoVector3: function ( optionalResult ) {\n\n\t\tif ( optionalResult ) {\n\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t} else {\n\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\n\n\t\t}\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\n// File:src/math/Line3.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Line3 = function ( start, end ) {\n\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\n\n};\n\nTHREE.Line3.prototype = {\n\n\tconstructor: THREE.Line3,\n\n\tset: function ( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t},\n\n\tdelta: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.end, this.start );\n\n\t},\n\n\tdistanceSq: function () {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t},\n\n\tdistance: function () {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tclosestPointToPointParameter: function () {\n\n\t\tvar startP = new THREE.Vector3();\n\t\tvar startEnd = new THREE.Vector3();\n\n\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\tstartP.subVectors( point, this.start );\n\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\tif ( clampToLine ) {\n\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\n\n\t\t\t}\n\n\t\t\treturn t;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n};\n\n// File:src/math/Box2.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Box2 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\n\n};\n\nTHREE.Box2.prototype = {\n\n\tconstructor: THREE.Box2,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Box3.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Box3 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\n\n};\n\nTHREE.Box3.prototype = {\n\n\tconstructor: THREE.Box3,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromArray: function ( array ) {\n\n\t\tvar minX = + Infinity;\n\t\tvar minY = + Infinity;\n\t\tvar minZ = + Infinity;\n\n\t\tvar maxX = - Infinity;\n\t\tvar maxY = - Infinity;\n\t\tvar maxZ = - Infinity;\n\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tvar x = array[ i ];\n\t\t\tvar y = array[ i + 1 ];\n\t\t\tvar z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function () {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromObject( object ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\n\n\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\n\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\tv1.fromArray( positions, i );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsSphere: ( function () {\n\n\t\tvar closestPoint;\n\n\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\n\n\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t};\n\n\t} )(),\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tvar min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tgetBoundingSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\n\t\t\tresult.center = this.center();\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar points = [\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3()\n\t\t];\n\n\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t// transform of empty box is an empty box.\n\t\t\tif( this.isEmpty() ) return this;\n\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Matrix3.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n * @author tschw\n */\n\nTHREE.Matrix3 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0,\n\t\t0, 1, 0,\n\t\t0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix3.prototype = {\n\n\tconstructor: THREE.Matrix3,\n\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix4: function( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t},\n\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\tif ( matrix instanceof THREE.Matrix4 ) {\n\n\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n\t\t}\n\n\t\tvar me = matrix.elements,\n\t\t\tte = this.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t},\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Matrix4.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Matrix4 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix4.prototype = {\n\n\tconstructor: THREE.Matrix4,\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Matrix4().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tthis.elements.set( m.elements );\n\n\t\treturn this;\n\n\t},\n\n\tcopyPosition: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0,       0,       0,       1\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function () {\n\n\t\tvar v1;\n\n\t\treturn function extractRotation( m ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeRotationFromEuler: function ( euler ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\tte[ 4 ] = xy - wz;\n\t\tte[ 8 ] = xz + wy;\n\n\t\tte[ 1 ] = xy + wz;\n\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\tte[ 9 ] = yz - wx;\n\n\t\tte[ 2 ] = xz - wy;\n\t\tte[ 6 ] = yz + wx;\n\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function () {\n\n\t\tvar x, y, z;\n\n\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\tif ( x === undefined ) {\n\n\t\t\t\tx = new THREE.Vector3();\n\t\t\t\ty = new THREE.Vector3();\n\t\t\t\tz = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\tz.z = 1;\n\n\t\t\t}\n\n\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\tz.z += 0.0001;\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t}\n\n\t\t\ty.crossVectors( z, x );\n\n\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tpremultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyToArray: function ( a, b, r ) {\n\n\t\tvar te = this.elements;\n\n\t\tthis.multiplyMatrices( a, b );\n\n\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetPosition: function () {\n\n\t\tvar v1;\n\n\t\treturn function getPosition() {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t};\n\n\t}(),\n\n\tsetPosition: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 12 ] = v.x;\n\t\tte[ 13 ] = v.y;\n\t\tte[ 14 ] = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements,\n\t\t\tme = m.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t},\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0,  0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s,  c, 0,\n\t\t\t0, 0,  0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts,  c, 0, 0,\n\t\t\t0,  0, 1, 0,\n\t\t\t0,  0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function ( position, quaternion, scale ) {\n\n\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\tthis.scale( scale );\n\t\tthis.setPosition( position );\n\n\t\treturn this;\n\n\t},\n\n\tdecompose: function () {\n\n\t\tvar vector, matrix;\n\n\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tvector = new THREE.Vector3();\n\t\t\t\tmatrix = new THREE.Matrix4();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t// if determine is negative, we need to invert one scale\n\t\t\tvar det = this.determinant();\n\t\t\tif ( det < 0 ) {\n\n\t\t\t\tsx = - sx;\n\n\t\t\t}\n\n\t\t\tposition.x = te[ 12 ];\n\t\t\tposition.y = te[ 13 ];\n\t\t\tposition.z = te[ 14 ];\n\n\t\t\t// scale the rotation part\n\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\tvar invSX = 1 / sx;\n\t\t\tvar invSY = 1 / sy;\n\t\t\tvar invSZ = 1 / sz;\n\n\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\tvar ymin = - ymax;\n\t\tvar xmin = ymin * aspect;\n\t\tvar xmax = ymax * aspect;\n\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = 1.0 / ( right - left );\n\t\tvar h = 1.0 / ( top - bottom );\n\t\tvar p = 1.0 / ( far - near );\n\n\t\tvar x = ( right + left ) * w;\n\t\tvar y = ( top + bottom ) * h;\n\t\tvar z = ( far + near ) * p;\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( matrix ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = matrix.elements;\n\n\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Ray.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Ray = function ( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\n};\n\nTHREE.Ray.prototype = {\n\n\tconstructor: THREE.Ray,\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\tlookAt: function ( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\trecast: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function recast( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.subVectors( point, this.origin );\n\t\tvar directionDistance = result.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn result.copy( this.origin );\n\n\t\t}\n\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t},\n\n\tdistanceSqToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t// point behind the ray\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t}\n\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\treturn v1.distanceToSquared( point );\n\n\t\t};\n\n\t}(),\n\n\tdistanceSqToSegment: function () {\n\n\t\tvar segCenter = new THREE.Vector3();\n\t\tvar segDir = new THREE.Vector3();\n\t\tvar diff = new THREE.Vector3();\n\n\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\tvar c = diff.lengthSq();\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\tif ( det > 0 ) {\n\n\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\n\t\t};\n\n\t}(),\n\n\tintersectSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\tvar tca = v1.dot( this.direction );\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\tvar t0 = tca - thc;\n\n\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\tvar t1 = tca + thc;\n\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t// test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t :  null;\n\n\t},\n\n\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\tvar t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, optionalTarget );\n\n\t},\n\n\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tintersectBox: function ( box, optionalTarget ) {\n\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tvar invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tvar origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t},\n\n\tintersectsBox: ( function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t};\n\n\t} )(),\n\n\tintersectTriangle: function () {\n\n\t\t// Compute the offset origin, edges, and normal.\n\t\tvar diff = new THREE.Vector3();\n\t\tvar edge1 = new THREE.Vector3();\n\t\tvar edge2 = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\n\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\tedge1.subVectors( b, a );\n\t\t\tedge2.subVectors( c, a );\n\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\tvar sign;\n\n\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\tsign = 1;\n\n\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\tsign = - 1;\n\t\t\t\tDdN = - DdN;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tdiff.subVectors( this.origin, a );\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t// b1 < 0, no intersection\n\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t// b2 < 0, no intersection\n\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// b1+b2 > 1, no intersection\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Line intersects triangle, check if ray does.\n\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t// t < 0, no intersection\n\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Ray intersects triangle.\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.sub( this.origin );\n\t\tthis.direction.normalize();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n};\n\n// File:src/math/Sphere.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Sphere = function ( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n};\n\nTHREE.Sphere.prototype = {\n\n\tconstructor: THREE.Sphere,\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function () {\n\n\t\tvar box = new THREE.Box3();\n\n\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\tvar center = this.center;\n\n\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromPoints( points ).center( center );\n\n\t\t\t}\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We use the following equation to compute the signed distance from\n\t\t// the center of the sphere to the plane.\n\t\t//\n\t\t// distance = q * n - d\n\t\t//\n\t\t// If this distance is greater than the radius of the sphere,\n\t\t// then there is no intersection.\n\n\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tresult.sub( this.center ).normalize();\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\tvar box = optionalTarget || new THREE.Box3();\n\n\t\tbox.set( this.center, this.center );\n\t\tbox.expandByScalar( this.radius );\n\n\t\treturn box;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n};\n\n// File:src/math/Frustum.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://clara.io\n */\n\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\n\tthis.planes = [\n\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\n\t];\n\n};\n\nTHREE.Frustum.prototype = {\n\n\tconstructor: THREE.Frustum,\n\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tvar planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( frustum ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix: function ( m ) {\n\n\t\tvar planes = this.planes;\n\t\tvar me = m.elements;\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\tintersectsObject: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsObject( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSprite: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar planes = this.planes;\n\t\tvar center = sphere.center;\n\t\tvar negRadius = - sphere.radius;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsBox: function () {\n\n\t\tvar p1 = new THREE.Vector3(),\n\t\t\tp2 = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\n\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t}(),\n\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n};\n\n// File:src/math/Plane.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Plane = function ( normal, constant ) {\n\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n};\n\nTHREE.Plane.prototype = {\n\n\tconstructor: THREE.Plane,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t},\n\n\torthoPoint: function ( point, optionalTarget ) {\n\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t},\n\n\tintersectLine: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tvar direction = line.delta( v1 );\n\n\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t};\n\n\t}(),\n\n\tintersectsLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t},\n\n\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar m1 = new THREE.Matrix3();\n\n\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t// transform normal based on theory here:\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n};\n\n// File:src/math/Spherical.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The poles (phi) are at the positive and negative y axis.\n * The equator starts at positive z.\n */\n\nTHREE.Spherical = function ( radius, phi, theta ) {\n\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\treturn this;\n\n};\n\nTHREE.Spherical.prototype = {\n\n\tconstructor: THREE.Spherical,\n\n\tset: function ( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( other ) {\n\n\t\tthis.radius.copy( other.radius );\n\t\tthis.phi.copy( other.phi );\n\t\tthis.theta.copy( other.theta );\n\n\t\treturn this;\n\n\t},\n\n\t// restrict phi to be betwee EPS and PI-EPS\n\tmakeSafe: function() {\n\n\t\tvar EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromVector3: function( vec3 ) {\n\n\t\tthis.radius = vec3.length();\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n};\n\n// File:src/math/Math.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Math = {\n\n\tDEG2RAD: Math.PI / 180,\n\tRAD2DEG: 180 / Math.PI,\n\n\tgenerateUUID: function () {\n\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\tvar uuid = new Array( 36 );\n\t\tvar rnd = 0, r;\n\n\t\treturn function generateUUID() {\n\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n\t\t\t\t\tuuid[ i ] = '-';\n\n\t\t\t\t} else if ( i === 14 ) {\n\n\t\t\t\t\tuuid[ i ] = '4';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uuid.join( '' );\n\n\t\t};\n\n\t}(),\n\n\tclamp: function ( value, min, max ) {\n\n\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t},\n\n\t// compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\teuclideanModulo: function ( n, m ) {\n\n\t\treturn ( ( n % m ) + m ) % m;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * ( 3 - 2 * x );\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t},\n\n\trandom16: function () {\n\n\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\treturn Math.random();\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tdegToRad: function ( degrees ) {\n\n\t\treturn degrees * THREE.Math.DEG2RAD;\n\n\t},\n\n\tradToDeg: function ( radians ) {\n\n\t\treturn radians * THREE.Math.RAD2DEG;\n\n\t},\n\n\tisPowerOfTwo: function ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t},\n\n\tnearestPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n\t},\n\n\tnextPowerOfTwo: function ( value ) {\n\n\t\tvalue --;\n\t\tvalue |= value >> 1;\n\t\tvalue |= value >> 2;\n\t\tvalue |= value >> 4;\n\t\tvalue |= value >> 8;\n\t\tvalue |= value >> 16;\n\t\tvalue ++;\n\n\t\treturn value;\n\n\t}\n\n};\n\n// File:src/math/Spline.js\n\n/**\n * Spline from Tween.js, slightly optimized (and trashed)\n * http://sole.github.com/tween.js/examples/05_spline.html\n *\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Spline = function ( points ) {\n\n\tthis.points = points;\n\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tthis.initFromArray = function ( a ) {\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t}\n\n\t};\n\n\tthis.getPoint = function ( k ) {\n\n\t\tpoint = ( this.points.length - 1 ) * k;\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\tpa = this.points[ c[ 0 ] ];\n\t\tpb = this.points[ c[ 1 ] ];\n\t\tpc = this.points[ c[ 2 ] ];\n\t\tpd = this.points[ c[ 3 ] ];\n\n\t\tw2 = weight * weight;\n\t\tw3 = weight * w2;\n\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\treturn v3;\n\n\t};\n\n\tthis.getControlPointsArray = function () {\n\n\t\tvar i, p, l = this.points.length,\n\t\t\tcoords = [];\n\n\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\tp = this.points[ i ];\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t}\n\n\t\treturn coords;\n\n\t};\n\n\t// approximate length by summing linear segments\n\n\tthis.getLength = function ( nSubDivisions ) {\n\n\t\tvar i, index, nSamples, position,\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\toldPosition = new THREE.Vector3(),\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tchunkLengths = [],\n\t\t\ttotalLength = 0;\n\n\t\t// first point has 0 length\n\n\t\tchunkLengths[ 0 ] = 0;\n\n\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\n\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\tindex = i / nSamples;\n\n\t\t\tposition = this.getPoint( index );\n\t\t\ttmpVec.copy( position );\n\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\toldPosition.copy( position );\n\n\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\tintPoint = Math.floor( point );\n\n\t\t\tif ( intPoint !== oldIntPoint ) {\n\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// last point ends with total length\n\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t};\n\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\tvar i, j,\n\t\t\tindex, indexCurrent, indexNext,\n\t\t\trealDistance,\n\t\t\tsampling, position,\n\t\t\tnewpoints = [],\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tsl = this.getLength();\n\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t}\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t}\n\n\t\tthis.points = newpoints;\n\n\t};\n\n\t// Catmull-Rom\n\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/math/Triangle.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Triangle = function ( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\n};\n\nTHREE.Triangle.normal = function () {\n\n\tvar v0 = new THREE.Vector3();\n\n\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.subVectors( c, b );\n\t\tv0.subVectors( a, b );\n\t\tresult.cross( v0 );\n\n\t\tvar resultLengthSq = result.lengthSq();\n\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t}\n\n\t\treturn result.set( 0, 0, 0 );\n\n\t};\n\n}();\n\n// static/instance method to calculate barycentric coordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\nTHREE.Triangle.barycoordFromPoint = function () {\n\n\tvar v0 = new THREE.Vector3();\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\n\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\tv0.subVectors( c, a );\n\t\tv1.subVectors( b, a );\n\t\tv2.subVectors( point, a );\n\n\t\tvar dot00 = v0.dot( v0 );\n\t\tvar dot01 = v0.dot( v1 );\n\t\tvar dot02 = v0.dot( v2 );\n\t\tvar dot11 = v1.dot( v1 );\n\t\tvar dot12 = v1.dot( v2 );\n\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tvar invDenom = 1 / denom;\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn result.set( 1 - u - v, v, u );\n\n\t};\n\n}();\n\nTHREE.Triangle.containsPoint = function () {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function containsPoint( point, a, b, c ) {\n\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t};\n\n}();\n\nTHREE.Triangle.prototype = {\n\n\tconstructor: THREE.Triangle,\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tarea: function () {\n\n\t\tvar v0 = new THREE.Vector3();\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function area() {\n\n\t\t\tv0.subVectors( this.c, this.b );\n\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t};\n\n\t}(),\n\n\tmidpoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tnormal: function ( optionalTarget ) {\n\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tplane: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Plane();\n\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tclosestPointToPoint: function () {\n\n\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\n\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\tif ( plane === undefined ) {\n\n\t\t\t\tplane = new THREE.Plane();\n\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\n\t\t\t\tprojectedPoint = new THREE.Vector3();\n\t\t\t\tclosestPoint = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\tvar minDistance = Infinity;\n\n\t\t\t// project the point onto the plane of the triangle\n\n\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t// check if the projection lies within the triangle\n\n\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t// if so, this is the closest point\n\n\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t} else {\n\n\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\tif( distance < minDistance ) {\n\n\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n};\n\n// File:src/math/Interpolant.js\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n * @author tschw\n */\n\nTHREE.Interpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tthis.parameterPositions = parameterPositions;\n\tthis._cachedIndex = 0;\n\n\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\tthis.sampleValues = sampleValues;\n\tthis.valueSize = sampleSize;\n\n};\n\nTHREE.Interpolant.prototype = {\n\n\tconstructor: THREE.Interpolant,\n\n\tevaluate: function( t ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\ti1 = this._cachedIndex,\n\n\t\t\tt1 = pp[   i1   ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tvar right;\n\n\t\t\t\tlinear_scan: {\n//- See http://jsperf.com/comparison-to-undefined/3\n//- slower code:\n//-\n//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n//- slower code:\n//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t},\n\n\tsettings: null, // optional, subclass-specific settings structure\n\t// Note: The indirection allows central control of many interpolants.\n\n\t// --- Protected interface\n\n\tDefaultSettings_: {},\n\n\tgetSettings_: function() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t},\n\n\tcopySampleValue_: function( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Template methods for derived classes:\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tthrow new Error( \"call to abstract method\" );\n\t\t// implementations shall return this.resultBuffer\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t// empty\n\n\t}\n\n};\n\nObject.assign( THREE.Interpolant.prototype, {\n\n\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_,\n\n\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_\n\n} );\n\n// File:src/math/interpolants/CubicInterpolant.js\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n *\n * @author tschw\n */\n\nTHREE.CubicInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\tthis._weightPrev = -0;\n\tthis._offsetPrev = -0;\n\tthis._weightNext = -0;\n\tthis._offsetNext = -0;\n\n};\n\nTHREE.CubicInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.CubicInterpolant,\n\n\tDefaultSettings_: {\n\n\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\tiPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t},\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/DiscreteInterpolant.js\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n *\n * @author tschw\n */\n\nTHREE.DiscreteInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.DiscreteInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.DiscreteInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n} );\n\n// File:src/math/interpolants/LinearInterpolant.js\n\n/**\n * @author tschw\n */\n\nTHREE.LinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.LinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.LinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/QuaternionLinearInterpolant.js\n\n/**\n * Spherical linear unit quaternion interpolant.\n *\n * @author tschw\n */\n\nTHREE.QuaternionLinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.QuaternionLinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.QuaternionLinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset = i1 * stride,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\n\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/core/Clock.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Clock = function ( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n};\n\nTHREE.Clock.prototype = {\n\n\tconstructor: THREE.Clock,\n\n\tstart: function () {\n\n\t\tthis.startTime = ( performance || Date ).now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.running = true;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\n\t},\n\n\tgetElapsedTime: function () {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t},\n\n\tgetDelta: function () {\n\n\t\tvar diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tvar newTime = ( performance || Date ).now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n};\n\n// File:src/core/EventDispatcher.js\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nTHREE.EventDispatcher = function () {};\n\nObject.assign( THREE.EventDispatcher.prototype, {\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function ( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\tvar array = [], i = 0;\n\t\t\tvar length = listenerArray.length;\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/core/Layers.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Layers = function () {\n\n\tthis.mask = 1;\n\n};\n\nTHREE.Layers.prototype = {\n\n\tconstructor: THREE.Layers,\n\n\tset: function ( channel ) {\n\n\t\tthis.mask = 1 << channel;\n\n\t},\n\n\tenable: function ( channel ) {\n\n\t\tthis.mask |= 1 << channel;\n\n\t},\n\n\ttoggle: function ( channel ) {\n\n\t\tthis.mask ^= 1 << channel;\n\n\t},\n\n\tdisable: function ( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel );\n\n\t},\n\n\ttest: function ( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n};\n\n// File:src/core/Raycaster.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://clara.io/\n * @author stephomi / http://stephaneginier.com/\n */\n\n( function ( THREE ) {\n\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\n\t\tthis.ray = new THREE.Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t};\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tTHREE.Raycaster.prototype = {\n\n\t\tconstructor: THREE.Raycaster,\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t};\n\n}( THREE ) );\n\n// File:src/core/Object3D.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author elephantatwork / www.elephantatwork.ch\n */\n\nTHREE.Object3D = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Object3D';\n\n\tthis.parent = null;\n\tthis.children = [];\n\n\tthis.up = THREE.Object3D.DefaultUp.clone();\n\n\tvar position = new THREE.Vector3();\n\tvar rotation = new THREE.Euler();\n\tvar quaternion = new THREE.Quaternion();\n\tvar scale = new THREE.Vector3( 1, 1, 1 );\n\n\tfunction onRotationChange() {\n\n\t\tquaternion.setFromEuler( rotation, false );\n\n\t}\n\n\tfunction onQuaternionChange() {\n\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t}\n\n\trotation.onChange( onRotationChange );\n\tquaternion.onChange( onQuaternionChange );\n\n\tObject.defineProperties( this, {\n\t\tposition: {\n\t\t\tenumerable: true,\n\t\t\tvalue: position\n\t\t},\n\t\trotation: {\n\t\t\tenumerable: true,\n\t\t\tvalue: rotation\n\t\t},\n\t\tquaternion: {\n\t\t\tenumerable: true,\n\t\t\tvalue: quaternion\n\t\t},\n\t\tscale: {\n\t\t\tenumerable: true,\n\t\t\tvalue: scale\n\t\t},\n\t\tmodelViewMatrix: {\n\t\t\tvalue: new THREE.Matrix4()\n\t\t},\n\t\tnormalMatrix: {\n\t\t\tvalue: new THREE.Matrix3()\n\t\t}\n\t} );\n\n\tthis.matrix = new THREE.Matrix4();\n\tthis.matrixWorld = new THREE.Matrix4();\n\n\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\n\tthis.matrixWorldNeedsUpdate = false;\n\n\tthis.layers = new THREE.Layers();\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\tthis.renderOrder = 0;\n\n\tthis.userData = {};\n\n};\n\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\n\nObject.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t},\n\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t},\n\n\tsetRotationFromEuler: function ( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t},\n\n\tsetRotationFromMatrix: function ( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t},\n\n\trotateOnAxis: function () {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar q1 = new THREE.Quaternion();\n\n\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\ttranslateOnAxis: function () {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function translateX( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function translateY( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function translateZ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function () {\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function worldToLocal( vector ) {\n\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object instanceof THREE.Object3D ) {\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\tthis.children.push( object );\n\n\t\t} else {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t}\n\n\t},\n\n\tgetObjectById: function ( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t},\n\n\tgetObjectByName: function ( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t},\n\n\tgetObjectByProperty: function ( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t},\n\n\tgetWorldQuaternion: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar scale = new THREE.Vector3();\n\n\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Quaternion();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldRotation: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Euler();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t};\n\n\t}(),\n\n\tgetWorldScale: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldDirection: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t};\n\n\t}(),\n\n\traycast: function () {},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseVisible: function ( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseAncestors: function ( callback ) {\n\n\t\tvar parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\t// meta is '' when called from JSON.stringify\n\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\n\t\tvar output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tvar object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\n\t\tobject.matrix = this.matrix.toArray();\n\n\t\t//\n\n\t\tif ( this.geometry !== undefined ) {\n\n\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.geometry = this.geometry.uuid;\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\n\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.material = this.material.uuid;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\t\t\treturn values;\n\n\t\t}\n\n\t},\n\n\tclone: function ( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t},\n\n\tcopy: function ( source, recursive ) {\n\n\t\tif ( recursive === undefined ) recursive = true;\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tvar child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\nTHREE.Object3DIdCount = 0;\n\n// File:src/core/Face3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n};\n\nTHREE.Face3.prototype = {\n\n\tconstructor: THREE.Face3,\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.a = source.a;\n\t\tthis.b = source.b;\n\t\tthis.c = source.c;\n\n\t\tthis.normal.copy( source.normal );\n\t\tthis.color.copy( source.color );\n\n\t\tthis.materialIndex = source.materialIndex;\n\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/BufferAttribute.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.itemSize = itemSize;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\tthis.normalized = normalized === true;\n\n};\n\nTHREE.BufferAttribute.prototype = {\n\n\tconstructor: THREE.BufferAttribute,\n\n\tget count() {\n\n\t\treturn this.array.length / this.itemSize;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyArray: function ( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t},\n\n\tcopyColorsArray: function ( colors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\tvar color = colors[ i ];\n\n\t\t\tif ( color === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\tcolor = new THREE.Color();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = color.r;\n\t\t\tarray[ offset ++ ] = color.g;\n\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyIndicesArray: function ( indices ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tvar index = indices[ i ];\n\n\t\t\tarray[ offset ++ ] = index.a;\n\t\t\tarray[ offset ++ ] = index.b;\n\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector2sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector3sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector4sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize ];\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n//\n\nTHREE.Int8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\n};\n\nTHREE.Int16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\n\n};\n\nTHREE.Uint16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\n\n};\n\nTHREE.Int32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\n\n};\n\nTHREE.Uint32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\n\n};\n\nTHREE.Float32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\n\n};\n\nTHREE.Float64Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\n\n};\n\n\n// Deprecated\n\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\n\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\n\n};\n\n// File:src/core/InstancedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\n\n\tTHREE.BufferAttribute.call( this, array, itemSize );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\n\nTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\n\n\tTHREE.BufferAttribute.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBuffer = function ( array, stride ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.stride = stride;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n};\n\nTHREE.InterleavedBuffer.prototype = {\n\n\tconstructor: THREE.InterleavedBuffer,\n\n\tget length () {\n\n\t\treturn this.array.length;\n\n\t},\n\n\tget count () {\n\n\t\treturn this.array.length / this.stride;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.stride = source.stride;\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n// File:src/core/InstancedInterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\n\n\tTHREE.InterleavedBuffer.call( this, array, stride );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\n\nTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.data = interleavedBuffer;\n\tthis.itemSize = itemSize;\n\tthis.offset = offset;\n\n};\n\n\nTHREE.InterleavedBufferAttribute.prototype = {\n\n\tconstructor: THREE.InterleavedBufferAttribute,\n\n\tget length() {\n\n\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\treturn this.array.length;\n\n\t},\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/Geometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://clara.io\n */\n\nTHREE.Geometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [ [] ];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.elementsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tvar scope = this;\n\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tvar tempNormals = [];\n\t\tvar tempUVs = [];\n\t\tvar tempUVs2 = [];\n\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( indices !== undefined ) {\n\n\t\t\tvar groups = geometry.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tvar center = this.boundingSphere.center;\n\t\tvar radius = this.boundingSphere.radius;\n\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tvar matrix = new THREE.Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\tvertices = new Array( this.vertices.length );\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new THREE.Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t},\n\n\tcomputeLineDistances: function () {\n\n\t\tvar d = 0;\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tif ( i > 0 ) {\n\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\tif ( geometry instanceof THREE.Geometry === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalMatrix,\n\t\tvertexOffset = this.vertices.length,\n\t\tvertices1 = this.vertices,\n\t\tvertices2 = geometry.vertices,\n\t\tfaces1 = this.faces,\n\t\tfaces2 = geometry.faces,\n\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tif ( uv === undefined ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( mesh instanceof THREE.Mesh === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i, il, face;\n\t\tvar indices, j, jl;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\tvar dupIndex = - 1;\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tdupIndex = n;\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tvar faces = this.faces;\n\t\tvar length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tvar newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tvar faces = [];\n\t\tvar normals = [];\n\t\tvar normalsHash = {};\n\t\tvar colors = [];\n\t\tvar colorsHash = {};\n\t\tvar uvs = [];\n\t\tvar uvsHash = {};\n\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tvar hasMaterial = true;\n\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tvar faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.vertices = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\n\t\tvar vertices = source.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\tvar faces = source.faces;\n\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.GeometryIdCount = 0;\n\n// File:src/core/DirectGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'DirectGeometry';\n\n\tthis.indices = [];\n\tthis.vertices = [];\n\tthis.normals = [];\n\tthis.colors = [];\n\tthis.uvs = [];\n\tthis.uvs2 = [];\n\n\tthis.groups = [];\n\n\tthis.morphTargets = {};\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\t// this.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\n\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\n\n\tcomputeFaceNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeGroups: function ( geometry ) {\n\n\t\tvar group;\n\t\tvar groups = [];\n\t\tvar materialIndex;\n\n\t\tvar faces = geometry.faces;\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tvar faces = geometry.faces;\n\t\tvar vertices = geometry.vertices;\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tvar morphTargets = geometry.morphTargets;\n\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\tvar morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tvar morphNormals = geometry.morphNormals;\n\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\tvar morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tvar skinIndices = geometry.skinIndices;\n\t\tvar skinWeights = geometry.skinWeights;\n\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/core/BufferGeometry.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n};\n\nObject.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tthis.index = index;\n\n\t},\n\n\taddAttribute: function ( name, attribute ) {\n\n\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( name === 'index' ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\tthis.setIndex( attribute );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tremoveAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tvar normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tsetFromObject: function ( object ) {\n\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\n\n\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\n\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tupdateFromObject: function ( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\tif ( direct === undefined ) {\n\n\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\tgeometry = direct;\n\n\t\t}\n\n\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.position;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.normal;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.color;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\tvar attribute = this.attributes.uv;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\tvar attribute = this.attributes.lineDistance;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\n\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t},\n\n\tfromDirectGeometry: function ( geometry ) {\n\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tthis.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tvar positions = this.attributes.position.array;\n\n\t\tif ( positions !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromArray( positions );\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar box = new THREE.Box3();\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function computeBoundingSphere() {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes.position;\n\n\t\t\tif ( positions ) {\n\n\t\t\t\tvar array = positions.array;\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tbox.setFromArray( array );\n\t\t\t\tbox.center( center );\n\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tvar index = this.index;\n\t\tvar attributes = this.attributes;\n\t\tvar groups = this.groups;\n\n\t\tif ( attributes.position ) {\n\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar normals = attributes.normal.array;\n\n\t\t\tvar vA, vB, vC,\n\n\t\t\tpA = new THREE.Vector3(),\n\t\t\tpB = new THREE.Vector3(),\n\t\t\tpC = new THREE.Vector3(),\n\n\t\t\tcb = new THREE.Vector3(),\n\t\t\tab = new THREE.Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tvar attribute1 = attributes[ key ];\n\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar normals = this.attributes.normal.array;\n\n\t\tvar x, y, z, n;\n\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\tx = normals[ i ];\n\t\t\ty = normals[ i + 1 ];\n\t\t\tz = normals[ i + 2 ];\n\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\tnormals[ i ] *= n;\n\t\t\tnormals[ i + 1 ] *= n;\n\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t}\n\n\t},\n\n\ttoNonIndexed: function () {\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar geometry2 = new THREE.BufferGeometry();\n\n\t\tvar indices = this.index.array;\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tvar index = 0, index2 = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tdata.data = { attributes: {} };\n\n\t\tvar index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: array\n\t\t\t};\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: attribute.normalized\n\t\t\t};\n\n\t\t}\n\n\t\tvar groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tvar boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.BufferGeometry.MaxIndex = 65535;\n\n// File:src/core/InstancedBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferGeometry = function () {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'InstancedBufferGeometry';\n\tthis.maxInstancedCount = undefined;\n\n};\n\nTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\n\nTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\n\n\tthis.groups.push( {\n\n\t\tstart: start,\n\t\tcount: count,\n\t\tinstances: instances\n\n\t} );\n\n};\n\nTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\n\n\tvar index = source.index;\n\n\tif ( index !== null ) {\n\n\t\tthis.setIndex( index.clone() );\n\n\t}\n\n\tvar attributes = source.attributes;\n\n\tfor ( var name in attributes ) {\n\n\t\tvar attribute = attributes[ name ];\n\t\tthis.addAttribute( name, attribute.clone() );\n\n\t}\n\n\tvar groups = source.groups;\n\n\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tvar group = groups[ i ];\n\t\tthis.addGroup( group.start, group.count, group.instances );\n\n\t}\n\n\treturn this;\n\n};\n\n// File:src/core/Uniform.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Uniform = function ( value ) {\n\n\tif ( typeof value === 'string' ) {\n\n\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\tvalue = arguments[ 1 ];\n\n\t}\n\n\tthis.value = value;\n\n\tthis.dynamic = false;\n\n};\n\nTHREE.Uniform.prototype = {\n\n\tconstructor: THREE.Uniform,\n\n\tonUpdate: function ( callback ) {\n\n\t\tthis.dynamic = true;\n\t\tthis.onUpdateCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/animation/AnimationAction.js\n\n/**\n *\n * Action provided by AnimationMixer for scheduling clip playback on specific\n * objects.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n *\n */\n\nTHREE.AnimationAction = function() {\n\n\tthrow new Error( \"THREE.AnimationAction: \" +\n\t\t\t\"Use mixer.clipAction for construction.\" );\n\n};\n\nTHREE.AnimationAction._new =\n\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\tthis._mixer = mixer;\n\tthis._clip = clip;\n\tthis._localRoot = localRoot || null;\n\n\tvar tracks = clip.tracks,\n\t\tnTracks = tracks.length,\n\t\tinterpolants = new Array( nTracks );\n\n\tvar interpolantSettings = {\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\t};\n\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\tinterpolants[ i ] = interpolant;\n\t\tinterpolant.settings = interpolantSettings;\n\n\t}\n\n\tthis._interpolantSettings = interpolantSettings;\n\n\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t// inside: PropertyMixer (managed by the mixer)\n\tthis._propertyBindings = new Array( nTracks );\n\n\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\tthis._timeScaleInterpolant = null;\n\tthis._weightInterpolant = null;\n\n\tthis.loop = THREE.LoopRepeat;\n\tthis._loopCount = -1;\n\n\t// global mixer time when the action is to be started\n\t// it's set back to 'null' upon start of the action\n\tthis._startTime = null;\n\n\t// scaled local time of the action\n\t// gets clamped or wrapped to 0..clip.duration according to loop\n\tthis.time = 0;\n\n\tthis.timeScale = 1;\n\tthis._effectiveTimeScale = 1;\n\n\tthis.weight = 1;\n\tthis._effectiveWeight = 1;\n\n\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\n\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n};\n\nTHREE.AnimationAction._new.prototype = {\n\n\tconstructor: THREE.AnimationAction._new,\n\n\t// State & Scheduling\n\n\tplay: function() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t},\n\n\tstop: function() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t},\n\n\treset: function() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0;\t\t\t// restart clip\n\t\tthis._loopCount = -1;\t// forget previous loops\n\t\tthis._startTime = null;\t// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t},\n\n\tisRunning: function() {\n\n\t\tvar start = this._startTime;\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t},\n\n\t// return true when play has been called\n\tisScheduled: function() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t},\n\n\tstartAt: function( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t},\n\n\tsetLoop: function( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t},\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight: function( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t},\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight: function() {\n\n\t\treturn this._effectiveWeight;\n\n\t},\n\n\tfadeIn: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t},\n\n\tfadeOut: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t},\n\n\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n\t\tvar mixer = this._mixer;\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif( warp ) {\n\n\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t},\n\n\tstopFading: function() {\n\n\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Time Scale Control\n\n\t// set the weight stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale: function( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale: function() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t},\n\n\tsetDuration: function( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\tsyncWith: function( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\thalt: function( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t},\n\n\twarp: function( startTimeScale, endTimeScale, duration ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t},\n\n\tstopWarping: function() {\n\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Object Accessors\n\n\tgetMixer: function() {\n\n\t\treturn this._mixer;\n\n\t},\n\n\tgetClip: function() {\n\n\t\treturn this._clip;\n\n\t},\n\n\tgetRoot: function() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t},\n\n\t// Interna\n\n\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t// called by the mixer\n\n\t\tvar startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tvar weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tvar interpolants = this._interpolants;\n\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_updateWeight: function( time ) {\n\n\t\tvar weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t},\n\n\t_updateTimeScale: function( time ) {\n\n\t\tvar timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t},\n\n\t_updateTime: function( deltaTime ) {\n\n\t\tvar time = this.time + deltaTime;\n\n\t\tif ( deltaTime === 0 ) return time;\n\n\t\tvar duration = this._clip.duration,\n\n\t\t\tloop = this.loop,\n\t\t\tloopCount = this._loopCount;\n\n\t\tif ( loop === THREE.LoopOnce ) {\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tthis.loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else break handle_stop;\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tvar pingPong = ( loop === THREE.LoopPingPong );\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t// wrap around\n\n\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\tthis.time = time;\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.time = time;\n\t\treturn time;\n\n\t},\n\n\t_setEndings: function( atStart, atEnd, pingPong ) {\n\n\t\tvar settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\n\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationClip.js\n\n/**\n *\n * Reusable set of Tracks that represent an animation.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationClip = function ( name, duration, tracks ) {\n\n\tthis.name = name;\n\tthis.tracks = tracks;\n\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// this means it should figure out its duration by scanning the tracks\n\tif ( this.duration < 0 ) {\n\n\t\tthis.resetDuration();\n\n\t}\n\n\t// maybe only do these on demand, as doing them here could potentially slow down loading\n\t// but leaving these here during development as this ensures a lot of testing of these functions\n\tthis.trim();\n\tthis.optimize();\n\n};\n\nTHREE.AnimationClip.prototype = {\n\n\tconstructor: THREE.AnimationClip,\n\n\tresetDuration: function() {\n\n\t\tvar tracks = this.tracks,\n\t\t\tduration = 0;\n\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tvar track = this.tracks[ i ];\n\n\t\t\tduration = Math.max(\n\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t},\n\n\ttrim: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\toptimize: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.AnimationClip, {\n\n\tparse: function( json ) {\n\n\t\tvar tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\n\n\t},\n\n\n\ttoJSON: function( clip ) {\n\n\t\tvar tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tvar json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks\n\n\t\t};\n\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t},\n\n\n\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tvar times = [];\n\t\t\tvar values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\ti,\n\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\t\tnew THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\ttimes, values\n\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t}\n\n\t\treturn new THREE.AnimationClip( name, -1, tracks );\n\n\t},\n\n\tfindByName: function( objectOrClipArray, name ) {\n\n\t\tvar clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tvar o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\n\t\tvar animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar clips = [];\n\n\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t},\n\n\t// parse the animation.hierarchy format\n\tparseAnimation: function( animation, bones, nodeName ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar addNonemptyTrack = function(\n\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\tTHREE.AnimationUtils.flattenJSON(\n\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar tracks = [];\n\n\t\tvar clipName = animation.name || 'default';\n\t\t// automatic length determination in AnimationClip.\n\t\tvar duration = animation.length || -1;\n\t\tvar fps = animation.fps || 30;\n\n\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets in a way exactly compatible\n\t\t\t// with AnimationHandler.init( animation )\n\t\t\tif ( animationKeys[0].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tvar morphTargetNames = {};\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\n\n\t\treturn clip;\n\n\t}\n\n} );\n\n// File:src/animation/AnimationMixer.js\n\n/**\n *\n * Player for AnimationClips.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.AnimationMixer = function( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n};\n\nObject.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\tprototypeAction = null;\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tvar existingAction =\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tvar newAction = new THREE.\n\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function() {\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tthis._nActiveActions = 0;\n\t\tthis._nActiveBindings = 0;\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tactions[ i ].reset();\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].useCount = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tvar action = actions[ i ];\n\n\t\t\tif ( action.enabled ) {\n\n\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tvar bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function() {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function( clip ) {\n\n\t\tvar actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function( root ) {\n\n\t\tvar rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function( clip, optionalRoot ) {\n\n\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\nTHREE.AnimationMixer._Action = THREE.AnimationAction._new;\n\n// Implementation details:\n\nObject.assign( THREE.AnimationMixer.prototype, {\n\n\t_bindAction: function( action, prototypeAction ) {\n\n\t\tvar root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar track = tracks[ i ],\n\t\t\t\ttrackName = track.name,\n\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new THREE.PropertyMixer(\n\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\n\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for _Action objects\n\n\t_isActiveAction: function( action ) {\n\n\t\tvar index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\n\t\tvar actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function( action ) {\n\n\t\tvar actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tvar clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function( action ) {\n\n\t\tvar bindings = action._propertyBindings;\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tvar binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tbindings = this._bindings;\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tremove_empty_map: {\n\n\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function() {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new THREE.LinearInterpolant(\n\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function( interpolant ) {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\n} );\n\n// File:src/animation/AnimationObjectGroup.js\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n * \t-\tAdd objects you would otherwise pass as 'root' to the\n * \t\tconstructor or the .clipAction method of AnimationMixer.\n *\n * \t-\tInstead pass this object as 'root'.\n *\n * \t-\tYou can also add and remove objects later when the mixer\n * \t\tis running.\n *\n * Note:\n *\n *  \tObjects of this class appear as one object to the mixer,\n *  \tso cache control of the individual objects must be done\n *  \ton the group.\n *\n * Limitation:\n *\n * \t- \tThe animated properties must be compatible among the\n * \t\tall objects in the group.\n *\n *  -\tA single property can either be controlled through a\n *  \ttarget group or directly, but not both.\n *\n * @author tschw\n */\n\nTHREE.AnimationObjectGroup = function( var_args ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// cached objects followed by the active ones\n\tthis._objects = Array.prototype.slice.call( arguments );\n\n\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t// note: read by PropertyBinding.Composite\n\n\tvar indices = {};\n\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t}\n\n\tthis._paths = [];\t\t\t\t\t// inside: string\n\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\tvar scope = this;\n\n\tthis.stats = {\n\n\t\tobjects: {\n\t\t\tget total() { return scope._objects.length; },\n\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t},\n\n\t\tget bindingsPerObject() { return scope._bindings.length; }\n\n\t};\n\n};\n\nTHREE.AnimationObjectGroup.prototype = {\n\n\tconstructor: THREE.AnimationObjectGroup,\n\n\tadd: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\tnew THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tvar knownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject) {\n\n\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\tremove: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// remove & forget\n\tuncache: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_: function( path, parsedPath ) {\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ],\n\t\t\tbindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tvar paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( var i = nCachedObjects,\n\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\n\t\t\tvar object = objects[ i ];\n\n\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t},\n\n\tunsubscribe_: function( path ) {\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationUtils.js\n\n/**\n * @author tschw\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function( array, from, to ) {\n\n\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tvar n = times.length;\n\t\tvar result = new Array( n );\n\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function( values, stride, order ) {\n\n\t\tvar nValues = values.length;\n\t\tvar result = new values.constructor( nValues );\n\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tvar value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/KeyframeTrack.js\n\n/**\n *\n * A timed sequence of keyframes for a specific property.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\n\tif( times === undefined || times.length === 0 ) {\n\n\t\tthrow new Error( \"no keyframes in track named \" + name );\n\n\t}\n\n\tthis.name = name;\n\n\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\n\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\tthis.validate();\n\tthis.optimize();\n\n};\n\nTHREE.KeyframeTrack.prototype = {\n\n\tconstructor: THREE.KeyframeTrack,\n\n\tTimeBufferType: Float32Array,\n\tValueBufferType: Float32Array,\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodDiscrete: function( result ) {\n\n\t\treturn new THREE.DiscreteInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.LinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: function( result ) {\n\n\t\treturn new THREE.CubicInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tsetInterpolation: function( interpolation ) {\n\n\t\tvar factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase THREE.InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( message );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t},\n\n\tgetInterpolation: function() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn THREE.InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn THREE.InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn THREE.InterpolateSmooth;\n\n\t\t}\n\n\t},\n\n\tgetValueSize: function() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t},\n\n\t// move all keyframes either forwards or backwards in time\n\tshift: function( timeOffset ) {\n\n\t\tif( timeOffset !== 0.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale: function( timeScale ) {\n\n\t\tif( timeScale !== 1.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim: function( startTime, endTime ) {\n\n\t\tvar times = this.times,\n\t\t\tnKeys = times.length,\n\t\t\tfrom = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\n\t\t\tvar stride = this.getValueSize();\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = THREE.AnimationUtils.\n\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate: function() {\n\n\t\tvar valid = true;\n\n\t\tvar valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif( nKeys === 0 ) {\n\n\t\t\tconsole.error( \"track is empty\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar prevTime = null;\n\n\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tvar currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize: function() {\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\t\t\tstride = this.getValueSize(),\n\n\t\t\twriteIndex = 1;\n\n\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\n\n\t\t\tvar keep = false;\n\n\t\t\tvar time = times[ i ];\n\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\t\t\tvar offset = i * stride,\n\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.KeyframeTrack, {\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tparse: function( json ) {\n\n\t\tif( json.type === undefined ) {\n\n\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\n\t\t}\n\n\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\tif ( json.times === undefined ) {\n\n\t\t\tvar times = [], values = [];\n\n\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\tjson.times = times;\n\t\t\tjson.values = values;\n\n\t\t}\n\n\t\t// derived classes can define a static parse method\n\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\treturn trackType.parse( json );\n\n\t\t} else {\n\n\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\treturn new trackType(\n\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function( track ) {\n\n\t\tvar trackType = track.constructor;\n\n\t\tvar json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t},\n\n\t_getTrackTypeForValueTypeName: function( typeName ) {\n\n\t\tswitch( typeName.toLowerCase() ) {\n\n\t\t\tcase \"scalar\":\n\t\t\tcase \"double\":\n\t\t\tcase \"float\":\n\t\t\tcase \"number\":\n\t\t\tcase \"integer\":\n\n\t\t\t\treturn THREE.NumberKeyframeTrack;\n\n\t\t\tcase \"vector\":\n\t\t\tcase \"vector2\":\n\t\t\tcase \"vector3\":\n\t\t\tcase \"vector4\":\n\n\t\t\t\treturn THREE.VectorKeyframeTrack;\n\n\t\t\tcase \"color\":\n\n\t\t\t\treturn THREE.ColorKeyframeTrack;\n\n\t\t\tcase \"quaternion\":\n\n\t\t\t\treturn THREE.QuaternionKeyframeTrack;\n\n\t\t\tcase \"bool\":\n\t\t\tcase \"boolean\":\n\n\t\t\t\treturn THREE.BooleanKeyframeTrack;\n\n\t\t\tcase \"string\":\n\n\t\t\t\treturn THREE.StringKeyframeTrack;\n\n\t\t}\n\n\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\n\t}\n\n} );\n\n// File:src/animation/PropertyBinding.js\n\n/**\n *\n * A reference to a real property in the scene graph.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\n\n\tthis.path = path;\n\tthis.parsedPath = parsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis.node = THREE.PropertyBinding.findNode(\n\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\n\tthis.rootNode = rootNode;\n\n};\n\nTHREE.PropertyBinding.prototype = {\n\n\tconstructor: THREE.PropertyBinding,\n\n\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t// prototype version of these methods with one that represents\n\t\t// the bound state. When the property is not found, the methods\n\t\t// become no-ops.\n\n\t},\n\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t},\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind: function() {\n\n\t\tvar targetObject = this.node,\n\t\t\tparsedPath = this.parsedPath,\n\n\t\t\tobjectName = parsedPath.objectName,\n\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = THREE.PropertyBinding.findNode(\n\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n \t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tvar versioning = this.Versioning.None;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tvar bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( nodeProperty.length !== undefined ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t},\n\n\tunbind: function() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n};\n\nObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable: function() {},\n\t_setValue_unavailable: function() {},\n\n\t// initial state of these methods that calls 'bind'\n\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\n\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\n\n\tBindingType: {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t},\n\n\tVersioning: {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t},\n\n\tGetterByBindingType: [\n\n\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t},\n\n\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\tvar source = this.resolvedProperty;\n\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t},\n\n\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t}\n\n\t],\n\n\tSetterByBindingTypeAndVersioning: [\n\n\t\t[\n\t\t\t// Direct\n\n\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// EntireArray\n\n\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// ArrayElement\n\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// HasToFromArray\n\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t]\n\n\t]\n\n} );\n\nTHREE.PropertyBinding.Composite =\n\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\n\tvar parsedPath = optionalParsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis._targetGroup = targetGroup;\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n};\n\nTHREE.PropertyBinding.Composite.prototype = {\n\n\tconstructor: THREE.PropertyBinding.Composite,\n\n\tgetValue: function( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t},\n\n\tsetValue: function( array, offset ) {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t},\n\n\tbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t},\n\n\tunbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\n\n\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\n\n\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\n\n\t} else {\n\n\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\n\n\t}\n\n};\n\nTHREE.PropertyBinding.parseTrackName = function( trackName ) {\n\n\t// matches strings in the form of:\n\t//    nodeName.property\n\t//    nodeName.property[accessor]\n\t//    nodeName.material.property[accessor]\n\t//    uuid.property[accessor]\n\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t//    parentName/nodeName.property\n\t//    parentName/parentName/nodeName.property[index]\n\t//\t  .bone[Armature.DEF_cog].position\n\t// created and tested via https://regex101.com/#javascript\n\n\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\n\tvar matches = re.exec( trackName );\n\n\tif ( ! matches ) {\n\n\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\n\t}\n\n\tif ( matches.index === re.lastIndex ) {\n\n\t\tre.lastIndex++;\n\n\t}\n\n\tvar results = {\n\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\tnodeName: matches[ 3 ], \t// allowed to be null, specified root node.\n\t\tobjectName: matches[ 5 ],\n\t\tobjectIndex: matches[ 7 ],\n\t\tpropertyName: matches[ 9 ],\n\t\tpropertyIndex: matches[ 11 ]\t// allowed to be null, specifies that the whole property is set.\n\t};\n\n\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n\t}\n\n\treturn results;\n\n};\n\nTHREE.PropertyBinding.findNode = function( root, nodeName ) {\n\n\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\treturn root;\n\n\t}\n\n\t// search into skeleton bones.\n\tif ( root.skeleton ) {\n\n\t\tvar searchSkeleton = function( skeleton ) {\n\n\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n\t\t\t\tvar bone = skeleton.bones[ i ];\n\n\t\t\t\tif ( bone.name === nodeName ) {\n\n\t\t\t\t\treturn bone;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar bone = searchSkeleton( root.skeleton );\n\n\t\tif ( bone ) {\n\n\t\t\treturn bone;\n\n\t\t}\n\t}\n\n\t// search into node subtree.\n\tif ( root.children ) {\n\n\t\tvar searchNodeSubtree = function( children ) {\n\n\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\treturn childNode;\n\n\t\t\t\t}\n\n\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\tif ( result ) return result;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\tif ( subTreeNode ) {\n\n\t\t\treturn subTreeNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\n// File:src/animation/PropertyMixer.js\n\n/**\n *\n * Buffered scene graph property that allows weighted accumulation.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tvar bufferType = Float64Array,\n\t\tmixFunction;\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\n\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\n\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\n\t}\n\n\tthis.buffer = new bufferType( valueSize * 4 );\n\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\n\tthis._mixBufferRegion = mixFunction;\n\n\tthis.cumulativeWeight = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n};\n\nTHREE.PropertyMixer.prototype = {\n\n\tconstructor: THREE.PropertyMixer,\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tvar mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function( accuIndex ) {\n\n\t\tvar stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function() {\n\n\t\tvar binding = this.binding;\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * 3;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\tthis.cumulativeWeight = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function() {\n\n\t\tvar originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tvar s = 1 - t;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tvar j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/tracks/BooleanKeyframeTrack.js\n\n/**\n *\n * A Track of Boolean keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values );\n\n};\n\nTHREE.BooleanKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.BooleanKeyframeTrack,\n\n\tValueTypeName: 'bool',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\tInterpolantFactoryMethodSmooth: undefined\n\n\t// Note: Actually this track could have a optimized / compressed\n\t// representation of a single value and a custom interpolant that\n\t// computes \"firstValue ^ isOdd( index )\".\n\n} );\n\n// File:src/animation/tracks/ColorKeyframeTrack.js\n\n/**\n *\n * A Track of keyframe values that represent color.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.ColorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.ColorKeyframeTrack,\n\n\tValueTypeName: 'color'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n\n\t// Note: Very basic implementation and nothing special yet.\n\t// However, this is the place for color space parameterization.\n\n} );\n\n// File:src/animation/tracks/NumberKeyframeTrack.js\n\n/**\n *\n * A Track of numeric keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.NumberKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.NumberKeyframeTrack,\n\n\tValueTypeName: 'number',\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/animation/tracks/QuaternionKeyframeTrack.js\n\n/**\n *\n * A Track of quaternion keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.QuaternionKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.QuaternionKeyframeTrack,\n\n\tValueTypeName: 'quaternion',\n\n\t// ValueBufferType is inherited\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.QuaternionLinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n} );\n\n// File:src/animation/tracks/StringKeyframeTrack.js\n\n/**\n *\n * A Track that interpolates Strings\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.StringKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.StringKeyframeTrack,\n\n\tValueTypeName: 'string',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\n\tInterpolantFactoryMethodSmooth: undefined\n\n} );\n\n// File:src/animation/tracks/VectorKeyframeTrack.js\n\n/**\n *\n * A Track of vectored keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.VectorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.VectorKeyframeTrack,\n\n\tValueTypeName: 'vector'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/audio/Audio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.Audio = function ( listener ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Audio';\n\n\tthis.context = listener.context;\n\tthis.source = this.context.createBufferSource();\n\tthis.source.onended = this.onEnded.bind( this );\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( listener.getInput() );\n\n\tthis.autoplay = false;\n\n\tthis.startTime = 0;\n\tthis.playbackRate = 1;\n\tthis.isPlaying = false;\n\tthis.hasPlaybackControl = true;\n\tthis.sourceType = 'empty';\n\n\tthis.filters = [];\n\n};\n\nTHREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Audio,\n\n\tgetOutput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tsetNodeSource: function ( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t},\n\n\tsetBuffer: function ( audioBuffer ) {\n\n\t\tthis.source.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t},\n\n\tplay: function () {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar source = this.context.createBufferSource();\n\n\t\tsource.buffer = this.source.buffer;\n\t\tsource.loop = this.source.loop;\n\t\tsource.onended = this.source.onended;\n\t\tsource.start( 0, this.startTime );\n\t\tsource.playbackRate.value = this.playbackRate;\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\treturn this.connect();\n\n\t},\n\n\tpause: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = this.context.currentTime;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = 0;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdisconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilters: function () {\n\n\t\treturn this.filters;\n\n\t},\n\n\tsetFilters: function ( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value;\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t},\n\n\tsetFilter: function ( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t},\n\n\tsetPlaybackRate: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetPlaybackRate: function () {\n\n\t\treturn this.playbackRate;\n\n\t},\n\n\tonEnded: function () {\n\n\t\tthis.isPlaying = false;\n\n\t},\n\n\tgetLoop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.source.loop;\n\n\t},\n\n\tsetLoop: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.loop = value;\n\n\t},\n\n\tgetVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\n\tsetVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/audio/AudioAnalyser.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioAnalyser = function ( audio, fftSize ) {\n\n\tthis.analyser = audio.context.createAnalyser();\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\taudio.getOutput().connect( this.analyser );\n\n};\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\n\tgetFrequencyData: function () {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t},\n\n\tgetAverageFrequency: function () {\n\n\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n} );\n\n// File:src/audio/AudioContext.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.defineProperty( THREE, 'AudioContext', {\n\n\tget: ( function () {\n\n\t\tvar context;\n\n\t\treturn function get() {\n\n\t\t\tif ( context === undefined ) {\n\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t\t}\n\n\t\t\treturn context;\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/audio/PositionalAudio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PositionalAudio = function ( listener ) {\n\n\tTHREE.Audio.call( this, listener );\n\n\tthis.panner = this.context.createPanner();\n\tthis.panner.connect( this.gain );\n\n};\n\nTHREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {\n\n\tconstructor: THREE.PositionalAudio,\n\n\tgetOutput: function () {\n\n\t\treturn this.panner;\n\n\t},\n\n\tgetRefDistance: function () {\n\n\t\treturn this.panner.refDistance;\n\n\t},\n\n\tsetRefDistance: function ( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t},\n\n\tgetRolloffFactor: function () {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t},\n\n\tsetRolloffFactor: function ( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t},\n\n\tgetDistanceModel: function () {\n\n\t\treturn this.panner.distanceModel;\n\n\t},\n\n\tsetDistanceModel: function ( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t},\n\n\tgetMaxDistance: function () {\n\n\t\treturn this.panner.maxDistance;\n\n\t},\n\n\tsetMaxDistance: function ( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t};\n\n\t} )()\n\n\n} );\n\n// File:src/audio/AudioListener.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioListener = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'AudioListener';\n\n\tthis.context = THREE.AudioContext;\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( this.context.destination );\n\n\tthis.filter = null;\n\n};\n\nTHREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.AudioListener,\n\n\tgetInput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tremoveFilter: function ( ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.filter;\n\n\t},\n\n\tsetFilter: function ( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t},\n\n\tgetMasterVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\tsetMasterVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar scale = new THREE.Vector3();\n\n\t\tvar orientation = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tvar listener = this.context.listener;\n\t\t\tvar up = this.up;\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/cameras/Camera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.Camera = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Camera';\n\n\tthis.matrixWorldInverse = new THREE.Matrix4();\n\tthis.projectionMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Camera.prototype.constructor = THREE.Camera;\n\nTHREE.Camera.prototype.getWorldDirection = function () {\n\n\tvar quaternion = new THREE.Quaternion();\n\n\treturn function getWorldDirection( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.getWorldQuaternion( quaternion );\n\n\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.lookAt = function () {\n\n\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\tvar m1 = new THREE.Matrix4();\n\n\treturn function lookAt( vector ) {\n\n\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.clone = function () {\n\n\treturn new this.constructor().copy( this );\n\n};\n\nTHREE.Camera.prototype.copy = function ( source ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\treturn this;\n\n};\n\n// File:src/cameras/CubeCamera.js\n\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'CubeCamera';\n\n\tvar fov = 90, aspect = 1;\n\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, - 1, 0 );\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, - 1, 0 );\n\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, - 1 );\n\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, - 1, 0 );\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, - 1, 0 );\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\n\tthis.add( cameraNZ );\n\n\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\n\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderTarget.activeCubeFace = 0;\n\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 1;\n\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 2;\n\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 3;\n\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 4;\n\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderTarget.activeCubeFace = 5;\n\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\trenderer.setRenderTarget( null );\n\n\t};\n\n};\n\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\n\n// File:src/cameras/OrthographicCamera.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author arose / http://github.com/arose\n */\n\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'OrthographicCamera';\n\n\tthis.zoom = 1;\n\tthis.view = null;\n\n\tthis.left = left;\n\tthis.right = right;\n\tthis.top = top;\n\tthis.bottom = bottom;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.OrthographicCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t},\n\n\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tvar cx = ( this.right + this.left ) / 2;\n\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\tvar left = cx - dx;\n\t\tvar right = cx + dx;\n\t\tvar top = cy + dy;\n\t\tvar bottom = cy - dy;\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/PerspectiveCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author tschw\n */\n\nTHREE.PerspectiveCamera = function( fov, aspect, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'PerspectiveCamera';\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.zoom = 1;\n\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\tthis.focus = 10;\n\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.view = null;\n\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.PerspectiveCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength: function ( focalLength ) {\n\n\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength: function () {\n\n\t\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t},\n\n\tgetEffectiveFOV: function () {\n\n\t\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t},\n\n\tgetFilmWidth: function () {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t},\n\n\tgetFilmHeight: function () {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t},\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   var w = 1920;\n\t *   var h = 1080;\n\t *   var fullWidth = w * 3;\n\t *   var fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar near = this.near,\n\t\t\ttop = near * Math.tan(\n\t\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\theight = 2 * top,\n\t\t\twidth = this.aspect * height,\n\t\t\tleft = - 0.5 * width,\n\t\t\tview = this.view;\n\n\t\tif ( view !== null ) {\n\n\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tvar skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/StereoCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.StereoCamera = function () {\n\n\tthis.type = 'StereoCamera';\n\n\tthis.aspect = 1;\n\n\tthis.cameraL = new THREE.PerspectiveCamera();\n\tthis.cameraL.layers.enable( 1 );\n\tthis.cameraL.matrixAutoUpdate = false;\n\n\tthis.cameraR = new THREE.PerspectiveCamera();\n\tthis.cameraR.layers.enable( 2 );\n\tthis.cameraR.matrixAutoUpdate = false;\n\n};\n\nObject.assign( THREE.StereoCamera.prototype, {\n\n\tupdate: ( function () {\n\n\t\tvar focus, fov, aspect, near, far;\n\n\t\tvar eyeRight = new THREE.Matrix4();\n\t\tvar eyeLeft = new THREE.Matrix4();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\tfocus = camera.focus;\n\t\t\t\tfov = camera.fov;\n\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\tnear = camera.near;\n\t\t\t\tfar = camera.far;\n\n\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\tvar eyeSep = 0.064 / 2;\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t// translate xOffset\n\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t// for left eye\n\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t// for right eye\n\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t}\n\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/lights/Light.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Light = function ( color, intensity ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Light';\n\n\tthis.color = new THREE.Color( color );\n\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\tthis.receiveShadow = undefined;\n\n};\n\nTHREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Light,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/lights/LightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LightShadow = function ( camera ) {\n\n\tthis.camera = camera;\n\n\tthis.bias = 0;\n\tthis.radius = 1;\n\n\tthis.mapSize = new THREE.Vector2( 512, 512 );\n\n\tthis.map = null;\n\tthis.matrix = new THREE.Matrix4();\n\n};\n\nObject.assign( THREE.LightShadow.prototype, {\n\n\tcopy: function ( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\n// File:src/lights/AmbientLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AmbientLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'AmbientLight';\n\n\tthis.castShadow = undefined;\n\n};\n\nTHREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.AmbientLight\n\n} );\n\n// File:src/lights/DirectionalLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DirectionalLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'DirectionalLight';\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tthis.shadow = new THREE.DirectionalLightShadow();\n\n};\n\nTHREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.DirectionalLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/DirectionalLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectionalLightShadow = function ( light ) {\n\n\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n};\n\nTHREE.DirectionalLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.DirectionalLightShadow\n\n} );\n\n// File:src/lights/HemisphereLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\n\n\tTHREE.Light.call( this, skyColor, intensity );\n\n\tthis.type = 'HemisphereLight';\n\n\tthis.castShadow = undefined;\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.groundColor = new THREE.Color( groundColor );\n\n};\n\nTHREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.HemisphereLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/PointLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'PointLight';\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n};\n\nTHREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.PointLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'SpotLight';\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * Math.PI;\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / Math.PI;\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.SpotLightShadow();\n\n};\n\nTHREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.SpotLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SpotLightShadow = function () {\n\n\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n};\n\nTHREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.SpotLightShadow,\n\n\tupdate: function ( light ) {\n\n\t\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\n\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\tvar far = light.distance || 500;\n\n\t\tvar camera = this.camera;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/AudioLoader.js\n\n/**\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.AudioLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.AudioLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar context = THREE.AudioContext;\n\n\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t} );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n} );\n\n// File:src/loaders/Cache.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\n// File:src/loaders/Loader.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Loader = function () {\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function () {};\n\tthis.onLoadComplete = function () {};\n\n};\n\nTHREE.Loader.prototype = {\n\n\tconstructor: THREE.Loader,\n\n\tcrossOrigin: undefined,\n\n\textractUrlBase: function ( url ) {\n\n\t\tvar parts = url.split( '/' );\n\n\t\tif ( parts.length === 1 ) return './';\n\n\t\tparts.pop();\n\n\t\treturn parts.join( '/' ) + '/';\n\n\t},\n\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\tvar array = [];\n\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tcreateMaterial: ( function () {\n\n\t\tvar color, textureLoader, materialLoader;\n\n\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\tif ( color === undefined ) color = new THREE.Color();\n\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\n\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\n\n\t\t\t// convert from old material format\n\n\t\t\tvar textures = {};\n\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\n\n\t\t\t\tvar texture;\n\n\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t}\n\n\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t}\n\n\t\t\t\tvar uuid = THREE.Math.generateUUID();\n\n\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\treturn uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar json = {\n\t\t\t\tuuid: THREE.Math.generateUUID(),\n\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t};\n\n\t\t\tfor ( var name in m ) {\n\n\t\t\t\tvar value = m[ name ];\n\n\t\t\t\tswitch ( name ) {\n\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\tjson.blending = THREE[ value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\tjson.side = THREE.BackSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\tjson.side = THREE.DoubleSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\tcase 'opacity':\n\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\tcase 'visible':\n\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\treturn materialLoader.parse( json );\n\n\t\t};\n\n\t} )()\n\n};\n\nTHREE.Loader.Handlers = {\n\n\thandlers: [],\n\n\tadd: function ( regex, loader ) {\n\n\t\tthis.handlers.push( regex, loader );\n\n\t},\n\n\tget: function ( file ) {\n\n\t\tvar handlers = this.handlers;\n\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\tvar regex = handlers[ i ];\n\t\t\tvar loader  = handlers[ i + 1 ];\n\n\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n};\n\n// File:src/loaders/XHRLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.XHRLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.XHRLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\tvar scope = this;\n\n\t\tvar cached = THREE.Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tif ( onLoad ) {\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tonLoad( cached );\n\n\t\t\t\t}, 0 );\n\n\t\t\t}\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tvar request = new XMLHttpRequest();\n\t\trequest.overrideMimeType( 'text/plain' );\n\t\trequest.open( 'GET', url, true );\n\n\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\tvar response = event.target.response;\n\n\t\t\tTHREE.Cache.add( url, response );\n\n\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else {\n\n\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, false );\n\n\t\tif ( onProgress !== undefined ) {\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tonProgress( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}, false );\n\n\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\trequest.send( null );\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn request;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetResponseType: function ( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t},\n\n\tsetWithCredentials: function ( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/FontLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.FontLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.FontLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t}\n\n\t\t\tvar font = scope.parse( json );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\treturn new THREE.Font( json );\n\n\t}\n\n} );\n\n// File:src/loaders/ImageLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.ImageLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\timage.onload = function () {\n\n\t\t\tURL.revokeObjectURL( image.src );\n\t\t\tif ( onLoad ) onLoad( image );\n\n\t\t};\n\n\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\n\t\t\timage.src = url;\n\n\t\t} else {\n\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'blob' );\n\t\t\tloader.load( url, function ( blob ) {\n\n\t\t\t\timage.src = URL.createObjectURL( blob );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn image;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/JSONLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.JSONLoader = function ( manager ) {\n\n\tif ( typeof manager === 'boolean' ) {\n\n\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\tmanager = undefined;\n\n\t}\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\tthis.withCredentials = false;\n\n};\n\nObject.assign( THREE.JSONLoader.prototype, {\n\n\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json = JSON.parse( text );\n\t\t\tvar metadata = json.metadata;\n\n\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\tvar type = metadata.type;\n\n\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tparse: function ( json, texturePath ) {\n\n\t\tvar geometry = new THREE.Geometry(),\n\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\tparseModel( scale );\n\n\t\tparseSkin();\n\t\tparseMorphing( scale );\n\t\tparseAnimations();\n\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeBoundingSphere();\n\n\t\tfunction parseModel( scale ) {\n\n\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t}\n\n\t\t\tvar i, j, fi,\n\n\t\t\toffset, zLength,\n\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\ttype,\n\t\t\tisQuad,\n\t\t\thasMaterial,\n\t\t\thasFaceVertexUv,\n\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\tuvLayer, uv, u, v,\n\n\t\t\tfaces = json.faces,\n\t\t\tvertices = json.vertices,\n\t\t\tnormals = json.normals,\n\t\t\tcolors = json.colors,\n\n\t\t\tnUvLayers = 0;\n\n\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t// disregard empty arrays\n\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = vertices.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\tvertex = new THREE.Vector3();\n\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = faces.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\tfaceA = new THREE.Face3();\n\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\tfaceB = new THREE.Face3();\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\toffset += 4;\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface = new THREE.Face3();\n\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseSkin() {\n\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.bones = json.bones;\n\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseMorphing( scale ) {\n\n\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimations() {\n\n\t\t\tvar outputAnimations = [];\n\n\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\tvar animations = [];\n\n\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\tanimations.push( json.animation );\n\n\t\t\t}\n\n\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t}\n\n\t\t\t// parse implicit morph animations\n\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t}\n\n\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t}\n\n\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\treturn { geometry: geometry };\n\n\t\t} else {\n\n\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/LoadingManager.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n\tthis.onStart = undefined;\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\titemsTotal ++;\n\n\t\tif ( isLoading === false ) {\n\n\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLoading = true;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\titemsLoaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t}\n\n\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\tisLoading = false;\n\n\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\tscope.onLoad();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.itemError = function ( url ) {\n\n\t\tif ( scope.onError !== undefined ) {\n\n\t\t\tscope.onError( url );\n\n\t\t}\n\n\t};\n\n};\n\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\n\n// File:src/loaders/BufferGeometryLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometryLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.BufferGeometryLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar index = json.data.index;\n\n\t\tvar TYPED_ARRAYS = {\n\t\t\t'Int8Array': Int8Array,\n\t\t\t'Uint8Array': Uint8Array,\n\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t'Int16Array': Int16Array,\n\t\t\t'Uint16Array': Uint16Array,\n\t\t\t'Int32Array': Int32Array,\n\t\t\t'Uint32Array': Uint32Array,\n\t\t\t'Float32Array': Float32Array,\n\t\t\t'Float64Array': Float64Array\n\t\t};\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tvar attributes = json.data.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t}\n\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tvar center = new THREE.Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/loaders/MaterialLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MaterialLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.textures = {};\n\n};\n\nObject.assign( THREE.MaterialLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTextures: function ( value ) {\n\n\t\tthis.textures = value;\n\n\t},\n\n\tgetTexture: function ( name ) {\n\n\t\tvar textures = this.textures;\n\n\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t}\n\n\t\treturn textures[ name ];\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar material = new THREE[ json.type ];\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\n\t\t// for PointsMaterial\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\n\n\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\n\t\t\tmaterial.transparent = true;\n\n\t\t}\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tvar normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\n\n\t\tif ( json.envMap !== undefined ) {\n\n\t\t\tmaterial.envMap = this.getTexture( json.envMap );\n\t\t\tmaterial.combine = THREE.MultiplyOperation;\n\n\t\t}\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t// MultiMaterial\n\n\t\tif ( json.materials !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n} );\n\n// File:src/loaders/ObjectLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ObjectLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.texturePath = '';\n\n};\n\nObject.assign( THREE.ObjectLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.texturePath === '' ) {\n\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t}\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tparse: function ( json, onLoad ) {\n\n\t\tvar geometries = this.parseGeometries( json.geometries );\n\n\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\tif ( json.animations ) {\n\n\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t}\n\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t},\n\n\tparseGeometries: function ( json ) {\n\n\t\tvar geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE [ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\tcase 'TetrahedronGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t},\n\n\tparseMaterials: function ( json, textures ) {\n\n\t\tvar materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar loader = new THREE.MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t},\n\n\tparseAnimations: function ( json ) {\n\n\t\tvar animations = [];\n\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t},\n\n\tparseImages: function ( json, onLoad ) {\n\n\t\tvar scope = this;\n\t\tvar images = {};\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tvar manager = new THREE.LoadingManager( onLoad );\n\n\t\t\tvar loader = new THREE.ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar image = json[ i ];\n\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t},\n\n\tparseTextures: function ( json, images ) {\n\n\t\tfunction parseConstant( value ) {\n\n\t\t\tif ( typeof( value ) === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn THREE[ value ];\n\n\t\t}\n\n\t\tvar textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\n\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\t\t\t\tif ( Array.isArray( data.wrap ) ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t},\n\n\tparseObject: function () {\n\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\treturn function parseObject( data, geometries, materials ) {\n\n\t\t\tvar object;\n\n\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometries[ name ];\n\n\t\t\t}\n\n\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn materials[ name ];\n\n\t\t\t}\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'Scene':\n\n\t\t\t\t\tobject = new THREE.Scene();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LOD':\n\n\t\t\t\t\tobject = new THREE.LOD();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Line':\n\n\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointCloud':\n\t\t\t\tcase 'Points':\n\n\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Group':\n\n\t\t\t\t\tobject = new THREE.Group();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t} else {\n\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t}\n\n\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\tvar levels = data.levels;\n\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t};\n\n\t}()\n\n} );\n\n// File:src/loaders/TextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.TextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.TextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.Texture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/CubeTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.CubeTextureLoader.prototype, {\n\n\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.CubeTexture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tvar loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/BinaryTextureLoader.js\n\n/**\n * @author Nikos M. / https://github.com/foo123/\n *\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n */\n\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.BinaryTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new THREE.DataTexture();\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\n\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t}\n\n\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n// File:src/loaders/CompressedTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n */\n\nTHREE.CompressedTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.CompressedTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar images = [];\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/materials/Material.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Material = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Material';\n\n\tthis.fog = true;\n\tthis.lights = true;\n\n\tthis.blending = THREE.NormalBlending;\n\tthis.side = THREE.FrontSide;\n\tthis.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\tthis.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blendSrc = THREE.SrcAlphaFactor;\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\tthis.blendEquation = THREE.AddEquation;\n\tthis.blendSrcAlpha = null;\n\tthis.blendDstAlpha = null;\n\tthis.blendEquationAlpha = null;\n\n\tthis.depthFunc = THREE.LessEqualDepth;\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.clippingPlanes = null;\n\tthis.clipShadows = false;\n\n\tthis.colorWrite = true;\n\n\tthis.precision = null; // override the renderer's default precision for this material\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.alphaTest = 0;\n\tthis.premultipliedAlpha = false;\n\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\tthis.visible = true;\n\n\tthis._needsUpdate = true;\n\n};\n\nTHREE.Material.prototype = {\n\n\tconstructor: THREE.Material,\n\n\tget needsUpdate() {\n\n\t\treturn this._needsUpdate;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.update();\n\t\tthis._needsUpdate = value;\n\n\t},\n\n\tsetValues: function ( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( var key in values ) {\n\n\t\t\tvar newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue instanceof THREE.Color ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar isRoot = meta === undefined;\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\n\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\n\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\tif ( this.bumpMap instanceof THREE.Texture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\t\tif ( this.normalMap instanceof THREE.Texture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\t\tif ( this.displacementMap instanceof THREE.Texture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap instanceof THREE.Texture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t}\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;\n\t\tif ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;\n\t\tif ( this.side !== THREE.FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.shading = source.shading;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.alphaTest = source.alphaTest;\n\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\tthis.overdraw = source.overdraw;\n\n\t\tthis.visible = source.visible;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\tdstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tvar n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\n\t\treturn this;\n\n\t},\n\n\tupdate: function () {\n\n\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nObject.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.MaterialIdCount = 0;\n\n// File:src/materials/LineBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nTHREE.LineBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\n\nTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\tthis.linecap = source.linecap;\n\tthis.linejoin = source.linejoin;\n\n\treturn this;\n\n};\n\n// File:src/materials/LineDashedMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nTHREE.LineDashedMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineDashedMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\n\tthis.scale = 1;\n\tthis.dashSize = 3;\n\tthis.gapSize = 1;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\n\nTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\n\tthis.scale = source.scale;\n\tthis.dashSize = source.dashSize;\n\tthis.gapSize = source.gapSize;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>\n * }\n */\n\nTHREE.MeshBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\n\nTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshDepthMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / https://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshDepthMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshDepthMaterial';\n\n\tthis.depthPacking = THREE.BasicDepthPacking;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.map = null;\n\n\tthis.alphaMap = null;\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\n\nTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.depthPacking = source.depthPacking;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\tthis.map = source.map;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshLambertMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshLambertMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshLambertMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\n\nTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshNormalMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshNormalMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this, parameters );\n\n\tthis.type = 'MeshNormalMaterial';\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\n\nTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhongMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshPhongMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshPhongMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.specular = new THREE.Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\n\nTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.specular.copy( source.specular );\n\tthis.shininess = source.shininess;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshStandardMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshStandardMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.type = 'MeshStandardMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.roughness = 0.5;\n\tthis.metalness = 0.5;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.roughnessMap = null;\n\n\tthis.metalnessMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.envMapIntensity = 1.0;\n\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\n\nTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.color.copy( source.color );\n\tthis.roughness = source.roughness;\n\tthis.metalness = source.metalness;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.roughnessMap = source.roughnessMap;\n\n\tthis.metalnessMap = source.metalnessMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.envMapIntensity = source.envMapIntensity;\n\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhysicalMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  reflectivity: <float>\n * }\n */\n\nTHREE.MeshPhysicalMaterial = function ( parameters ) {\n\n\tTHREE.MeshStandardMaterial.call( this );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.type = 'MeshPhysicalMaterial';\n\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\tthis.clearCoat = 0.0;\n\tthis.clearCoatRoughness = 0.0;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\nTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\n\nTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.reflectivity = source.reflectivity;\n\n\tthis.clearCoat = source.clearCoat;\n\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\treturn this;\n\n};\n\n// File:src/materials/MultiMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MultiMaterial = function ( materials ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.type = 'MultiMaterial';\n\n\tthis.materials = materials instanceof Array ? materials : [];\n\n\tthis.visible = true;\n\n};\n\nTHREE.MultiMaterial.prototype = {\n\n\tconstructor: THREE.MultiMaterial,\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.2,\n\t\t\t\ttype: 'material',\n\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t},\n\t\t\tuuid: this.uuid,\n\t\t\ttype: this.type,\n\t\t\tmaterials: []\n\t\t};\n\n\t\tvar materials = this.materials;\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\tdelete material.metadata;\n\n\t\t\toutput.materials.push( material );\n\n\t\t}\n\n\t\toutput.visible = this.visible;\n\n\t\treturn output;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar material = new this.constructor();\n\n\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t\t}\n\n\t\tmaterial.visible = this.visible;\n\n\t\treturn material;\n\n\t}\n\n};\n\n// File:src/materials/PointsMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nTHREE.PointsMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'PointsMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\n\nTHREE.PointsMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.size = source.size;\n\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShaderMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.ShaderMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'ShaderMaterial';\n\n\tthis.defines = {};\n\tthis.uniforms = {};\n\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\tthis.lights = false; // set to use scene lights\n\tthis.clipping = false; // set to use user-defined clipping planes\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.extensions = {\n\t\tderivatives: false, // set to use derivatives\n\t\tfragDepth: false, // set to use fragment depth values\n\t\tdrawBuffers: false, // set to use draw buffers\n\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t};\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t'color': [ 1, 1, 1 ],\n\t\t'uv': [ 0, 0 ],\n\t\t'uv2': [ 0, 0 ]\n\t};\n\n\tthis.index0AttributeName = undefined;\n\n\tif ( parameters !== undefined ) {\n\n\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n};\n\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\n\nTHREE.ShaderMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.fragmentShader = source.fragmentShader;\n\tthis.vertexShader = source.vertexShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\n\n\tthis.defines = source.defines;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.lights = source.lights;\n\tthis.clipping = source.clipping;\n\n\tthis.skinning = source.skinning;\n\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.extensions = source.extensions;\n\n\treturn this;\n\n};\n\nTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\n\n\tdata.uniforms = this.uniforms;\n\tdata.vertexShader = this.vertexShader;\n\tdata.fragmentShader = this.fragmentShader;\n\n\treturn data;\n\n};\n\n// File:src/materials/RawShaderMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RawShaderMaterial = function ( parameters ) {\n\n\tTHREE.ShaderMaterial.call( this, parameters );\n\n\tthis.type = 'RawShaderMaterial';\n\n};\n\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\n\n// File:src/materials/SpriteMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *\tuvOffset: new THREE.Vector2(),\n *\tuvScale: new THREE.Vector2()\n * }\n */\n\nTHREE.SpriteMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'SpriteMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.map = null;\n\n\tthis.rotation = 0;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\n\nTHREE.SpriteMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.map = source.map;\n\n\tthis.rotation = source.rotation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShadowMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ShadowMaterial = function () {\n\n\tTHREE.ShaderMaterial.call( this, {\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\t\tvertexShader: THREE.ShaderChunk[ 'shadow_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]\n\t} );\n\n\tthis.lights = true;\n\tthis.transparent = true;\n\n\tObject.defineProperties( this, {\n\t\topacity: {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t}\n\t\t}\n\t} );\n\n};\n\nTHREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;\n\n// File:src/textures/Texture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.sourceFile = '';\n\n\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t//\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\n\n\tthis.version = 0;\n\tthis.onUpdate = null;\n\n};\n\nTHREE.Texture.DEFAULT_IMAGE = undefined;\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\n\nTHREE.Texture.prototype = {\n\n\tconstructor: THREE.Texture,\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tfunction getDataURL( image ) {\n\n\t\t\tvar canvas;\n\n\t\t\tif ( image.toDataURL !== undefined ) {\n\n\t\t\t\tcanvas = image;\n\n\t\t\t} else {\n\n\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = image.width;\n\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t} else {\n\n\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tvar image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tmeta.textures[ this.uuid ] = output;\n\n\t\treturn output;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t},\n\n\ttransformUv: function ( uv ) {\n\n\t\tif ( this.mapping !== THREE.UVMapping )  return;\n\n\t\tuv.multiply( this.repeat );\n\t\tuv.add( this.offset );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.TextureIdCount = 0;\n\n// File:src/textures/DepthTexture.js\n\n/**\n * @author Matt DesLauriers / @mattdesl\n */\n\nTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\n\n  this.image = { width: width, height: height };\n\n  this.type = type !== undefined ? type : THREE.UnsignedShortType;\n\n  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n  this.flipY = false;\n  this.generateMipmaps  = false;\n\n};\n\nTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\n\n// File:src/textures/CanvasTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.needsUpdate = true;\n\n};\n\nTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\n\n// File:src/textures/CubeTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\timages = images !== undefined ? images : [];\n\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\n\n\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.flipY = false;\n\n};\n\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\n\nObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\n\n\tget: function () {\n\n\t\treturn this.image;\n\n\t},\n\n\tset: function ( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n} );\n\n// File:src/textures/CompressedTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n\t// no flipping for cube textures\n\t// (also flipping doesn't work for compressed textures )\n\n\tthis.flipY = false;\n\n\t// can't generate mipmaps for compressed textures\n\t// mips must be embedded in DDS files\n\n\tthis.generateMipmaps = false;\n\n};\n\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\n\n// File:src/textures/DataTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { data: data, width: width, height: height };\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n\tthis.flipY = false;\n\tthis.generateMipmaps  = false;\n\n};\n\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\n\n// File:src/textures/VideoTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.generateMipmaps = false;\n\n\tvar scope = this;\n\n\tfunction update() {\n\n\t\trequestAnimationFrame( update );\n\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tscope.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tupdate();\n\n};\n\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\n\n// File:src/objects/Group.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Group = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Group';\n\n};\n\nTHREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Group\n\n} );\n\n// File:src/objects/Points.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Points = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Points';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Points,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar object = this;\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\tvar position = new THREE.Vector3();\n\n\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Line.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Line = function ( geometry, material, mode ) {\n\n\tif ( mode === 1 ) {\n\n\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\treturn new THREE.LineSegments( geometry, material );\n\n\t}\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Line';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Line,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar precision = raycaster.linePrecision;\n\t\t\tvar precisionSq = precision * precision;\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar vStart = new THREE.Vector3();\n\t\t\tvar vEnd = new THREE.Vector3();\n\t\t\tvar interSegment = new THREE.Vector3();\n\t\t\tvar interRay = new THREE.Vector3();\n\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LineSegments.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LineSegments = function ( geometry, material ) {\n\n\tTHREE.Line.call( this, geometry, material );\n\n\tthis.type = 'LineSegments';\n\n};\n\nTHREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {\n\n\tconstructor: THREE.LineSegments\n\n} );\n\n// File:src/objects/Mesh.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */\n\nTHREE.Mesh = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Mesh';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.drawMode = THREE.TrianglesDrawMode;\n\n\tthis.updateMorphTargets();\n\n};\n\nTHREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Mesh,\n\n\tsetDrawMode: function ( value ) {\n\n\t\tthis.drawMode = value;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.drawMode = source.drawMode;\n\n\t\treturn this;\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\n\n\t\t\tthis.morphTargetBase = - 1;\n\t\t\tthis.morphTargetInfluences = [];\n\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tgetMorphTargetIndexByName: function ( name ) {\n\n\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\n\t\t\treturn this.morphTargetDictionary[ name ];\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\n\n\t\treturn 0;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\tvar vA = new THREE.Vector3();\n\t\tvar vB = new THREE.Vector3();\n\t\tvar vC = new THREE.Vector3();\n\n\t\tvar tempA = new THREE.Vector3();\n\t\tvar tempB = new THREE.Vector3();\n\t\tvar tempC = new THREE.Vector3();\n\n\t\tvar uvA = new THREE.Vector2();\n\t\tvar uvB = new THREE.Vector2();\n\t\tvar uvC = new THREE.Vector2();\n\n\t\tvar barycoord = new THREE.Vector3();\n\n\t\tvar intersectionPoint = new THREE.Vector3();\n\t\tvar intersectionPointWorld = new THREE.Vector3();\n\n\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\treturn uv1.clone();\n\n\t\t}\n\n\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\tvar intersect;\n\t\t\tvar material = object.material;\n\n\t\t\tif ( material.side === THREE.BackSide ) {\n\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t} else {\n\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\n\n\t\t\t}\n\n\t\t\tif ( intersect === null ) return null;\n\n\t\t\tintersectionPointWorld.copy( point );\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\treturn {\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\tobject: object\n\t\t\t};\n\n\t\t}\n\n\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\tif ( intersection ) {\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n\t\t\t\t}\n\n\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\n\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t}\n\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar material = this.material;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\tif ( material === undefined ) return;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t// Check boundingBox before continuing\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t}\n\n\t\t\tvar uvs, intersection;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar a, b, c;\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\tuvs = attributes.uv.array;\n\n\t\t\t\t}\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\tc = indices[ i + 2 ];\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\n\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\tc = a + 2;\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\n\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Bone.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.Bone = function ( skin ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Bone';\n\n\tthis.skin = skin;\n\n};\n\nTHREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Bone,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.skin = source.skin;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/objects/Skeleton.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author michael guerrero / http://realitymeltdown.com\n * @author ikerr / http://verold.com\n */\n\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\n\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\tthis.identityMatrix = new THREE.Matrix4();\n\n\t// copy the bone array\n\n\tbones = bones || [];\n\n\tthis.bones = bones.slice( 0 );\n\n\t// create a bone texture or an array of floats\n\n\tif ( this.useVertexTexture ) {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\tsize = Math.max( size, 4 );\n\n\t\tthis.boneTextureWidth = size;\n\t\tthis.boneTextureHeight = size;\n\n\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\n\t} else {\n\n\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n\t}\n\n\t// use the supplied bone inverses or calculate the inverses\n\n\tif ( boneInverses === undefined ) {\n\n\t\tthis.calculateInverses();\n\n\t} else {\n\n\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Skeleton.prototype, {\n\n\tcalculateInverses: function () {\n\n\t\tthis.boneInverses = [];\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tvar inverse = new THREE.Matrix4();\n\n\t\t\tif ( this.bones[ b ] ) {\n\n\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t},\n\n\tpose: function () {\n\n\t\tvar bone;\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdate: ( function () {\n\n\t\tvar offsetMatrix = new THREE.Matrix4();\n\n\t\treturn function update() {\n\n\t\t\t// flatten bone matrices to array\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n\t\t\t}\n\n\t\t\tif ( this.useVertexTexture ) {\n\n\t\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )(),\n\n\tclone: function () {\n\n\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n\t}\n\n} );\n\n// File:src/objects/SkinnedMesh.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.type = 'SkinnedMesh';\n\n\tthis.bindMode = \"attached\";\n\tthis.bindMatrix = new THREE.Matrix4();\n\tthis.bindMatrixInverse = new THREE.Matrix4();\n\n\t// init bones\n\n\t// TODO: remove bone creation as there is no reason (other than\n\t// convenience) for THREE.SkinnedMesh to do this.\n\n\tvar bones = [];\n\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\tvar bone, gbone;\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tbone = new THREE.Bone( this );\n\t\t\tbones.push( bone );\n\n\t\t\tbone.name = gbone.name;\n\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t}\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\n\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\n\t\t\t} else {\n\n\t\t\t\tthis.add( bones[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.normalizeSkinWeights();\n\n\tthis.updateMatrixWorld( true );\n\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n};\n\n\nTHREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\n\n\tconstructor: THREE.SkinnedMesh,\n\n\tbind: function( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t},\n\n\tpose: function () {\n\n\t\tthis.skeleton.pose();\n\n\t},\n\n\tnormalizeSkinWeights: function () {\n\n\t\tif ( this.geometry instanceof THREE.Geometry ) {\n\n\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar vec = new THREE.Vector4();\n\n\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdateMatrixWorld: function( force ) {\n\n\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\n\n\t\tif ( this.bindMode === \"attached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t} else if ( this.bindMode === \"detached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t},\n\n\tclone: function() {\n\n\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LOD.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LOD = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'LOD';\n\n\tObject.defineProperties( this, {\n\t\tlevels: {\n\t\t\tenumerable: true,\n\t\t\tvalue: []\n\t\t}\n\t} );\n\n};\n\n\nTHREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LOD,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\n\n\t\tvar levels = source.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\taddLevel: function ( object, distance ) {\n\n\t\tif ( distance === undefined ) distance = 0;\n\n\t\tdistance = Math.abs( distance );\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\tthis.add( object );\n\n\t},\n\n\tgetObjectForDistance: function ( distance ) {\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn levels[ i - 1 ].object;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t};\n\n\t}() ),\n\n\tupdate: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.levels = [];\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/objects/Sprite.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Sprite = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Sprite';\n\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\n};\n\nTHREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Sprite,\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\n\t\t\tif ( distanceSq > guessSizeSq ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tintersects.push( {\n\n\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\tpoint: this.position,\n\t\t\t\tface: null,\n\t\t\t\tobject: this\n\n\t\t\t} );\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LensFlare.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.lensFlares = [];\n\n\tthis.positionScreen = new THREE.Vector3();\n\tthis.customUpdateCallback = undefined;\n\n\tif ( texture !== undefined ) {\n\n\t\tthis.add( texture, size, distance, blending, color );\n\n\t}\n\n};\n\nTHREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LensFlare,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.positionScreen.copy( source.positionScreen );\n\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\n\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\n\t\tif ( size === undefined ) size = - 1;\n\t\tif ( distance === undefined ) distance = 0;\n\t\tif ( opacity === undefined ) opacity = 1;\n\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\n\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\n\n\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\t\tthis.lensFlares.push( {\n\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\tscale: 1, \t\t// scale\n\t\t\trotation: 0, \t\t// rotation\n\t\t\topacity: opacity,\t// opacity\n\t\t\tcolor: color,\t\t// color\n\t\t\tblending: blending\t// blending\n\t\t} );\n\n\t},\n\n\t/*\n\t * Update lens flares update positions on all flares based on the screen position\n\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t */\n\n\tupdateLensFlares: function () {\n\n\t\tvar f, fl = this.lensFlares.length;\n\t\tvar flare;\n\t\tvar vecX = - this.positionScreen.x * 2;\n\t\tvar vecY = - this.positionScreen.y * 2;\n\n\t\tfor ( f = 0; f < fl; f ++ ) {\n\n\t\t\tflare = this.lensFlares[ f ];\n\n\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/scenes/Scene.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Scene = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Scene';\n\n\tthis.background = null;\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.autoUpdate = true; // checked by the renderer\n\n};\n\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Scene.prototype.constructor = THREE.Scene;\n\nTHREE.Scene.prototype.copy = function ( source, recursive ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\n\n\tif ( source.background !== null ) this.background = source.background.clone();\n\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\tthis.autoUpdate = source.autoUpdate;\n\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\treturn this;\n\n};\n\n// File:src/scenes/Fog.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Fog = function ( color, near, far ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n};\n\nTHREE.Fog.prototype.clone = function () {\n\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\n};\n\n// File:src/scenes/FogExp2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FogExp2 = function ( color, density ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n};\n\nTHREE.FogExp2.prototype.clone = function () {\n\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\n};\n\n// File:src/renderers/shaders/ShaderChunk.js\n\nTHREE.ShaderChunk = {};\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\n\nTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\n\nTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/common.glsl\n\nTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\n\nTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\n\nTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\n\nTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#include <normal_flip>\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#include <normal_flip>\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t\tfloat clearCoat;\\n\t\tfloat clearCoatRoughness;\\n\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\t#ifndef STANDARD\\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\t#ifndef STANDARD\\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\n\nTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\t#ifndef STANDARD\\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\t#else\\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\t#endif\\n\t\t\\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_flip.glsl\n\nTHREE.ShaderChunk[ 'normal_flip' ] = \"#ifdef DOUBLE_SIDED\\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\n\nTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/packing.glsl\n\nTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\n\nTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\n\nTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\n\nTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/UniformsUtils.js\n\n/**\n * Uniform Utilities\n */\n\nTHREE.UniformsUtils = {\n\n\tmerge: function ( uniforms ) {\n\n\t\tvar merged = {};\n\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn merged;\n\n\t},\n\n\tclone: function ( uniforms_src ) {\n\n\t\tvar uniforms_dst = {};\n\n\t\tfor ( var u in uniforms_src ) {\n\n\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uniforms_dst;\n\n\t}\n\n};\n\n// File:src/renderers/shaders/UniformsLib.js\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nTHREE.UniformsLib = {\n\n\tcommon: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\n\t\t\"specularMap\": { value: null },\n\t\t\"alphaMap\": { value: null },\n\n\t\t\"envMap\": { value: null },\n\t\t\"flipEnvMap\": { value: - 1 },\n\t\t\"reflectivity\": { value: 1.0 },\n\t\t\"refractionRatio\": { value: 0.98 }\n\n\t},\n\n\taomap: {\n\n\t\t\"aoMap\": { value: null },\n\t\t\"aoMapIntensity\": { value: 1 }\n\n\t},\n\n\tlightmap: {\n\n\t\t\"lightMap\": { value: null },\n\t\t\"lightMapIntensity\": { value: 1 }\n\n\t},\n\n\temissivemap: {\n\n\t\t\"emissiveMap\": { value: null }\n\n\t},\n\n\tbumpmap: {\n\n\t\t\"bumpMap\": { value: null },\n\t\t\"bumpScale\": { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\t\"normalMap\": { value: null },\n\t\t\"normalScale\": { value: new THREE.Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\t\"displacementMap\": { value: null },\n\t\t\"displacementScale\": { value: 1 },\n\t\t\"displacementBias\": { value: 0 }\n\n\t},\n\n\troughnessmap: {\n\n\t\t\"roughnessMap\": { value: null }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\t\"metalnessMap\": { value: null }\n\n\t},\n\n\tfog: {\n\n\t\t\"fogDensity\": { value: 0.00025 },\n\t\t\"fogNear\": { value: 1 },\n\t\t\"fogFar\": { value: 2000 },\n\t\t\"fogColor\": { value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\t\"ambientLightColor\": { value: [] },\n\n\t\t\"directionalLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"color\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"directionalShadowMap\": { value: [] },\n\t\t\"directionalShadowMatrix\": { value: [] },\n\n\t\t\"spotLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"direction\": {},\n\t\t\t\"distance\": {},\n\t\t\t\"coneCos\": {},\n\t\t\t\"penumbraCos\": {},\n\t\t\t\"decay\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"spotShadowMap\": { value: [] },\n\t\t\"spotShadowMatrix\": { value: [] },\n\n\t\t\"pointLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"decay\": {},\n\t\t\t\"distance\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"pointShadowMap\": { value: [] },\n\t\t\"pointShadowMatrix\": { value: [] },\n\n\t\t\"hemisphereLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"skyColor\": {},\n\t\t\t\"groundColor\": {}\n\t\t} }\n\n\t},\n\n\tpoints: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\t\t\"size\": { value: 1.0 },\n\t\t\"scale\": { value: 1.0 },\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) }\n\n\t}\n\n};\n\n// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\n\nTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\n\nTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\n\nTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\n\nTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\n\nTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\n\nTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\n\nTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\n\nTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\tuniform float clearCoat;\\n\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\n\nTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\n\nTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_frag.glsl\n\nTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_vert.glsl\n\nTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl\n\nTHREE.ShaderChunk[ 'shadow_frag' ] = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl\n\nTHREE.ShaderChunk[ 'shadow_vert' ] = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib.js\n\n/**\n * Webgl Shader Library for three.js\n *\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\n\nTHREE.ShaderLib = {\n\n\t'basic': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\n\n\t},\n\n\t'lambert': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\n\n\t},\n\n\t'phong': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"specular\" : { value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"shininess\": { value: 30 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\n\n\t},\n\n\t'standard': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"roughness\": { value: 0.5 },\n\t\t\t\t\"metalness\": { value: 0 },\n\t\t\t\t\"envMapIntensity\" : { value: 1 }, // temporary\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n\t},\n\n\t'points': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'points' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\n\n\t},\n\n\t'dashed': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\n\t\t\t{\n\t\t\t\t\"scale\"    : { value: 1 },\n\t\t\t\t\"dashSize\" : { value: 1 },\n\t\t\t\t\"totalSize\": { value: 2 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\n\n\t},\n\n\t'depth': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\n\n\t},\n\n\t'normal': {\n\n\t\tuniforms: {\n\n\t\t\t\"opacity\" : { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'cube': {\n\n\t\tuniforms: {\n\t\t\t\"tCube\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'equirect': {\n\n\t\tuniforms: {\n\t\t\t\"tEquirect\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\n\n\t},\n\n\t'distanceRGBA': {\n\n\t\tuniforms: {\n\n\t\t\t\"lightPos\": { value: new THREE.Vector3() }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\n\n\t}\n\n};\n\nTHREE.ShaderLib[ 'physical' ] = {\n\n\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\n\n\t\t{\n\t\t\t\"clearCoat\": { value: 0 },\n\t\t\t\"clearCoatRoughness\": { value: 0 }\n\t\t}\n\n\t] ),\n\n\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n};\n\n// File:src/renderers/WebGLRenderer.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n * @author tschw\n */\n\nTHREE.WebGLRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n\tvar lights = [];\n\n\tvar opaqueObjects = [];\n\tvar opaqueObjectsLastIndex = - 1;\n\tvar transparentObjects = [];\n\tvar transparentObjectsLastIndex = - 1;\n\n\tvar morphInfluences = new Float32Array( 8 );\n\n\tvar sprites = [];\n\tvar lensFlares = [];\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\t// user-defined clipping\n\n\tthis.clippingPlanes = [];\n\tthis.localClippingEnabled = false;\n\n\t// physically based shading\n\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\n\t// physical lights\n\n\tthis.physicallyCorrectLights = false;\n\n\t// tone mapping\n\n\tthis.toneMapping = THREE.LinearToneMapping;\n\tthis.toneMappingExposure = 1.0;\n\tthis.toneMappingWhitePoint = 1.0;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t// internal state cache\n\n\t_currentProgram = null,\n\t_currentRenderTarget = null,\n\t_currentFramebuffer = null,\n\t_currentMaterialId = - 1,\n\t_currentGeometryProgram = '',\n\t_currentCamera = null,\n\n\t_currentScissor = new THREE.Vector4(),\n\t_currentScissorTest = null,\n\n\t_currentViewport = new THREE.Vector4(),\n\n\t//\n\n\t_usedTextureUnits = 0,\n\n\t//\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearAlpha = 0,\n\n\t_width = _canvas.width,\n\t_height = _canvas.height,\n\n\t_pixelRatio = 1,\n\n\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\n\t_scissorTest = false,\n\n\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\n\n\t// frustum\n\n\t_frustum = new THREE.Frustum(),\n\n\t// clipping\n\n\t_clipping = new THREE.WebGLClipping(),\n\t_clippingEnabled = false,\n\t_localClippingEnabled = false,\n\n\t_sphere = new THREE.Sphere(),\n\n\t// camera matrices cache\n\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_vector3 = new THREE.Vector3(),\n\n\t// light arrays cache\n\n\t_lights = {\n\n\t\thash: '',\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tdirectional: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotShadowMap: [],\n\t\tspotShadowMatrix: [],\n\t\tpoint: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: [],\n\n\t\tshadows: []\n\n\t},\n\n\t// info\n\n\t_infoRender = {\n\n\t\tcalls: 0,\n\t\tvertices: 0,\n\t\tfaces: 0,\n\t\tpoints: 0\n\n\t};\n\n\tthis.info = {\n\n\t\trender: _infoRender,\n\t\tmemory: {\n\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\n\t\t},\n\t\tprograms: null\n\n\t};\n\n\n\t// initialize\n\n\tvar _gl;\n\n\ttry {\n\n\t\tvar attributes = {\n\t\t\talpha: _alpha,\n\t\t\tdepth: _depth,\n\t\t\tstencil: _stencil,\n\t\t\tantialias: _antialias,\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t};\n\n\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\tif ( _gl === null ) {\n\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\n\t\t\t} else {\n\n\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t};\n\n\t\t}\n\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t} catch ( error ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\n\t}\n\n\tvar extensions = new THREE.WebGLExtensions( _gl );\n\n\textensions.get( 'WEBGL_depth_texture' );\n\textensions.get( 'OES_texture_float' );\n\textensions.get( 'OES_texture_float_linear' );\n\textensions.get( 'OES_texture_half_float' );\n\textensions.get( 'OES_texture_half_float_linear' );\n\textensions.get( 'OES_standard_derivatives' );\n\textensions.get( 'ANGLE_instanced_arrays' );\n\n\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\n\n\t}\n\n\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\n\n\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\n\tvar properties = new THREE.WebGLProperties();\n\tvar textures = new THREE.WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\n\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\n\tvar lightCache = new THREE.WebGLLights();\n\n\tthis.info.programs = programCache.programs;\n\n\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\n\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t//\n\n\tvar backgroundCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\tvar backgroundCamera2 = new THREE.PerspectiveCamera();\n\tvar backgroundPlaneMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry( 2, 2 ),\n\t\tnew THREE.MeshBasicMaterial( { depthTest: false, depthWrite: false } )\n\t);\n\tvar backgroundBoxShader = THREE.ShaderLib[ 'cube' ];\n\tvar backgroundBoxMesh = new THREE.Mesh(\n\t\tnew THREE.BoxBufferGeometry( 5, 5, 5 ),\n\t\tnew THREE.ShaderMaterial( {\n\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\tside: THREE.BackSide\n\t\t} )\n\t);\n\tobjects.update( backgroundPlaneMesh );\n\tobjects.update( backgroundBoxMesh );\n\n\t//\n\n\tfunction getTargetPixelRatio() {\n\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t}\n\n\tfunction glClearColor( r, g, b, a ) {\n\n\t\tif ( _premultipliedAlpha === true ) {\n\n\t\t\tr *= a; g *= a; b *= a;\n\n\t\t}\n\n\t\tstate.clearColor( r, g, b, a );\n\n\t}\n\n\tfunction setDefaultGLState() {\n\n\t\tstate.init();\n\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t}\n\n\tfunction resetGLState() {\n\n\t\t_currentProgram = null;\n\t\t_currentCamera = null;\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\n\t\tstate.reset();\n\n\t}\n\n\tsetDefaultGLState();\n\n\tthis.context = _gl;\n\tthis.capabilities = capabilities;\n\tthis.extensions = extensions;\n\tthis.properties = properties;\n\tthis.state = state;\n\n\t// shadow map\n\n\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\n\n\tthis.shadowMap = shadowMap;\n\n\n\t// Plugins\n\n\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\n\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _gl.getContextAttributes();\n\n\t};\n\n\tthis.forceContextLoss = function () {\n\n\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\n\t};\n\n\tthis.getMaxAnisotropy = function () {\n\n\t\treturn capabilities.getMaxAnisotropy();\n\n\t};\n\n\tthis.getPrecision = function () {\n\n\t\treturn capabilities.precision;\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value === undefined ) return;\n\n\t\t_pixelRatio = value;\n\n\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\n\t};\n\n\tthis.getSize = function () {\n\n\t\treturn {\n\t\t\twidth: _width,\n\t\t\theight: _height\n\t\t};\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_canvas.width = width * _pixelRatio;\n\t\t_canvas.height = height * _pixelRatio;\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t};\n\n\t// Clearing\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\n\t};\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.set( color );\n\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\n\t};\n\n\tthis.setClearAlpha = function ( alpha ) {\n\n\t\t_clearAlpha = alpha;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\tthis.clear( true, false, false );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\tthis.clear( false, true, false );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\tthis.clear( false, false, true );\n\n\t};\n\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t};\n\n\t// Reset\n\n\tthis.resetGLState = resetGLState;\n\n\tthis.dispose = function() {\n\n\t\ttransparentObjects = [];\n\t\ttransparentObjectsLastIndex = -1;\n\t\topaqueObjects = [];\n\t\topaqueObjectsLastIndex = -1;\n\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n\t};\n\n\t// Events\n\n\tfunction onContextLost( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tresetGLState();\n\t\tsetDefaultGLState();\n\n\t\tproperties.clear();\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tvar material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t}\n\n\t// Buffer deallocation\n\n\tfunction deallocateMaterial( material ) {\n\n\t\treleaseMaterialProgramReference( material );\n\n\t\tproperties.delete( material );\n\n\t}\n\n\n\tfunction releaseMaterialProgramReference( material ) {\n\n\t\tvar programInfo = properties.get( material ).program;\n\n\t\tmaterial.program = undefined;\n\n\t\tif ( programInfo !== undefined ) {\n\n\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t}\n\n\t}\n\n\t// Buffer rendering\n\n\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\tstate.initAttributes();\n\n\t\tvar buffers = properties.get( object );\n\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\n\n\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.normal );\n\n\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.uv );\n\n\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.color );\n\n\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\tsetMaterial( material );\n\n\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\tvar updateBuffers = false;\n\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphTargetInfluences !== undefined ) {\n\n\t\t\tvar activeInfluences = [];\n\n\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\n\t\t\t}\n\n\t\t\tactiveInfluences.sort( absNumericalSort );\n\n\t\t\tif ( activeInfluences.length > 8 ) {\n\n\t\t\t\tactiveInfluences.length = 8;\n\n\t\t\t}\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\n\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\n\t\t\t\t\tvar index = influence[ 1 ];\n\n\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t//\n\n\t\tvar index = geometry.index;\n\t\tvar position = geometry.attributes.position;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tindex = objects.getWireframeAttribute( geometry );\n\n\t\t}\n\n\t\tvar renderer;\n\n\t\tif ( index !== null ) {\n\n\t\t\trenderer = indexedBufferRenderer;\n\t\t\trenderer.setIndex( index );\n\n\t\t} else {\n\n\t\t\trenderer = bufferRenderer;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar dataStart = 0;\n\t\tvar dataCount = Infinity;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdataCount = index.count;\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\tdataCount = position.count;\n\n\t\t}\n\n\t\tvar rangeStart = geometry.drawRange.start;\n\t\tvar rangeCount = geometry.drawRange.count;\n\n\t\tvar groupStart = group !== null ? group.start : 0;\n\t\tvar groupCount = group !== null ? group.count : Infinity;\n\n\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\n\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t//\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\tcase THREE.TrianglesDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleStripDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleFanDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\tif ( object instanceof THREE.LineSegments ) {\n\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Points ) {\n\n\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t}\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t}\n\n\t};\n\n\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\tvar extension;\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\tstate.initAttributes();\n\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( var name in programAttributes ) {\n\n\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\n\t\t\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\t\t\ttype = _gl.FLOAT;\n\n\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\n\n\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\t\t\ttype = _gl.SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\n\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\t\t\ttype = _gl.INT;\n\n\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\t\t\ttype = _gl.BYTE;\n\n\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\n\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t}\n\n\t// Sorting\n\n\tfunction absNumericalSort( a, b ) {\n\n\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\treturn a.material.id - b.material.id;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn a.z - b.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\tfunction reversePainterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar fog = scene.fog;\n\n\t\t// reset caching for this frame\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\t\t_currentCamera = null;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\tlights.length = 0;\n\n\t\topaqueObjectsLastIndex = - 1;\n\t\ttransparentObjectsLastIndex = - 1;\n\n\t\tsprites.length = 0;\n\t\tlensFlares.length = 0;\n\n\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\tprojectObject( scene, camera );\n\n\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\n\t\tif ( _this.sortObjects === true ) {\n\n\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\tsetupShadows( lights );\n\n\t\tshadowMap.render( scene, camera );\n\n\t\tsetupLights( lights, camera );\n\n\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t//\n\n\t\t_infoRender.calls = 0;\n\t\t_infoRender.vertices = 0;\n\t\t_infoRender.faces = 0;\n\t\t_infoRender.points = 0;\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = null;\n\n\t\t}\n\n\t\tthis.setRenderTarget( renderTarget );\n\n\t\t//\n\n\t\tvar background = scene.background;\n\n\t\tif ( background === null ) {\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t} else if ( background instanceof THREE.Color ) {\n\n\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\n\t\t}\n\n\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background instanceof THREE.CubeTexture ) {\n\n\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\n\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n\t\t} else if ( background instanceof THREE.Texture ) {\n\n\t\t\tbackgroundPlaneMesh.material.map = background;\n\n\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\n\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\n\n\t\t} else {\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\t\t\trenderObjects( opaqueObjects, camera, fog );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\trenderObjects( transparentObjects, camera, fog );\n\n\t\t}\n\n\t\t// custom render plugins (post pass)\n\n\t\tspritePlugin.render( scene, camera );\n\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\tif ( renderTarget ) {\n\n\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tstate.setDepthTest( true );\n\t\tstate.setDepthWrite( true );\n\t\tstate.setColorWrite( true );\n\n\t\t// _gl.finish();\n\n\t};\n\n\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\n\t\tvar array, index;\n\n\t\t// allocate the next position in the appropriate array\n\n\t\tif ( material.transparent ) {\n\n\t\t\tarray = transparentObjects;\n\t\t\tindex = ++ transparentObjectsLastIndex;\n\n\t\t} else {\n\n\t\t\tarray = opaqueObjects;\n\t\t\tindex = ++ opaqueObjectsLastIndex;\n\n\t\t}\n\n\t\t// recycle existing render item or grow the array\n\n\t\tvar renderItem = array[ index ];\n\n\t\tif ( renderItem !== undefined ) {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.z = _vector3.z;\n\t\t\trenderItem.group = group;\n\n\t\t} else {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tz: _vector3.z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\t// assert( index === array.length );\n\t\t\tarray.push( renderItem );\n\n\t\t}\n\n\t}\n\n\t// TODO Duplicated code (Frustum)\n\n\tfunction isObjectViewable( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometry.boundingSphere === null )\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSpriteViewable( sprite ) {\n\n\t\t_sphere.center.set( 0, 0, 0 );\n\t\t_sphere.radius = 0.7071067811865476;\n\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSphereViewable( sphere ) {\n\n\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\tif ( numPlanes === 0 ) return true;\n\n\t\tvar planes = _this.clippingPlanes,\n\n\t\t\tcenter = sphere.center,\n\t\t\tnegRad = - sphere.radius,\n\t\t\ti = 0;\n\n\t\tdo {\n\n\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t} while ( ++ i !== numPlanes );\n\n\t\treturn true;\n\n\t}\n\n\tfunction projectObject( object, camera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\tlights.push( object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n\t\t\t\t\tsprites.push( object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\t\tlensFlares.push( object );\n\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\n\n\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar geometry = objects.update( object );\n\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera );\n\n\t\t}\n\n\t}\n\n\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\n\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\tvar object = renderItem.object;\n\t\t\tvar geometry = renderItem.geometry;\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\tvar group = renderItem.group;\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tsetMaterial( material );\n\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initMaterial( material, fog, object ) {\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tvar parameters = programCache.getParameters(\n\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, object );\n\n\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\tvar program = materialProperties.program;\n\t\tvar programChange = true;\n\n\t\tif ( program === undefined ) {\n\n\t\t\t// new material\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t} else if ( program.code !== code ) {\n\n\t\t\t// changed glsl or parameters\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t// same glsl and uniform list\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// only rebuild uniform list\n\t\t\tprogramChange = false;\n\n\t\t}\n\n\t\tif ( programChange ) {\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\n\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\n\t\t\tmaterialProperties.program = program;\n\t\t\tmaterial.program = program;\n\n\t\t}\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\n\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\n\t\t\t\tmaterial.clipping === true ) {\n\n\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t}\n\n\t\tif ( material.lights ) {\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\n\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\n\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\n\t\t}\n\n\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\tuniformsList =\n\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\tmaterialProperties.uniformsList = uniformsList;\n\t\tmaterialProperties.dynamicUniforms =\n\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\n\n\t}\n\n\tfunction setMaterial( material ) {\n\n\t\tif ( material.side !== THREE.DoubleSide )\n\t\t\tstate.enable( _gl.CULL_FACE );\n\t\telse\n\t\t\tstate.disable( _gl.CULL_FACE );\n\n\t\tstate.setFlipSided( material.side === THREE.BackSide );\n\n\t\tif ( material.transparent === true ) {\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\t} else {\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\n\t\t}\n\n\t\tstate.setDepthFunc( material.depthFunc );\n\t\tstate.setDepthTest( material.depthTest );\n\t\tstate.setDepthWrite( material.depthWrite );\n\t\tstate.setColorWrite( material.colorWrite );\n\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t}\n\n\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t_usedTextureUnits = 0;\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tif ( _clippingEnabled ) {\n\n\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\tvar useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t// (#8465, #8379)\n\t\t\t\t_clipping.setState(\n\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\n\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t}\n\n\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\tmaterialProperties.numClippingPlanes !== _clipping.numPlanes ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( materialProperties.lightsHash !== undefined &&\n\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tinitMaterial( material, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tvar refreshProgram = false;\n\t\tvar refreshMaterial = false;\n\t\tvar refreshLights = false;\n\n\t\tvar program = materialProperties.program,\n\t\t\tp_uniforms = program.getUniforms(),\n\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( program.id !== _currentProgram ) {\n\n\t\t\t_gl.useProgram( program.program );\n\t\t\t_currentProgram = program.id;\n\n\t\t\trefreshProgram = true;\n\t\t\trefreshMaterial = true;\n\t\t\trefreshLights = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t}\n\n\n\t\t\tif ( camera !== _currentCamera ) {\n\n\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t}\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material.envMap ) {\n\n\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material.skinning ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\tvar skeleton = object.skeleton;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t// values\n\t\t\t\t//\n\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t// the GL state when required\n\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t}\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t}\n\n\t\t\t// refresh single material specific uniforms\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\n\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\n\n\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\tTHREE.WebGLUniforms.upload(\n\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t}\n\n\n\t\t// common matrices\n\n\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\n\t\t// dynamic uniforms\n\n\t\tvar dynUniforms = materialProperties.dynamicUniforms;\n\n\t\tif ( dynUniforms !== null ) {\n\n\t\t\tTHREE.WebGLUniforms.evalDynamic(\n\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\n\n\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon ( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tuniforms.diffuse.value = material.color;\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tuniforms.map.value = material.map;\n\t\tuniforms.specularMap.value = material.specularMap;\n\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. specular map\n\t\t// 3. normal map\n\t\t// 4. bump map\n\t\t// 5. alpha map\n\t\t// 6. emissive map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.displacementMap ) {\n\n\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t} else if ( material.roughnessMap ) {\n\n\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t} else if ( material.metalnessMap ) {\n\n\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t} else if ( material.emissiveMap ) {\n\n\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tvar offset = uvScaleMap.offset;\n\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t\tuniforms.envMap.value = material.envMap;\n\n\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;\n\n\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t}\n\n\tfunction refreshUniformsLine ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\n\t}\n\n\tfunction refreshUniformsDash ( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\n\n\t\tuniforms.map.value = material.map;\n\n\t\tif ( material.map !== null ) {\n\n\t\t\tvar offset = material.map.offset;\n\t\t\tvar repeat = material.map.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsFog ( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value = fog.color;\n\n\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLambert ( uniforms, material ) {\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong ( uniforms, material ) {\n\n\t\tuniforms.specular.value = material.specular;\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard ( uniforms, material ) {\n\n\t\tuniforms.roughness.value = material.roughness;\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t}\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical ( uniforms, material ) {\n\n\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\trefreshUniformsStandard( uniforms, material );\n\n\t}\n\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\n\n\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\tuniforms.directionalLights.needsUpdate = value;\n\t\tuniforms.pointLights.needsUpdate = value;\n\t\tuniforms.spotLights.needsUpdate = value;\n\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t}\n\n\t// Lighting\n\n\tfunction setupShadows ( lights ) {\n\n\t\tvar lightShadowsLength = 0;\n\n\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tvar light = lights[ i ];\n\n\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.shadows.length = lightShadowsLength;\n\n\t}\n\n\tfunction setupLights ( lights, camera ) {\n\n\t\tvar l, ll, light,\n\t\tr = 0, g = 0, b = 0,\n\t\tcolor,\n\t\tintensity,\n\t\tdistance,\n\t\tshadowMap,\n\n\t\tviewMatrix = camera.matrixWorldInverse,\n\n\t\tdirectionalLength = 0,\n\t\tpointLength = 0,\n\t\tspotLength = 0,\n\t\themiLength = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tcolor = light.color;\n\t\t\tintensity = light.intensity;\n\t\t\tdistance = light.distance;\n\n\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\n\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\n\n\t\t\t\t}\n\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.ambient[ 0 ] = r;\n\t\t_lights.ambient[ 1 ] = g;\n\t\t_lights.ambient[ 2 ] = b;\n\n\t\t_lights.directional.length = directionalLength;\n\t\t_lights.spot.length = spotLength;\n\t\t_lights.point.length = pointLength;\n\t\t_lights.hemi.length = hemiLength;\n\n\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n\t}\n\n\t// GL state setting\n\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\tstate.setCullFace( cullFace );\n\t\tstate.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );\n\n\t};\n\n\t// Textures\n\n\tfunction allocTextureUnit() {\n\n\t\tvar textureUnit = _usedTextureUnits;\n\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t}\n\n\t\t_usedTextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\tthis.allocTextureUnit = allocTextureUnit;\n\n\t// this.setTexture2D = setTexture2D;\n\tthis.setTexture2D = ( function() {\n\n\t\tvar warned = false;\n\n\t\t// backwards compatibility: peel texture.texture\n\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\tif ( texture instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTexture = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTexture( texture, slot ) {\n\n\t\t\tif ( ! warned ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\twarned = true;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTextureCube = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\tif ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t// TODO: unify these code paths\n\t\t\tif ( texture instanceof THREE.CubeTexture ||\n\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t} else {\n\n\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tthis.getCurrentRenderTarget = function() {\n\n\t\treturn _currentRenderTarget;\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t_currentRenderTarget = renderTarget;\n\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t}\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar framebuffer;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\n\t\t\t}\n\n\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t_currentViewport.copy( renderTarget.viewport );\n\n\t\t} else {\n\n\t\t\tframebuffer = null;\n\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n\t\t}\n\n\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\tstate.scissor( _currentScissor );\n\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\tstate.viewport( _currentViewport );\n\n\t\tif ( isCube ) {\n\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t}\n\n\t};\n\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\tif ( framebuffer ) {\n\n\t\t\tvar restore = false;\n\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\trestore = true;\n\n\t\t\t}\n\n\t\t\ttry {\n\n\t\t\t\tvar texture = renderTarget.texture;\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\n\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\n\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\n\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t}\n\n\t\t\t} finally {\n\n\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Map three.js constants to WebGL constants\n\n\tfunction paramThreeToGL ( p ) {\n\n\t\tvar extension;\n\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\n\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\n\n\t\t}\n\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\n\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\n\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n};\n\n// File:src/renderers/WebGLRenderTarget.js\n\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n * @author Marius Kintel / https://github.com/kintel\n */\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\n\tthis.scissorTest = false;\n\n\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\n\n\toptions = options || {};\n\n\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\n\n\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\tthis.depthTexture = null;\n\n};\n\nObject.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {\n\n\tsetSize: function ( width, height ) {\n\n\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.texture = source.texture.clone();\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\tthis.depthTexture = source.depthTexture;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/renderers/WebGLRenderTargetCube.js\n\n/**\n * @author alteredq / http://alteredqualia.com\n */\n\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\tthis.activeMipMapLevel = 0;\n\n};\n\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\n\n// File:src/renderers/webgl/WebGLBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawArrays( mode, start, count );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar position = geometry.attributes.position;\n\n\t\tvar count = 0;\n\n\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tcount = position.data.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t} else {\n\n\t\t\tcount = position.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t}\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t}\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLClipping.js\n\nTHREE.WebGLClipping = function() {\n\n\tvar scope = this,\n\n\t\tglobalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false,\n\n\t\tplane = new THREE.Plane(),\n\t\tviewNormalMatrix = new THREE.Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\n\tthis.init = function( planes, enableLocalClipping, camera ) {\n\n\t\tvar enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function() {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function() {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function( planes, clipShadows, camera, cache, fromCache ) {\n\n\t\tif ( ! localClippingEnabled ||\n\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tcache.clippingState = dstArray;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\tdstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\treturn dstArray;\n\n\t}\n\n};\n\n\n// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tvar type, size;\n\n\tfunction setIndex( index ) {\n\n\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\ttype = _gl.UNSIGNED_INT;\n\t\t\tsize = 4;\n\n\t\t} else {\n\n\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\t\tsize = 2;\n\n\t\t}\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawElements( mode, count, type, start * size );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry, start, count ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t}\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLExtensions.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLExtensions = function ( gl ) {\n\n\tvar extensions = {};\n\n\tthis.get = function ( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tvar extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLCapabilities.js\n\nTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\n\n\tvar maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tthis.getMaxAnisotropy = getMaxAnisotropy;\n\tthis.getMaxPrecision = getMaxPrecision;\n\n\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\n\n\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\tthis.vertexTextures = this.maxVertexTextures > 0;\n\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\n\n\tvar _maxPrecision = getMaxPrecision( this.precision );\n\n\tif ( _maxPrecision !== this.precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\n\t\tthis.precision = _maxPrecision;\n\n\t}\n\n\tif ( this.logarithmicDepthBuffer ) {\n\n\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLGeometries.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLGeometries = function ( gl, properties, info ) {\n\n\tvar geometries = {};\n\n\tfunction get( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\n\t\t\treturn geometries[ geometry.id ];\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tvar buffergeometry;\n\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tbuffergeometry = geometry;\n\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\n\n\t\t\t}\n\n\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t}\n\n\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tvar geometry = event.target;\n\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\tdeleteAttribute( buffergeometry.index );\n\n\t\t}\n\n\t\tdeleteAttributes( buffergeometry.attributes );\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\t// TODO\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe ) {\n\n\t\t\tdeleteAttribute( property.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( geometry );\n\n\t\tvar bufferproperty = properties.get( buffergeometry );\n\n\t\tif ( bufferproperty.wireframe ) {\n\n\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( buffergeometry );\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction deleteAttribute( attribute ) {\n\n\t\tvar buffer = getAttributeBuffer( attribute );\n\n\t\tif ( buffer !== undefined ) {\n\n\t\t\tgl.deleteBuffer( buffer );\n\t\t\tremoveAttributeBuffer( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction deleteAttributes( attributes ) {\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tdeleteAttribute( attributes[ name ] );\n\n\t\t}\n\n\t}\n\n\tfunction removeAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tproperties.delete( attribute.data );\n\n\t\t} else {\n\n\t\t\tproperties.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tthis.get = get;\n\n};\n\n// File:src/renderers/webgl/WebGLLights.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLLights = function () {\n\n\tvar lights = {};\n\n\tthis.get = function ( light ) {\n\n\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\treturn lights[ light.id ];\n\n\t\t}\n\n\t\tvar uniforms;\n\n\t\tswitch ( light.type ) {\n\n\t\t\tcase 'DirectionalLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tconeCos: 0,\n\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tskyColor: new THREE.Color(),\n\t\t\t\t\tgroundColor: new THREE.Color()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tlights[ light.id ] = uniforms;\n\n\t\treturn uniforms;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLObjects.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLObjects = function ( gl, properties, info ) {\n\n\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\n\n\t//\n\n\tfunction update( object ) {\n\n\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n\t\tvar geometry = geometries.get( object );\n\n\t\tif ( object.geometry instanceof THREE.Geometry ) {\n\n\t\t\tgeometry.updateFromObject( object );\n\n\t\t}\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\n\t\tif ( index !== null ) {\n\n\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction updateAttribute( attribute, bufferType ) {\n\n\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\n\n\t\tvar attributeProperties = properties.get( data );\n\n\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\n\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\n\t\t} else if ( attributeProperties.version !== data.version ) {\n\n\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\n\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\tgl.bufferData( bufferType, data.array, usage );\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\n\t\t} else if ( data.updateRange.count === 0 ) {\n\n\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t} else {\n\n\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n\t\t\tdata.updateRange.count = 0; // reset range\n\n\t\t}\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe !== undefined ) {\n\n\t\t\treturn property.wireframe;\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\t\tvar position = attributes.position;\n\n\t\t// console.time( 'wireframe' );\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar edges = {};\n\t\t\tvar array = index.array;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\n\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\n\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar array = attributes.position.array;\n\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tvar a = i + 0;\n\t\t\t\tvar b = i + 1;\n\t\t\t\tvar c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// console.timeEnd( 'wireframe' );\n\n\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\n\n\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\tproperty.wireframe = attribute;\n\n\t\treturn attribute;\n\n\t}\n\n\tfunction checkEdge( edges, a, b ) {\n\n\t\tif ( a > b ) {\n\n\t\t\tvar tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\n\t\t}\n\n\t\tvar list = edges[ a ];\n\n\t\tif ( list === undefined ) {\n\n\t\t\tedges[ a ] = [ b ];\n\t\t\treturn true;\n\n\t\t} else if ( list.indexOf( b ) === -1 ) {\n\n\t\t\tlist.push( b );\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tthis.getAttributeBuffer = getAttributeBuffer;\n\tthis.getWireframeAttribute = getWireframeAttribute;\n\n\tthis.update = update;\n\n};\n\n// File:src/renderers/webgl/WebGLProgram.js\n\nTHREE.WebGLProgram = ( function () {\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase THREE.LinearEncoding:\n\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\tcase THREE.sRGBEncoding:\n\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\tcase THREE.RGBEEncoding:\n\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\tcase THREE.RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\tcase THREE.RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\tcase THREE.RGBDEncoding:\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\tcase THREE.GammaEncoding:\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase THREE.LinearToneMapping:\n\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.ReinhardToneMapping:\n\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.CineonToneMapping:\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = THREE.ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\treturn function WebGLProgram( renderer, code, material, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar extensions = material.extensions;\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeReflectionMapping:\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.CubeUVReflectionMapping:\n\t\t\t\tcase THREE.CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.EquirectangularReflectionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase THREE.MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material instanceof THREE.RawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\n\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\n\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\t}\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function() {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms =\n\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function() {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function() {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLPrograms.js\n\nTHREE.WebGLPrograms = function ( renderer, capabilities ) {\n\n\tvar programs = [];\n\n\tvar shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points'\n\t};\n\n\tvar parameterNames = [\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\n\t];\n\n\n\tfunction allocateBones ( object ) {\n\n\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t//\n\t\t\t//  - leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t}\n\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\tvar encoding;\n\n\t\tif ( ! map ) {\n\n\t\t\tencoding = THREE.LinearEncoding;\n\n\t\t} else if ( map instanceof THREE.Texture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\tencoding = map.texture.encoding;\n\n\t\t}\n\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\tencoding = THREE.GammaEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\n\n\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tvar maxBones = allocateBones( object );\n\t\tvar precision = renderer.getPrecision();\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\n\t\tvar parameters = {\n\n\t\t\tshaderID: shaderID,\n\n\t\t\tprecision: precision,\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\tmap: !! material.map,\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\tenvMap: !! material.envMap,\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\n\t\t\tlightMap: !! material.lightMap,\n\t\t\taoMap: !! material.aoMap,\n\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\tbumpMap: !! material.bumpMap,\n\t\t\tnormalMap: !! material.normalMap,\n\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\tspecularMap: !! material.specularMap,\n\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\tcombine: material.combine,\n\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\n\t\t\tflatShading: material.shading === THREE.FlatShading,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\tskinning: material.skinning,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumClippingPlanes: nClipPlanes,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\tflipSided: material.side === THREE.BackSide,\n\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t};\n\n\t\treturn parameters;\n\n\t};\n\n\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\tvar array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( material.fragmentShader );\n\t\t\tarray.push( material.vertexShader );\n\n\t\t}\n\n\t\tif ( material.defines !== undefined ) {\n\n\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t}\n\n\t\treturn array.join();\n\n\t};\n\n\tthis.acquireProgram = function ( material, parameters, code ) {\n\n\t\tvar program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\tprogram = programInfo;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\tthis.releaseProgram = function( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tvar i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t};\n\n\t// Exposed for resource monitoring & error feedback via renderer.info:\n\tthis.programs = programs;\n\n};\n\n// File:src/renderers/webgl/WebGLProperties.js\n\n/**\n* @author fordacious / fordacious.github.io\n*/\n\nTHREE.WebGLProperties = function () {\n\n\tvar properties = {};\n\n\tthis.get = function ( object ) {\n\n\t\tvar uuid = object.uuid;\n\t\tvar map = properties[ uuid ];\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties[ uuid ] = map;\n\n\t\t}\n\n\t\treturn map;\n\n\t};\n\n\tthis.delete = function ( object ) {\n\n\t\tdelete properties[ object.uuid ];\n\n\t};\n\n\tthis.clear = function () {\n\n\t\tproperties = {};\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLShader.js\n\nTHREE.WebGLShader = ( function () {\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\treturn function WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLShadowMap.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\n\n\tvar _gl = _renderer.context,\n\t_state = _renderer.state,\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_lightShadows = _lights.shadows,\n\n\t_shadowMapSize = new THREE.Vector2(),\n\n\t_lookTarget = new THREE.Vector3(),\n\t_lightPositionWorld = new THREE.Vector3(),\n\n\t_renderList = [],\n\n\t_MorphingFlag = 1,\n\t_SkinningFlag = 2,\n\n\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t_materialCache = {};\n\n\tvar cubeDirections = [\n\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\n\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\n\t];\n\n\tvar cubeUps = [\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\n\t];\n\n\tvar cube2DViewPorts = [\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\n\t];\n\n\t// init\n\n\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\n\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\n\tdepthMaterialTemplate.clipping = true;\n\n\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\n\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\n\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\tdepthMaterial.morphTargets = useMorphing;\n\t\tdepthMaterial.skinning = useSkinning;\n\n\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\n\t\t\tdefines: {\n\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t},\n\t\t\tuniforms: distanceUniforms,\n\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\tmorphTargets: useMorphing,\n\t\t\tskinning: useSkinning,\n\t\t\tclipping: true\n\t\t} );\n\n\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t}\n\n\t//\n\n\tvar scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = THREE.PCFShadowMap;\n\n\tthis.renderReverseSided = true;\n\tthis.renderSingleSided = true;\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( _lightShadows.length === 0 ) return;\n\n\t\t// Set GL state for depth map.\n\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t_state.disable( _gl.BLEND );\n\t\t_state.setDepthTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tvar faceCount, isPointLight;\n\n\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n\t\t\tvar light = _lightShadows[ i ];\n\t\t\tvar shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tif ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tfaceCount = 6;\n\t\t\t\tisPointLight = true;\n\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t// following orientation:\n\t\t\t\t//\n\t\t\t\t//  xzXZ\n\t\t\t\t//   y Y\n\t\t\t\t//\n\t\t\t\t// X - Positive x direction\n\t\t\t\t// x - Negative x direction\n\t\t\t\t// Y - Positive y direction\n\t\t\t\t// y - Negative y direction\n\t\t\t\t// Z - Positive z direction\n\t\t\t\t// z - Negative z direction\n\n\t\t\t\t// positive X\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative X\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Z\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative Z\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Y\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t// negative Y\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t} else {\n\n\t\t\t\tfaceCount = 1;\n\t\t\t\tisPointLight = false;\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\n\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\n\n\t\t\t\tshadow.update( light );\n\n\t\t\t}\n\n\t\t\tvar shadowMap = shadow.map;\n\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t// run a single pass if not\n\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t}\n\n\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\t\t// compute shadow matrix\n\n\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t);\n\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t_renderList.length = 0;\n\n\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\n\t\t\t\t// render shadow map\n\t\t\t\t// render regular objects\n\n\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Restore GL state.\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\n\t\tscope.needsUpdate = false;\n\n\t};\n\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tvar result = null;\n\n\t\tvar materialVariants = _depthMaterials;\n\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\tif ( isPointLight ) {\n\n\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t}\n\n\t\tif ( ! customMaterial ) {\n\n\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\n\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\n\n\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\n\n\t\t\tvar variantIndex = 0;\n\n\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t} else {\n\n\t\t\tresult = customMaterial;\n\n\t\t}\n\n\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t material.clipShadows === true &&\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tvar side = material.side;\n\n\t\tif ( scope.renderSingleSided && side == THREE.DoubleSide ) {\n\n\t\t\tside = THREE.FrontSide;\n\n\t\t}\n\n\t\tif ( scope.renderReverseSided ) {\n\n\t\t\tif ( side === THREE.FrontSide ) side = THREE.BackSide;\n\t\t\telse if ( side === THREE.BackSide ) side = THREE.FrontSide;\n\n\t\t}\n\n\t\tresult.side = side;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction projectObject( object, camera, shadowCamera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\n\n\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t_renderList.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLState.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\n\n\tvar _this = this;\n\n\tthis.buffers = {\n\t\tcolor: new THREE.WebGLColorBuffer( gl, this ),\n\t\tdepth: new THREE.WebGLDepthBuffer( gl, this ),\n\t\tstencil: new THREE.WebGLStencilBuffer( gl, this )\n\t};\n\n\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\tvar capabilities = {};\n\n\tvar compressedTextureFormats = null;\n\n\tvar currentBlending = null;\n\tvar currentBlendEquation = null;\n\tvar currentBlendSrc = null;\n\tvar currentBlendDst = null;\n\tvar currentBlendEquationAlpha = null;\n\tvar currentBlendSrcAlpha = null;\n\tvar currentBlendDstAlpha = null;\n\tvar currentPremultipledAlpha = false;\n\n\tvar currentFlipSided = null;\n\tvar currentCullFace = null;\n\n\tvar currentLineWidth = null;\n\n\tvar currentPolygonOffsetFactor = null;\n\tvar currentPolygonOffsetUnits = null;\n\n\tvar currentScissorTest = null;\n\n\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n\tvar currentTextureSlot = null;\n\tvar currentBoundTextures = {};\n\n\tvar currentScissor = new THREE.Vector4();\n\tvar currentViewport = new THREE.Vector4();\n\n\tfunction createTexture( type, target, count ) {\n\n\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tvar texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tvar emptyTextures = {};\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t//\n\n\tthis.init = function () {\n\n\t\tthis.clearColor( 0, 0, 0, 1 );\n\t\tthis.clearDepth( 1 );\n\t\tthis.clearStencil( 0 );\n\n\t\tthis.enable( gl.DEPTH_TEST );\n\t\tthis.setDepthFunc( THREE.LessEqualDepth );\n\n\t\tthis.setFlipSided( false );\n\t\tthis.setCullFace( THREE.CullFaceBack );\n\t\tthis.enable( gl.CULL_FACE );\n\n\t\tthis.enable( gl.BLEND );\n\t\tthis.setBlending( THREE.NormalBlending );\n\n\t};\n\n\tthis.initAttributes = function () {\n\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttribute = function ( attribute ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t};\n\n\tthis.disableUnusedAttributes = function () {\n\n\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.enable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tcapabilities[ id ] = true;\n\n\t\t}\n\n\t};\n\n\tthis.disable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tcapabilities[ id ] = false;\n\n\t\t}\n\n\t};\n\n\tthis.getCompressedTextureFormats = function () {\n\n\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\tcompressedTextureFormats = [];\n\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn compressedTextureFormats;\n\n\t};\n\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending !== THREE.NoBlending ) {\n\n\t\t\tthis.enable( gl.BLEND );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.BLEND );\n\t\t\tcurrentBlending = blending; // no blending, that is\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\tif ( blending === THREE.AdditiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentBlending = blending;\n\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t}\n\n\t\tif ( blending === THREE.CustomBlending ) {\n\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t}\n\n\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tcurrentBlendEquation = null;\n\t\t\tcurrentBlendSrc = null;\n\t\t\tcurrentBlendDst = null;\n\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.setColorWrite = function ( colorWrite ) {\n\n\t\tthis.buffers.color.setMask( colorWrite );\n\n\t};\n\n\tthis.setDepthTest = function ( depthTest ) {\n\n\t\tthis.buffers.depth.setTest( depthTest );\n\n\t};\n\n\tthis.setDepthWrite = function ( depthWrite ) {\n\n\t\tthis.buffers.depth.setMask( depthWrite );\n\n\t};\n\n\tthis.setDepthFunc = function ( depthFunc ) {\n\n\t\tthis.buffers.depth.setFunc( depthFunc );\n\n\t};\n\n\tthis.setStencilTest = function ( stencilTest ) {\n\n\t\tthis.buffers.stencil.setTest( stencilTest );\n\n\t};\n\n\tthis.setStencilWrite = function ( stencilWrite ) {\n\n\t\tthis.buffers.stencil.setMask( stencilWrite );\n\n\t};\n\n\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tthis.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );\n\n\t};\n\n\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tthis.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );\n\n\t};\n\n\t//\n\n\tthis.setFlipSided = function ( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t};\n\n\tthis.setCullFace = function ( cullFace ) {\n\n\t\tif ( cullFace !== THREE.CullFaceNone ) {\n\n\t\t\tthis.enable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t};\n\n\tthis.setLineWidth = function ( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tgl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t};\n\n\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t};\n\n\tthis.getScissorTest = function () {\n\n\t\treturn currentScissorTest;\n\n\t};\n\n\tthis.setScissorTest = function ( scissorTest ) {\n\n\t\tcurrentScissorTest = scissorTest;\n\n\t\tif ( scissorTest ) {\n\n\t\t\tthis.enable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t};\n\n\t// texture\n\n\tthis.activeTexture = function ( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t};\n\n\tthis.bindTexture = function ( webglType, webglTexture ) {\n\n\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t_this.activeTexture();\n\n\t\t}\n\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t};\n\n\tthis.compressedTexImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\tthis.texImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.clearColor = function ( r, g, b, a ) {\n\n\t\tthis.buffers.color.setClear( r, g, b, a );\n\n\t};\n\n\tthis.clearDepth = function ( depth ) {\n\n\t\tthis.buffers.depth.setClear( depth );\n\n\t};\n\n\tthis.clearStencil = function ( stencil ) {\n\n\t\tthis.buffers.stencil.setClear( stencil );\n\n\t};\n\n\t//\n\n\tthis.scissor = function ( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t};\n\n\tthis.viewport = function ( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tthis.reset = function () {\n\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcapabilities = {};\n\n\t\tcompressedTextureFormats = null;\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentBlending = null;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tthis.buffers.color.reset();\n\t\tthis.buffers.depth.reset();\n\t\tthis.buffers.stencil.reset();\n\n\t};\n\n};\n\nTHREE.WebGLColorBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar color = new THREE.Vector4();\n\tvar currentColorMask = null;\n\tvar currentColorClear = new THREE.Vector4();\n\n\tthis.setMask = function ( colorMask ) {\n\n\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\tcurrentColorMask = colorMask;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( r, g, b, a ) {\n\n\t\tcolor.set( r, g, b, a );\n\n\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\tgl.clearColor( r, g, b, a );\n\t\t\tcurrentColorClear.copy( color );\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentColorMask = null;\n\t\tcurrentColorClear = new THREE.Vector4();\n\n\t};\n\n};\n\nTHREE.WebGLDepthBuffer = function( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentDepthMask = null;\n\tvar currentDepthFunc = null;\n\tvar currentDepthClear = null;\n\n\tthis.setTest = function ( depthTest ) {\n\n\t\tif ( depthTest ) {\n\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function( depthMask ){\n\n\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\tgl.depthMask( depthMask );\n\t\t\tcurrentDepthMask = depthMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( depthFunc ) {\n\n\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\tif ( depthFunc ) {\n\n\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\tcase THREE.NeverDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.AlwaysDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.EqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.NotEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t}\n\n\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( depth ) {\n\n\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\tgl.clearDepth( depth );\n\t\t\tcurrentDepthClear = depth;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentDepthMask = null;\n\t\tcurrentDepthFunc = null;\n\t\tcurrentDepthClear = null;\n\n\t};\n\n};\n\nTHREE.WebGLStencilBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentStencilMask = null;\n\tvar currentStencilFunc = null;\n\tvar currentStencilRef = null;\n\tvar currentStencilFuncMask = null;\n\tvar currentStencilFail  = null;\n\tvar currentStencilZFail = null;\n\tvar currentStencilZPass = null;\n\tvar currentStencilClear = null;\n\n\tthis.setTest = function ( stencilTest ) {\n\n\t\tif ( stencilTest ) {\n\n\t\t\tstate.enable( gl.STENCIL_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.STENCIL_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function ( stencilMask ) {\n\n\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\tgl.stencilMask( stencilMask );\n\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\n\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setOp\t = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t     currentStencilZFail !== stencilZFail ||\n\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\n\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( stencil ) {\n\n\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\tgl.clearStencil( stencil );\n\t\t\tcurrentStencilClear = stencil;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentStencilMask = null;\n\t\tcurrentStencilFunc = null;\n\t\tcurrentStencilRef = null;\n\t\tcurrentStencilFuncMask = null;\n\t\tcurrentStencilFail = null;\n\t\tcurrentStencilZFail = null;\n\t\tcurrentStencilZPass = null;\n\t\tcurrentStencilClear = null;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLTextures.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLTextures = function ( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n\tvar _infoMemory = info.memory;\n\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n\t//\n\n\tfunction clampToMaxSize ( image, maxSize ) {\n\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t// premultiplied alpha.\n\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction isPowerOfTwo( image ) {\n\n\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\n\n\t}\n\n\tfunction makePowerOfTwo( image ) {\n\n\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\n\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\n\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\n\n\t\treturn false;\n\n\t}\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback ( f ) {\n\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\n\t\t\treturn _gl.NEAREST;\n\n\t\t}\n\n\t\treturn _gl.LINEAR;\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tvar texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\t_infoMemory.textures --;\n\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tvar renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t_infoMemory.textures --;\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t// cube texture\n\n\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t} else {\n\n\t\t\t// 2D texture\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\t// remove all webgl properties\n\t\tproperties.delete( texture );\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\tif ( ! renderTarget ) return;\n\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t}\n\n\t\tproperties.delete( renderTarget.texture );\n\t\tproperties.delete( renderTarget );\n\n\t}\n\n\t//\n\n\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tvar image = texture.image;\n\n\t\t\tif ( image === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTextureCube ( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t} else {\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setTextureCubeDynamic ( texture, slot ) {\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t}\n\n\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\n\n\t\tvar extension;\n\n\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension ) {\n\n\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t_infoMemory.textures ++;\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\timage = makePowerOfTwo( image );\n\n\t\t}\n\n\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\tglFormat = paramThreeToGL( texture.format ),\n\t\tglType = paramThreeToGL( texture.type );\n\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\tif ( texture instanceof THREE.DepthTexture ) {\n\n\t\t\t// populate depth texture with dummy data\n\n\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\tif ( texture.type === THREE.FloatType ) {\n\n\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t}\n\n\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t} else if ( texture instanceof THREE.DataTexture ) {\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t}\n\n\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\n\n\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t_infoMemory.textures ++;\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tvar texture = renderTarget.texture;\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\n\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t_gl.generateMipmap( target );\n\t\t\tstate.bindTexture( target, null );\n\n\t\t}\n\n\t}\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n};\n\n// File:src/renderers/webgl/WebGLUniforms.js\n\n/**\n *\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [renderer] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'renderer' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (renderer factorizations):\n *\n * .upload( gl, seq, values, renderer )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n * .splitDynamic( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\n *\n *\n * Methods of the top-level container (renderer factorizations):\n *\n * .setValue( gl, name, value )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .set( gl, obj, prop )\n *\n * \t\tsets uniform from object and property with same name than uniform\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n *\n * @author tschw\n *\n */\n\nTHREE.WebGLUniforms = ( function() { // scope\n\n\tvar emptyTexture = new THREE.Texture();\n\tvar emptyCubeTexture = new THREE.CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tvar UniformContainer = function() {\n\n\t\t\tthis.seq = [];\n\t\t\tthis.map = {};\n\n\t\t},\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\t\tarrayCacheF32 = [],\n\t\tarrayCacheI32 = [],\n\n\t\tuncacheTemporaryArrays = function() {\n\n\t\t\tarrayCacheF32.length = 0;\n\t\t\tarrayCacheI32.length = 0;\n\n\t\t},\n\n\t// Flattening for arrays of vectors and matrices\n\n\t\tflatten = function( array, nBlocks, blockSize ) {\n\n\t\t\tvar firstElem = array[ 0 ];\n\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t// see http://jacksondunstan.com/articles/983\n\n\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\tr = arrayCacheF32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Float32Array( n );\n\t\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tif ( nBlocks !== 0 ) {\n\n\t\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\t\toffset += blockSize;\n\t\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// Texture unit allocation\n\n\t\tallocTexUnits = function( renderer, n ) {\n\n\t\t\tvar r = arrayCacheI32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Int32Array( n );\n\t\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t\t// Single scalar\n\n\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\n\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\n\n\t\t// Single float vector (from flat array or THREE.VectorN)\n\n\t\tsetValue2fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\n\t\t},\n\n\t\tsetValue3fv = function( gl, v ) {\n\n\t\t\tif ( v.x !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\t\telse if ( v.r !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\t\telse\n\t\t\t\tgl.uniform3fv( this.addr, v );\n\n\t\t},\n\n\t\tsetValue4fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t},\n\n\t\t// Single matrix (from flat array or MatrixN)\n\n\t\tsetValue2fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue3fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue4fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\t// Single texture (2D / Cube)\n\n\t\tsetValueT1 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t\t},\n\n\t\tsetValueT6 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t\t},\n\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\n\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\n\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\n\n\t\t// Helper to pick the right setter for the singular case\n\n\t\tgetSingularSetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Array of scalars\n\n\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\n\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\n\n\t\t// Array of vectors (flat or from THREE classes)\n\n\t\tsetValueV2a = function( gl, v ) {\n\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t\t},\n\n\t\tsetValueV3a = function( gl, v ) {\n\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t\t},\n\n\t\tsetValueV4a = function( gl, v ) {\n\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\t// Array of matrices (flat or from THREE clases)\n\n\t\tsetValueM2a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\tsetValueM3a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t\t},\n\n\t\tsetValueM4a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t\t},\n\n\t\t// Array of textures (2D / Cube)\n\n\t\tsetValueT1a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetValueT6a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\t\tgetPureArraySetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t// --- Uniform Classes ---\n\n\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tPureArrayUniform = function( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.size = activeInfo.size;\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tStructuredUniform = function( id ) {\n\n\t\t\tthis.id = id;\n\n\t\t\tUniformContainer.call( this ); // mix-in\n\n\t\t};\n\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\n\t\t// extracts\n\t\t// \t- the identifier (member name or array index)\n\t\t//  - followed by an optional right bracket (found when array index)\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t//\n\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t// in the uniform names.\n\n\t\taddUniform = function( container, uniformObject ) {\n\n\t\t\tcontainer.seq.push( uniformObject );\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t\t},\n\n\t\tparseUniform = function( activeInfo, addr, container ) {\n\n\t\t\tvar path = activeInfo.name,\n\t\t\t\tpathLength = path.length;\n\n\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\tRePathPart.lastIndex = 0;\n\n\t\t\tfor (; ;) {\n\n\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\t\tif ( subscript === undefined ||\n\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\t\tvar map = container.map,\n\t\t\t\t\t\tnext = map[ id ];\n\n\t\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer = next;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t// Root Container\n\n\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\n\n\t\t\tUniformContainer.call( this );\n\n\t\t\tthis.renderer = renderer;\n\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\tpath = info.name,\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\t\tparseUniform( info, addr, this );\n\n\t\t\t}\n\n\t\t};\n\n\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.splitDynamic = function( seq, values ) {\n\n\t\tvar r = null,\n\t\t\tn = seq.length,\n\t\t\tw = 0;\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v && v.dynamic === true ) {\n\n\t\t\t\tif ( r === null ) r = [];\n\t\t\t\tr.push( u );\n\n\t\t\t} else {\n\n\t\t\t\t// in-place compact 'seq', removing the matches\n\t\t\t\tif ( w < i ) seq[ w ] = u;\n\t\t\t\t++ w;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( w < n ) seq.length = w;\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar v = values[ seq[ i ].id ],\n\t\t\t\tf = v.onUpdateCallback;\n\n\t\t\tif ( f !== undefined ) f.call( v, object, camera );\n\n\t\t}\n\n\t};\n\n\treturn WebGLUniforms;\n\n} )();\n\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar shader, program, attributes, uniforms;\n\n\tvar tempTexture, occlusionTexture;\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 1, - 1,  0, 0,\n\t\t\t 1, - 1,  1, 0,\n\t\t\t 1,  1,  1, 1,\n\t\t\t- 1,  1,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\t// buffers\n\n\t\tvertexBuffer     = gl.createBuffer();\n\t\telementBuffer    = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t// textures\n\n\t\ttempTexture      = gl.createTexture();\n\t\tocclusionTexture = gl.createTexture();\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tshader = {\n\n\t\t\tvertexShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\"uniform float rotation;\",\n\n\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\n\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" ),\n\n\t\t\tfragmentShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t// pink square\n\n\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t\t// restore\n\n\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t\t// flare\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" )\n\n\t\t};\n\n\t\tprogram = createProgram( shader );\n\n\t\tattributes = {\n\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t};\n\n\t\tuniforms = {\n\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t};\n\n\t}\n\n\t/*\n\t * Render lens flares\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t *         reads these back and calculates occlusion.\n\t */\n\n\tthis.render = function ( scene, camera, viewport ) {\n\n\t\tif ( flares.length === 0 ) return;\n\n\t\tvar tempPosition = new THREE.Vector3();\n\n\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\thalfViewportHeight = viewport.w * 0.5;\n\n\t\tvar size = 16 / viewport.w,\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\n\t\tvar validArea = new THREE.Box2();\n\n\t\tvalidArea.min.set( 0, 0 );\n\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.vertex );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\t// loop through all lens flares to update their occlusion and positions\n\t\t// setup gl and common used attribs/uniforms\n\n\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\tgl.uniform1i( uniforms.map, 1 );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.setDepthWrite( false );\n\n\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n\t\t\tsize = 16 / viewport.w;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t// calc object screen position\n\n\t\t\tvar flare = flares[ i ];\n\n\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t// setup arrays for gl programs\n\n\t\t\tscreenPosition.copy( tempPosition );\n\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t// screen cull\n\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// render pink quad\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// restore graphics\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// update object positions\n\n\t\t\t\tflare.positionScreen.copy( screenPosition );\n\n\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t}\n\n\t\t\t\t// render flares\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\tstate.enable( gl.BLEND );\n\n\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\n\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\t\tstate.enable( gl.DEPTH_TEST );\n\t\tstate.setDepthWrite( true );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram ( shader ) {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\tgl.compileShader( fragmentShader );\n\t\tgl.compileShader( vertexShader );\n\n\t\tgl.attachShader( program, fragmentShader );\n\t\tgl.attachShader( program, vertexShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n};\n\n// File:src/renderers/webgl/plugins/SpritePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpritePlugin = function ( renderer, sprites ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar program, attributes, uniforms;\n\n\tvar texture;\n\n\t// decompose matrixWorld\n\n\tvar spritePosition = new THREE.Vector3();\n\tvar spriteRotation = new THREE.Quaternion();\n\tvar spriteScale = new THREE.Vector3();\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t- 0.5,   0.5,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\tvertexBuffer  = gl.createBuffer();\n\t\telementBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\tprogram = createProgram();\n\n\t\tattributes = {\n\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t};\n\n\t\tuniforms = {\n\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\n\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\n\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t};\n\n\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tcanvas.width = 8;\n\t\tcanvas.height = 8;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = 'white';\n\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\ttexture = new THREE.Texture( canvas );\n\t\ttexture.needsUpdate = true;\n\n\t}\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( sprites.length === 0 ) return;\n\n\t\t// setup gl\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.position );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.enable( gl.BLEND );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\tvar oldFogType = 0;\n\t\tvar sceneFogType = 0;\n\t\tvar fog = scene.fog;\n\n\t\tif ( fog ) {\n\n\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\toldFogType = 1;\n\t\t\t\tsceneFogType = 1;\n\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\toldFogType = 2;\n\t\t\t\tsceneFogType = 2;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\toldFogType = 0;\n\t\t\tsceneFogType = 0;\n\n\t\t}\n\n\n\t\t// update positions and sort\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\n\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t}\n\n\t\tsprites.sort( painterSortStable );\n\n\t\t// render all sprites\n\n\t\tvar scale = [];\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\t\t\tvar material = sprite.material;\n\n\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\tvar fogType = 0;\n\n\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\tfogType = sceneFogType;\n\n\t\t\t}\n\n\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\toldFogType = fogType;\n\n\t\t\t}\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t}\n\n\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setTexture2D( texture, 0 );\n\n\t\t\t}\n\n\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram () {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform float rotation;',\n\t\t\t'uniform vec2 scale;',\n\t\t\t'uniform vec2 uvOffset;',\n\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t'attribute vec2 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D map;',\n\t\t\t'uniform float opacity;',\n\n\t\t\t'uniform int fogType;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t\t'uniform float fogDensity;',\n\t\t\t'uniform float fogNear;',\n\t\t\t'uniform float fogFar;',\n\t\t\t'uniform float alphaTest;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t'}',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.compileShader( vertexShader );\n\t\tgl.compileShader( fragmentShader );\n\n\t\tgl.attachShader( program, vertexShader );\n\t\tgl.attachShader( program, fragmentShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\t\t\n\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn b.id - a.id;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/Three.Legacy.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.assign( THREE, {\n\tFace4: function ( a, b, c, d, normal, color, materialIndex ) {\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\n\t},\n\tLineStrip: 0,\n\tLinePieces: 1,\n\tMeshFaceMaterial: THREE.MultiMaterial,\n\tPointCloud: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tParticle: THREE.Sprite,\n\tParticleSystem: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tPointCloudMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleBasicMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleSystemMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tVertex: function ( x, y, z ) {\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new THREE.Vector3( x, y, z );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Box2.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t}\n} );\n\nObject.assign( THREE.Box3.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Matrix3.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\treturn vector.applyMatrix3( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t}\n} );\n\nObject.assign( THREE.Matrix4.prototype, {\n\textractPosition: function ( m ) {\n\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\treturn this.copyPosition( m );\n\t},\n\tsetRotationFromQuaternion: function ( q ) {\n\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\treturn this.makeRotationFromQuaternion( q );\n\t},\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\treturn vector.applyProjection( this );\n\t},\n\tmultiplyVector4: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t},\n\trotateAxis: function ( v ) {\n\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\tv.transformDirection( this );\n\t},\n\tcrossVector: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\ttranslate: function ( v ) {\n\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t},\n\trotateX: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t},\n\trotateY: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t},\n\trotateZ: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t},\n\trotateByAxis: function ( axis, angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t}\n} );\n\nObject.assign( THREE.Plane.prototype, {\n\tisIntersectionLine: function ( line ) {\n\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\treturn this.intersectsLine( line );\n\t}\n} );\n\nObject.assign( THREE.Quaternion.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\treturn vector.applyQuaternion( this );\n\t}\n} );\n\nObject.assign( THREE.Ray.prototype, {\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionPlane: function ( plane ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\treturn this.intersectsPlane( plane );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Vector3.prototype, {\n\tsetEulerFromRotationMatrix: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t},\n\tsetEulerFromQuaternion: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t},\n\tgetPositionFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\treturn this.setFromMatrixPosition( m );\n\t},\n\tgetScaleFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\treturn this.setFromMatrixScale( m );\n\t},\n\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\treturn this.setFromMatrixColumn( matrix, index );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Object3D.prototype, {\n\tgetChildByName: function ( name ) {\n\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\treturn this.getObjectByName( name );\n\t},\n\trenderDepth: function ( value ) {\n\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t},\n\ttranslate: function ( distance, axis ) {\n\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\treturn this.translateOnAxis( axis, distance );\n\t}\n} );\n\nObject.defineProperties( THREE.Object3D.prototype, {\n\teulerOrder: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\treturn this.rotation.order;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\tthis.rotation.order = value;\n\t\t}\n\t},\n\tuseQuaternion: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.LOD.prototype, {\n\tobjects: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\treturn this.levels;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\tthis.setFocalLength( focalLength );\n\n};\n\n//\n\nObject.defineProperties( THREE.Light.prototype, {\n\tonlyShadow: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t}\n\t},\n\tshadowCameraFov: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\tthis.shadow.camera.fov = value;\n\t\t}\n\t},\n\tshadowCameraLeft: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\tthis.shadow.camera.left = value;\n\t\t}\n\t},\n\tshadowCameraRight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\tthis.shadow.camera.right = value;\n\t\t}\n\t},\n\tshadowCameraTop: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\tthis.shadow.camera.top = value;\n\t\t}\n\t},\n\tshadowCameraBottom: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\tthis.shadow.camera.bottom = value;\n\t\t}\n\t},\n\tshadowCameraNear: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\tthis.shadow.camera.near = value;\n\t\t}\n\t},\n\tshadowCameraFar: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\tthis.shadow.camera.far = value;\n\t\t}\n\t},\n\tshadowCameraVisible: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t}\n\t},\n\tshadowBias: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\tthis.shadow.bias = value;\n\t\t}\n\t},\n\tshadowDarkness: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t}\n\t},\n\tshadowMapWidth: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\tthis.shadow.mapSize.width = value;\n\t\t}\n\t},\n\tshadowMapHeight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\tthis.shadow.mapSize.height = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.BufferAttribute.prototype, {\n\tlength: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\treturn this.array.length;\n\t\t}\n\t}\n} );\n\nObject.assign( THREE.BufferGeometry.prototype, {\n\taddIndex: function ( index ) {\n\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\tthis.setIndex( index );\n\t},\n\taddDrawCall: function ( start, count, indexOffset ) {\n\t\tif ( indexOffset !== undefined ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t}\n\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\tthis.addGroup( start, count );\n\t},\n\tclearDrawCalls: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\tthis.clearGroups();\n\t},\n\tcomputeTangents: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t},\n\tcomputeOffsets: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.BufferGeometry.prototype, {\n\tdrawcalls: {\n\t\tget: function () {\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t},\n\toffsets: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.Material.prototype, {\n\twrapAround: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t}\n\t},\n\twrapRGB: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\treturn new THREE.Color();\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\n\tmetal: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\treturn false;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.ShaderMaterial.prototype, {\n\tderivatives: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\treturn this.extensions.derivatives;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\tthis.extensions.derivatives = value;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.EventDispatcher.prototype = Object.assign( Object.create( {\n\n\t// Note: Extra base ensures these properties are not 'assign'ed.\n\n\tconstructor: THREE.EventDispatcher,\n\n\tapply: function ( target ) {\n\n\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\n\t\tObject.assign( target, this );\n\n\t}\n\n} ), THREE.EventDispatcher.prototype );\n\n//\n\nObject.assign( THREE.WebGLRenderer.prototype, {\n\tsupportsFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_float' );\n\t},\n\tsupportsHalfFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t},\n\tsupportsStandardDerivatives: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t},\n\tsupportsCompressedTextureS3TC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t},\n\tsupportsCompressedTexturePVRTC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t},\n\tsupportsBlendMinMax: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t},\n\tsupportsVertexTextures: function () {\n\t\treturn this.capabilities.vertexTextures;\n\t},\n\tsupportsInstancedArrays: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t},\n\tenableScissorTest: function ( boolean ) {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\tthis.setScissorTest( boolean );\n\t},\n\tinitMaterial: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t},\n\taddPrePlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t},\n\taddPostPlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t},\n\tupdateShadowMap: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLRenderer.prototype, {\n\tshadowMapEnabled: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.enabled;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\tthis.shadowMap.enabled = value;\n\t\t}\n\t},\n\tshadowMapType: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\tthis.shadowMap.type = value;\n\t\t}\n\t},\n\tshadowMapCullFace: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.cullFace;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\tthis.shadowMap.cullFace = value;\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLShadowMap.prototype, {\n\tcullFace: {\n\t\tget: function () {\n\t\t\treturn this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;\n\t\t},\n\t\tset: function ( cullFace ) {\n\t\t\tvar value = ( cullFace !== THREE.CullFaceBack );\n\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\tthis.renderReverseSided = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\n\twrapS: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\treturn this.texture.wrapS;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\tthis.texture.wrapS = value;\n\t\t}\n\t},\n\twrapT: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\treturn this.texture.wrapT;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\tthis.texture.wrapT = value;\n\t\t}\n\t},\n\tmagFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\treturn this.texture.magFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\tthis.texture.magFilter = value;\n\t\t}\n\t},\n\tminFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\treturn this.texture.minFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\tthis.texture.minFilter = value;\n\t\t}\n\t},\n\tanisotropy: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\treturn this.texture.anisotropy;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\tthis.texture.anisotropy = value;\n\t\t}\n\t},\n\toffset: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\treturn this.texture.offset;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\tthis.texture.offset = value;\n\t\t}\n\t},\n\trepeat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\treturn this.texture.repeat;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\tthis.texture.repeat = value;\n\t\t}\n\t},\n\tformat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\treturn this.texture.format;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\tthis.texture.format = value;\n\t\t}\n\t},\n\ttype: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\treturn this.texture.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\tthis.texture.type = value;\n\t\t}\n\t},\n\tgenerateMipmaps: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\treturn this.texture.generateMipmaps;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\tthis.texture.generateMipmaps = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.assign( THREE.Audio.prototype, {\n\tload: function ( file ) {\n\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\tvar scope = this;\n\t\tvar audioLoader = new THREE.AudioLoader();\n\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\tscope.setBuffer( buffer );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\tgetData: function ( file ) {\n\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\treturn this.getFrequencyData();\n\t}\n} );\n\n//\n\nTHREE.GeometryUtils = {\n\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\tvar matrix;\n\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\n\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\tmatrix = geometry2.matrix;\n\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t}\n\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t},\n\n\tcenter: function ( geometry ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\treturn geometry.center();\n\n\t}\n\n};\n\nTHREE.ImageUtils = {\n\n\tcrossOrigin: undefined,\n\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\tvar loader = new THREE.TextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\tvar loader = new THREE.CubeTextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTexture: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t},\n\n\tloadCompressedTextureCube: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t}\n\n};\n\n//\n\nTHREE.Projector = function () {\n\n\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\tvector.project( camera );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\tvector.unproject( camera );\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t};\n\n};\n\n//\n\nTHREE.CanvasRenderer = function () {\n\n\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\tthis.clear = function () {};\n\tthis.render = function () {};\n\tthis.setClearColor = function () {};\n\tthis.setSize = function () {};\n\n};\n\n// File:src/extras/CurveUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.CurveUtils = {\n\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t},\n\n\t// Puay Bing, thanks for helping with this derivative!\n\n\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\n\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t3 * t * t * p3;\n\n\t},\n\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t// To check if my formulas are correct\n\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\n\t\tvar h01 = - 6 * t * t + 6 * t; \t//  2t3 + 3t2\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\n\n\t\treturn h00 + h10 + h01 + h11;\n\n\t},\n\n\t// Catmull-Rom\n\n\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\tvar t2 = t * t;\n\t\tvar t3 = t * t2;\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/extras/SceneUtils.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\tvar group = new THREE.Group();\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t},\n\n\tdetach: function ( child, parent, scene ) {\n\n\t\tchild.applyMatrix( parent.matrixWorld );\n\t\tparent.remove( child );\n\t\tscene.add( child );\n\n\t},\n\n\tattach: function ( child, scene, parent ) {\n\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\tscene.remove( child );\n\t\tparent.add( child );\n\n\t}\n\n};\n\n// File:src/extras/ShapeUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.ShapeUtils = {\n\n\t// calculate area of the contour polygon\n\n\tarea: function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t},\n\n\ttriangulate: ( function () {\n\n\t\t/**\n\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t * See original code and more information here:\n\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t *\n\t\t * ported to actionscript by Zevan Rosser\n\t\t * www.actionsnippet.com\n\t\t *\n\t\t * ported to javascript by Joshua Koo\n\t\t * http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t */\n\n\t\tfunction snip( contour, u, v, w, n, verts ) {\n\n\t\t\tvar p;\n\t\t\tvar ax, ay, bx, by;\n\t\t\tvar cx, cy, px, py;\n\n\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\tay = contour[ verts[ u ] ].y;\n\n\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\tby = contour[ verts[ v ] ].y;\n\n\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\tcy = contour[ verts[ w ] ].y;\n\n\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\n\n\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\tcX = bx - ax;  cY = by - ay;\n\n\t\t\tfor ( p = 0; p < n; p ++ ) {\n\n\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\tpy = contour[ verts[ p ] ].y;\n\n\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\n\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t\t// see if p is inside triangle abc\n\n\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\n\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// takes in an contour array and returns\n\n\t\treturn function triangulate( contour, indices ) {\n\n\t\t\tvar n = contour.length;\n\n\t\t\tif ( n < 3 ) return null;\n\n\t\t\tvar result = [],\n\t\t\t\tverts = [],\n\t\t\t\tvertIndices = [];\n\n\t\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\t\tvar u, v, w;\n\n\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t\t}\n\n\t\t\tvar nv = n;\n\n\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\t\tvar count = 2 * nv;   /* error detection */\n\n\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\n\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\t\tif ( ( count -- ) <= 0 ) {\n\n\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t//return null;\n\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\treturn result;\n\n\t\t\t\t}\n\n\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t\t/* true names of the vertices */\n\n\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\tc = verts[ w ];\n\n\t\t\t\t\t/* output Triangle */\n\n\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnv --;\n\n\t\t\t\t\t/* reset error detection counter */\n\n\t\t\t\t\tcount = 2 * nv;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( indices ) return vertIndices;\n\t\t\treturn result;\n\n\t\t}\n\n\t} )(),\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\n\t\t\t\t// not parallel\n\n\t\t\t\tvar perpSeg2;\n\t\t\t\tif ( limit > 0 ) {\n\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\n\t\t\t\t}\n\n\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\tif ( perpSeg2 === 0 ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\tif ( perpSeg2 === limit ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt2 ];\n\n\t\t\t\t}\n\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\n\t\t\t\t// return real intersection point\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n\t\t\t} else {\n\n\t\t\t\t// parallel or collinear\n\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\n\t\t\t\t// they are collinear or degenerate\n\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t// both segments are points\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\n\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\n\t\t\t\t}\n\t\t\t\t// segment#1  is a single point\n\t\t\t\tif ( seg1Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\t// segment#2  is a single point\n\t\t\t\tif ( seg2Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\treturn [ inSeg2Pt1 ];\n\n\t\t\t\t}\n\n\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\tif ( seg1dx !== 0 ) {\n\n\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg2min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg1min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n\t\t\t// The order of legs is important\n\n\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n\t\t\t\t// angle != 180 deg.\n\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n\t\t\t\tif ( from2toAngle > 0 ) {\n\n\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// angle == 180 deg.\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\treturn\t( from2otherAngle > 0 );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction removeHoles( contour, holes ) {\n\n\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\tvar hole;\n\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\treturn\ttrue;\n\n\t\t\t}\n\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with shape edges\n\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t}\n\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar indepHoles = [];\n\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with hole edges\n\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\tshapePt, holePt,\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\ttmpHole1, tmpHole2;\n\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tindepHoles.push( h );\n\n\t\t\t}\n\n\t\t\tvar minShapeIndex = 0;\n\t\t\tvar counter = indepHoles.length * 2;\n\t\t\twhile ( indepHoles.length > 0 ) {\n\n\t\t\t\tcounter --;\n\t\t\t\tif ( counter < 0 ) {\n\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t// which can be connected without intersections\n\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\tholeIndex\t= - 1;\n\n\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\n\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\n\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\n\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\n\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn shape; \t\t\t/* shape with no holes */\n\n\t\t}\n\n\n\t\tvar i, il, f, face,\n\t\t\tkey, index,\n\t\t\tallPointsMap = {};\n\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\tvar allpoints = contour.concat();\n\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\n\t\t}\n\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\t// prepare all points map\n\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\n\n\t\t\t}\n\n\t\t\tallPointsMap[ key ] = i;\n\n\t\t}\n\n\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\n\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t//console.log( \"triangles\",triangles, triangles.length );\n\n\t\t// check all face vertices against all points map\n\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\tface = triangles[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangles.concat();\n\n\t},\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn THREE.ShapeUtils.area( pts ) < 0;\n\n\t},\n\n\t// Bezier Curves formulas obtained from\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t// Quad Bezier Functions\n\n\tb2: ( function () {\n\n\t\tfunction b2p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * p;\n\n\t\t}\n\n\t\tfunction b2p1( t, p ) {\n\n\t\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t\t}\n\n\t\tfunction b2p2( t, p ) {\n\n\t\t\treturn t * t * p;\n\n\t\t}\n\n\t\treturn function b2( t, p0, p1, p2 ) {\n\n\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\n\t\t};\n\n\t} )(),\n\n\t// Cubic Bezier Functions\n\n\tb3: ( function () {\n\n\t\tfunction b3p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * k * p;\n\n\t\t}\n\n\t\tfunction b3p1( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * k * t * p;\n\n\t\t}\n\n\t\tfunction b3p2( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * t * t * p;\n\n\t\t}\n\n\t\tfunction b3p3( t, p ) {\n\n\t\t\treturn t * t * t * p;\n\n\t\t}\n\n\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\n\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\n\t\t};\n\n\t} )()\n\n};\n\n// File:src/extras/core/Curve.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of Curve methods\n * .getPoint(t), getTangent(t)\n * .getPointAt(u), getTagentAt(u)\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following classes subclasses THREE.Curve:\n *\n * -- 2d classes --\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.CubicBezierCurve\n * THREE.SplineCurve\n * THREE.ArcCurve\n * THREE.EllipseCurve\n *\n * -- 3d classes --\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n * THREE.CubicBezierCurve3\n * THREE.SplineCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nTHREE.Curve = function () {\n\n};\n\nTHREE.Curve.prototype = {\n\n\tconstructor: THREE.Curve,\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint: function ( t ) {\n\n\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\treturn null;\n\n\t},\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t );\n\n\t},\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar d, pts = [];\n\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpts.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn pts;\n\n\t},\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar d, pts = [];\n\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpts.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn pts;\n\n\t},\n\n\t// Get total curve arc length\n\n\tgetLength: function () {\n\n\t\tvar lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t},\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n\t\tif ( this.cacheArcLengths\n\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t&& ! this.needsUpdate ) {\n\n\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tvar cache = [];\n\t\tvar current, last = this.getPoint( 0 );\n\t\tvar p, sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n\t},\n\n\tupdateArcLengths: function() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping: function ( u, distance ) {\n\n\t\tvar arcLengths = this.getLengths();\n\n\t\tvar i = 0, il = arcLengths.length;\n\n\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t//var time = Date.now();\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tvar low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\t//console.log('b' , i, low, high, Date.now()- time);\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\tvar t = i / ( il - 1 );\n\t\t\treturn t;\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tvar lengthBefore = arcLengths[ i ];\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t},\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent: function( t ) {\n\n\t\tvar delta = 0.0001;\n\t\tvar t1 = t - delta;\n\t\tvar t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tvar pt1 = this.getPoint( t1 );\n\t\tvar pt2 = this.getPoint( t2 );\n\n\t\tvar vec = pt2.clone().sub( pt1 );\n\t\treturn vec.normalize();\n\n\t},\n\n\tgetTangentAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t );\n\n\t}\n\n};\n\n// TODO: Transformation for Curves?\n\n/**************************************************************\n *\t3D Curves\n **************************************************************/\n\n// A Factory method for creating new curve subclasses\n\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\tconstructor.prototype.constructor = constructor;\n\tconstructor.prototype.getPoint = getPointFunc;\n\n\treturn constructor;\n\n};\n\n// File:src/extras/core/CurvePath.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nTHREE.CurvePath = function () {\n\n\tthis.curves = [];\n\n\tthis.autoClose = false; // Automatically closes the path\n\n};\n\nTHREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {\n\n\tconstructor: THREE.CurvePath,\n\n\tadd: function ( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t},\n\n\tclosePath: function () {\n\n\t\t// TODO Test\n\t\t// and verify for vector3 (needs to implement equals)\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\n\n\t\t}\n\n\t},\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint: function ( t ) {\n\n\t\tvar d = t * this.getLength();\n\t\tvar curveLengths = this.getCurveLengths();\n\t\tvar i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\tvar u = 1 - diff / curve.getLength();\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t},\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength: function () {\n\n\t\tvar lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t},\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths: function () {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tvar lengths = [], sums = 0;\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t},\n\n\t/**************************************************************\n\t *\tCreate Geometries Helpers\n\t **************************************************************/\n\n\t/// Generate geometry from path points (for Line or Points objects)\n\n\tcreatePointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\t// Generate geometry from equidistant sampling along the path\n\n\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getSpacedPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\tcreateGeometry: function ( points ) {\n\n\t\tvar geometry = new THREE.Geometry();\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/extras/core/Font.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Font = function ( data ) {\n\n\tthis.data = data;\n\n};\n\nObject.assign( THREE.Font.prototype, {\n\n\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\tfunction createPaths( text ) {\n\n\t\t\tvar chars = String( text ).split( '' );\n\t\t\tvar scale = size / data.resolution;\n\t\t\tvar offset = 0;\n\n\t\t\tvar paths = [];\n\n\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\toffset += ret.offset;\n\n\t\t\t\tpaths.push( ret.path );\n\n\t\t\t}\n\n\t\t\treturn paths;\n\n\t\t}\n\n\t\tfunction createPath( c, scale, offset ) {\n\n\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n\t\t\tif ( ! glyph ) return;\n\n\t\t\tvar path = new THREE.Path();\n\n\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\n\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n\t\t\tif ( glyph.o ) {\n\n\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn { offset: glyph.ha * scale, path: path };\n\n\t\t}\n\n\t\t//\n\n\t\tif ( size === undefined ) size = 100;\n\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\tvar data = this.data;\n\n\t\tvar paths = createPaths( text );\n\t\tvar shapes = [];\n\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n// File:src/extras/core/Path.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n *\n **/\n\nTHREE.Path = function ( points ) {\n\n\tTHREE.CurvePath.call( this );\n\n\tthis.actions = [];\n\n\tif ( points ) {\n\n\t\tthis.fromPoints( points );\n\n\t}\n\n};\n\nTHREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {\n\n\tconstructor: THREE.Path,\n\n\t// TODO Clean up PATH API\n\n\t// Create path using straight lines to connect all points\n\t// - vectors: array of Vector2\n\n\tfromPoints: function ( vectors ) {\n\n\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n\t\t}\n\n\t},\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.QuadraticBezierCurve(\n\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.CubicBezierCurve(\n\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\n\n\t},\n\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\tvar args = Array.prototype.slice.call( arguments );\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\n\t\tArray.prototype.push.apply( npts, pts );\n\n\t\tvar curve = new THREE.SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = pts[ pts.length - 1 ];\n\t\targs.push( lastPoint.x );\n\t\targs.push( lastPoint.y );\n\n\t\tthis.actions.push( { action: 'splineThru', args: args } );\n\n\t},\n\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t},\n\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar args = [\n\t\t\taX, aY,\n\t\t\txRadius, yRadius,\n\t\t\taStartAngle, aEndAngle,\n\t\t\taClockwise,\n\t\t\taRotation || 0 // aRotation is optional.\n\t\t];\n\n\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = curve.getPoint( 1 );\n\t\targs.push( lastPoint.x );\n\t\targs.push( lastPoint.y );\n\n\t\tthis.actions.push( { action: 'ellipse', args: args } );\n\n\t},\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 40;\n\n\t\tvar points = [];\n\n\t\tfor ( var i = 0; i < divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tgetPoints: function ( divisions ) {\n\n\t\tdivisions = divisions || 12;\n\n\t\tvar b2 = THREE.ShapeUtils.b2;\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\n\t\tvar points = [];\n\n\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\n\t\t\tlaste, tx, ty;\n\n\t\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\n\n\t\t\tvar item = this.actions[ i ];\n\n\t\t\tvar action = item.action;\n\t\t\tvar args = item.args;\n\n\t\t\tswitch ( action ) {\n\n\t\t\tcase 'moveTo':\n\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'lineTo':\n\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'quadraticCurveTo':\n\n\t\t\t\tcpx  = args[ 2 ];\n\t\t\t\tcpy  = args[ 3 ];\n\n\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\tcpy1 = args[ 1 ];\n\n\t\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / divisions;\n\n\t\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\n\t\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'bezierCurveTo':\n\n\t\t\t\tcpx  = args[ 4 ];\n\t\t\t\tcpy  = args[ 5 ];\n\n\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\tcpy1 = args[ 1 ];\n\n\t\t\t\tcpx2 = args[ 2 ];\n\t\t\t\tcpy2 = args[ 3 ];\n\n\t\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t\t}\n\n\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / divisions;\n\n\t\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'splineThru':\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\n\t\t\t\tvar spts = [ last ];\n\n\t\t\t\tvar n = divisions * args[ 0 ].length;\n\n\t\t\t\tspts = spts.concat( args[ 0 ] );\n\n\t\t\t\tvar spline = new THREE.SplineCurve( spts );\n\n\t\t\t\tfor ( var j = 1; j <= n; j ++ ) {\n\n\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'arc':\n\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\taRadius = args[ 2 ],\n\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\n\t\t\t\t\taClockwise = !! args[ 5 ];\n\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\tvar angle;\n\t\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / tdivisions;\n\n\t\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\n\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\n\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\t//console.log(points);\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ellipse':\n\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\txRadius = args[ 2 ],\n\t\t\t\t\tyRadius = args[ 3 ],\n\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\n\t\t\t\t\taClockwise = !! args[ 6 ],\n\t\t\t\t\taRotation = args[ 7 ];\n\n\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\tvar angle;\n\t\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\t\tvar cos, sin;\n\t\t\t\tif ( aRotation !== 0 ) {\n\n\t\t\t\t\tcos = Math.cos( aRotation );\n\t\t\t\t\tsin = Math.sin( aRotation );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / tdivisions;\n\n\t\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\n\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\n\n\t\t\t\t\tif ( aRotation !== 0 ) {\n\n\t\t\t\t\t\tvar x = tx, y = ty;\n\n\t\t\t\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\n\t\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\t//console.log(points);\n\n\t\t\t\tbreak;\n\n\t\t\t} // end switch\n\n\t\t}\n\n\n\n\t\t// Normalize to remove the closing point by default.\n\t\tvar lastPoint = points[ points.length - 1 ];\n\t\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\n\t\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\n\t\t\tpoints.splice( points.length - 1, 1 );\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\tfunction extractSubpaths( inActions ) {\n\n\t\t\tvar subPaths = [], lastPath = new THREE.Path();\n\n\t\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\n\n\t\t\t\tvar item = inActions[ i ];\n\n\t\t\t\tvar args = item.args;\n\t\t\t\tvar action = item.action;\n\n\t\t\t\tif ( action === 'moveTo' ) {\n\n\t\t\t\t\tif ( lastPath.actions.length !== 0 ) {\n\n\t\t\t\t\t\tsubPaths.push( lastPath );\n\t\t\t\t\t\tlastPath = new THREE.Path();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlastPath[ action ].apply( lastPath, args );\n\n\t\t\t}\n\n\t\t\tif ( lastPath.actions.length !== 0 ) {\n\n\t\t\t\tsubPaths.push( lastPath );\n\n\t\t\t}\n\n\t\t\t// console.log(subPaths);\n\n\t\t\treturn\tsubPaths;\n\n\t\t}\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\tvar tmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\t//console.log(\"shape\", shapes);\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tvar inside = false;\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\n\n\t\tvar subPaths = extractSubpaths( this.actions );\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new THREE.Shape();\n\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tvar betterShapeHoles = [];\n\t\tvar newShapes = [];\n\t\tvar newShapeHoles = [];\n\t\tvar mainIdx = 0;\n\t\tvar tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tvar ambiguous = false;\n\t\t\tvar toChange = [];\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmpHoles;\n\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n// File:src/extras/core/Shape.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nTHREE.Shape = function () {\n\n\tTHREE.Path.apply( this, arguments );\n\n\tthis.holes = [];\n\n};\n\nTHREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {\n\n\tconstructor: THREE.Shape,\n\n\t// Convenience method to return ExtrudeGeometry\n\n\textrude: function ( options ) {\n\n\t\treturn new THREE.ExtrudeGeometry( this, options );\n\n\t},\n\n\t// Convenience method to return ShapeGeometry\n\n\tmakeGeometry: function ( options ) {\n\n\t\treturn new THREE.ShapeGeometry( this, options );\n\n\t},\n\n\tgetPointsHoles: function ( divisions ) {\n\n\t\tvar holesPts = [];\n\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t},\n\n\t// Get points of shape and holes (keypoints based on segments parameter)\n\n\textractAllPoints: function ( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t},\n\n\textractPoints: function ( divisions ) {\n\n\t\treturn this.extractAllPoints( divisions );\n\n\t}\n\n} );\n\n// File:src/extras/curves/LineCurve.js\n\n/**************************************************************\n *\tLine\n **************************************************************/\n\nTHREE.LineCurve = function ( v1, v2 ) {\n\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\n\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\n\tvar point = this.v2.clone().sub( this.v1 );\n\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\n\treturn this.getPoint( u );\n\n};\n\nTHREE.LineCurve.prototype.getTangent = function( t ) {\n\n\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\treturn tangent.normalize();\n\n};\n\n// File:src/extras/curves/QuadraticBezierCurve.js\n\n/**************************************************************\n *\tQuadratic Bezier curve\n **************************************************************/\n\n\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\n\n\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b2 = THREE.ShapeUtils.b2;\n\n\treturn new THREE.Vector2(\n\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t);\n\n};\n\n\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\n\n\treturn new THREE.Vector2(\n\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/CubicBezierCurve.js\n\n/**************************************************************\n *\tCubic Bezier curve\n **************************************************************/\n\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\tthis.v3 = v3;\n\n};\n\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\n\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b3 = THREE.ShapeUtils.b3;\n\n\treturn new THREE.Vector2( \n\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t);\n\n};\n\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\n\n\treturn new THREE.Vector2( \n\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/SplineCurve.js\n\n/**************************************************************\n *\tSpline curve\n **************************************************************/\n\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\n\tthis.points = ( points == undefined ) ? [] : points;\n\n};\n\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\n\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\n\tvar points = this.points;\n\tvar point = ( points.length - 1 ) * t;\n\n\tvar intPoint = Math.floor( point );\n\tvar weight = point - intPoint;\n\n\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\tvar point1 = points[ intPoint ];\n\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\treturn new THREE.Vector2(\n\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t);\n\n};\n\n// File:src/extras/curves/EllipseCurve.js\n\n/**************************************************************\n *\tEllipse curve\n **************************************************************/\n\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\tthis.aX = aX;\n\tthis.aY = aY;\n\n\tthis.xRadius = xRadius;\n\tthis.yRadius = yRadius;\n\n\tthis.aStartAngle = aStartAngle;\n\tthis.aEndAngle = aEndAngle;\n\n\tthis.aClockwise = aClockwise;\n\t\n\tthis.aRotation = aRotation || 0;\n\n};\n\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\n\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\n\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\n\n\tvar angle;\n\n\tif ( this.aClockwise === true ) {\n\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\n\n\t} else {\n\n\t\tangle = this.aStartAngle + t * deltaAngle;\n\n\t}\n\t\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\tif ( this.aRotation !== 0 ) {\n\n\t\tvar cos = Math.cos( this.aRotation );\n\t\tvar sin = Math.sin( this.aRotation );\n\n\t\tvar tx = x, ty = y;\n\n\t\t// Rotate the point about the center of the ellipse.\n\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\n\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\n\n\t}\n\n\treturn new THREE.Vector2( x, y );\n\n};\n\n// File:src/extras/curves/ArcCurve.js\n\n/**************************************************************\n *\tArc curve\n **************************************************************/\n\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n};\n\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\n\n// File:src/extras/curves/LineCurve3.js\n\n/**************************************************************\n *\tLine3D\n **************************************************************/\n\nTHREE.LineCurve3 = THREE.Curve.create(\n\n\tfunction ( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\tvector.multiplyScalar( t );\n\t\tvector.add( this.v1 );\n\n\t\treturn vector;\n\n\t}\n\n);\n\n// File:src/extras/curves/QuadraticBezierCurve3.js\n\n/**************************************************************\n *\tQuadratic Bezier 3D curve\n **************************************************************/\n\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\n\n\t\treturn new THREE.Vector3(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CubicBezierCurve3.js\n\n/**************************************************************\n *\tCubic Bezier 3D curve\n **************************************************************/\n\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\n\t\treturn new THREE.Vector3(\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/SplineCurve3.js\n\n/**************************************************************\n *\tSpline 3D curve\n **************************************************************/\n\n\nTHREE.SplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */ ) {\n\n\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\tthis.points = ( points == undefined ) ? [] : points;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\t\treturn new THREE.Vector3(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CatmullRomCurve3.js\n\n/**\n * @author zz85 https://github.com/zz85\n *\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\nTHREE.CatmullRomCurve3 = ( function() {\n\n\tvar\n\t\ttmp = new THREE.Vector3(),\n\t\tpx = new CubicPoly(),\n\t\tpy = new CubicPoly(),\n\t\tpz = new CubicPoly();\n\n\t/*\n\tBased on an optimized c++ solution in\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t - http://ideone.com/NoEbVM\n\n\tThis CubicPoly class could be used for reusing some variables and calculations,\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\twhich can be placed in CurveUtils.\n\t*/\n\n\tfunction CubicPoly() {\n\n\t}\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\n\t\tthis.c0 = x0;\n\t\tthis.c1 = t0;\n\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t};\n\n\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t// compute tangents when parameterized in [t1,t2]\n\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t// rescale tangents for parametrization in [0,1]\n\t\tt1 *= dt1;\n\t\tt2 *= dt1;\n\n\t\t// initCubicPoly\n\t\tthis.init( x1, x2, t1, t2 );\n\n\t};\n\n\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\n\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t};\n\n\tCubicPoly.prototype.calc = function( t ) {\n\n\t\tvar t2 = t * t;\n\t\tvar t3 = t2 * t;\n\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\n\t};\n\n\t// Subclass Three.js curve\n\treturn THREE.Curve.create(\n\n\t\tfunction ( p /* array of Vector3 */ ) {\n\n\t\t\tthis.points = p || [];\n\t\t\tthis.closed = false;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar points = this.points,\n\t\t\t\tpoint, intPoint, weight, l;\n\n\t\t\tl = points.length;\n\n\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tif ( this.closed ) {\n\n\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\t\tintPoint = l - 2;\n\t\t\t\tweight = 1;\n\n\t\t\t}\n\n\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate first point\n\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\tp0 = tmp;\n\n\t\t\t}\n\n\t\t\tp1 = points[ intPoint % l ];\n\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate last point\n\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\tp3 = tmp;\n\n\t\t\t}\n\n\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t\t// safety check for repeated points\n\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t\t} else if ( this.type === 'catmullrom' ) {\n\n\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n\t\t\t}\n\n\t\t\tvar v = new THREE.Vector3(\n\t\t\t\tpx.calc( weight ),\n\t\t\t\tpy.calc( weight ),\n\t\t\t\tpz.calc( weight )\n\t\t\t);\n\n\t\t\treturn v;\n\n\t\t}\n\n\t);\n\n} )();\n\n// File:src/extras/curves/ClosedSplineCurve3.js\n\n/**************************************************************\n *\tClosed Spline 3D curve\n **************************************************************/\n\n\nTHREE.ClosedSplineCurve3 = function ( points ) {\n\n\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\n\tTHREE.CatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\tthis.closed = true;\n\n};\n\nTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\n\n// File:src/extras/geometries/BoxGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n */\n\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'BoxGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\n\nTHREE.CubeGeometry = THREE.BoxGeometry;\n\n// File:src/extras/geometries/BoxBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'BoxBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tvar scope = this;\n\n\t// segments\n\twidthSegments = Math.floor( widthSegments ) || 1;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\tvar numberOfVertices = 0;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// build each side of the box geometry\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\t// helper functions\n\n\tfunction calculateVertexCount ( w, h, d ) {\n\n\t\tvar vertices = 0;\n\n\t\t// calculate the amount of vertices for each side (plane)\n\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\n\t\treturn vertices;\n\n\t}\n\n\tfunction calculateIndexCount ( w, h, d ) {\n\n\t\tvar index = 0;\n\n\t\t// calculate the amount of squares for each side\n\t\tindex += w * h * 2; // xy\n\t\tindex += w * d * 2; // xz\n\t\tindex += d * h * 2; // zy\n\n\t\treturn index * 6; // two triangles per square => six vertices per square\n\n\t}\n\n\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\tvar segmentWidth\t= width / gridX;\n\t\tvar segmentHeight = height / gridY;\n\n\t\tvar widthHalf = width / 2;\n\t\tvar heightHalf = height / 2;\n\t\tvar depthHalf = depth / 2;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar vertexCounter = 0;\n\t\tvar groupCount = 0;\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = 0;\n\t\t\t\tvector[ v ] = 0;\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t// now apply vector to normal buffer\n\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// uvs\n\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\t\t\t\tvertexCounter += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 1. you need three indices to draw a single face\n\t\t// 2. a single segment consists of two faces\n\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tindexBufferOffset += 6;\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t\t// update total number of vertices\n\t\tnumberOfVertices += vertexCounter;\n\n\t}\n\n};\n\nTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\n\n// File:src/extras/geometries/CircleGeometry.js\n\n/**\n * @author hughes\n */\n\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CircleGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\n\n// File:src/extras/geometries/CircleBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CircleBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tvar vertices = segments + 2;\n\n\tvar positions = new Float32Array( vertices * 3 );\n\tvar normals = new Float32Array( vertices * 3 );\n\tvar uvs = new Float32Array( vertices * 2 );\n\n\t// center data is already zero, but need to set a few extras\n\tnormals[ 2 ] = 1.0;\n\tuvs[ 0 ] = 0.5;\n\tuvs[ 1 ] = 0.5;\n\n\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\n\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\n\t\tnormals[ i + 2 ] = 1; // normal z\n\n\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var i = 1; i <= segments; i ++ ) {\n\n\t\tindices.push( i, i + 1, 0 );\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\n\n// File:src/extras/geometries/CylinderBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CylinderBufferGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tvar scope = this;\n\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\theight = height !== undefined ? height : 100;\n\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\n\topenEnded = openEnded !== undefined ? openEnded : false;\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n\t// used to calculate buffer length\n\n\tvar nbCap = 0;\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\tif ( radiusBottom > 0 ) nbCap ++;\n\n\t}\n\n\tvar vertexCount = calculateVertexCount();\n\tvar indexCount = calculateIndexCount();\n\n\t// buffers\n\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\n\tvar index = 0,\n\t    indexOffset = 0,\n\t    indexArray = [],\n\t    halfHeight = height / 2;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// generate geometry\n\n\tgenerateTorso();\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// helper functions\n\n\tfunction calculateVertexCount() {\n\n\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction calculateIndexCount() {\n\n\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += radialSegments * nbCap * 3;\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction generateTorso() {\n\n\t\tvar x, y;\n\t\tvar normal = new THREE.Vector3();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\t// this will be used to calculate the normal\n\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar indexRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\t// calculate the radius of the current row\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\n\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormal.copy( vertex );\n\n\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\n\n\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\n\n\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\n\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\n\n\t\t\t\t}\n\n\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\t// save index of vertex in respective row\n\t\t\t\tindexRow.push( index );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// now save vertices of the row in our index array\n\t\t\tindexArray.push( indexRow );\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n\tfunction generateCap( top ) {\n\n\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\tvar uv = new THREE.Vector2();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t// save the index of the first center vertex\n\t\tcenterIndexStart = index;\n\n\t\t// first we generate the center vertex data of the cap.\n\t\t// because the geometry needs one set of uvs per face,\n\t\t// we must generate a center vertex per face/segment\n\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = 0.5;\n\t\t\tuv.y = 0.5;\n\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// save the index of the last center vertex\n\t\tcenterIndexEnd = index;\n\n\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\tvar u = x / radialSegments;\n\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * sinTheta;\n\t\t\tvertex.y = halfHeight * sign;\n\t\t\tvertex.z = radius * cosTheta;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar c = centerIndexStart + x;\n\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\tif ( top === true ) {\n\n\t\t\t\t// face top\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t} else {\n\n\t\t\t\t// face bottom\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t}\n\n\t\t\t// update counters\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n};\n\nTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\n\n// File:src/extras/geometries/CylinderGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CylinderGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\n\n// File:src/extras/geometries/ConeBufferGeometry.js\n\n/*\n * @author: abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeBufferGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderBufferGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;\n\n// File:src/extras/geometries/ConeGeometry.js\n\n/**\n * @author abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );\nTHREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;\n\n// File:src/extras/geometries/EdgesGeometry.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tvar geometry2;\n\n\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tgeometry2 = new THREE.Geometry();\n\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry2 = geometry.clone();\n\n\t}\n\n\tgeometry2.mergeVertices();\n\tgeometry2.computeFaceNormals();\n\n\tvar vertices = geometry2.vertices;\n\tvar faces = geometry2.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\tedge.sort( sortFunction );\n\n\t\t\tvar key = edge.toString();\n\n\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t} else {\n\n\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvar coords = [];\n\n\tfor ( var key in hash ) {\n\n\t\tvar h = hash[ key ];\n\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t}\n\n\t}\n\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\n\n};\n\nTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\n\n// File:src/extras/geometries/ExtrudeGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  amount: <int>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n *\n *  uvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\n\tif ( typeof( shapes ) === \"undefined\" ) {\n\n\t\tshapes = [];\n\t\treturn;\n\n\t}\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ExtrudeGeometry';\n\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n\t// can't really use automatic vertex normals\n\t// as then front and back sides get smoothed too\n\t// should do separate smoothing just for sides\n\n\t//this.computeVertexNormals();\n\n\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n};\n\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\n\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tvar sl = shapes.length;\n\n\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\tvar shape = shapes[ s ];\n\t\tthis.addShape( shape, options );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\tvar extrudePath = options.extrudePath;\n\tvar extrudePts, extrudeByPath = false;\n\n\t// Use default WorldUVGenerator if no UV generators are specified.\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\n\tvar splineTube, binormal, normal, position2;\n\tif ( extrudePath ) {\n\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\textrudeByPath = true;\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t// SETUP TNB variables\n\n\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t// TODO1 - have a .isClosed in spline?\n\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\n\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\tbinormal = new THREE.Vector3();\n\t\tnormal = new THREE.Vector3();\n\t\tposition2 = new THREE.Vector3();\n\n\t}\n\n\t// Safeguards if bevels are not enabled\n\n\tif ( ! bevelEnabled ) {\n\n\t\tbevelSegments = 0;\n\t\tbevelThickness = 0;\n\t\tbevelSize = 0;\n\n\t}\n\n\t// Variables initialization\n\n\tvar ahole, h, hl; // looping of holes\n\tvar scope = this;\n\n\tvar shapesOffset = this.vertices.length;\n\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t}\n\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t/* Vertices */\n\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\tvertices = vertices.concat( ahole );\n\n\t}\n\n\n\tfunction scalePt2 ( pt, vec, size ) {\n\n\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t}\n\n\tvar b, bs, t, z,\n\t\tvert, vlen = vertices.length,\n\t\tface, flen = faces.length;\n\n\n\t// Find directions for point movement\n\n\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t//\n\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\n\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t// check for collinear edges\n\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t// not collinear\n\n\t\t\t// length of vectors for normalizing\n\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t// vector from inPt to intersection point\n\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t//  but prevent crazy spikes\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\n\n\t\t\t} else {\n\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// handle special case of collinear edges\n\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( direction_eq ) {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t} else {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t}\n\n\n\tvar contourMovements = [];\n\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\tif ( j === il ) j = 0;\n\t\tif ( k === il ) k = 0;\n\n\t\t//  (j)---(i)---(k)\n\t\t// console.log('i,j,k', i, j , k)\n\n\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t}\n\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\toneHoleMovements = [];\n\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t}\n\n\t\tholesMovements.push( oneHoleMovements );\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t}\n\n\n\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\n\t\t//z = bevelThickness * t;\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\n\t\t//bs = bevelSize * t; // linear\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbs = bevelSize;\n\n\t// Back facing vertices\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\tif ( ! extrudeByPath ) {\n\n\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t} else {\n\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t}\n\n\t}\n\n\t// Add stepped vertices...\n\t// Including front facing vertices\n\n\tvar s;\n\n\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Add bevel segments planes\n\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Faces */\n\n\t// Top and bottom faces\n\n\tbuildLidFaces();\n\n\t// Sides faces\n\n\tbuildSideFaces();\n\n\n\t/////  Internal functions\n\n\tfunction buildLidFaces() {\n\n\t\tif ( bevelEnabled ) {\n\n\t\t\tvar layer = 0; // steps + 1\n\t\t\tvar offset = vlen * layer;\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t}\n\n\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\toffset = vlen * layer;\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t}\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Create faces for the z-sides of the shape\n\n\tfunction buildSideFaces() {\n\n\t\tvar layeroffset = 0;\n\t\tsidewalls( contour, layeroffset );\n\t\tlayeroffset += contour.length;\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t//, true\n\t\t\tlayeroffset += ahole.length;\n\n\t\t}\n\n\t}\n\n\tfunction sidewalls( contour, layeroffset ) {\n\n\t\tvar j, k;\n\t\ti = contour.length;\n\n\t\twhile ( -- i >= 0 ) {\n\n\t\t\tj = i;\n\t\t\tk = i - 1;\n\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\tfunction v( x, y, z ) {\n\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t}\n\n\tfunction f3( a, b, c ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\n\n\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\n\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\t\td += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\n\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\n\n\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\n\t\treturn [\n\t\t\tnew THREE.Vector2( a.x, a.y ),\n\t\t\tnew THREE.Vector2( b.x, b.y ),\n\t\t\tnew THREE.Vector2( c.x, c.y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\t\tvar d = vertices[ indexD ];\n\n\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\n\t\t\t];\n\n\t\t}\n\n\t}\n};\n\n// File:src/extras/geometries/ShapeGeometry.js\n\n/**\n * @author jonobr1 / http://jonobr1.com\n *\n * Creates a one-sided polygonal geometry from a path shape. Similar to\n * ExtrudeGeometry.\n *\n * parameters = {\n *\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n *\n *\tmaterial: <int> // material index for front and back faces\n *\tuvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ShapeGeometry = function ( shapes, options ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ShapeGeometry';\n\n\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\n\n/**\n * Add an array of shapes to THREE.ShapeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\tthis.addShape( shapes[ i ], options );\n\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tif ( options === undefined ) options = {};\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar material = options.material;\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\t//\n\n\tvar i, l, hole;\n\n\tvar shapesOffset = this.vertices.length;\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\thole = holes[ i ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\n\n\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false;\n\n\t}\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t// Vertices\n\n\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\thole = holes[ i ];\n\t\tvertices = vertices.concat( hole );\n\n\t}\n\n\t//\n\n\tvar vert, vlen = vertices.length;\n\tvar face, flen = faces.length;\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = vertices[ i ];\n\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\n\t}\n\n\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\tface = faces[ i ];\n\n\t\tvar a = face[ 0 ] + shapesOffset;\n\t\tvar b = face[ 1 ] + shapesOffset;\n\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\n\t}\n\n};\n\n// File:src/extras/geometries/LatheBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n // points - to create a closed torus, one must use a set of points\n //    like so: [ a, b, c, d, a ], see first is the same as last.\n // segments - the number of circumference segments to create\n // phiStart - the starting radian\n // phiLength - the radian (0 to 2PI) range of the lathed section\n //    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'LatheBufferGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tsegments = Math.floor( segments ) || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || Math.PI * 2;\n\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( segments + 1 ) * points.length;\n\tvar indexCount = segments * points.length * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar index = 0, indexOffset = 0, base;\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\tvar inverseSegments = 1.0 / segments;\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar i, j;\n\n\t// generate vertices and uvs\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar sin = Math.sin( phi );\n\t\tvar cos = Math.cos( phi );\n\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\tvertex.y = points[ j ].y;\n\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / segments;\n\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\tbase = j + i * points.length;\n\n\t\t\t// indices\n\t\t\tvar a = base;\n\t\t\tvar b = base + points.length;\n\t\t\tvar c = base + points.length + 1;\n\t\t\tvar d = base + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// generate normals\n\n\tthis.computeVertexNormals();\n\n\t// if the geometry is closed, we need to average the normals along the seam.\n\t// because the corresponding vertices are identical (but still have different UVs).\n\n\tif( phiLength === Math.PI * 2 ) {\n\n\t\tvar normals = this.attributes.normal.array;\n\t\tvar n1 = new THREE.Vector3();\n\t\tvar n2 = new THREE.Vector3();\n\t\tvar n = new THREE.Vector3();\n\n\t\t// this is the buffer offset for the last line of vertices\n\t\tbase = segments * points.length * 3;\n\n\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t// select the normal of the vertex in the first line\n\t\t\tn1.x = normals[ j + 0 ];\n\t\t\tn1.y = normals[ j + 1 ];\n\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t// select the normal of the vertex in the last line\n\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t// average normals\n\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t// assign the new values to both normals\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t} // next row\n\n\t}\n\n};\n\nTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\n\n// File:src/extras/geometries/LatheGeometry.js\n\n/**\n * @author astrodud / http://astrodud.isgreat.org/\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n */\n\n// points - to create a closed torus, one must use a set of points\n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2PI) range of the lathed section\n//    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'LatheGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\n\n// File:src/extras/geometries/PlaneGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PlaneGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n};\n\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\n\n// File:src/extras/geometries/PlaneBufferGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'PlaneBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tvar width_half = width / 2;\n\tvar height_half = height / 2;\n\n\tvar gridX = Math.floor( widthSegments ) || 1;\n\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\tvar gridX1 = gridX + 1;\n\tvar gridY1 = gridY + 1;\n\n\tvar segment_width = width / gridX;\n\tvar segment_height = height / gridY;\n\n\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\n\tvar offset = 0;\n\tvar offset2 = 0;\n\n\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\tvar y = iy * segment_height - height_half;\n\n\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\tvertices[ offset ] = x;\n\t\t\tvertices[ offset + 1 ] = - y;\n\n\t\t\tnormals[ offset + 2 ] = 1;\n\n\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\n\t\t\toffset += 3;\n\t\t\toffset2 += 2;\n\n\t\t}\n\n\t}\n\n\toffset = 0;\n\n\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\n\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\n\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iy;\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\tindices[ offset ] = a;\n\t\t\tindices[ offset + 1 ] = b;\n\t\t\tindices[ offset + 2 ] = d;\n\n\t\t\tindices[ offset + 3 ] = b;\n\t\t\tindices[ offset + 4 ] = c;\n\t\t\tindices[ offset + 5 ] = d;\n\n\t\t\toffset += 6;\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\n\n// File:src/extras/geometries/RingBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'RingBufferGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tinnerRadius = innerRadius || 20;\n\touterRadius = outerRadius || 50;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// some helper variables\n\tvar index = 0, indexOffset = 0, segment;\n\tvar radius = innerRadius;\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\t// values are generate from the inside of the ring to the outside\n\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex++;\n\n\t\t}\n\n\t\t// increase the radius for next row of vertices\n\t\tradius += radiusStep;\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t// indices\n\t\t\tvar a = segment;\n\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\tvar d = segment + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n};\n\nTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\n\n// File:src/extras/geometries/RingGeometry.js\n\n/**\n * @author Kaleb Murphy\n */\n\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'RingGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\n\n// File:src/extras/geometries/SphereGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'SphereGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n};\n\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\n\n// File:src/extras/geometries/SphereBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n * based on THREE.SphereGeometry\n */\n\nTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'SphereBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tphiStart = phiStart !== undefined ? phiStart : 0;\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar thetaEnd = thetaStart + thetaLength;\n\n\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\n\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\tvar index = 0, vertices = [], normal = new THREE.Vector3();\n\n\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\n\t\tvar verticesRow = [];\n\n\t\tvar v = y / heightSegments;\n\n\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\tvar u = x / widthSegments;\n\n\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tnormal.set( px, py, pz ).normalize();\n\n\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\tverticesRow.push( index );\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\n\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\n\tthis.addAttribute( 'position', positions );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\n\n// File:src/extras/geometries/TextGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float> // how far from text outline is bevel\n * }\n */\n\nTHREE.TextGeometry = function ( text, parameters ) {\n\n\tparameters = parameters || {};\n\n\tvar font = parameters.font;\n\n\tif ( font instanceof THREE.Font === false ) {\n\n\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\treturn new THREE.Geometry();\n\n\t}\n\n\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\n\n\tthis.type = 'TextGeometry';\n\n};\n\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\n\n// File:src/extras/geometries/TorusBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\tarc = arc || Math.PI * 2;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\n\t// helper variables\n\tvar center = new THREE.Vector3();\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / tubularSegments * arc;\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t// vertex\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\n\t\t\t// this vector is used to calculate the normal\n\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\tcenter.y = radius * Math.sin( u );\n\n\t\t\t// normal\n\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\n\t\t\t// uv\n\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\n\t\t\t// update offsets\n\t\t\tvertexBufferOffset += 3;\n\t\t\tuvBufferOffset += 2;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t// face one\n\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t// face two\n\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t// update offset\n\t\t\tindexBufferOffset += 6;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\n\n// File:src/extras/geometries/TorusGeometry.js\n\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n */\n\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n};\n\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\n\n// File:src/extras/geometries/TorusKnotBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * see: http://www.blackpawn.com/texts/pqtorus/\n */\nTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusKnotBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\tp = p || 2;\n\tq = q || 3;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar i, j, index = 0, indexOffset = 0;\n\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\n\tvar P1 = new THREE.Vector3();\n\tvar P2 = new THREE.Vector3();\n\n\tvar B = new THREE.Vector3();\n\tvar T = new THREE.Vector3();\n\tvar N = new THREE.Vector3();\n\n\t// generate vertices, normals and uvs\n\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t// calculate orthonormal basis\n\n\t\tT.subVectors( P2, P1 );\n\t\tN.addVectors( P2, P1 );\n\t\tB.crossVectors( T, N );\n\t\tN.crossVectors( B, T );\n\n\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\tB.normalize();\n\t\tN.normalize();\n\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t// now calculate the final vertex position.\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / tubularSegments;\n\t\t\tuv.y = j / radialSegments;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// this function calculates the current position on the torus curve\n\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = q / p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t}\n\n};\n\nTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\n\n// File:src/extras/geometries/TorusKnotGeometry.js\n\n/**\n * @author oosmoxiecode\n */\n\nTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusKnotGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\n\n// File:src/extras/geometries/TubeGeometry.js\n\n/**\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n * @author jonobr1 / https://github.com/jonobr1\n *\n * Modified from the TorusKnotGeometry by @oosmoxiecode\n *\n * Creates a tube which extrudes along a 3d spline\n *\n * Uses parallel transport frames as described in\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n */\n\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TubeGeometry';\n\n\tthis.parameters = {\n\t\tpath: path,\n\t\tsegments: segments,\n\t\tradius: radius,\n\t\tradialSegments: radialSegments,\n\t\tclosed: closed,\n\t\ttaper: taper\n\t};\n\n\tsegments = segments || 64;\n\tradius = radius || 1;\n\tradialSegments = radialSegments || 8;\n\tclosed = closed || false;\n\ttaper = taper || THREE.TubeGeometry.NoTaper;\n\n\tvar grid = [];\n\n\tvar scope = this,\n\n\t\ttangent,\n\t\tnormal,\n\t\tbinormal,\n\n\t\tnumpoints = segments + 1,\n\n\t\tu, v, r,\n\n\t\tcx, cy,\n\t\tpos, pos2 = new THREE.Vector3(),\n\t\ti, j,\n\t\tip, jp,\n\t\ta, b, c, d,\n\t\tuva, uvb, uvc, uvd;\n\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\n\t\ttangents = frames.tangents,\n\t\tnormals = frames.normals,\n\t\tbinormals = frames.binormals;\n\n\t// proxy internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\t// construct the grid\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tgrid[ i ] = [];\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\tpos = path.getPointAt( u );\n\n\t\ttangent = tangents[ i ];\n\t\tnormal = normals[ i ];\n\t\tbinormal = binormals[ i ];\n\n\t\tr = radius * taper( u );\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tv = j / radialSegments * 2 * Math.PI;\n\n\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = r * Math.sin( v );\n\n\t\t\tpos2.copy( pos );\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\n\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\n\t\t}\n\n\t}\n\n\n\t// construct the mesh\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\n\t\t\tjp = ( j + 1 ) % radialSegments;\n\n\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\tb = grid[ ip ][ j ];\n\t\t\tc = grid[ ip ][ jp ];\n\t\t\td = grid[ i ][ jp ];\n\n\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\n\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\n\nTHREE.TubeGeometry.NoTaper = function ( u ) {\n\n\treturn 1;\n\n};\n\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\n\n\treturn Math.sin( Math.PI * u );\n\n};\n\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\n\n\tvar\tnormal = new THREE.Vector3(),\n\n\t\ttangents = [],\n\t\tnormals = [],\n\t\tbinormals = [],\n\n\t\tvec = new THREE.Vector3(),\n\t\tmat = new THREE.Matrix4(),\n\n\t\tnumpoints = segments + 1,\n\t\ttheta,\n\t\tsmallest,\n\n\t\ttx, ty, tz,\n\t\ti, u;\n\n\n\t// expose internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\t// compute the tangent vectors for each segment on the path\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\ttangents[ i ] = path.getTangentAt( u );\n\t\ttangents[ i ].normalize();\n\n\t}\n\n\tinitialNormal3();\n\n\t/*\n\tfunction initialNormal1(lastBinormal) {\n\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t}\n\n\tfunction initialNormal2() {\n\n\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\tvar t2 = path.getTangentAt( epsilon );\n\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\n\t}\n\t*/\n\n\tfunction initialNormal3() {\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the smallest tangent xyz component\n\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tsmallest = Number.MAX_VALUE;\n\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\tty = Math.abs( tangents[ 0 ].y );\n\t\ttz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= smallest ) {\n\n\t\t\tsmallest = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= smallest ) {\n\n\t\t\tsmallest = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= smallest ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t}\n\n\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\n\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\tvec.normalize();\n\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t}\n\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t}\n\n\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\tif ( closed ) {\n\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\n\t\ttheta /= ( numpoints - 1 );\n\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\n\n\t\t\ttheta = - theta;\n\n\t\t}\n\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\t\t// twist a little...\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/extras/geometries/PolyhedronGeometry.js\n\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PolyhedronGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\tvar that = this;\n\n\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\n\n\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\n\n\t}\n\n\tvar p = this.vertices;\n\n\tvar faces = [];\n\n\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\n\n\t\tvar v1 = p[ indices[ i ] ];\n\t\tvar v2 = p[ indices[ i + 1 ] ];\n\t\tvar v3 = p[ indices[ i + 2 ] ];\n\n\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\n\t}\n\n\tvar centroid = new THREE.Vector3();\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tsubdivide( faces[ i ], detail );\n\n\t}\n\n\n\t// Handle case when face straddles the seam\n\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\n\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\tvar x0 = uvs[ 0 ].x;\n\t\tvar x1 = uvs[ 1 ].x;\n\t\tvar x2 = uvs[ 2 ].x;\n\n\t\tvar max = Math.max( x0, x1, x2 );\n\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\n\n\t\t}\n\n\t}\n\n\n\t// Apply radius\n\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\tthis.vertices[ i ].multiplyScalar( radius );\n\n\t}\n\n\n\t// Merge vertices\n\n\tthis.mergeVertices();\n\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n\n\t// Project vector onto sphere's surface\n\n\tfunction prepare( vector ) {\n\n\t\tvar vertex = vector.normalize().clone();\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\n\t\treturn vertex;\n\n\t}\n\n\n\t// Approximate a curved face with recursively sub-divided triangles.\n\n\tfunction make( v1, v2, v3 ) {\n\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\tthat.faces.push( face );\n\n\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\n\t\tvar azi = azimuth( centroid );\n\n\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t] );\n\n\t}\n\n\n\t// Analytically subdivide a face to the required detail level.\n\n\tfunction subdivide( face, detail ) {\n\n\t\tvar cols = Math.pow( 2, detail );\n\t\tvar a = prepare( that.vertices[ face.a ] );\n\t\tvar b = prepare( that.vertices[ face.b ] );\n\t\tvar c = prepare( that.vertices[ face.c ] );\n\t\tvar v = [];\n\n\t\t// Construct all of the vertices for this subdivision.\n\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\n\n\t\t\tv[ i ] = [];\n\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\n\t\t\tvar rows = cols - i;\n\n\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\n\n\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Construct all of the faces.\n\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ],\n\t\t\t\t\t\tv[ i ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n\n\t// Texture fixing helper. Spheres have some odd behaviours.\n\n\tfunction correctUV( uv, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\t\treturn uv.clone();\n\n\t}\n\n\n};\n\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\n\n// File:src/extras/geometries/DodecahedronGeometry.js\n\n/**\n * @author Abe Pazos / https://hamoid.com\n */\n\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\tvar r = 1 / t;\n\n\tvar vertices = [\n\n\t\t// (1, 1, 1)\n\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t 1,  1, - 1,     1,  1,  1,\n\n\t\t// (0, 1/, )\n\t\t 0, - r, - t,     0, - r,  t,\n\t\t 0,  r, - t,     0,  r,  t,\n\n\t\t// (1/, , 0)\n\t\t- r, - t,  0,    - r,  t,  0,\n\t\t r, - t,  0,     r,  t,  0,\n\n\t\t// (, 0, 1/)\n\t\t- t,  0, - r,     t,  0, - r,\n\t\t- t,  0,  r,     t,  0,  r\n\t];\n\n\tvar indices = [\n\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'DodecahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\n\n// File:src/extras/geometries/IcosahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t];\n\n\tvar indices = [\n\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'IcosahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\n\n// File:src/extras/geometries/OctahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.OctahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t];\n\n\tvar indices = [\n\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'OctahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\n\n// File:src/extras/geometries/TetrahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t];\n\n\tvar indices = [\n\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'TetrahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\n\n// File:src/extras/geometries/ParametricGeometry.js\n\n/**\n * @author zz85 / https://github.com/zz85\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n *\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\n *\n */\n\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ParametricGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\tvar verts = this.vertices;\n\tvar faces = this.faces;\n\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\tvar i, j, p;\n\tvar u, v;\n\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tv = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tu = j / slices;\n\n\t\t\tp = func( u, v );\n\t\t\tverts.push( p );\n\n\t\t}\n\n\t}\n\n\tvar a, b, c, d;\n\tvar uva, uvb, uvc, uvd;\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\ta = i * sliceCount + j;\n\t\t\tb = i * sliceCount + j + 1;\n\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\td = ( i + 1 ) * sliceCount + j;\n\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\n\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\t// console.log(this);\n\n\t// magic bullet\n\t// var diff = this.mergeVertices();\n\t// console.log('removed ', diff, ' vertices by merging');\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\n\n// File:src/extras/geometries/WireframeGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeGeometry = function ( geometry ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\tvar vertices = geometry.vertices;\n\t\tvar faces = geometry.faces;\n\t\tvar numEdges = 0;\n\n\t\t// allocate maximal size\n\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\n\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\t// Indexed BufferGeometry\n\n\t\t\tvar indices = geometry.index.array;\n\t\t\tvar vertices = geometry.attributes.position;\n\t\t\tvar groups = geometry.groups;\n\t\t\tvar numEdges = 0;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t}\n\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\tvar start = group.start;\n\t\t\t\tvar count = group.count;\n\n\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\n\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t} else {\n\n\t\t\t// non-indexed BufferGeometry\n\n\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\tvar numEdges = vertices.length / 3;\n\t\t\tvar numTris = numEdges / 3;\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\n\n// File:src/extras/helpers/AxisHelper.js\n\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AxisHelper = function ( size ) {\n\n\tsize = size || 1;\n\n\tvar vertices = new Float32Array( [\n\t\t0, 0, 0,  size, 0, 0,\n\t\t0, 0, 0,  0, size, 0,\n\t\t0, 0, 0,  0, 0, size\n\t] );\n\n\tvar colors = new Float32Array( [\n\t\t1, 0, 0,  1, 0.6, 0,\n\t\t0, 1, 0,  0.6, 1, 0,\n\t\t0, 0, 1,  0, 0.6, 1\n\t] );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\n\n// File:src/extras/helpers/ArrowHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / http://github.com/zz85\n * @author bhouston / http://clara.io\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  color - color in hex value\n *  headLength - Number\n *  headWidth - Number\n */\n\nTHREE.ArrowHelper = ( function () {\n\n\tvar lineGeometry = new THREE.BufferGeometry();\n\tlineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\tvar coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tTHREE.Object3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\n\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\n\n\tvar axis = new THREE.Vector3();\n\tvar radians;\n\n\treturn function setDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tradians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t}\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\tthis.line.updateMatrix();\n\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\tthis.cone.position.y = length;\n\tthis.cone.updateMatrix();\n\n};\n\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\n\n\tthis.line.material.color.copy( color );\n\tthis.cone.material.color.copy( color );\n\n};\n\n// File:src/extras/helpers/BoxHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BoxHelper = function ( object, color ) {\n\t\n\tif ( color === undefined ) color = 0xffff00;\n\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\tvar positions = new Float32Array( 8 * 3 );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ) );\n\n\tif ( object !== undefined ) {\n\n\t\tthis.update( object );\n\n\t}\n\n};\n\nTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\n\nTHREE.BoxHelper.prototype.update = ( function () {\n\n\tvar box = new THREE.Box3();\n\n\treturn function update( object ) {\n\n\t\tif ( object instanceof THREE.Box3 ) {\n\n\t\t\tbox.copy( object );\n\n\t\t} else {\n\n\t\t\tbox.setFromObject( object );\n\n\t\t}\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tvar min = box.min;\n\t\tvar max = box.max;\n\n\t\t/*\n\t\t  5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tvar position = this.geometry.attributes.position;\n\t\tvar array = position.array;\n\n\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t};\n\n} )();\n\n// File:src/extras/helpers/BoundingBoxHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\n// a helper to show the world-axis-aligned bounding box for an object\n\nTHREE.BoundingBoxHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\tthis.object = object;\n\n\tthis.box = new THREE.Box3();\n\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n};\n\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\n\nTHREE.BoundingBoxHelper.prototype.update = function () {\n\n\tthis.box.setFromObject( this.object );\n\n\tthis.box.size( this.scale );\n\n\tthis.box.center( this.position );\n\n};\n\n// File:src/extras/helpers/CameraHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nTHREE.CameraHelper = function ( camera ) {\n\n\tvar geometry = new THREE.Geometry();\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\n\tvar pointMap = {};\n\n\t// colors\n\n\tvar hexFrustum = 0xffaa00;\n\tvar hexCone = 0xff0000;\n\tvar hexUp = 0x00aaff;\n\tvar hexTarget = 0xffffff;\n\tvar hexCross = 0x333333;\n\n\t// near\n\n\taddLine( \"n1\", \"n2\", hexFrustum );\n\taddLine( \"n2\", \"n4\", hexFrustum );\n\taddLine( \"n4\", \"n3\", hexFrustum );\n\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t// far\n\n\taddLine( \"f1\", \"f2\", hexFrustum );\n\taddLine( \"f2\", \"f4\", hexFrustum );\n\taddLine( \"f4\", \"f3\", hexFrustum );\n\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t// sides\n\n\taddLine( \"n1\", \"f1\", hexFrustum );\n\taddLine( \"n2\", \"f2\", hexFrustum );\n\taddLine( \"n3\", \"f3\", hexFrustum );\n\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t// cone\n\n\taddLine( \"p\", \"n1\", hexCone );\n\taddLine( \"p\", \"n2\", hexCone );\n\taddLine( \"p\", \"n3\", hexCone );\n\taddLine( \"p\", \"n4\", hexCone );\n\n\t// up\n\n\taddLine( \"u1\", \"u2\", hexUp );\n\taddLine( \"u2\", \"u3\", hexUp );\n\taddLine( \"u3\", \"u1\", hexUp );\n\n\t// target\n\n\taddLine( \"c\", \"t\", hexTarget );\n\taddLine( \"p\", \"c\", hexCross );\n\n\t// cross\n\n\taddLine( \"cn1\", \"cn2\", hexCross );\n\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\taddLine( \"cf1\", \"cf2\", hexCross );\n\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\tfunction addLine( a, b, hex ) {\n\n\t\taddPoint( a, hex );\n\t\taddPoint( b, hex );\n\n\t}\n\n\tfunction addPoint( id, hex ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\n\n\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\tpointMap[ id ] = [];\n\n\t\t}\n\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t}\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.camera = camera;\n\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\tthis.matrix = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = pointMap;\n\n\tthis.update();\n\n};\n\nTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\n\nTHREE.CameraHelper.prototype.update = function () {\n\n\tvar geometry, pointMap;\n\n\tvar vector = new THREE.Vector3();\n\tvar camera = new THREE.Camera();\n\n\tfunction setPoint( point, x, y, z ) {\n\n\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\tvar points = pointMap[ point ];\n\n\t\tif ( points !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn function update() {\n\n\t\tgeometry = this.geometry;\n\t\tpointMap = this.pointMap;\n\n\t\tvar w = 1, h = 1;\n\n\t\t// we need just camera projection matrix\n\t\t// world matrix must be identity\n\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t// center / target\n\n\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t// near\n\n\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\tsetPoint( \"f4\",   w,   h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\n\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/DirectionalLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.DirectionalLightHelper = function ( light, size ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tif ( size === undefined ) size = 1;\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [\n\t\t- size,   size, 0,\n\t\t  size,   size, 0,\n\t\t  size, - size, 0,\n\t\t- size, - size, 0,\n\t\t- size,   size, 0\n\t], 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.add( new THREE.Line( geometry, material ) );\n\n\tgeometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\tthis.add( new THREE.Line( geometry, material ));\n\n\tthis.update();\n\n};\n\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\n\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\n\n\tvar lightPlane = this.children[ 0 ];\n\tvar targetLine = this.children[ 1 ];\n\n\tlightPlane.geometry.dispose();\n\tlightPlane.material.dispose();\n\ttargetLine.geometry.dispose();\n\ttargetLine.material.dispose();\n\n};\n\nTHREE.DirectionalLightHelper.prototype.update = function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar v3 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\tv3.subVectors( v2, v1 );\n\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\n\t\tlightPlane.lookAt( v3 );\n\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\ttargetLine.lookAt( v3 );\n\t\ttargetLine.scale.z = v3.length();\n\n\t};\n\n}();\n\n// File:src/extras/helpers/EdgesHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @param object THREE.Mesh whose geometry will be used\n * @param hex line color\n * @param thresholdAngle the minimum angle (in degrees),\n * between the face normals of adjacent faces,\n * that is required to render an edge. A value of 10 means\n * an edge is only rendered if the angle is at least 10 degrees.\n */\n\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\n\n// File:src/extras/helpers/FaceNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\t// FaceNormalsHelper only supports THREE.Geometry\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length;\n\n\t} else {\n\n\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\tthis.update();\n\n};\n\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\n\nTHREE.FaceNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tvar vertices = objGeometry.vertices;\n\n\t\tvar faces = objGeometry.faces;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar normal = face.normal;\n\n\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t.divideScalar( 3 )\n\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/GridHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.GridHelper = function ( size, step, color1, color2 ) {\n\n\tcolor1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );\n\tcolor2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );\n\n\tvar vertices = [];\n\tvar colors = [];\n\n\tfor ( var i = - size, j = 0; i <= size; i += step ) {\n\n\t\tvertices.push( - size, 0, i, size, 0, i );\n\t\tvertices.push( i, 0, - size, i, 0, size );\n\n\t\tvar color = i === 0 ? color1 : color2;\n\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\n\t}\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\n\nTHREE.GridHelper.prototype.setColors = function () {\n\n\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n};\n\n// File:src/extras/helpers/HemisphereLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\n\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\tgeometry.rotateX( - Math.PI / 2 );\n\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t}\n\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\n\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\n\tthis.add( this.lightSphere );\n\n\tthis.update();\n\n};\n\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\n\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\n\n\tthis.lightSphere.geometry.dispose();\n\tthis.lightSphere.material.dispose();\n\n};\n\nTHREE.HemisphereLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/PointLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLightHelper = function ( light, sphereSize ) {\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tvar geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.matrix = this.light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\t/*\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tvar d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n};\n\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\n\nTHREE.PointLightHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n\n};\n\nTHREE.PointLightHelper.prototype.update = function () {\n\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t/*\n\tvar d = this.light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.visible = true;\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\t*/\n\n};\n\n// File:src/extras/helpers/SkeletonHelper.js\n\n/**\n * @author Sean Griffin / http://twitter.com/sgrif\n * @author Michael Guerrero / http://realitymeltdown.com\n * @author mrdoob / http://mrdoob.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkeletonHelper = function ( object ) {\n\n\tthis.bones = this.getBoneList( object );\n\n\tvar geometry = new THREE.Geometry();\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dynamic = true;\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.root = object;\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\n\nTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\n\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\n\n\tvar boneList = [];\n\n\tif ( object instanceof THREE.Bone ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n};\n\nTHREE.SkeletonHelper.prototype.update = function () {\n\n\tvar geometry = this.geometry;\n\n\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\n\n\tvar boneMatrix = new THREE.Matrix4();\n\n\tvar j = 0;\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tj += 2;\n\n\t\t}\n\n\t}\n\n\tgeometry.verticesNeedUpdate = true;\n\n\tgeometry.computeBoundingSphere();\n\n};\n\n// File:src/extras/helpers/SpotLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.SpotLightHelper = function ( light ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = [\n\t\t0, 0, 0,   0,   0,   1,\n\t\t0, 0, 0,   1,   0,   1,\n\t\t0, 0, 0, - 1,   0,   1,\n\t\t0, 0, 0,   0,   1,   1,\n\t\t0, 0, 0,   0, - 1,   1\n\t];\n\n\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\tpositions.push(\n\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t);\n\n\t}\n\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.cone = new THREE.LineSegments( geometry, material );\n\tthis.add( this.cone );\n\n\tthis.update();\n\n};\n\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\n\nTHREE.SpotLightHelper.prototype.dispose = function () {\n\n\tthis.cone.geometry.dispose();\n\tthis.cone.material.dispose();\n\n};\n\nTHREE.SpotLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\tvar vector2 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t};\n\n}();\n\n// File:src/extras/helpers/VertexNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length * 3;\n\n\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\n\nTHREE.VertexNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\tvar idx = 0;\n\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/WireframeHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\n\n// File:src/extras/objects/ImmediateRenderObject.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ImmediateRenderObject = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.material = material;\n\tthis.render = function ( renderCallback ) {};\n\n};\n\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\n\n// File:src/extras/objects/MorphBlendMesh.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphBlendMesh = function( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.animationsMap = {};\n\tthis.animationsList = [];\n\n\t// prepare default animation\n\t// (all frames played together in 1 second)\n\n\tvar numFrames = this.geometry.morphTargets.length;\n\n\tvar name = \"__default\";\n\n\tvar startFrame = 0;\n\tvar endFrame = numFrames - 1;\n\n\tvar fps = numFrames / 1;\n\n\tthis.createAnimation( name, startFrame, endFrame, fps );\n\tthis.setAnimationWeight( name, 1 );\n\n};\n\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\n\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\n\tvar animation = {\n\n\t\tstart: start,\n\t\tend: end,\n\n\t\tlength: end - start + 1,\n\n\t\tfps: fps,\n\t\tduration: ( end - start ) / fps,\n\n\t\tlastFrame: 0,\n\t\tcurrentFrame: 0,\n\n\t\tactive: false,\n\n\t\ttime: 0,\n\t\tdirection: 1,\n\t\tweight: 1,\n\n\t\tdirectionBackwards: false,\n\t\tmirroredLoop: false\n\n\t};\n\n\tthis.animationsMap[ name ] = animation;\n\tthis.animationsList.push( animation );\n\n};\n\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\n\tvar pattern = /([a-z]+)_?(\\d+)/i;\n\n\tvar firstAnimation, frameRanges = {};\n\n\tvar geometry = this.geometry;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar chunks = morph.name.match( pattern );\n\n\t\tif ( chunks && chunks.length > 1 ) {\n\n\t\t\tvar name = chunks[ 1 ];\n\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\n\n\t\t\tvar range = frameRanges[ name ];\n\n\t\t\tif ( i < range.start ) range.start = i;\n\t\t\tif ( i > range.end ) range.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\n\t\t}\n\n\t}\n\n\tfor ( var name in frameRanges ) {\n\n\t\tvar range = frameRanges[ name ];\n\t\tthis.createAnimation( name, range.start, range.end, fps );\n\n\t}\n\n\tthis.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = 1;\n\t\tanimation.directionBackwards = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = - 1;\n\t\tanimation.directionBackwards = true;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.fps = fps;\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.duration = duration;\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.weight = weight;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = time;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\n\tvar time = 0;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\ttime = animation.time;\n\n\t}\n\n\treturn time;\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\n\tvar duration = - 1;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tduration = animation.duration;\n\n\t}\n\n\treturn duration;\n\n};\n\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = 0;\n\t\tanimation.active = true;\n\n\t} else {\n\n\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.active = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\n\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\n\t\tvar animation = this.animationsList[ i ];\n\n\t\tif ( ! animation.active ) continue;\n\n\t\tvar frameTime = animation.duration / animation.length;\n\n\t\tanimation.time += animation.direction * delta;\n\n\t\tif ( animation.mirroredLoop ) {\n\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\n\t\t\t\tanimation.direction *= - 1;\n\n\t\t\t\tif ( animation.time > animation.duration ) {\n\n\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\tanimation.directionBackwards = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( animation.time < 0 ) {\n\n\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\tanimation.directionBackwards = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tanimation.time = animation.time % animation.duration;\n\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\n\t\t}\n\n\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\tvar weight = animation.weight;\n\n\t\tif ( keyframe !== animation.currentFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\tanimation.currentFrame = keyframe;\n\n\t\t}\n\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\n\t\tif ( animation.currentFrame !== animation.lastFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\n\t\t} else {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\n\n\t\t}\n\n\t}\n\n};\n\n"],"sourceRoot":"/source/"}